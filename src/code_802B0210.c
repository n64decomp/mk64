#include <ultra64.h>
#include <macros.h>
#include <defines.h>

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? vec3f_copy(void *, void *, void *, void *); // extern

void func_802B0210(void *arg0, void *arg1) {
    void *temp_a0;
    void *temp_a2;
    void *temp_a3;

    temp_a3 = arg0;
    temp_a2 = arg1;
    arg1->unk0 = arg0->unk0;
    arg1->unk2 = arg0->unk2;
    arg1->unk4 = arg0->unk4;
    arg1->unk6 = arg0->unk6;
    arg1->unk8 = arg0->unk8;
    arg1->unkA = arg0->unkA;
    arg1->unkC = arg0->unkC;
    arg1->unk10 = arg0->unk10;
    temp_a0 = arg1 + 0x18;
    arg1->unk14 = arg0->unk14;
    arg0 = temp_a3;
    arg1 = temp_a2;
    vec3f_copy(temp_a0, temp_a3 + 0x18, temp_a2, temp_a3);
    vec3f_copy(arg1 + 0x24, arg0 + 0x24, arg1, arg0);
    vec3f_copy(arg1 + 0x30, arg0 + 0x30, arg1, arg0);
}
#else
GLOBAL_ASM("asm/non_matchings/code_802B0210/func_802B0210.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern ? D_8015F9B8;

void func_802B02B4(void *arg0, s32 arg1) {
    s32 temp_f6;
    void *temp_v0;

    temp_v0 = (arg0->unk4 * 0x70) + &D_8015F9B8;
    temp_v0->unk4 = temp_v0->unk4 - 1;
    temp_f6 = arg0->unk8;
    if (temp_f6 != 0) {
        if (temp_f6 != 1) {
            if (temp_f6 != 2) {

            } else {
                temp_v0->unk2C = -1.0f;
            }
        } else {
            temp_v0->unk28 = -1.0f;
        }
    } else {
        temp_v0->unk24 = -1.0f;
    }
    arg0->unk2 = -0x8000;
    arg0->unk12 = 0;
    arg0->unk4 = 0x3C;
    arg0->unk28 = 3.0f;
    if (arg1 != 7) {
        if (arg1 != 8) {
            return;
        }
        arg0->unk6 = 7;
        return;
    }
    arg0->unk6 = 5;
}
#else
GLOBAL_ASM("asm/non_matchings/code_802B0210/func_802B02B4.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern f64 D_802B9E80;
extern f64 D_802B9E88;
extern f64 D_802B9E90;

void func_802B039C(void *arg0) {
    f32 temp_f6;
    s32 temp_v0;
    f32 phi_f6;

    arg0->unk6 = 1;
    arg0->unk4 = 0xB4;
    arg0->unk24 = (random_int(0xC8) - 0x64) * D_802B9E80;
    temp_v0 = random_int(0xC8);
    temp_f6 = temp_v0;
    phi_f6 = temp_f6;
    if (temp_v0 < 0) {
        phi_f6 = temp_f6 + 4294967296.0f;
    }
    arg0->unk28 = phi_f6 * D_802B9E88;
    arg0->unk2C = (random_int(0xC8) - 0x64) * D_802B9E90;
}
#else
GLOBAL_ASM("asm/non_matchings/code_802B0210/func_802B039C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_802B039C(void *); // extern
extern ? D_8015F9B8;

void func_802B0464(s16 arg0) {
    s16 temp_s0;
    void *temp_a0;
    s16 phi_s0;

    phi_s0 = arg0;
    if (arg0 != -1) {
        do {
            temp_a0 = &D_8015F9B8 + (phi_s0 * 0x70);
            func_802B039C(temp_a0);
            temp_s0 = temp_a0->unk14;
            phi_s0 = temp_s0;
        } while (temp_s0 != -1);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_802B0210/func_802B0464.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_802B039C(void *); // extern
extern ? D_8015F9B8;

void func_802B04E8(s32 arg0, s16 arg1) {
    s16 temp_s0;
    void *temp_a0;
    s16 phi_s0;

    phi_s0 = arg1;
    if (arg1 != -1) {
        do {
            temp_a0 = &D_8015F9B8 + (phi_s0 * 0x70);
            func_802B039C(temp_a0);
            temp_s0 = temp_a0->unk12;
            phi_s0 = temp_s0;
        } while (temp_s0 != -1);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_802B0210/func_802B04E8.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800C9060(s32, ?); // extern
? func_802B0464(s16); // extern
? func_802B04E8(void *, s16); // extern
extern ? D_8015F9B8;
extern ? gPlayers;

void func_802B0570(void *arg0) {
    s16 temp_v0;
    void *temp_v0_2;

    func_802B0464(arg0->unk14);
    func_802B04E8(arg0, arg0->unk12);
    temp_v0 = arg0->unk10;
    if ((*(&gPlayers + (temp_v0 * 0xDD8)) & 0x4000) != 0) {
        func_800C9060(temp_v0 & 0xFF, 0x19019053);
    }
    arg0->unk2 = -0x8000;
    arg0->unk4 = 0x3C;
    arg0->unk6 = 5;
    temp_v0_2 = (arg0->unk8 * 0x70) + &D_8015F9B8;
    arg0->unk28 = 3.0f;
    temp_v0_2->unk12 = -1;
    temp_v0_2->unk14 = -1;
    temp_v0_2->unk16 = -1;
    temp_v0_2->unk18 = -1;
    temp_v0_2->unk1A = -1;
}
#else
GLOBAL_ASM("asm/non_matchings/code_802B0210/func_802B0570.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern ? D_8015F9B8;

void func_802B0648(void *arg0) {
    s16 temp_v0;
    s16 temp_v0_2;
    s16 temp_v0_3;
    s16 temp_v0_4;
    s16 temp_v0_5;
    s16 temp_v0_6;
    s32 temp_lo;
    s32 temp_lo_2;
    s32 temp_lo_3;
    s32 temp_lo_4;
    s32 temp_lo_5;
    void *phi_v1;

    temp_v0 = arg0->unk1A;
    arg0->unk1C = arg0->unk1C - 1;
    if (temp_v0 != -1) {
        temp_lo = temp_v0 * 0x70;
        arg0->unk1A = -1;
        phi_v1 = &D_8015F9B8 + temp_lo;
        goto block_10;
    }
    temp_v0_2 = arg0->unk18;
    if (temp_v0_2 != -1) {
        temp_lo_2 = temp_v0_2 * 0x70;
        arg0->unk18 = -1;
        phi_v1 = &D_8015F9B8 + temp_lo_2;
        goto block_10;
    }
    temp_v0_3 = arg0->unk16;
    if (temp_v0_3 != -1) {
        temp_lo_3 = temp_v0_3 * 0x70;
        arg0->unk16 = -1;
        phi_v1 = &D_8015F9B8 + temp_lo_3;
        goto block_10;
    }
    temp_v0_4 = arg0->unk14;
    if (temp_v0_4 != -1) {
        temp_lo_4 = temp_v0_4 * 0x70;
        arg0->unk14 = -1;
        phi_v1 = &D_8015F9B8 + temp_lo_4;
        goto block_10;
    }
    temp_v0_5 = arg0->unk12;
    if (temp_v0_5 != -1) {
        temp_lo_5 = temp_v0_5 * 0x70;
        arg0->unk12 = -1;
        phi_v1 = &D_8015F9B8 + temp_lo_5;
block_10:
        temp_v0_6 = phi_v1->unk12;
        phi_v1->unk6 = 1;
        phi_v1->unk4 = 0xB4;
        phi_v1->unk24 = 0.0f;
        phi_v1->unk2C = 0.0f;
        phi_v1->unk28 = 1.5f;
        if (temp_v0_6 != -1) {
            (&D_8015F9B8 + (temp_v0_6 * 0x70))->unk14 = -1;
        }
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_802B0210/func_802B0648.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_802B64C4(f32 *, s16); // extern
? load_giant_egg(f32, f32 *, ?, f32, f32); // extern
extern ? D_8015F9B8;

void func_802B0788(s16 arg0, void *arg1, void *arg2) {
    f32 sp34;
    void *sp30;
    f32 temp_f0;
    f32 temp_f2;
    s16 temp_a0;
    s16 temp_a0_2;
    s16 temp_a0_3;
    s16 temp_a0_4;
    s16 temp_a1;
    s16 temp_a3;
    s32 temp_lo;
    s32 temp_lo_2;
    s32 temp_lo_3;
    s32 temp_lo_4;
    s32 temp_lo_5;
    void *phi_v0;
    f32 phi_f12;
    f32 phi_f0;

    temp_a3 = arg1->unk1A;
    arg1->unk1C = arg1->unk1C - 1;
    if (temp_a3 != -1) {
        temp_lo = temp_a3 * 0x70;
        arg1->unk1A = -1;
        phi_v0 = &D_8015F9B8 + temp_lo;
        goto block_10;
    }
    temp_a0 = arg1->unk18;
    if (temp_a0 != -1) {
        temp_lo_2 = temp_a0 * 0x70;
        arg1->unk18 = -1;
        phi_v0 = &D_8015F9B8 + temp_lo_2;
        goto block_10;
    }
    temp_a0_2 = arg1->unk16;
    if (temp_a0_2 != -1) {
        temp_lo_3 = temp_a0_2 * 0x70;
        arg1->unk16 = -1;
        phi_v0 = &D_8015F9B8 + temp_lo_3;
        goto block_10;
    }
    temp_a0_3 = arg1->unk14;
    if (temp_a0_3 != -1) {
        temp_lo_4 = temp_a0_3 * 0x70;
        arg1->unk14 = -1;
        phi_v0 = &D_8015F9B8 + temp_lo_4;
        goto block_10;
    }
    temp_a0_4 = arg1->unk12;
    if (temp_a0_4 != -1) {
        temp_lo_5 = temp_a0_4 * 0x70;
        arg1->unk12 = -1;
        phi_v0 = &D_8015F9B8 + temp_lo_5;
block_10:
        temp_a1 = phi_v0->unk12;
        phi_v0->unk6 = 1;
        phi_v0->unk4 = 0x1E;
        if (temp_a1 != -1) {
            (&D_8015F9B8 + (temp_a1 * 0x70))->unk14 = -1;
        }
        temp_f2 = arg2->unk94;
        if (temp_f2 < 2.0f) {
            phi_f12 = 4.0f;
            phi_f0 = ((arg0 - 30.0f) / 20.0f) + 1.5f;
        } else {
            temp_f0 = ((arg0 - 30.0f) / 20.0f) + 1.5f;
            phi_f12 = (temp_f2 * 0.75f) + 4.5f + temp_f0;
            phi_f0 = temp_f0;
        }
        sp30 = phi_v0;
        load_giant_egg(phi_f12, &sp34, 0, phi_f0, phi_f12);
        func_802B64C4(&sp34, arg2->unk2E + arg2->unkC0);
        phi_v0->unk24 = sp34;
        phi_v0->unk28 = sp38;
        phi_v0->unk2C = sp3C;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_802B0210/func_802B0788.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern s16 D_8015F9BE[];

s32 func_802B09C0(s16 arg0) {
    s16 temp_v0;

    if (arg0 == -1) {
        return 0;
    }
    temp_v0 = &D_8015F9BE[arg0];
    if (temp_v0 == 2) {
        return 1;
    }
    if (temp_v0 == 3) {
        return 1;
    }
    return 0;
}
#else
GLOBAL_ASM("asm/non_matchings/code_802B0210/func_802B09C0.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
? func_800C9060(s32, ?);                            /* extern */
? func_8029E854(void *, s32);                       /* extern */
? func_802B0648(void *);                            /* extern */
? func_802B0788(s16, void *, Player *, Player *);   /* extern */
? func_802B2914(void *, Player *, ?, Player *);     /* extern */
extern ? D_8015F9B8;

void update_obj_banana_bunch(void *arg0) {
    void *sp2C;
    void *sp28;
    void *sp24;
    s16 temp_a0_2;
    s16 temp_t4;
    s16 temp_t6;
    s16 temp_v1_2;
    u16 temp_t9;
    u16 temp_v1;
    void *temp_a0;
    void *temp_a1;
    void *temp_a2;
    void *temp_a3;
    void *temp_t0;
    void *phi_v1;
    void *phi_v1_2;
    void *phi_v1_3;
    void *phi_v1_4;
    void *phi_v1_5;

    temp_t6 = arg0->unk10;
    temp_t9 = arg0->unk6;
    switch (temp_t9) {
    case 0:
        func_802B2914(arg0, &gPlayers[temp_t6], 0, &gPlayers[temp_t6]);
        arg0->unk4 = 4;
        arg0->unk6 = 1;
        arg0->unk1C = 1;
        return;
    case 1:
        arg0->unk4 = arg0->unk4 - 1;
        if (arg0->unk4 == 0) {
            func_802B2914(arg0, &gPlayers[temp_t6], 1, &gPlayers[temp_t6]);
            arg0->unk4 = 4;
            arg0->unk6 = 2;
            arg0->unk1C = arg0->unk1C + 1;
            return;
        }
    default:
        return;
    case 2:
        arg0->unk4 = arg0->unk4 - 1;
        if (arg0->unk4 == 0) {
            func_802B2914(arg0, &gPlayers[temp_t6], 2, &gPlayers[temp_t6]);
            arg0->unk4 = 4;
            arg0->unk6 = 3;
            arg0->unk1C = arg0->unk1C + 1;
            return;
        }
        /* Duplicate return node #31. Try simplifying control flow for better match */
        return;
    case 3:
        arg0->unk4 = arg0->unk4 - 1;
        if (arg0->unk4 == 0) {
            func_802B2914(arg0, &gPlayers[temp_t6], 3, &gPlayers[temp_t6]);
            arg0->unk4 = 4;
            arg0->unk6 = 4;
            arg0->unk1C = arg0->unk1C + 1;
            return;
        }
        /* Duplicate return node #31. Try simplifying control flow for better match */
        return;
    case 4:
        arg0->unk4 = arg0->unk4 - 1;
        if (arg0->unk4 == 0) {
            func_802B2914(arg0, &gPlayers[temp_t6], 4, &gPlayers[temp_t6]);
            arg0->unk4 = 4;
            arg0->unk6 = 5;
            arg0->unk1C = arg0->unk1C + 1;
            return;
        }
        /* Duplicate return node #31. Try simplifying control flow for better match */
        return;
    case 5:
        arg0->unk6 = 6;
        temp_a0 = &D_8015F9B8 + (arg0->unk12 * 0x70);
        temp_a0->unk2 = temp_a0->unk2 | 0x5000;
        temp_a1 = &D_8015F9B8 + (arg0->unk14 * 0x70);
        temp_a1->unk2 = temp_a1->unk2 | 0x5000;
        temp_a2 = &D_8015F9B8 + (arg0->unk16 * 0x70);
        temp_a2->unk2 = temp_a2->unk2 | 0x5000;
        temp_a3 = &D_8015F9B8 + (arg0->unk18 * 0x70);
        temp_a3->unk2 = temp_a3->unk2 | 0x5000;
        temp_t0 = &D_8015F9B8 + (arg0->unk1A * 0x70);
        temp_t0->unk2 = temp_t0->unk2 | 0x5000;
        return;
    case 6:
        sp2C = &gPlayers[temp_t6];
        sp24 = NULL;
        phi_v1 = sp24;
        if (func_802B09C0(arg0->unk12, MIPS2C_ERROR(Read from unset register $a1)) == 1) {
            phi_v1 = 1;
        }
        sp2C = &gPlayers[temp_t6];
        sp24 = phi_v1;
        phi_v1_2 = phi_v1;
        if (func_802B09C0(arg0->unk14, 1) == 1) {
            phi_v1_2 = phi_v1 + 1;
        }
        sp2C = &gPlayers[temp_t6];
        sp24 = phi_v1_2;
        phi_v1_3 = phi_v1_2;
        if (func_802B09C0(arg0->unk16, 1) == 1) {
            phi_v1_3 = phi_v1_2 + 1;
        }
        sp2C = &gPlayers[temp_t6];
        sp24 = phi_v1_3;
        phi_v1_4 = phi_v1_3;
        if (func_802B09C0(arg0->unk18, 1) == 1) {
            phi_v1_4 = phi_v1_3 + 1;
        }
        sp2C = &gPlayers[temp_t6];
        sp24 = phi_v1_4;
        phi_v1_5 = phi_v1_4;
        if (func_802B09C0(arg0->unk1A, 1) == 1) {
            phi_v1_5 = phi_v1_4 + 1;
        }
        if (phi_v1_5 == 0) {
            sp2C = &gPlayers[temp_t6];
            func_8029E854(arg0, 1);
            gPlayers[temp_t6].unk_00C &= 0xFFFBFFFF;
            return;
        }
        if (((gPlayers[temp_t6].unk_000 & PLAYER_HUMAN) != 0) && (temp_t4 = arg0->unk10, temp_v1 = gControllers[temp_t4].buttonPressed, ((temp_v1 & 0x2000) != 0))) {
            gControllers[temp_t4].buttonPressed = temp_v1 & 0xDFFF;
            sp2C = &gPlayers[temp_t6];
            sp28 = &gControllers[temp_t4];
            func_800C9060(((&gPlayers[temp_t6] - D_800DC4DC) / 3544) & 0xFF, 0x19008012);
            temp_a0_2 = gControllers[temp_t4].rawStickY;
            if ((temp_a0_2 >= 0x1F) && (temp_v1_2 = gControllers[temp_t4].rawStickX, ((temp_v1_2 < 0x28) != 0)) && (temp_v1_2 >= -0x27)) {
                func_802B0788(temp_a0_2, arg0, &gPlayers[temp_t6], &gPlayers[temp_t6]);
                return;
            }
            func_802B0648(arg0);
            /* Duplicate return node #31. Try simplifying control flow for better match */
            return;
        }
        /* Duplicate return node #31. Try simplifying control flow for better match */
        return;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_802B0210/update_obj_banana_bunch.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern ? D_8015F9B8;

? func_802B0E14(s16 arg0) {
    void *temp_v0;

    if (arg0 < 0) {
        return 0;
    }
    temp_v0 = (arg0 * 0x70) + &D_8015F9B8;
    if (temp_v0->unk0 == 7) {
        if (temp_v0->unk6 == 4) {
            return 1;
        }
        return 0;
    }
    if (temp_v0->unk6 == 6) {
        return 1;
    }
    return 0;
}
#else
GLOBAL_ASM("asm/non_matchings/code_802B0210/func_802B0E14.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
? func_8000ED80(s32);                               /* extern */
? func_8000EDC8(s32);                               /* extern */
? func_800C9060(u8, ?);                             /* extern */
? func_800C90F4(u8, s32);                           /* extern */
? func_8029E854(void *);                            /* extern */
s32 func_802B19EC(void *, Player *, s16, ?);        /* extern */
? func_802B64C4(f32 *, s16);                        /* extern */
extern ? D_8015F9B8;

void update_obj_triple_shell(void *arg0, s16 arg1) {
    s16 sp4E;
    void *sp44;
    f32 sp40;
    f32 sp3C;
    f32 sp38;
    s16 sp32;
    void *sp28;
    f32 *temp_a0;
    f32 *temp_a0_2;
    f32 temp_f0;
    f32 temp_f0_2;
    f32 temp_f0_3;
    s16 temp_t0;
    s16 temp_t7;
    s16 temp_t8;
    s16 temp_v0;
    s16 temp_v1_2;
    s16 temp_v1_3;
    s16 temp_v1_4;
    s32 temp_v1;
    u16 temp_t9;
    void *temp_v0_2;
    void *temp_v0_3;
    void *temp_v0_4;
    void *temp_v0_5;
    void *temp_v0_6;
    void *temp_v0_7;
    s16 phi_v1;
    s16 phi_v1_2;
    s16 phi_v1_3;

    temp_v0 = arg0->unk10;
    temp_t9 = arg0->unk6;
    temp_t8 = arg0->unk12 + temp_v0;
    temp_t0 = arg0->unk14;
    arg0->unk12 = temp_t8;
    temp_v1 = temp_t8 & 0xFFFF;
    switch (temp_t9) {
    case 0:
        sp4E = temp_t0;
        if (func_802B19EC(arg0, &gPlayers[temp_t0], arg1, 0) != -1) {
            func_800C9060(temp_t0 & 0xFF, 0x19008012);
            arg0->unk4 = arg0->unk4 + 1;
        }
        arg0->unk6 = 1;
        return;
    case 1:
        if (temp_v0 > 0) {
            if (temp_v1 >= 0xD556) {
                sp4E = temp_t0;
                if (func_802B19EC(arg0, &gPlayers[temp_t0], arg1, 1) != -1) {
                    func_800C9060(temp_t0 & 0xFF, 0x19008012);
                    arg0->unk4 = arg0->unk4 + 1;
                }
                arg0->unk6 = 2;
                return;
            }
            /* Duplicate return node #61. Try simplifying control flow for better match */
            return;
        }
        if (temp_v1 < 0x2AAA) {
            sp4E = temp_t0;
            if (func_802B19EC(arg0, &gPlayers[temp_t0], arg1, 1) != -1) {
                func_800C9060(temp_t0 & 0xFF, 0x19008012);
                arg0->unk4 = arg0->unk4 + 1;
            }
            arg0->unk6 = 2;
            return;
        }
    default:
        return;
    case 2:
        if (temp_v0 > 0) {
            if ((temp_v1 >= 0x2AAB) && (temp_v1 < 0x31C7)) {
                sp4E = temp_t0;
                if (func_802B19EC(arg0, &gPlayers[temp_t0], arg1, 2) != -1) {
                    func_800C9060(temp_t0 & 0xFF, 0x19008012);
                    arg0->unk4 = arg0->unk4 + 1;
                }
                arg0->unk6 = 3;
                return;
            }
            /* Duplicate return node #61. Try simplifying control flow for better match */
            return;
        }
        if ((temp_v1 < 0xD555) && (temp_v1 >= 0xCE39)) {
            sp4E = temp_t0;
            if (func_802B19EC(arg0, &gPlayers[temp_t0], arg1, 2) != -1) {
                func_800C9060(temp_t0 & 0xFF, 0x19008012);
                arg0->unk4 = arg0->unk4 + 1;
            }
            arg0->unk6 = 3;
            return;
        }
        /* Duplicate return node #61. Try simplifying control flow for better match */
        return;
    case 3:
        arg0->unk6 = 4;
        temp_v0_2 = &D_8015F9B8 + (arg0->unk24 * 0x70);
        temp_v0_2->unk2 = temp_v0_2->unk2 | 0x4000;
        temp_v0_3 = &D_8015F9B8 + (arg0->unk28 * 0x70);
        temp_v0_3->unk2 = temp_v0_3->unk2 | 0x4000;
        temp_v0_4 = &D_8015F9B8 + (arg0->unk2C * 0x70);
        temp_v0_4->unk2 = temp_v0_4->unk2 | 0x4000;
        return;
    case 4:
        sp4E = temp_t0;
        sp32 = 0;
        phi_v1 = sp32;
        if (func_802B0E14(arg0->unk24, arg1) == 1) {
            phi_v1 = 1;
        } else {
            arg0->unk24 = -1.0f;
        }
        sp4E = temp_t0;
        sp32 = phi_v1;
        phi_v1_2 = phi_v1;
        if (func_802B0E14(arg0->unk28, MIPS2C_ERROR(Read from unset register $a1)) == 1) {
            phi_v1_2 = phi_v1 + 1;
        } else {
            arg0->unk28 = -1.0f;
        }
        sp4E = temp_t0;
        sp32 = phi_v1_2;
        phi_v1_3 = phi_v1_2;
        if (func_802B0E14(arg0->unk2C, MIPS2C_ERROR(Read from unset register $a1)) == 1) {
            phi_v1_3 = phi_v1_2 + 1;
        } else {
            arg0->unk2C = -1.0f;
        }
        if (phi_v1_3 == 0) {
            func_8029E854(arg0);
            return;
        }
        temp_t7 = arg0->unk14;
        if ((gControllers[temp_t7].buttonPressed & 0x2000) != 0) {
            arg0->unk8 = arg0->unk8 + 1.0f;
            gControllers[temp_t7].buttonPressed &= 0xDFFF;
        }
        if (arg0->unk8 > 0.0f) {
            temp_f0 = arg0->unk24;
            if ((temp_f0 > 0.0f) && ((temp_v0_5 = &D_8015F9B8 + (temp_f0 * 0x70), temp_v1_2 = temp_v0_5->unk12, temp_a0 = &sp38, ((temp_v1_2 < 0x38E) != 0)) || (temp_v1_2 >= -0x38D))) {
                sp38 = 0.0f;
                sp3C = 0.0f;
                sp40 = 8.0f;
                sp28 = &gPlayers[temp_t0];
                sp44 = temp_v0_5;
                func_802B64C4(temp_a0, gPlayers[temp_t0].unk_02E + gPlayers[temp_t0].unk_0C0);
                temp_v0_5->unk24 = sp38;
                temp_v0_5->unk28 = sp3C;
                temp_v0_5->unk6 = 2;
                temp_v0_5->unk4 = 0x1E;
                temp_v0_5->unk2C = sp40;
                func_800C9060(arg0->unk15, 0x19008004);
                func_800C90F4(arg0->unk15, (gPlayers[temp_t0].characterId * 0x10) + 0x29008000);
                if (arg0->unk0 == 0x16) {
                    func_8000ED80(arg0->unk24);
                } else {
                    func_8000EDC8(arg0->unk24);
                }
                arg0->unk24 = -1.0f;
                arg0->unk4 = arg0->unk4 - 1;
                arg0->unk8 = arg0->unk8 - 1.0f;
                return;
            }
            temp_f0_2 = arg0->unk28;
            if ((temp_f0_2 > 0.0f) && ((temp_v0_6 = &D_8015F9B8 + (temp_f0_2 * 0x70), temp_v1_3 = temp_v0_6->unk12, ((temp_v1_3 < 0xAA1) != 0)) || (temp_v1_3 >= 0x38F))) {
                sp38 = 0.0f;
                sp3C = 0.0f;
                sp40 = 8.0f;
                sp28 = &gPlayers[temp_t0];
                sp44 = temp_v0_6;
                func_802B64C4(&sp38, gPlayers[temp_t0].unk_02E + gPlayers[temp_t0].unk_0C0);
                temp_v0_6->unk24 = sp38;
                temp_v0_6->unk28 = sp3C;
                temp_v0_6->unk6 = 2;
                temp_v0_6->unk4 = 0x1E;
                temp_v0_6->unk2C = sp40;
                func_800C90F4(arg0->unk15, (gPlayers[temp_t0].characterId * 0x10) + 0x29008000);
                func_800C9060(arg0->unk15, 0x19008004);
                if (arg0->unk0 == 0x16) {
                    func_8000ED80(arg0->unk28);
                } else {
                    func_8000EDC8(arg0->unk28);
                }
                arg0->unk28 = -1.0f;
                arg0->unk4 = arg0->unk4 - 1;
                arg0->unk8 = arg0->unk8 - 1.0f;
                return;
            }
            temp_f0_3 = arg0->unk2C;
            if ((temp_f0_3 > 0.0f) && ((temp_v0_7 = &D_8015F9B8 + (temp_f0_3 * 0x70), temp_v1_4 = temp_v0_7->unk12, temp_a0_2 = &sp38, ((temp_v1_4 < -0x38E) != 0)) || (temp_v1_4 >= -0x71B))) {
                sp38 = 0.0f;
                sp3C = 0.0f;
                sp40 = 8.0f;
                sp28 = &gPlayers[temp_t0];
                sp44 = temp_v0_7;
                func_802B64C4(temp_a0_2, gPlayers[temp_t0].unk_02E + gPlayers[temp_t0].unk_0C0);
                temp_v0_7->unk24 = sp38;
                temp_v0_7->unk28 = sp3C;
                temp_v0_7->unk6 = 2;
                temp_v0_7->unk4 = 0x1E;
                temp_v0_7->unk2C = sp40;
                func_800C9060(arg0->unk15, 0x19008004);
                func_800C90F4(arg0->unk15, (gPlayers[temp_t0].characterId * 0x10) + 0x29008000);
                if (arg0->unk0 == 0x16) {
                    func_8000ED80(arg0->unk2C);
                } else {
                    func_8000EDC8(arg0->unk2C);
                }
                arg0->unk2C = -1.0f;
                arg0->unk4 = arg0->unk4 - 1;
                arg0->unk8 = arg0->unk8 - 1.0f;
            }
            /* Duplicate return node #61. Try simplifying control flow for better match */
            return;
        }
        /* Duplicate return node #61. Try simplifying control flow for better match */
        return;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_802B0210/update_obj_triple_shell.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s16 func_8029EC88(? *, ? *, ? *, ?); // extern
extern ? D_8015F9B8;
extern ? D_802B9140;
extern ? D_802B914C;
extern ? D_802B9154;

s16 func_802B17F4(void *arg0) {
    ? sp34;
    ? sp2C;
    ? sp20;
    s16 temp_v0;
    void *temp_v1;

    sp34.unk0 = D_802B9140.unk0;
    sp34.unk4 = D_802B9140.unk4;
    sp34.unk8 = D_802B9140.unk8;
    sp2C.unk0 = D_802B914C.unk0;
    sp2C.unk4 = D_802B914C.unk4;
    sp20.unk0 = D_802B9154.unk0;
    sp20.unk4 = D_802B9154.unk4;
    sp20.unk8 = D_802B9154.unk8;
    temp_v0 = func_8029EC88(&sp20, &sp2C, &sp34, 0xE);
    if (temp_v0 < 0) {
        return temp_v0;
    }
    temp_v1 = (temp_v0 * 0x70) + &D_8015F9B8;
    temp_v1->unk6 = 0;
    temp_v1->unk10 = (arg0 - D_800DC4DC) / 0xDD8;
    arg0->unkC = arg0->unkC | 0x40000;
    return temp_v0;
}
#else
GLOBAL_ASM("asm/non_matchings/code_802B0210/func_802B17F4.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s16 func_8029EC88(? *, ? *, ? *, s16); // extern
extern ? D_8015F9B8;
extern ? D_802B9160;
extern ? D_802B916C;
extern ? D_802B9174;

s16 func_802B18E4(s32 arg0, s16 arg1) {
    ? sp34;
    ? sp2C;
    ? sp20;
    s16 temp_v0;
    void *temp_v1;

    sp34.unk0 = D_802B9160.unk0;
    sp34.unk4 = D_802B9160.unk4;
    sp34.unk8 = D_802B9160.unk8;
    sp2C.unk0 = D_802B916C.unk0;
    sp2C.unk4 = D_802B916C.unk4;
    sp20.unk0 = D_802B9174.unk0;
    sp20.unk4 = D_802B9174.unk4;
    sp20.unk8 = D_802B9174.unk8;
    temp_v0 = func_8029EC88(&sp20, &sp2C, &sp34, arg1);
    if (temp_v0 < 0) {
        return temp_v0;
    }
    temp_v1 = (temp_v0 * 0x70) + &D_8015F9B8;
    temp_v1->unk6 = 0;
    temp_v1->unk10 = 0x5B0;
    temp_v1->unk12 = -0x8000;
    temp_v1->unk14 = (arg0 - D_800DC4DC) / 0xDD8;
    temp_v1->unk4 = 0;
    temp_v1->unk8 = 0.0f;
    return temp_v0;
}
#else
GLOBAL_ASM("asm/non_matchings/code_802B0210/func_802B18E4.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s16 func_8029EC88(f32 *, ? *, ? *, s16); // extern
? func_802AD950(void *, f32, s32, s32, f32, f32, f32, f32); // extern
? func_802B4E30(void *); // extern
? func_802B63B8(f32 *, void *); // extern
extern ? D_8015F9B8;
extern ? D_802B9180;
extern ? D_802B918C;

? func_802B19EC(s32 arg0, void *arg1, s16 arg2, u16 arg3) {
    ? sp54;
    ? sp4C;
    f32 sp48;
    f32 sp44;
    f32 sp40;
    f32 *temp_a0;
    f32 *temp_a0_2;
    s16 temp_v0;
    s32 temp_t3;
    void *temp_a1;
    void *temp_s0;

    sp54.unk0 = D_802B9180.unk0;
    sp54.unk4 = D_802B9180.unk4;
    sp54.unk8 = D_802B9180.unk8;
    temp_a1 = arg1 + 0x174;
    temp_a0 = &sp40;
    sp4C.unk0 = D_802B918C.unk0;
    sp4C.unk4 = D_802B918C.unk4;
    sp40 = 0.0f;
    sp44 = -temp_a1->unk-104;
    sp48 = temp_a1->unk-104 - 4.0f;
    func_802B63B8(temp_a0, temp_a1);
    temp_a0_2 = &sp40;
    sp40 = 0.0f + arg1->unk14;
    sp44 += arg1->unk18;
    sp48 += arg1->unk1C;
    temp_v0 = func_8029EC88(temp_a0_2, &sp4C, &sp54, arg2);
    if (temp_v0 < 0) {
        (arg0 + (arg3 * 4))->unk24 = -1.0f;
        return -1;
    }
    temp_t3 = temp_v0 * 7;
    sp40 = arg1->unk14;
    temp_s0 = (temp_t3 * 0x10) + &D_8015F9B8;
    sp44 = arg1->unk18;
    sp48 = arg1->unk1C;
    func_802AD950(temp_s0 + 0x30, temp_s0->unkC + 1.0f, temp_s0->unk18, temp_s0->unk1C, temp_s0->unk20, sp40, sp44, sp48);
    func_802B4E30(temp_s0);
    temp_s0->unk2 = -0x7000;
    if (arg2 != 7) {
        if (arg2 != 8) {

        } else {
            temp_s0->unk6 = 6;
        }
    } else {
        temp_s0->unk6 = 4;
    }
    temp_s0->unk10 = 0;
    temp_s0->unk12 = -0x8000;
    temp_s0->unk14 = (arg1 - D_800DC4DC) / 0xDD8;
    temp_s0->unk4 = (arg0 - &D_8015F9B8) / 0x70;
    temp_s0->unk8 = arg3;
    (arg0 + (arg3 * 4))->unk24 = (temp_s0 - &D_8015F9B8) / 0x70;
    return 1;
}
#else
GLOBAL_ASM("asm/non_matchings/code_802B0210/func_802B19EC.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s16 func_8029EC88(f32 *, ? *, ? *, ?); // extern
? func_802AD950(void *, f32, s32, s32, f32, f32, f32, f32); // extern
? func_802B4E30(void *); // extern
? func_802B63B8(f32 *, s32); // extern
extern ? D_8015F9B8;
extern ? D_802B9194;
extern ? D_802B91A0;

s16 func_802B1C9C(void *arg0) {
    ? sp54;
    ? sp4C;
    f32 sp48;
    f32 sp44;
    f32 sp40;
    s16 sp3E;
    f32 *temp_a0;
    s16 temp_v0;
    s16 temp_v1;
    s32 temp_t8;
    void *temp_s0;

    sp54.unk0 = D_802B9194.unk0;
    sp54.unk4 = D_802B9194.unk4;
    sp54.unk8 = D_802B9194.unk8;
    sp4C.unk0 = D_802B91A0.unk0;
    sp4C.unk4 = D_802B91A0.unk4;
    sp40 = 0.0f;
    sp44 = -arg0->unk70;
    sp48 = arg0->unk70 - 4.0f;
    func_802B63B8(&sp40, arg0 + 0x174);
    temp_a0 = &sp40;
    sp40 = 0.0f + arg0->unk14;
    sp44 += arg0->unk18;
    sp48 += arg0->unk1C;
    temp_v0 = func_8029EC88(temp_a0, &sp4C, &sp54, 7);
    temp_v1 = temp_v0;
    if (temp_v0 < 0) {
        return temp_v0;
    }
    temp_t8 = temp_v1 * 7;
    sp40 = arg0->unk14;
    temp_s0 = (temp_t8 * 0x10) + &D_8015F9B8;
    sp44 = arg0->unk18;
    sp48 = arg0->unk1C;
    sp3E = temp_v1;
    func_802AD950(temp_s0 + 0x30, temp_s0->unkC + 1.0f, temp_s0->unk18, temp_s0->unk1C, temp_s0->unk20, sp40, sp44, sp48);
    func_802B4E30(temp_s0);
    temp_s0->unk6 = 0;
    temp_s0->unk10 = 0;
    temp_s0->unk12 = -0x8000;
    temp_s0->unk14 = (arg0 - D_800DC4DC) / 0xDD8;
    return sp3E;
}
#else
GLOBAL_ASM("asm/non_matchings/code_802B0210/func_802B1C9C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s16 func_8029EC88(f32 *, ? *, ? *, ?); // extern
? func_802AD950(void *, f32, s32, s32, f32, f32, f32, f32); // extern
? func_802B4E30(void *); // extern
? func_802B63B8(f32 *, s32); // extern
extern ? D_8015F9B8;
extern ? D_802B91A8;
extern ? D_802B91B4;

s16 func_802B1E48(void *arg0) {
    ? sp54;
    ? sp4C;
    f32 sp48;
    f32 sp44;
    f32 sp40;
    s16 sp3E;
    f32 *temp_a0;
    s16 temp_v0;
    s16 temp_v1;
    s32 temp_t8;
    void *temp_s0;

    sp54.unk0 = D_802B91A8.unk0;
    sp54.unk4 = D_802B91A8.unk4;
    sp54.unk8 = D_802B91A8.unk8;
    sp4C.unk0 = D_802B91B4.unk0;
    sp4C.unk4 = D_802B91B4.unk4;
    sp40 = 0.0f;
    sp44 = -arg0->unk70;
    sp48 = arg0->unk70 - 4.0f;
    func_802B63B8(&sp40, arg0 + 0x174);
    temp_a0 = &sp40;
    sp40 = 0.0f + arg0->unk14;
    sp44 += arg0->unk18;
    sp48 += arg0->unk1C;
    temp_v0 = func_8029EC88(temp_a0, &sp4C, &sp54, 8);
    temp_v1 = temp_v0;
    if (temp_v0 < 0) {
        return temp_v0;
    }
    temp_t8 = temp_v1 * 7;
    sp40 = arg0->unk14;
    temp_s0 = (temp_t8 * 0x10) + &D_8015F9B8;
    sp44 = arg0->unk18;
    sp48 = arg0->unk1C;
    sp3E = temp_v1;
    func_802AD950(temp_s0 + 0x30, temp_s0->unkC + 1.0f, temp_s0->unk18, temp_s0->unk1C, temp_s0->unk20, sp40, sp44, sp48);
    func_802B4E30(temp_s0);
    temp_s0->unk6 = 0;
    temp_s0->unk10 = 0;
    temp_s0->unk12 = arg0->unk2E - 0x8000;
    temp_s0->unk14 = (arg0 - D_800DC4DC) / 0xDD8;
    return sp3E;
}
#else
GLOBAL_ASM("asm/non_matchings/code_802B0210/func_802B1E48.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 func_802B1E48(); // extern
extern ? D_8015F9B8;

void func_802B1FFC(void) {
    *(&D_8015F9B8 + (func_802B1E48() * 0x70)) = 0x2A;
}
#else
GLOBAL_ASM("asm/non_matchings/code_802B0210/func_802B1FFC.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
? func_800C9060(s32, ?, u16);                       /* extern */
? func_8029E854(void *);                            /* extern */
? func_8029FDC8(f32, void *);                       /* extern */
? func_802ADDC8(f32, void *, void *, f32, f32, f32, f32); /* extern */
? func_802B4E30(void *);                            /* extern */
? func_802B64C4(f32 *, s16);                        /* extern */
? load_giant_egg(f32, f32 *, ?, f32, f32);          /* extern */
extern ? D_8015F9B8;

void update_obj_banana(void *arg0) {
    void *sp88;
    void *sp84;
    void *sp80;
    f32 sp7C;
    f32 sp78;
    f32 sp74;
    f32 sp70;
    f32 sp6C;
    f32 sp68;
    f32 sp48;
    f32 sp44;
    f32 sp40;
    f32 sp3C;
    f32 sp38;
    f32 sp34;
    f32 temp_f0;
    f32 temp_f0_10;
    f32 temp_f0_2;
    f32 temp_f0_3;
    f32 temp_f0_4;
    f32 temp_f0_5;
    f32 temp_f0_6;
    f32 temp_f0_7;
    f32 temp_f0_8;
    f32 temp_f0_9;
    f32 temp_f10;
    f32 temp_f12;
    f32 temp_f12_2;
    f32 temp_f12_3;
    f32 temp_f14;
    f32 temp_f14_2;
    f32 temp_f14_3;
    f32 temp_f14_4;
    f32 temp_f14_5;
    f32 temp_f16;
    f32 temp_f16_2;
    f32 temp_f16_3;
    f32 temp_f18;
    f32 temp_f2;
    f32 temp_f2_2;
    f32 temp_f2_3;
    f32 temp_f2_4;
    f32 temp_f2_5;
    s16 temp_a0;
    s16 temp_t6;
    s16 temp_v0;
    u16 temp_a2;
    u16 temp_t9;
    void *temp_v0_2;
    f32 phi_f6;
    void *phi_f14;
    void *phi_v1;
    f32 phi_f12;
    f32 phi_f8;
    void *phi_f14_2;

    temp_t6 = arg0->unk10;
    temp_t9 = arg0->unk6;
    switch (temp_t9) {
    case 0:
        temp_f2 = gPlayers[temp_t6].posX - arg0->unk18;
        temp_f14 = gPlayers[temp_t6].posY - arg0->unk1C;
        sp48 = temp_f2;
        temp_f16 = gPlayers[temp_t6].posZ - arg0->unk20;
        sp44 = temp_f14;
        sp88 = &gPlayers[temp_t6];
        sp40 = temp_f16;
        temp_f12 = sqrtf((temp_f2 * temp_f2) + (temp_f14 * temp_f14) + (temp_f16 * temp_f16), temp_f14) / 10.0f;
        phi_f14 = (bitwise void *) temp_f14;
        if (temp_f12 == 0.0f) {
            temp_f0 = D_802B9EE0;
            arg0->unk18 = gPlayers[temp_t6].posX + temp_f0;
            arg0->unk1C = gPlayers[temp_t6].posY + temp_f0;
            phi_f6 = gPlayers[temp_t6].posZ + temp_f0;
        } else {
            temp_f14_2 = temp_f14 / temp_f12;
            arg0->unk18 = gPlayers[temp_t6].posX - (temp_f2 / temp_f12);
            arg0->unk1C = (gPlayers[temp_t6].posY - temp_f14_2) - 2.0f;
            phi_f6 = gPlayers[temp_t6].posZ - (temp_f16 / temp_f12);
            phi_f14 = (bitwise void *) temp_f14_2;
        }
        arg0->unk20 = phi_f6;
        sp88 = &gPlayers[temp_t6];
        func_802ADDC8(temp_f12, phi_f14, arg0 + 0x30, arg0->unkC + 1.0f, arg0->unk18, arg0->unk1C, arg0->unk20);
        func_802B4E30(arg0);
        if ((gPlayers[temp_t6].unk_000 & PLAYER_HUMAN) != 0) {
            if (D_800DC51C != 0) {
                phi_v1 = D_800DC4BC;
            } else {
                phi_v1 = &gControllers[arg0->unk10];
            }
            temp_a2 = phi_v1->unk8;
            if ((temp_a2 & 0x2000) != 0) {
                phi_v1->unk8 = temp_a2 & 0xDFFF;
                arg0->unk6 = 1;
                arg0->unk4 = 0xB4;
                gPlayers[temp_t6].unk_00C &= 0xFFFBFFFF;
                sp80 = phi_v1;
                sp88 = &gPlayers[temp_t6];
                func_800C9060(((&gPlayers[temp_t6] - D_800DC4DC) / 3544) & 0xFF, 0x19008012, temp_a2);
                temp_f0_2 = phi_v1->unk2;
                if ((temp_f0_2 > 30.0f) && (temp_a0 = phi_v1->unk0, ((temp_a0 < 0xA) != 0)) && (temp_a0 >= -9)) {
                    temp_f2_2 = gPlayers[temp_t6].unk_094;
                    temp_f0_3 = ((temp_f0_2 - 30.0f) / 20.0f) + 0.5f;
                    if (temp_f2_2 < 2.0f) {
                        phi_f12 = 4.0f;
                    } else {
                        phi_f12 = (temp_f2_2 * 0.75f) + 3.5f + temp_f0_3;
                    }
                    sp88 = &gPlayers[temp_t6];
                    load_giant_egg(phi_f12, &sp68, 0, temp_f0_3, phi_f12);
                    func_802B64C4(&sp68, gPlayers[temp_t6].unk_02E + gPlayers[temp_t6].unk_0C0);
                    arg0->unk24 = sp68;
                    arg0->unk28 = sp6C;
                    arg0->unk2C = sp70;
                    return;
                }
                arg0->unk24 = 0.0f;
                arg0->unk2C = 0.0f;
                arg0->unk28 = 1.5f;
                return;
            }
            /* Duplicate return node #45. Try simplifying control flow for better match */
            return;
        }
    default:
        return;
    case 1:
        temp_v0 = arg0->unk4;
        if (temp_v0 != 0) {
            arg0->unk4 = temp_v0 - 1;
            if (arg0->unk4 == 0) {
                arg0->unk2 = arg0->unk2 & 0xEFFF;
            }
        }
        temp_f0_4 = arg0->unk28;
        arg0->unk18 = arg0->unk18 + arg0->unk24;
        arg0->unk20 = arg0->unk20 + arg0->unk2C;
        if (temp_f0_4 > -1.0f) {
            arg0->unk28 = temp_f0_4 - D_802B9EE4;
        }
        temp_f12_2 = arg0->unk20;
        arg0->unk1C = arg0->unk1C + arg0->unk28;
        if ((temp_f12_2 < D_8015F6F2) || (D_8015F6F0 < temp_f12_2) || (temp_f0_5 = arg0->unk18, (temp_f0_5 < D_8015F6EA)) || (D_8015F6E8 < temp_f0_5) || (temp_f2_3 = arg0->unk1C, (temp_f2_3 < D_8015F6EE))) {
            func_8029FDC8(temp_f12_2, arg0);
            return;
        }
        func_802ADDC8(temp_f12_2, arg0 + 0x30, (bitwise void *) (arg0->unkC + 1.0f), temp_f0_5, temp_f2_3, temp_f12_2);
        arg0->unk34 = 1;
        if (((1 & 0xFFFF) != 0) && (arg0->unk44 < 0.0f)) {
            sp74 = -arg0->unk60;
            sp78 = -arg0->unk64;
            sp7C = -arg0->unk68;
            temp_f0_6 = arg0->unk44;
            arg0->unk18 = arg0->unk18 + (sp74 * temp_f0_6);
            arg0->unk1C = arg0->unk1C + (sp78 * temp_f0_6);
            arg0->unk2 = arg0->unk2 & 0xEFFF;
            arg0->unk6 = 4;
            arg0->unk20 = arg0->unk20 + (sp7C * temp_f0_6);
            return;
        }
        /* Duplicate return node #45. Try simplifying control flow for better match */
        return;
    case 2:
        sp68 = 0.0f;
        sp6C = 0.0f;
        sp70 = -5.0f;
        sp88 = &gPlayers[temp_t6];
        func_802B64C4(&sp68, gPlayers[temp_t6].unk_02E + gPlayers[temp_t6].unk_0C0);
        temp_f18 = sp68 + gPlayers[temp_t6].posX;
        temp_f0_7 = sp6C + gPlayers[temp_t6].posY;
        temp_f10 = sp70 + gPlayers[temp_t6].posZ;
        sp34 = temp_f10;
        temp_f2_4 = temp_f18 - arg0->unk18;
        sp3C = temp_f18;
        sp38 = temp_f0_7;
        temp_f14_3 = temp_f0_7 - arg0->unk1C;
        sp48 = temp_f2_4;
        temp_f16_2 = temp_f10 - arg0->unk20;
        sp44 = temp_f14_3;
        sp40 = temp_f16_2;
        temp_f0_8 = sqrtf((temp_f2_4 * temp_f2_4) + (temp_f14_3 * temp_f14_3) + (temp_f16_2 * temp_f16_2), temp_f14_3);
        if (temp_f0_8 == 0.0f) {
            temp_f0_9 = D_802B9EE8;
            arg0->unk18 = gPlayers[temp_t6].posX + temp_f0_9;
            arg0->unk1C = gPlayers[temp_t6].posY + temp_f0_9;
            arg0->unk20 = gPlayers[temp_t6].posZ + temp_f0_9;
        } else {
            arg0->unk18 = sp68 + (temp_f18 - (temp_f2_4 / temp_f0_8));
            arg0->unk1C = (sp38 - (temp_f14_3 / temp_f0_8)) - 2.0f;
            arg0->unk20 = sp34 - (temp_f16_2 / temp_f0_8);
        }
        func_802ADDC8((bitwise f32) (arg0 + 0x30), (bitwise void *) (arg0->unkC + 1.0f), (bitwise void *) arg0->unk18, arg0->unk1C, arg0->unk20);
        func_802B4E30(arg0);
        return;
    case 3:
        temp_v0_2 = (arg0->unk12 * 0x70) + &D_8015F9B8;
        temp_f2_5 = temp_v0_2->unk18 - arg0->unk18;
        temp_f14_4 = temp_v0_2->unk1C - arg0->unk1C;
        sp48 = temp_f2_5;
        temp_f16_3 = temp_v0_2->unk20 - arg0->unk20;
        sp44 = temp_f14_4;
        sp84 = temp_v0_2;
        sp40 = temp_f16_3;
        temp_f12_3 = sqrtf((temp_f2_5 * temp_f2_5) + (temp_f14_4 * temp_f14_4) + (temp_f16_3 * temp_f16_3), temp_f14_4) / 5.0f;
        phi_f14_2 = (bitwise void *) temp_f14_4;
        if (temp_f12_3 == 0.0f) {
            temp_f0_10 = D_802B9EEC;
            arg0->unk18 = temp_v0_2->unk18 + temp_f0_10;
            arg0->unk1C = temp_v0_2->unk1C + temp_f0_10;
            phi_f8 = temp_v0_2->unk20 + temp_f0_10;
        } else {
            temp_f14_5 = temp_f14_4 / temp_f12_3;
            arg0->unk18 = temp_v0_2->unk18 - (temp_f2_5 / temp_f12_3);
            arg0->unk1C = (temp_v0_2->unk1C - temp_f14_5) - 2.0f;
            phi_f8 = temp_v0_2->unk20 - (temp_f16_3 / temp_f12_3);
            phi_f14_2 = (bitwise void *) temp_f14_5;
        }
        arg0->unk20 = phi_f8;
        func_802ADDC8(temp_f12_3, phi_f14_2, arg0 + 0x30, arg0->unkC + 1.0f, arg0->unk18, arg0->unk1C, arg0->unk20);
        func_802B4E30(arg0);
        return;
    case 5:
        arg0->unk28 = arg0->unk28 - D_802B9EF0;
        if (arg0->unk28 < -5.0f) {
            arg0->unk28 = -5.0f;
        }
        arg0->unk4 = arg0->unk4 - 1;
        arg0->unk1C = arg0->unk1C + arg0->unk28;
        arg0->unk10 = arg0->unk10 + 0x16C;
        arg0->unk12 = arg0->unk12 - 0x5B0;
        arg0->unk14 = arg0->unk14 + 0x38E;
        if (arg0->unk4 == 0) {
            func_8029E854(arg0);
            return;
        }
        /* Duplicate return node #45. Try simplifying control flow for better match */
        return;
    case 4:
        arg0->unk2 = arg0->unk2 | 0xC000;
        arg0->unk2 = arg0->unk2 & 0xEFFF;
        /* Duplicate return node #45. Try simplifying control flow for better match */
        return;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_802B0210/update_obj_banana.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
? func_800C9060(s32, ?, s32 *, s32);                /* extern */
s32 func_8029EC88(f32 *, s16 *, f32 *, ?);          /* extern */
? func_802AD950(void *, f32, s32, s32, f32, f32, f32, f32); /* extern */
? func_802B4E30(void *);                            /* extern */
? func_802B63B8(f32 *, f32 *);                      /* extern */
extern ? D_8015F9B8;

void func_802B2914(void *arg0, Player *player, s16 arg2) {
    s16 sp6E;
    f32 sp68;
    f32 sp64;
    f32 sp60;
    s16 sp5C;
    s16 sp5A;
    s16 sp58;
    f32 sp54;
    f32 sp50;
    f32 sp4C;
    f32 *temp_a0;
    f32 *temp_a2;
    s16 *temp_a1;
    s16 temp_t6;
    s32 temp_lo;
    s32 temp_v0;
    void *temp_s0;
    void *phi_v0;

    sp4C = 0.0f;
    sp50 = -player->unk_070;
    sp54 = -(player->unk_070 + 4.0f);
    func_802B63B8(&sp4C, player->unk_174);
    temp_a0 = &sp4C;
    temp_a1 = &sp58;
    temp_a2 = &sp60;
    sp4C += player->posX;
    sp50 += player->posY;
    sp54 += player->posZ;
    sp60 = player->unk_034;
    sp64 = player->unk_038;
    sp58 = 0;
    sp5A = 0;
    sp5C = 0;
    sp68 = player->unk_03C;
    temp_v0 = func_8029EC88(temp_a0, temp_a1, temp_a2, 6);
    temp_t6 = temp_v0;
    if (temp_v0 >= 0) {
        temp_lo = temp_t6 * 0x70;
        sp4C = player->posX;
        sp50 = player->posY;
        temp_s0 = &D_8015F9B8 + temp_lo;
        sp54 = player->posZ;
        sp6E = temp_t6;
        func_802AD950(temp_s0 + 0x30, temp_s0->unkC + 1.0f, temp_s0->unk18, temp_s0->unk1C, temp_s0->unk20, sp4C, sp50, sp54);
        func_802B4E30(temp_s0);
        temp_s0->unk2 = -0x7000;
        temp_s0->unk10 = (player - D_800DC4DC) / 3544;
        temp_s0->unk8 = (arg0 - &D_8015F9B8) / 112;
        temp_s0->unk14 = -1;
        temp_s0->unk4 = 0x14;
        temp_s0->unkA = arg2;
        switch (arg2) {
        case 0:
            temp_s0->unk6 = 2;
            arg0->unk12 = sp6E;
            temp_s0->unk12 = -1;
            break;
        case 1:
            temp_s0->unk6 = 3;
            arg0->unk14 = sp6E;
            temp_s0->unk12 = arg0->unk12;
            phi_v0 = &D_8015F9B8 + (arg0->unk12 * 0x70);
block_8:
            phi_v0->unk14 = sp6E;
            break;
        case 2:
            temp_s0->unk6 = 3;
            arg0->unk16 = sp6E;
            temp_s0->unk12 = arg0->unk14;
            phi_v0 = &D_8015F9B8 + (arg0->unk14 * 0x70);
            goto block_8;
        case 3:
            temp_s0->unk6 = 3;
            arg0->unk18 = sp6E;
            temp_s0->unk12 = arg0->unk16;
            phi_v0 = &D_8015F9B8 + (arg0->unk16 * 0x70);
            goto block_8;
        case 4:
            temp_s0->unk6 = 3;
            arg0->unk1A = sp6E;
            temp_s0->unk12 = arg0->unk18;
            phi_v0 = &D_8015F9B8 + (arg0->unk18 * 0x70);
            goto block_8;
        }
        if ((player->unk_000 & PLAYER_HUMAN) != 0) {
            func_800C9060(((player - D_800DC4DC) / 3544) & 0xFF, 0x19008012, &D_800DC4DC, 0xDD8);
        }
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_802B0210/func_802B2914.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s16 func_8029EC88(f32 *, s16 *, f32 *, ?); // extern
? func_802B63B8(f32 *, void *); // extern
extern ? D_8015F9B8;

s16 func_802B2C40(void *arg0) {
    f32 sp40;
    f32 sp3C;
    f32 sp38;
    s16 sp34;
    s16 sp32;
    s16 sp30;
    f32 sp2C;
    f32 sp28;
    f32 sp24;
    f32 *temp_a0;
    f32 *temp_a2;
    s16 *temp_a1;
    s16 temp_v0;
    void *temp_v1;

    sp24 = 0.0f;
    sp28 = -arg0->unk70;
    sp2C = -(arg0->unk70 + 4.0f);
    func_802B63B8(&sp24, arg0 + 0x174);
    temp_a0 = &sp24;
    temp_a1 = &sp30;
    temp_a2 = &sp38;
    sp24 += arg0->unk14;
    sp28 += arg0->unk18;
    sp2C += arg0->unk1C;
    sp38 = arg0->unk34;
    sp3C = arg0->unk38;
    sp30 = 0;
    sp32 = 0;
    sp34 = 0;
    sp40 = arg0->unk3C;
    temp_v0 = func_8029EC88(temp_a0, temp_a1, temp_a2, 0xD);
    if (temp_v0 < 0) {
        return temp_v0;
    }
    temp_v1 = (temp_v0 * 0x70) + &D_8015F9B8;
    temp_v1->unk6 = 0;
    temp_v1->unk24 = (arg0 - D_800DC4DC) / 0xDD8;
    arg0->unkC = arg0->unkC | 0x40000;
    return temp_v0;
}
#else
GLOBAL_ASM("asm/non_matchings/code_802B0210/func_802B2C40.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s16 func_8029EC88(f32 *, s16 *, f32 *, ?); // extern
? func_802B63B8(f32 *, void *); // extern
extern ? D_8015F9B8;

s16 func_802B2D70(void *arg0) {
    f32 sp44;
    f32 sp40;
    f32 sp3C;
    s16 sp38;
    s16 sp36;
    s16 sp34;
    f32 sp30;
    f32 sp2C;
    f32 sp28;
    s32 sp20;
    f32 *temp_a0;
    f32 *temp_a2;
    s16 *temp_a1;
    s16 temp_v0;
    s32 temp_t0;
    void *temp_v1;

    temp_t0 = ((arg0 - D_800DC4DC) / 0xDD8) & 0xFFFF;
    if (temp_t0 >= 8) {
        return -1;
    }
    sp28 = 0.0f;
    sp2C = -arg0->unk70;
    sp20 = temp_t0;
    sp30 = -(arg0->unk70 + 4.0f);
    func_802B63B8(&sp28, arg0 + 0x174);
    temp_a0 = &sp28;
    temp_a1 = &sp34;
    temp_a2 = &sp3C;
    sp28 += arg0->unk14;
    sp2C += arg0->unk18;
    sp30 += arg0->unk1C;
    sp3C = arg0->unk34;
    sp40 = arg0->unk38;
    sp34 = 0;
    sp36 = 0;
    sp38 = 0;
    sp44 = arg0->unk3C;
    temp_v0 = func_8029EC88(temp_a0, temp_a1, temp_a2, 6);
    if (temp_v0 < 0) {
        return temp_v0;
    }
    temp_v1 = (temp_v0 * 0x70) + &D_8015F9B8;
    temp_v1->unk10 = temp_t0;
    temp_v1->unk6 = 0;
    temp_v1->unk4 = 0x14;
    arg0->unkC = arg0->unkC | 0x40000;
    return temp_v0;
}
#else
GLOBAL_ASM("asm/non_matchings/code_802B0210/func_802B2D70.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_8009E5BC(); // extern
? func_800CAB4C(s32); // extern
extern ? gGfxPools;
extern ? gPlayers;

void func_802B2EBC(u16 *arg0) {
    u16 *temp_a2;
    void *temp_v0;
    u16 *phi_a2;
    ? *phi_v1;
    void *phi_a0;
    void *phi_a1;
    void *phi_v0;

    func_8009E5BC();
    temp_a2 = arg0;
    phi_a2 = temp_a2;
    if ((*temp_a2 & 0x4000) != 0) {
        arg0 = temp_a2;
        func_800CAB4C(((temp_a2 - D_800DC4DC) / 0xDD8) & 0xFF);
        phi_a2 = arg0;
    }
    phi_v1 = &gPlayers;
    phi_a0 = &gPlayers + 0xDD8;
    phi_a1 = &gPlayers + 0x1BB0;
    phi_v0 = &gPlayers + 0x2988;
    do {
        if (phi_a2 != phi_v1) {
            phi_v1->unkC = phi_v1->unkC | 0x4000;
        }
        phi_v1 += 0x3760;
        if (phi_a2 != phi_a0) {
            phi_a0->unkC = phi_a0->unkC | 0x4000;
        }
        phi_a0 += 0x3760;
        if (phi_a2 != phi_a1) {
            phi_a1->unkC = phi_a1->unkC | 0x4000;
        }
        if (phi_a2 != phi_v0) {
            phi_v0->unkC = phi_v0->unkC | 0x4000;
        }
        temp_v0 = phi_v0 + 0x3760;
        phi_a1 += 0x3760;
        phi_v0 = temp_v0;
    } while (temp_v0 != (&gGfxPools + 0x2978));
}
#else
GLOBAL_ASM("asm/non_matchings/code_802B0210/func_802B2EBC.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
? func_8007AC9C(s32);                               /* extern */
? func_802B17F4();                                  /* extern */
? func_802B18E4(?);                                 /* extern */
? func_802B1C9C();                                  /* extern */
? func_802B1E48();                                  /* extern */
? func_802B1FFC();                                  /* extern */
? func_802B2C40();                                  /* extern */
? func_802B2D70();                                  /* extern */
? func_802B2EBC();                                  /* extern */

void func_802B2FA0(Player *player) {
    s32 sp1C;
    s16 temp_t9;

    sp1C = (player - D_800DC4DC) / 3544;
    temp_t9 = player->unk10;
    switch (temp_t9) {
    case 3:
        func_802B1C9C();
        break;
    case 5:
        func_802B1E48();
        break;
    case 7:
        func_802B1FFC();
        break;
    case 1:
        func_802B2D70();
        break;
    case 2:
        func_802B17F4();
        break;
    case 12:
        player->unk_00C |= 0x200;
        break;
    case 13:
        player->unk_00C |= 0x200;
        break;
    case 14:
        player->unk_00C |= 0x200;
        break;
    case 15:
        player->unk_00C |= 0x200;
        break;
    case 11:
        player->unk_00C |= 0x800;
        break;
    case 10:
        player->unk_00C |= 0x2000;
        break;
    case 8:
        func_802B2EBC();
        break;
    case 9:
        func_802B2C40();
        break;
    case 4:
        func_802B18E4(0x15);
        break;
    case 6:
        func_802B18E4(0x16);
        break;
    }
    func_8007AC9C(sp1C);
}
#else
GLOBAL_ASM("asm/non_matchings/code_802B0210/func_802B2FA0.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 func_800910E4(? *); // extern
? func_802B2FA0(? *); // extern
extern ? *D_800DC4D0;
extern ? *D_800DC4D4;
extern ? *D_800DC4D8;
extern ? gControllers;
extern ? gPlayers;

void func_802B30EC(void) {
    ? *temp_s2;
    u16 temp_v0;
    u16 temp_v0_2;
    ? *phi_s0;
    ? *phi_s1;
    ? *phi_s2;

    phi_s0 = &gPlayers;
    phi_s2 = &gControllers;
    do {
        phi_s1 = phi_s2;
        if (func_800910E4(phi_s0) == 0) {
            temp_v0 = phi_s0->unk0;
            if ((temp_v0 & 0x100) != 0) {
                if (((phi_s0 - D_800DC4E0) / 0xDD8) == 0) {
                    phi_s1 = D_800DC4D0;
                } else if (((phi_s0 - D_800DC4E4) / 0xDD8) == 0) {
                    phi_s1 = D_800DC4D4;
                } else if (((phi_s0 - D_800DC4DC) / 0xDD8) == 0) {
                    phi_s1 = D_800DC4D8;
                }
            }
            if (((temp_v0 & 0x4000) != 0) && (phi_s0->unk10 != 0) && ((temp_v0 & 0x2000) == 0)) {
                temp_v0_2 = phi_s1->unk6;
                if ((temp_v0_2 & 0x2000) != 0) {
                    phi_s1->unk6 = temp_v0_2 & ~0x2000;
                    func_802B2FA0(phi_s0);
                }
            }
        }
        temp_s2 = phi_s2 + 0x10;
        phi_s0 += 0xDD8;
        phi_s2 = temp_s2;
    } while (temp_s2 != (&gControllers + 0x40));
}
#else
GLOBAL_ASM("asm/non_matchings/code_802B0210/func_802B30EC.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
? func_8000EDC8(s32);                               /* extern */
? func_800C9060(u8, ?);                             /* extern */
? func_800C90F4(u8, s32);                           /* extern */
? func_800C98B8(void *, void *, ?);                 /* extern */
? func_8029E854(f32, void *);                       /* extern */
? func_8029FDC8(f32, void *);                       /* extern */
? func_802AC098(void *, void *);                    /* extern */
? func_802AD950(void *, ?, f32, f32, f32, f32, f32, f32); /* extern */
? func_802B0210(s16 *, void *);                     /* extern */
? func_802B4E30(void *);                            /* extern */
? func_802B63B8(f32 *, f32 *, f32 *);               /* extern */
? func_802B64C4(f32 *, s16);                        /* extern */
extern ? D_8015F9B8;

void update_obj_green_shell(void *arg0) {
    f32 sp80;
    f32 sp7C;
    f32 sp78;
    f32 sp74;
    f32 sp70;
    f32 sp6C;
    f32 sp54;
    void *sp34;
    Player *temp_s1;
    Player *temp_s1_2;
    Player *temp_s1_4;
    f32 temp_f0;
    f32 temp_f0_2;
    f32 temp_f0_3;
    f32 temp_f0_4;
    f32 temp_f12;
    f32 temp_f14;
    f32 temp_f18;
    f32 temp_f2;
    f32 temp_f2_2;
    s16 temp_t4;
    s16 temp_t9;
    s16 temp_v0;
    s16 temp_v0_2;
    u16 temp_t3;
    u16 temp_v1;
    void *temp_a0;
    void *temp_s1_3;
    void *temp_v0_3;
    f32 phi_f2;
    f32 phi_f2_2;

    temp_f2 = arg0->unk20;
    temp_f0 = arg0->unk18;
    temp_f12 = arg0->unk1C;
    if ((temp_f2 < D_8015F6F2) || (D_8015F6F0 < temp_f2) || (temp_f0 < D_8015F6EA) || (D_8015F6E8 < temp_f0) || (temp_f12 < D_8015F6EE)) {
        func_8029FDC8(temp_f12, arg0);
    }
    temp_t3 = arg0->unk6;
    arg0->unk10 = arg0->unk10 + 0x71C;
    switch (temp_t3) {
    case 0:
        temp_s1 = &gPlayers[arg0->unk14];
        func_802B0210(&temp_s1->unk_110, arg0 + 0x30);
        sp6C = 0.0f;
        sp70 = temp_s1->unk_070;
        sp74 = -(temp_s1->unk_070 + arg0->unkC + 2.0f);
        func_802B63B8(&sp6C, temp_s1->unk_174);
        arg0->unk18 = sp6C + temp_s1->posX;
        temp_f14 = temp_s1->posY - sp70;
        arg0->unk20 = sp74 + temp_s1->posZ;
        sp54 = temp_f14;
        temp_f0_2 = func_802ABE30(arg0->unk18, temp_f14, arg0->unk20, temp_s1->unk_11A);
        temp_f2_2 = temp_f14 - temp_f0_2;
        if ((temp_f2_2 < 5.0f) && (temp_f2_2 > -5.0f)) {
            arg0->unk1C = arg0->unkC + temp_f0_2;
        } else {
            arg0->unk1C = temp_f14;
        }
        if (((temp_s1->unk_000 & PLAYER_HUMAN) != 0) && (temp_t9 = arg0->unk14, temp_v1 = gControllers[temp_t9].buttonDepressed, ((temp_v1 & 0x2000) != 0))) {
            gControllers[temp_t9].buttonDepressed = temp_v1 & 0xDFFF;
            if (gControllers[temp_t9].rawStickY < -0x2D) {
                temp_f0_3 = temp_s1->unk_094;
                phi_f2 = 8.0f;
                if (temp_f0_3 > 8.0f) {
                    phi_f2 = temp_f0_3 * D_802B9F5C;
                }
                sp6C = 0.0f;
                sp70 = 0.0f;
                sp74 = -phi_f2;
                func_802B64C4(&sp6C, temp_s1->unk_02E + temp_s1->unk_0C0);
                arg0->unk24 = sp6C;
                arg0->unk28 = sp70;
                arg0->unk6 = 2;
                arg0->unk2C = sp74;
                func_800C9060(arg0->unk15, 0x19008004);
                func_800C90F4(arg0->unk15, (temp_s1->characterId * 0x10) + 0x29008000);
                func_8000EDC8((arg0 - &D_8015F9B8) / 112);
                return;
            }
            arg0->unk6 = 1;
            if (temp_s1->unk_0C0 > 0) {
                arg0->unk12 = 0x78E3;
                return;
            }
            arg0->unk12 = -0x78E4;
            return;
        }
    default:
        return;
    case 1:
        temp_v0 = arg0->unk12;
        temp_s1_2 = &gPlayers[arg0->unk14];
        if (temp_v0 > 0) {
            arg0->unk12 = temp_v0 - 0xE38;
            if (arg0->unk12 < 0) {
                arg0->unk6 = 2;
                arg0->unk4 = 0x1E;
                func_800C9060(arg0->unk15, 0x19008004);
                func_800C90F4(arg0->unk15, (temp_s1_2->characterId * 0x10) + 0x29008000);
                func_8000EDC8((arg0 - &D_8015F9B8) / 112);
            }
        } else {
            arg0->unk12 = temp_v0 + 0xE38;
            if (arg0->unk12 > 0) {
                arg0->unk6 = 2;
                arg0->unk4 = 0x1E;
                func_800C9060(arg0->unk15, 0x19008004);
                func_800C90F4(arg0->unk15, (temp_s1_2->characterId * 0x10) + 0x29008000);
                func_8000EDC8((arg0 - &D_8015F9B8) / 112);
            }
        }
        if (arg0->unk6 == 2) {
            temp_f0_4 = temp_s1_2->unk_094;
            phi_f2_2 = 8.0f;
            if (temp_f0_4 > 8.0f) {
                phi_f2_2 = temp_f0_4 * D_802B9F60;
            }
            sp6C = 0.0f;
            sp70 = 0.0f;
            sp74 = phi_f2_2;
            func_802B64C4(&sp6C, temp_s1_2->unk_02E + temp_s1_2->unk_0C0);
            arg0->unk24 = sp6C;
            arg0->unk28 = sp70;
            arg0->unk2C = sp74;
            return;
        }
        sp6C = sins(arg0->unk12) * 6.0f;
        sp70 = arg0->unkC - temp_s1_2->unk_070;
        sp74 = coss(arg0->unk12, MIPS2C_ERROR(Read from unset register $a1)) * 6.0f;
        func_802B63B8(&sp6C, temp_s1_2->unk_174);
        arg0->unk18 = sp6C + temp_s1_2->posX;
        arg0->unk1C = sp70 + temp_s1_2->posY;
        arg0->unk20 = sp74 + temp_s1_2->posZ;
        return;
    case 2:
        temp_v0_2 = arg0->unk4;
        if (temp_v0_2 > 0) {
            arg0->unk4 = temp_v0_2 - 1;
            if (arg0->unk4 == 0) {
                arg0->unk2 = arg0->unk2 & 0xEFFF;
            }
        }
        arg0->unk28 = arg0->unk28 - 0.5f;
        if (arg0->unk28 < -2.0f) {
            arg0->unk28 = -2.0f;
        }
        temp_a0 = arg0 + 0x30;
        sp78 = arg0->unk18;
        sp7C = arg0->unk1C;
        sp80 = arg0->unk20;
        arg0->unk18 = arg0->unk18 + arg0->unk24;
        arg0->unk1C = arg0->unk1C + arg0->unk28;
        arg0->unk20 = arg0->unk20 + arg0->unk2C;
        sp34 = temp_a0;
        func_802AD950(temp_a0, 0x40800000, arg0->unk18, arg0->unk1C, arg0->unk20, sp78, sp7C, sp80);
        func_802B4E30(arg0);
        temp_s1_3 = arg0 + 0x24;
        if ((arg0->unk3C < 0.0f) || (arg0->unk40 < 0.0f)) {
            func_802AC098(temp_a0, temp_s1_3);
            func_800C98B8(arg0 + 0x18, temp_s1_3, 0x19008054);
            arg0->unk2 = arg0->unk2 | 0x80;
            return;
        }
        /* Duplicate return node #46. Try simplifying control flow for better match */
        return;
    case 4:
        temp_v0_3 = (arg0->unk4 * 0x70) + &D_8015F9B8;
        temp_s1_4 = &gPlayers[arg0->unk14];
        if (temp_v0_3->unk0 != 0x15) {
            func_8029FDC8((bitwise f32) arg0);
            return;
        }
        temp_t4 = arg0->unk12 + temp_v0_3->unk10;
        arg0->unk12 = temp_t4;
        sp6C = sins(temp_t4 & 0xFFFF) * 8.0f;
        sp70 = arg0->unkC - temp_s1_4->unk_070;
        temp_f18 = coss(arg0->unk12, MIPS2C_ERROR(Read from unset register $a1)) * 8.0f;
        sp74 = temp_f18;
        func_802B63B8((bitwise f32 *) 8.0f, &sp6C, temp_s1_4->unk_174);
        sp78 = arg0->unk18;
        sp7C = arg0->unk1C;
        sp80 = arg0->unk20;
        arg0->unk18 = sp6C + temp_s1_4->posX;
        arg0->unk1C = sp70 + temp_s1_4->posY;
        arg0->unk20 = temp_f18 + temp_s1_4->posZ;
        func_802AD950(arg0 + 0x30, 0x40800000, arg0->unk18, arg0->unk1C, arg0->unk20, sp78, sp7C, sp80);
        func_802B4E30(arg0);
        return;
    case 5:
        arg0->unk28 = arg0->unk28 - D_802B9F64;
        if (arg0->unk28 < -5.0f) {
            arg0->unk28 = -5.0f;
        }
        arg0->unk4 = arg0->unk4 - 1;
        arg0->unk12 = arg0->unk12 + 0x5B0;
        arg0->unk1C = arg0->unk1C + arg0->unk28;
        if (arg0->unk4 == 0) {
            func_8029E854(-5.0f, arg0);
        }
        /* Duplicate return node #46. Try simplifying control flow for better match */
        return;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_802B0210/update_obj_green_shell.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_802AD950(void *, f32, f32, f32, f32, f32, f32, f32); // extern
? func_802B4E30(void *); // extern
extern u16 D_80164430;
extern s32 D_80164490;

void func_802B3B44(void *arg0) {
    f32 spAC;
    f32 spA8;
    f32 spA4;
    f32 sp70;
    f32 sp6C;
    f32 sp68;
    f32 sp60;
    f32 sp5C;
    f32 sp58;
    f32 temp_f0;
    f32 temp_f0_2;
    f32 temp_f0_3;
    f32 temp_f10;
    f32 temp_f12;
    f32 temp_f12_2;
    f32 temp_f12_3;
    f32 temp_f14;
    f32 temp_f14_2;
    f32 temp_f16;
    f32 temp_f16_2;
    f32 temp_f16_3;
    f32 temp_f18;
    f32 temp_f18_2;
    f32 temp_f18_3;
    f32 temp_f20;
    f32 temp_f22;
    f32 temp_f22_2;
    f32 temp_f24;
    f32 temp_f26;
    f32 temp_f28;
    f32 temp_f2;
    f32 temp_f2_2;
    f32 temp_f2_3;
    s32 temp_a1;
    s32 temp_a3;
    s32 temp_t1;
    u16 temp_t0;
    u16 temp_v1;
    void *temp_v0;
    void *temp_v0_2;
    void *temp_v0_3;
    u16 phi_a2;
    f32 phi_f2;
    f32 phi_f14;
    f32 phi_f16;

    temp_v1 = arg0->unk12;
    temp_t1 = D_80164490;
    temp_v0 = temp_t1 + (temp_v1 * 8);
    temp_t0 = D_80164430;
    temp_a1 = temp_v1 + 1;
    temp_a3 = temp_a1 & 0xFFFF;
    temp_f2 = temp_v0->unk0;
    temp_f12 = temp_v0->unk2;
    temp_f28 = temp_v0->unk4;
    phi_a2 = temp_a1 & 0xFFFF;
    if (temp_a3 >= temp_t0) {
        phi_a2 = (temp_a3 - temp_t0) & 0xFFFF;
    }
    temp_f0 = arg0->unk18;
    temp_f16 = arg0->unk1C;
    temp_f18 = arg0->unk20;
    temp_f20 = temp_f2 - temp_f0;
    temp_f22 = temp_f12 - temp_f16;
    temp_v0_2 = temp_t1 + (phi_a2 * 8);
    temp_f24 = temp_f28 - temp_f18;
    sp60 = temp_f0;
    sp5C = temp_f16;
    sp58 = temp_f18;
    temp_f14 = (temp_f20 * temp_f20) + (temp_f22 * temp_f22) + (temp_f24 * temp_f24);
    if (temp_f14 > 400.0f) {
        temp_f0_2 = temp_v0_2->unk0 - sp60;
        temp_f2_2 = temp_v0_2->unk2 - sp5C;
        temp_f12_2 = temp_v0_2->unk4 - sp58;
        if (((temp_f0_2 * temp_f0_2) + (temp_f2_2 * temp_f2_2) + (temp_f12_2 * temp_f12_2)) < temp_f14) {
            arg0->unk12 = phi_a2;
            return;
        }
        temp_f18_2 = sqrtf(temp_f14) * 4.0f;
        temp_f22_2 = temp_f22 / temp_f18_2;
        temp_f2_3 = arg0->unk24 + (temp_f20 / temp_f18_2);
        temp_f10 = temp_f2_3 * temp_f2_3;
        spAC = temp_f2_3;
        temp_f14_2 = arg0->unk28 + temp_f22_2;
        spA8 = temp_f14_2;
        temp_f16_2 = arg0->unk2C + (temp_f24 / temp_f18_2);
        spA4 = temp_f16_2;
        temp_f0_3 = sqrtf(temp_f10 + (temp_f14_2 * temp_f14_2) + (temp_f16_2 * temp_f16_2));
        phi_f2 = temp_f2_3;
        phi_f14 = temp_f14_2;
        phi_f16 = temp_f16_2;
        if (temp_f0_3 > 6.0f) {
            temp_f12_3 = temp_f0_3 / 6.0f;
            phi_f2 = temp_f2_3 / temp_f12_3;
            phi_f14 = temp_f14_2 / temp_f12_3;
            phi_f16 = temp_f16_2 / temp_f12_3;
        }
        arg0->unk24 = phi_f2;
        arg0->unk28 = phi_f14;
        arg0->unk2C = phi_f16;
        sp68 = arg0->unk18;
        sp6C = arg0->unk1C;
        sp70 = arg0->unk20;
        arg0->unk18 = arg0->unk18 + phi_f2;
        arg0->unk1C = arg0->unk1C + phi_f14;
        arg0->unk20 = arg0->unk20 + phi_f16;
        func_802AD950(arg0 + 0x30, 4.0f, arg0->unk18, arg0->unk1C, arg0->unk20, sp68, sp6C, sp70);
        func_802B4E30(arg0);
        return;
    }
    temp_v0_3 = temp_t1 + (phi_a2 * 8);
    if (temp_f14 > 5.0f) {
        arg0->unk18 = temp_f2;
        arg0->unk20 = temp_f28;
        arg0->unk12 = phi_a2;
        arg0->unk1C = arg0->unkC + temp_f12;
        return;
    }
    temp_f16_3 = temp_v0_3->unk0;
    temp_f18_3 = temp_v0_3->unk2;
    temp_f26 = temp_v0_3->unk4;
    arg0->unk18 = (temp_f2 + temp_f16_3) * 0.5f;
    arg0->unk1C = ((temp_f12 + temp_f18_3) * 0.5f) + arg0->unkC;
    arg0->unk20 = (temp_f28 + temp_f26) * 0.5f;
    arg0->unk24 = (temp_f16_3 - temp_f2) * 0.5f;
    arg0->unk28 = (temp_f18_3 - temp_f12) * 0.5f;
    arg0->unk2C = (temp_f26 - temp_f28) * 0.5f;
}
#else
GLOBAL_ASM("asm/non_matchings/code_802B0210/func_802B3B44.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_8029FDC8(f32, f32, void *, ?); // extern
? func_802AD950(f32, f32, void *, ?, f32, f32, f32, f32, f32, f32); // extern
? func_802B4104(void *); // extern
? func_802B4E30(void *); // extern

void func_802B3E7C(void *arg0, void *arg1) {
    f32 sp44;
    f32 sp40;
    f32 sp38;
    f32 sp34;
    f32 sp30;
    f32 temp_f12;
    f32 temp_f14;
    f32 temp_f2;
    f32 phi_f2;
    f32 phi_f14;

    temp_f2 = arg1->unk14 - arg0->unk18;
    temp_f14 = arg1->unk1C - arg0->unk20;
    sp44 = temp_f2;
    sp40 = temp_f14;
    temp_f12 = sqrtf((temp_f2 * temp_f2) + (temp_f14 * temp_f14)) / 8.0f;
    if (temp_f12 == 0.0f) {
        phi_f2 = 0.0f;
        phi_f14 = 0.0f;
    } else {
        phi_f2 = temp_f2 / temp_f12;
        phi_f14 = temp_f14 / temp_f12;
    }
    sp30 = arg0->unk18;
    sp34 = arg0->unk1C;
    sp38 = arg0->unk20;
    arg0->unk24 = phi_f2;
    arg0->unk2C = phi_f14;
    arg0->unk18 = arg0->unk18 + phi_f2;
    arg0->unk1C = arg0->unk1C - 2.0f;
    arg0->unk28 = -2.0f;
    arg0->unk20 = arg0->unk20 + phi_f14;
    if (arg1->unkBC & 0x80000000) {
        func_8029FDC8(temp_f12, phi_f14, arg0, 0x40800000);
        return;
    }
    func_802AD950(temp_f12, phi_f14, arg0 + 0x30, 0x40800000, arg0->unk18, arg0->unk1C, arg0->unk20, sp30, sp34, sp38);
    func_802B4E30(arg0);
    func_802B4104(arg0);
}
#else
GLOBAL_ASM("asm/non_matchings/code_802B0210/func_802B3E7C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
f32 func_802B51E8(void *, s32); // extern
extern ? gPlayerBalloonCount;
extern f32 D_802B9F68;
extern u16 gPlayers;

s16 func_802B3FD0(s32 arg0, s32 arg1) {
    f32 temp_f0;
    s32 temp_s1;
    u16 *phi_s0;
    s32 phi_s1;
    f32 phi_f20;
    s16 phi_fp;

    phi_s0 = &gPlayers;
    phi_s1 = 0;
    phi_f20 = D_802B9F68;
    phi_fp = -1;
    do {
        if (((*phi_s0 & 0x8000) != 0) && (phi_s0 != arg0) && (*(&gPlayerBalloonCount + (phi_s1 * 2)) >= 0)) {
            temp_f0 = func_802B51E8(phi_s0 + 0x14, arg1 + 0x18);
            if (temp_f0 < phi_f20) {
                phi_fp = (phi_s0 - D_800DC4DC) / 0xDD8;
                phi_f20 = temp_f0;
            }
        }
        temp_s1 = phi_s1 + 1;
        phi_s0 += 0xDD8;
        phi_s1 = temp_s1;
    } while (temp_s1 != 4);
    return phi_fp;
}
#else
GLOBAL_ASM("asm/non_matchings/code_802B0210/func_802B3FD0.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800C98B8(void *, void *, ?); // extern
? func_8029FDC8(void *); // extern

void func_802B4104(void *arg0) {
    f32 temp_f0;
    f32 temp_f0_2;

    if ((arg0->unk3C < 0.0f) && ((temp_f0 = arg0->unk4C, (temp_f0 < 0.25f)) || (temp_f0 > -0.25f))) {
        func_8029FDC8(arg0);
        func_800C98B8(arg0 + 0x18, arg0 + 0x24, 0x19008054);
        arg0->unk2 = arg0->unk2 | 0x80;
        return;
    }
    if ((arg0->unk40 < 0.0f) && ((temp_f0_2 = arg0->unk58, (temp_f0_2 < 0.25f)) || (temp_f0_2 < -0.25f))) {
        func_8029FDC8(arg0);
        func_800C98B8(arg0 + 0x18, arg0 + 0x24, 0x19008054);
        arg0->unk2 = arg0->unk2 | 0x80;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_802B0210/func_802B4104.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
? func_8000ED80(s32);                               /* extern */
? func_8000EE10(s32);                               /* extern */
? func_800C9060(u8, ?);                             /* extern */
? func_800C90F4(u8, s32);                           /* extern */
? func_800C9D80(void *, void *, ?);                 /* extern */
? func_8029E854(f32, void *);                       /* extern */
? func_8029FDC8(f32, void *);                       /* extern */
? func_802AD950(void *, ?, f32, f32, f32, f32, f32, f32); /* extern */
? func_802B0210(s16 *, void *);                     /* extern */
? func_802B3B44(void *);                            /* extern */
? func_802B3E7C(void *, Player *);                  /* extern */
? func_802B4104(void *);                            /* extern */
? func_802B4E30(void *);                            /* extern */
? func_802B63B8(f32 *, f32 *);                      /* extern */
? func_802B64C4(f32 *, s16);                        /* extern */
extern ? D_8015F9B8;
extern ? D_80164438;

void update_obj_red_blue_shell(void *arg0) {
    f32 sp94;
    f32 sp90;
    f32 sp8C;
    f32 sp68;
    s16 sp56;
    f32 sp40;
    f32 sp3C;
    f32 sp38;
    Player *temp_s1;
    Player *temp_s1_2;
    Player *temp_s1_3;
    f32 *temp_a0;
    f32 temp_f0;
    f32 temp_f0_2;
    f32 temp_f0_3;
    f32 temp_f0_4;
    f32 temp_f10;
    f32 temp_f12;
    f32 temp_f14;
    f32 temp_f16;
    f32 temp_f2;
    f32 temp_f2_2;
    f32 temp_f2_3;
    f32 temp_f2_4;
    f32 temp_f2_5;
    f32 temp_f4;
    s16 temp_t3;
    s16 temp_t4_2;
    s16 temp_t6;
    s16 temp_t7;
    s16 temp_v0;
    s16 temp_v0_2;
    s16 temp_v0_3;
    s16 temp_v0_4;
    s16 temp_v0_5;
    s16 temp_v0_6;
    u16 temp_t4;
    u16 temp_v1;
    u16 temp_v1_2;
    u16 temp_v1_3;
    u16 temp_v1_4;
    void *temp_v0_7;
    struct Controller *phi_v0;
    f32 phi_f0;
    s16 phi_v0_2;
    s16 phi_v0_3;
    s16 phi_v0_4;

    temp_f2 = arg0->unk20;
    temp_f0 = arg0->unk18;
    temp_f12 = arg0->unk1C;
    sp56 = arg0->unk0;
    if ((temp_f2 < D_8015F6F2) || (D_8015F6F0 < temp_f2) || (temp_f0 < D_8015F6EA) || (D_8015F6E8 < temp_f0) || (temp_f12 < D_8015F6EE)) {
        func_8029FDC8(temp_f12, arg0);
    }
    temp_t4 = arg0->unk6;
    arg0->unk10 = arg0->unk10 + 0x71C;
    switch (temp_t4) {
    case 0:
        temp_s1 = &gPlayers[arg0->unk14];
        func_802B0210(&temp_s1->unk_110, arg0 + 0x30);
        sp8C = 0.0f;
        sp90 = temp_s1->unk_070;
        temp_f16 = -(temp_s1->unk_070 + arg0->unkC + 2.0f);
        sp94 = temp_f16;
        func_802B63B8(&sp8C, temp_s1->unk_174);
        arg0->unk18 = sp8C + temp_s1->posX;
        temp_f14 = temp_s1->posY - sp90;
        arg0->unk20 = temp_f16 + temp_s1->posZ;
        sp68 = temp_f14;
        temp_f0_2 = func_802ABE30(arg0->unk18, temp_f14, arg0->unk20, temp_s1->unk_11A);
        temp_f2_2 = temp_f14 - temp_f0_2;
        if ((temp_f2_2 < 5.0f) && (temp_f2_2 > -5.0f)) {
            arg0->unk1C = arg0->unkC + temp_f0_2;
        } else {
            arg0->unk1C = temp_f14;
        }
        if ((temp_s1->unk_000 & PLAYER_HUMAN) != 0) {
            if (D_800DC51C != 0) {
                goto block_16;
            }
            phi_v0 = &gControllers[arg0->unk14];
        } else {
block_16:
            phi_v0 = D_800DC4BC;
        }
        temp_v1 = phi_v0->buttonDepressed;
        if ((temp_v1 & 0x2000) != 0) {
            phi_v0->buttonDepressed = temp_v1 & 0xDFFF;
            arg0->unk6 = 1;
            if (temp_s1->unk_0C0 > 0) {
                arg0->unk12 = 0x78E3;
                return;
            }
            arg0->unk12 = -0x78E4;
            return;
        }
    default:
        return;
    case 1:
        temp_v0 = arg0->unk12;
        temp_s1_2 = &gPlayers[arg0->unk14];
        if (temp_v0 > 0) {
            arg0->unk12 = temp_v0 - 0x71C;
            if (arg0->unk12 < 0) {
                arg0->unk6 = 2;
                func_800C9060(arg0->unk15, 0x19008004);
                func_800C90F4(arg0->unk15, (temp_s1_2->characterId * 0x10) + 0x29008000);
                if (sp56 == 8) {
                    func_8000ED80((arg0 - &D_8015F9B8) / 112);
                } else {
                    func_8000EE10((arg0 - &D_8015F9B8) / 112);
                    func_800C9D80(arg0 + 0x18, arg0 + 0x24, 0x51018008);
                }
            }
        } else {
            arg0->unk12 = temp_v0 + 0x71C;
            if (arg0->unk12 > 0) {
                arg0->unk6 = 2;
                func_800C9060(arg0->unk15, 0x19008004);
                func_800C90F4(arg0->unk15, (temp_s1_2->characterId * 0x10) + 0x29008000);
                if (sp56 == 8) {
                    func_8000ED80((arg0 - &D_8015F9B8) / 112);
                } else {
                    func_8000EE10((arg0 - &D_8015F9B8) / 112);
                    func_800C9D80(arg0 + 0x18, arg0 + 0x24, 0x51018008);
                }
            }
        }
        if (arg0->unk6 == 2) {
            arg0->unk4 = 0x1E;
            temp_f2_3 = temp_s1_2->unk_094;
            phi_f0 = 8.0f;
            if (temp_f2_3 > 8.0f) {
                phi_f0 = temp_f2_3 * D_802B9F94;
            }
            sp94 = phi_f0;
            temp_a0 = &sp8C;
            sp8C = 0.0f;
            sp90 = 0.0f;
            func_802B64C4(temp_a0, temp_s1_2->unk_02E + temp_s1_2->unk_0C0);
            arg0->unk24 = sp8C;
            arg0->unk28 = sp90;
            arg0->unk2C = sp94;
            return;
        }
        temp_f10 = sins(arg0->unk12) * 8.0f;
        sp8C = temp_f10;
        temp_f4 = arg0->unkC - temp_s1_2->unk_070;
        sp90 = temp_f4;
        sp94 = coss(arg0->unk12) * 8.0f;
        func_802B63B8(&sp8C, temp_s1_2->unk_174);
        arg0->unk18 = temp_f10 + temp_s1_2->posX;
        arg0->unk1C = temp_f4 + temp_s1_2->posY;
        arg0->unk20 = sp94 + temp_s1_2->posZ;
        return;
    case 2:
        temp_t7 = arg0->unk14;
        arg0->unk4 = arg0->unk4 - 1;
        if (arg0->unk4 == 0) {
            arg0->unk2 = arg0->unk2 & 0xEFFF;
            if (arg0->unk0 == 0x2A) {
                arg0->unk6 = 8;
                arg0->unk4 = D_8015F8F0;
                arg0->unk8 = 1000.0f;
                temp_v1_2 = D_80164430;
                temp_v0_2 = *(&D_80164438 + (((&gPlayers[temp_t7] - D_800DC4DC) / 3544) * 2)) + 8;
                phi_v0_2 = temp_v0_2;
                if (temp_v1_2 < temp_v0_2) {
                    phi_v0_2 = temp_v0_2 - temp_v1_2;
                }
                arg0->unk12 = phi_v0_2;
            } else if (gModeSelection == BATTLE) {
                arg0->unk8 = 1000.0f;
                arg0->unk4 = func_802B3FD0(&gPlayers[temp_t7], arg0);
                if (arg0->unk4 < 0) {
                    arg0->unk2 = -0x8000;
                    arg0->unk12 = 0;
                    arg0->unk4 = 0x3C;
                    arg0->unk6 = 7;
                    arg0->unk28 = 3.0f;
                } else {
                    arg0->unk6 = 3;
                }
            } else {
                temp_v0_3 = gPlayers[temp_t7].unk_004;
                if (temp_v0_3 == 0) {
                    arg0->unk6 = 4;
                    arg0->unk4 = 0x258;
                    temp_v1_3 = D_80164430;
                    temp_v0_4 = *(&D_80164438 + (((&gPlayers[temp_t7] - D_800DC4DC) / 3544) * 2)) + 8;
                    phi_v0_3 = temp_v0_4;
                    if (temp_v1_3 < temp_v0_4) {
                        phi_v0_3 = temp_v0_4 - temp_v1_3;
                    }
                    arg0->unk12 = phi_v0_3;
                } else if (temp_v0_3 >= 5) {
                    arg0->unk6 = 5;
                    arg0->unk8 = 1000.0f;
                    temp_v1_4 = D_80164430;
                    temp_v0_5 = *(&D_80164438 + (((&gPlayers[temp_t7] - D_800DC4DC) / 3544) * 2)) + 8;
                    phi_v0_4 = temp_v0_5;
                    if (temp_v1_4 < temp_v0_5) {
                        phi_v0_4 = temp_v0_5 - temp_v1_4;
                    }
                    arg0->unk12 = phi_v0_4;
                    arg0->unk4 = (&D_8015F8F0)[gPlayers[temp_t7].unk_004].unk-2;
                } else {
                    arg0->unk6 = 3;
                    arg0->unk8 = 1000.0f;
                    arg0->unk4 = (&D_8015F8F0)[gPlayers[temp_t7].unk_004].unk-2;
                }
            }
        }
        arg0->unk28 = arg0->unk28 - 0.5;
        if (arg0->unk28 < -2.0f) {
            arg0->unk28 = -2.0f;
        }
        sp38 = arg0->unk18;
        sp3C = arg0->unk1C;
        sp40 = arg0->unk20;
        arg0->unk18 = arg0->unk18 + arg0->unk24;
        arg0->unk1C = arg0->unk1C + arg0->unk28;
        arg0->unk20 = arg0->unk20 + arg0->unk2C;
        func_802AD950(arg0 + 0x30, 0x40800000, arg0->unk18, arg0->unk1C, arg0->unk20, sp38, sp3C, sp40);
        func_802B4E30(arg0);
        func_802B4104(arg0);
        return;
    case 3:
        func_802B3E7C(arg0, &gPlayers[arg0->unk4]);
        return;
    case 4:
        func_802B3B44(arg0);
        temp_v0_6 = arg0->unk4;
        if (temp_v0_6 == 0) {
            if ((arg0->unk2 & 0xF) == 0) {
                func_8029FDC8((bitwise f32) arg0);
                return;
            }
            arg0->unk4 = temp_v0_6 - 1;
            return;
        }
        /* Duplicate return node #73. Try simplifying control flow for better match */
        return;
    case 5:
        func_802B3B44(arg0);
        temp_t4_2 = arg0->unk4;
        temp_f0_3 = gPlayers[temp_t4_2].posX - arg0->unk18;
        temp_f2_4 = gPlayers[temp_t4_2].posZ - arg0->unk20;
        if (((temp_f0_3 * temp_f0_3) + (temp_f2_4 * temp_f2_4)) < D_802B9F98) {
            arg0->unk6 = 3;
            return;
        }
        /* Duplicate return node #73. Try simplifying control flow for better match */
        return;
    case 6:
        temp_v0_7 = (arg0->unk4 * 0x70) + &D_8015F9B8;
        temp_s1_3 = &gPlayers[arg0->unk14];
        if (temp_v0_7->unk0 != 0x16) {
            func_8029FDC8((bitwise f32) arg0);
            return;
        }
        temp_t6 = arg0->unk12 + temp_v0_7->unk10;
        arg0->unk12 = temp_t6;
        sp8C = sins(temp_t6 & 0xFFFF) * 8.0f;
        sp90 = arg0->unkC - temp_s1_3->unk_070;
        sp94 = coss(arg0->unk12) * 8.0f;
        func_802B63B8(&sp8C, temp_s1_3->unk_174);
        sp38 = arg0->unk18;
        sp3C = arg0->unk1C;
        sp40 = arg0->unk20;
        arg0->unk18 = sp8C + temp_s1_3->posX;
        arg0->unk1C = sp90 + temp_s1_3->posY;
        arg0->unk20 = sp94 + temp_s1_3->posZ;
        func_802AD950(arg0 + 0x30, 0x40800000, arg0->unk18, arg0->unk1C, arg0->unk20, sp38, sp3C, sp40);
        func_802B4E30(arg0);
        return;
    case 7:
        arg0->unk28 = arg0->unk28 - D_802B9F9C;
        if (arg0->unk28 < -5.0f) {
            arg0->unk28 = -5.0f;
        }
        arg0->unk4 = arg0->unk4 - 1;
        arg0->unk12 = arg0->unk12 + 0x5B0;
        arg0->unk1C = arg0->unk1C + arg0->unk28;
        if (arg0->unk4 == 0) {
            func_8029E854(-5.0f, arg0);
            return;
        }
        /* Duplicate return node #73. Try simplifying control flow for better match */
        return;
    case 8:
        func_802B3B44(arg0);
        arg0->unk4 = D_8015F8F0;
        temp_t3 = D_8015F8F0;
        temp_f0_4 = gPlayers[temp_t3].posX - arg0->unk18;
        temp_f2_5 = gPlayers[temp_t3].posZ - arg0->unk20;
        if (((temp_f0_4 * temp_f0_4) + (temp_f2_5 * temp_f2_5)) < D_802B9FA0) {
            arg0->unk6 = 9;
            return;
        }
        /* Duplicate return node #73. Try simplifying control flow for better match */
        return;
    case 9:
        func_802B3E7C(arg0, &gPlayers[arg0->unk4]);
        /* Duplicate return node #73. Try simplifying control flow for better match */
        return;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_802B0210/update_obj_red_blue_shell.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void func_802B4E30(void *arg0) {
    f32 temp_f0;
    f32 temp_f0_2;
    f32 temp_f0_3;

    temp_f0 = arg0->unk44;
    if ((temp_f0 < 0.0f) && (arg0->unk34 == 1)) {
        arg0->unk18 = arg0->unk18 - (arg0->unk60 * temp_f0);
        arg0->unk1C = arg0->unk1C - (arg0->unk64 * temp_f0);
        arg0->unk20 = arg0->unk20 - (arg0->unk68 * temp_f0);
    }
    temp_f0_2 = arg0->unk3C;
    if ((temp_f0_2 < 0.0f) && (arg0->unk30 == 1)) {
        arg0->unk18 = arg0->unk18 - (arg0->unk48 * temp_f0_2);
        arg0->unk1C = arg0->unk1C - (arg0->unk4C * temp_f0_2);
        arg0->unk20 = arg0->unk20 - (arg0->unk50 * temp_f0_2);
    }
    temp_f0_3 = arg0->unk40;
    if ((temp_f0_3 < 0.0f) && (arg0->unk32 == 1)) {
        arg0->unk18 = arg0->unk18 - (arg0->unk54 * temp_f0_3);
        arg0->unk1C = arg0->unk1C - (arg0->unk58 * temp_f0_3);
        arg0->unk20 = arg0->unk20 - (arg0->unk5C * temp_f0_3);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_802B0210/func_802B4E30.s")
#endif
