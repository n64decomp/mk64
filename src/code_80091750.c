#include <ultra64.h>
#include <macros.h>
#include <defines.h>
#include "variables.h"

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
f64 func_80091750(f64 arg0, s32 arg2) {
    s32 temp_t7;
    s32 phi_v0;
    s32 phi_v0_2;
    f64 phi_f2;
    f64 phi_f2_2;
    f64 phi_f2_3;
    f64 phi_f12;

    phi_f12 = arg0;
    if (arg2 < 0) {
        phi_v0 = -arg2;
    } else {
        phi_v0 = arg2;
    }
    phi_v0_2 = phi_v0;
    phi_f2 = 1.0;
    phi_f2_3 = 1.0;
    if (phi_v0 != 0) {
        do {
            temp_t7 = phi_v0_2 >> 1;
            phi_f2_2 = phi_f2_3;
            if ((phi_v0_2 & 1) != 0) {
                phi_f2_2 = phi_f2_3 * phi_f12;
            }
            phi_v0_2 = temp_t7;
            phi_f2 = phi_f2_2;
            phi_f2_3 = phi_f2_2;
            phi_f12 *= phi_f12;
        } while (temp_t7 != 0);
    }
    if (arg2 >= 0) {
        return phi_f2;
    }
    return 1.0 / phi_f2;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_80091750.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
f64 func_80091750(s32); // extern
f64 func_8009186C(f64); // extern
f64 func_8009195C(f64, f64); // extern
extern f64 D_800F0CB0;
extern f64 D_800F0CB8;

f64 func_800917B0(f64 arg0, f64 arg1, f64 arg2) {
    s32 temp_f8;
    f64 phi_a2;

    phi_a2 = arg2;
    if ((arg1 <= D_800F0CB0) && (D_800F0CB8 <= arg1) && (temp_f8 = arg1, phi_a2 = (bitwise f64) temp_f8, (arg1 == temp_f8))) {
        return func_80091750(temp_f8);
    }
    if (arg0 > 0.0) {
        arg2 = arg1;
        return func_8009195C(func_8009186C(phi_a2) * arg2, arg2);
    }
    return 0.0;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800917B0.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
f64 func_80091A6C(?, s32); // extern
? func_80091AC0(f64, f64, s32 *); // extern
extern f64 D_800F0CC0;
extern f64 D_800F0CC8;

f64 func_8009186C(f64 arg0) {
    s32 sp38;
    f64 temp_f14;
    f64 temp_f14_2;
    f64 temp_f14_3;
    f64 temp_f14_4;
    f64 temp_f2;
    s32 temp_v0;
    f64 phi_f2;
    f64 phi_f14;
    s32 phi_v0;

    temp_f14 = arg0;
    if (arg0 <= 0.0) {
        return 0.0;
    }
    arg0 = temp_f14;
    func_80091AC0(temp_f14 / D_800F0CC0, temp_f14, &sp38);
    temp_f14_2 = arg0 / func_80091A6C(0, sp38);
    temp_f14_3 = (temp_f14_2 - 1.0) / (temp_f14_2 + 1.0);
    phi_f2 = temp_f14_3;
    phi_f14 = temp_f14_3;
    phi_v0 = 1;
    do {
        temp_v0 = phi_v0 + 2;
        temp_f14_4 = phi_f14 * (temp_f14_3 * temp_f14_3);
        temp_f2 = phi_f2 + (temp_f14_4 / temp_v0);
        phi_f2 = temp_f2;
        phi_f14 = temp_f14_4;
        phi_v0 = temp_v0;
    } while (phi_f2 != temp_f2);
    return (sp38 * D_800F0CC8) + (2.0 * temp_f2);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009186C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80091A6C(f64, f64, s32); // extern
extern f64 D_800F0CD0;

void func_8009195C(f64 arg0) {
    f64 temp_f14;
    f64 temp_f18;
    f64 temp_f2;
    f64 temp_f2_2;
    s32 temp_f10;

    if (arg0 >= 0.0) {

    }
    temp_f18 = D_800F0CD0;
    temp_f10 = 0.0 + (arg0 / temp_f18);
    temp_f14 = arg0 - (temp_f10 * temp_f18);
    temp_f2 = temp_f14 * temp_f14;
    temp_f2_2 = 2.0 + (temp_f2 / (6 + (temp_f2 / (0xA + (temp_f2 / (0xE + (temp_f2 / (0x12 + (temp_f2 / 22.0)))))))));
    func_80091A6C((temp_f2_2 + temp_f14) / (temp_f2_2 - temp_f14), temp_f14, temp_f10);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009195C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
f64 func_80091A6C(f64 arg0, s32 arg2) {
    s32 temp_t7;
    s32 phi_a2;
    s32 phi_a2_2;
    f64 phi_f12;
    f64 phi_f12_2;
    f64 phi_f12_3;
    f64 phi_f0;

    phi_a2 = arg2;
    phi_f12 = arg0;
    phi_f12_3 = arg0;
    if (arg2 >= 0) {

    } else {
        phi_a2 = -arg2;
    }
    phi_a2_2 = phi_a2;
    phi_f0 = 0.0;
    if (phi_a2 != 0) {
        do {
            temp_t7 = phi_a2_2 >> 1;
            phi_f12_2 = phi_f12_3;
            if ((phi_a2_2 & 1) != 0) {
                phi_f12_2 = phi_f12_3 * phi_f0;
            }
            phi_a2_2 = temp_t7;
            phi_f12 = phi_f12_2;
            phi_f12_3 = phi_f12_2;
            phi_f0 *= phi_f0;
        } while (temp_t7 != 0);
    }
    return phi_f12;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_80091A6C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
f64 func_80091AC0(f64 arg0, s32 *arg2) {
    f64 phi_f12;
    f64 phi_f12_2;
    s32 phi_v0;
    f64 phi_f12_3;
    s32 phi_v0_2;
    s32 phi_v0_3;

    phi_f12 = arg0;
    phi_v0 = 0;
    phi_f12_3 = arg0;
    phi_v0_3 = 0;
    if ((arg0 < 0.5) || (arg0 >= 1.0)) {
        do {
loop_2:
            if (phi_f12 < 0.5) {
                phi_f12_2 = phi_f12 * 2.0;
                phi_v0_2 = phi_v0_3 - 1;
            } else {
                phi_f12_2 = phi_f12 / 2.0;
                phi_v0_2 = phi_v0_3 + 1;
            }
            phi_f12 = phi_f12_2;
            phi_v0 = phi_v0_2;
            phi_f12_3 = phi_f12_2;
            phi_v0_3 = phi_v0_2;
            if (phi_f12_2 < 0.5) {
                goto loop_2;
            }
        } while (phi_f12_2 >= 1.0);
    }
    *arg2 = phi_v0;
    return phi_f12_3;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_80091AC0.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void func_80091B64(s32 *arg0, s32 *arg1) {
    s32 temp_v0;

    temp_v0 = *arg0;
    *arg0 = *arg1;
    *arg1 = temp_v0;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_80091B64.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 func_80091D74(); // extern
? func_80094C60(); // extern
? func_800AF9B0(); // extern
? func_800B44BC(); // extern
? func_800B4A10(); // extern
? func_800C97C4(s32); // extern
? func_800C9D0C(s32); // extern
extern s8 D_800E852C;
extern s32 D_800E86A0;
extern s32 D_800E86A4;
extern s32 D_8018D9B0;
extern s32 D_8018D9B4;
extern s32 D_8018D9B8;
extern s32 D_8018D9C0;
extern ? D_8018E7AC;
extern ? D_8018E7B1;
extern ? D_8018E838;
extern ? D_8018E83C;
extern s8 D_8018EDF4;
extern s8 D_8018EDF5;
extern s8 D_8018EDF6;
extern s8 D_8018EE0C;
extern ? _course_mario_raceway_dl_mio0SegmentRomStart;
extern s32 gPrevLoadedAddress;
extern OSMesgQueue gSIEventMesgQueue;

void func_80091B78(void) {
    s32 temp_s0;
    s32 temp_s0_2;
    u32 temp_v0;
    u32 temp_v0_2;
    ? *phi_v0;
    ? *phi_v0_2;
    s32 phi_s0;
    s32 phi_s0_2;

    if (D_800E852C != 0) {
        D_800E852C = 0;
        D_8018EDF4 = 0xA;
        D_8018EDF5 = 5;
        D_8018EDF6 = 0xA;
        if (osEepromProbe(&gSIEventMesgQueue) != 0) {
            func_800B4A10();
        }
        if (func_80091D74() != 0) {
            D_800E86A0 = 9;
        }
    }
    if (D_800E86A0 == 8) {
        gPrevLoadedAddress = D_8015F734;
        set_segment_base_addr(6, func_802AA88C(&_data_825800SegmentRomStart, &_course_mario_raceway_dl_mio0SegmentRomStart));
    }
    gPrevLoadedAddress = D_8015F734;
    D_8018D9B0 = func_802A7B70(0x900B0);
    D_8018D9B4 = func_802A7B70(0xCE00);
    D_8018D9B8 = func_802A7B70(0x12C00);
    D_8018D9C0 = func_802A7B70(0x1000);
    func_800AF9B0();
    D_8018EE0C = 0;
    phi_v0 = &D_8018E7AC;
    do {
        temp_v0 = phi_v0 + 1;
        temp_v0->unk-1 = 0;
        phi_v0 = temp_v0;
    } while (temp_v0 < &D_8018E7B1);
    phi_v0_2 = &D_8018E838;
    do {
        temp_v0_2 = phi_v0_2 + 1;
        temp_v0_2->unk-1 = 0;
        phi_v0_2 = temp_v0_2;
    } while (temp_v0_2 < &D_8018E83C);
    D_800DC5EC->unk30 = 0xA0;
    D_800DC5EC->unk32 = 0x78;
    D_800DC5EC->unk2C = 0x140;
    D_800DC5EC->unk2E = 0xF0;
    D_800E86A4 = 1;
    func_80094C60();
    phi_s0 = 0;
    do {
        func_800C97C4(phi_s0 & 0xFF);
        temp_s0 = phi_s0 + 1;
        phi_s0 = temp_s0;
    } while (temp_s0 < 4);
    phi_s0_2 = 1;
    do {
        func_800C9D0C(phi_s0_2 & 0xFF);
        temp_s0_2 = phi_s0_2 + 1;
        phi_s0_2 = temp_s0_2;
    } while (temp_s0_2 != 8);
    func_800B44BC();
    osViSetSpecialFeatures(0x40);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_80091B78.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 func_800CE720(OSMesgQueue *, OSPfs *, ?); // extern
extern OSPfs D_8018E868;
extern ? D_8018E938;
extern ? D_8018EB38;
extern s32 D_8018EB78;
extern s32 D_8018EB7C;
extern s32 D_8018EB80;
extern u8 gControllerBits;
extern ? gControllerStatuses;
extern OSMesgQueue gSIEventMesgQueue;

? func_80091D74(void) {
    u8 sp67;
    ? *temp_s1;
    s32 temp_s0;
    s32 phi_s0;
    ? *phi_s1;

    if (gControllerBits == 0) {
        return 0;
    }
    if (((*(&gControllerStatuses + 2) == 0) & 1) != 0) {
        return 0;
    }
    if ((D_800DC4BC->button & 0x1000) == 0) {
        return 0;
    }
    osPfsIsPlug(&gSIEventMesgQueue, &sp67);
    if ((sp67 & 1) != 0) {
        if (func_800CE720(&gSIEventMesgQueue, &D_8018E868, 0) != 0) {
            return 0;
        }
        phi_s0 = 0;
        if (osPfsNumFiles(&D_8018E868, &D_8018EB78, &D_8018EB7C) != 0) {
            return 0;
        }
        phi_s1 = &D_8018EB38;
        do {
            temp_s0 = phi_s0 + 1;
            temp_s1 = phi_s1 + 4;
            temp_s1->unk-4 = osPfsFileState(&D_8018E868, phi_s0, &D_8018E938 + (phi_s0 << 5));
            phi_s0 = temp_s0;
            phi_s1 = temp_s1;
        } while (temp_s0 != 0x10);
        if (osPfsFreeBlocks(&D_8018E868, &D_8018EB80) != 0) {
            return 0;
        }
        D_8018EB80 = D_8018EB80 >> 8;
        return 1;
    }
    return 0;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_80091D74.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 func_800B5F30(); // extern
? func_800B64EC(s32); // extern
? func_800B6708(); // extern
extern s8 D_800E86F8;
extern s8 D_8018EDFB;
extern ? D_8018EE10;
extern s8 gCupSelection;

void func_80091EE4(void) {
    s32 temp_s0;
    s32 temp_s2;
    void *temp_v0;
    s32 phi_s0;
    s32 phi_s0_2;

    D_800E86F8 = 0;
    if ((D_8018EDFB != 0) && (func_800B5F30() == 0)) {
        temp_s2 = (gCupSelection * 4) + gCupCourseSelection;
        func_800B6708();
        phi_s0 = 0;
        do {
            temp_v0 = &D_8018EE10 + (phi_s0 << 7);
            phi_s0_2 = phi_s0;
            if ((temp_v0->unk4 != 0) && (temp_s2 == temp_v0->unk5)) {
                func_800B64EC(phi_s0);
                D_8018EDFB = 0;
                phi_s0_2 = 2;
            }
            temp_s0 = phi_s0_2 + 1;
            phi_s0 = temp_s0;
        } while (temp_s0 < 2);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_80091EE4.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80092258(); // extern
? func_80099110(); // extern
? func_8009A344(); // extern
? func_8009E620(); // extern
? func_8009E650(?, ?, ?, ?); // extern
? func_800B5F30(); // extern
extern s32 D_8018D9B0;
extern s32 D_8018D9B4;
extern s32 D_8018D9B8;
extern s32 D_8018D9BC;
extern ? D_8018E7AC;
extern ? D_8018E7B1;
extern s8 D_8018E838;
extern s8 D_8018EE08;
extern u8 gControllerBits;

void func_80091FA4(void) {
    u32 temp_v1;
    ? *phi_v1;

    D_8018D9B4 = func_802A7B70(0x2800);
    D_8018D9B0 = func_802A7B70(0x124F8);
    D_8018D9B8 = func_802A7B70(0x1000);
    D_8018D9BC = func_802A7B70(4);
    phi_v1 = &D_8018E7AC;
    do {
        temp_v1 = phi_v1 + 1;
        temp_v1->unk-1 = 0;
        phi_v1 = temp_v1;
    } while (temp_v1 < &D_8018E7B1);
    D_8018E838 = 0;
    D_8018E838 = 0;
    D_8018E838 = 0;
    D_8018E838 = 0;
    func_80099110();
    func_8009A344();
    func_8009E620();
    func_80092258();
    func_8009E650(0x96, 0x64, 0x24, 1);
    func_8009E650(0x97, 0x64, 0xDD, 1);
    func_8009E650(0x98, 0, 0, 0);
    func_8009E650(0xC7, 0, 0, 0);
    if (gModeSelection == TIME_TRIALS) {
        func_8009E650(0xBE, 0, 0, 0);
        func_8009E650(0x10E, 0, 0, 0);
    }
    if ((D_8015F890 != 0) && (gModeSelection == TIME_TRIALS)) {
        func_8009E650(0xBD, 0, 0, 0);
    }
    if (((gControllerBits & 1) == 0) && (D_8018EE08 != 0)) {
        func_8009E650(4, 0, 0, 2);
    }
    func_800B5F30();
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_80091FA4.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern void *D_800DC4CC;
extern s8 D_8018D9D8;
extern s8 D_8018D9D9;

void func_80092148(void) {
    void *temp_v0;
    s32 phi_v1;

    temp_v0 = D_800DC4CC;
    phi_v1 = 0;
    if (temp_v0->unk4 != 0) {
        phi_v1 = 1;
    }
    if (temp_v0->unk6 != 0) {
        D_8018D9D9 = 1;
    }
    if ((phi_v1 != 0) && (D_8018D9D9 != 0)) {
        D_8018D9D8 = 1;
        return;
    }
    D_8018D9D8 = 0;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_80092148.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern s8 D_8018D9D9;

void func_800921B4(void) {
    D_8018D9D9 = 0;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800921B4.s")
#endif

void set_text_color(s32);
extern s32 func_800B4520();

void func_800921C0(s32 test, s32 target, s32 alternative_color) {
    if (test == target) {
        if (func_800B4520() != 0) {
            set_text_color(gGlobalTimer % 3);
            return;
        }
        set_text_color(TEXT_BLUE_GREEN_RED_CYCLE_2);
        return;
    }
    set_text_color(alternative_color);
}

void func_80092224(s32 test, s32 target, s32 alternative_color) {
    if (test == target) {
        set_text_color(TEXT_BLUE_GREEN_RED_CYCLE_2);
        return;
    }
    set_text_color(alternative_color);
}

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern s32 D_8018E850;
extern ? D_8018E858;

void func_80092258(void) {
    ? *temp_a0;
    s32 temp_v0;
    s32 phi_v0;
    s32 *phi_v1;
    ? *phi_a0;

    phi_v0 = 0;
    phi_v1 = &D_8018E850;
    phi_a0 = &D_8018E858;
    do {
        *phi_v1 = phi_v0;
        temp_v0 = phi_v0 + 1;
        temp_a0 = phi_a0 + 4;
        temp_a0->unk-4 = 0;
        phi_v0 = temp_v0;
        phi_v1 += 4;
        phi_a0 = temp_a0;
    } while (temp_v0 != 2);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_80092258.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 segmented_to_virtual_dupe(s32, s32 *, s32 *, s32); // extern
extern s32 D_800E84C0;
extern ? D_800E84CC;
extern s32 gGlobalTimer;

void func_80092290(s32 arg0, s32 *arg1, s32 *arg2, s32 arg3) {
    s32 *temp_a2;
    s32 *temp_s0;
    s32 temp_a0;
    s32 temp_a1;
    s32 temp_a3;
    s32 temp_s4;
    s32 temp_t0;
    s32 temp_t6;
    s32 temp_t7;
    s32 temp_t8;
    s32 temp_t8_2;
    s32 temp_t9;
    s32 temp_v0;
    void *temp_v1;
    void *temp_v1_2;
    s32 *phi_s0;
    s32 *phi_a1;
    s32 *phi_a2;
    s32 phi_a3;

    phi_a1 = arg1;
    phi_a2 = arg2;
    phi_a3 = arg3;
    if ((arg0 >= 4) && (arg0 < 6)) {
        temp_t8 = *arg2 + 0x10;
        *arg2 = temp_t8;
        if (temp_t8 >= 0x100) {
            *arg2 = 0;
            *arg1 = (*arg1 + 1) % 3;
        }
        temp_s4 = (((arg0 * 4) + ((gGlobalTimer % 2) * 2)) - 6) * 0x10;
        phi_s0 = &D_800E84C0;
        do {
            temp_v0 = segmented_to_virtual_dupe(*phi_s0, phi_a1, phi_a2, phi_a3);
            temp_a0 = *arg2;
            temp_a2 = temp_v0 + temp_s4;
            temp_a1 = 0x100 - temp_a0;
            temp_s0 = phi_s0 + 4;
            temp_t0 = (*arg1 * 2) + 2;
            temp_v1 = temp_v0 + (temp_t0 * 0x10);
            temp_a3 = (temp_t0 % 6) + 2;
            temp_v1_2 = temp_v0 + (temp_a3 * 0x10);
            temp_t6 = ((temp_a1 * temp_v1->unkC) + (temp_a0 * temp_v1_2->unkC)) / 0x100;
            temp_a2->unkC = temp_t6;
            temp_t9 = ((temp_a1 * temp_v1->unkD) + (temp_a0 * temp_v1_2->unkD)) / 0x100;
            temp_a2->unkD = temp_t9;
            temp_t7 = ((temp_a1 * temp_v1->unkE) + (temp_a0 * temp_v1_2->unkE)) / 0x100;
            temp_a2->unkE = temp_t7;
            temp_t8_2 = ((temp_a1 * temp_v1->unkF) + (temp_a0 * temp_v1_2->unkF)) / 0x100;
            temp_a2->unkF = temp_t8_2;
            temp_a2->unk1C = temp_t6;
            temp_a2->unk1D = temp_t9;
            temp_a2->unk1E = temp_t7;
            temp_a2->unk1F = temp_t8_2;
            phi_s0 = temp_s0;
            phi_a1 = temp_t8_2;
            phi_a2 = temp_a2;
            phi_a3 = temp_a3;
        } while (temp_s0 != &D_800E84CC);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_80092290.s")
#endif

extern s32 gModeSelection;
void func_80092500(void) {

    switch(gModeSelection) {
        case GRAND_PRIX:
            func_8009E650(0xAA, 0, 0, 0);
            break;
        case TIME_TRIALS:
            func_8009E650(0xB9, 0, 0, 0);
            break;
    }
}

void func_80092564(void) {
    func_8009E650(0xAC, 0, 0, 0);
    func_8005D18C();
    func_8001968C();
}

void func_800925A0(void) {
    func_8009E650(0xAF, 0, 0, 0);
}

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern void *func_800AAEF4(s32); // extern
// removed a temp from this func temp = func_800AAEF4.
void func_800925CC(void) {
    if (func_800AAEF4(0xAF)->unk4 == 2) {
        func_800AAEF4(0xAF)->unk4 = 3;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800925CC.s")
#endif

void func_80092604(void) {
    func_8009E650(0xB0, 0, 0, 0);
}

void func_80092630(void) {
    func_8009E650(0xBC, 0, 0, 0);
}


void func_8009265C(void) {
    func_8009E650(0x12B, 0, 0, 2);
}

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
? func_8009E650(?, ?, ?, ?);                        /* extern */

void func_80092688(void) {
    u16 temp_t6;

    temp_t6 = D_800DC5E4;
    switch (temp_t6) {
    case 0:
        func_8009E650(0x1CE, 0, 0, 2);
        return;
    default:
        func_8009E650(0x190, 0, 0, 2);
        func_8009E650(0x191, 0, 0, 2);
        return;
    case 2:
        func_8009E650(0x192, 0, 0, 2);
        func_8009E650(0x193, 0, 0, 2);
        return;
    case 3:
        func_8009E650(0x194, 0, 0, 2);
        func_8009E650(0x195, 0, 0, 2);
        return;
    case 4:
        func_8009E650(0x196, 0, 0, 2);
        func_8009E650(0x197, 0, 0, 2);
        return;
    case 5:
        func_8009E650(0x198, 0, 0, 2);
        func_8009E650(0x199, 0, 0, 2);
        func_8009E650(0x19A, 0, 0, 2);
        func_8009E650(0x19B, 0, 0, 2);
        return;
    case 6:
        func_8009E650(0x198, 0, 0, 2);
        func_8009E650(0x19C, 0, 0, 2);
        func_8009E650(0x19D, 0, 0, 2);
        func_8009E650(0x19E, 0, 0, 2);
        return;
    case 7:
        func_8009E650(0x19F, 0, 0, 2);
        func_8009E650(0x1A0, 0, 0, 2);
        func_8009E650(0x1A1, 0, 0, 2);
        func_8009E650(0x1A2, 0, 0, 2);
        return;
    case 8:
        func_8009E650(0x1A3, 0, 0, 2);
        func_8009E650(0x1A4, 0, 0, 2);
        return;
    case 9:
        func_8009E650(0x1A5, 0, 0, 2);
        func_8009E650(0x1A6, 0, 0, 2);
        func_8009E650(0x1A7, 0, 0, 2);
        func_8009E650(0x1A8, 0, 0, 2);
        func_8009E650(0x1A9, 0, 0, 2);
        return;
    case 10:
        func_8009E650(0x1A5, 0, 0, 2);
        func_8009E650(0x1A6, 0, 0, 2);
        func_8009E650(0x1AA, 0, 0, 2);
        func_8009E650(0x1AB, 0, 0, 2);
        func_8009E650(0x1AC, 0, 0, 2);
        return;
    case 11:
        func_8009E650(0x1AD, 0, 0, 2);
        func_8009E650(0x1AE, 0, 0, 2);
        func_8009E650(0x1AF, 0, 0, 2);
        func_8009E650(0x1B0, 0, 0, 2);
        return;
    case 12:
        func_8009E650(0x1B1, 0, 0, 2);
        func_8009E650(0x1B2, 0, 0, 2);
        return;
    case 13:
        func_8009E650(0x1B3, 0, 0, 2);
        func_8009E650(0x1B4, 0, 0, 2);
        func_8009E650(0x1B5, 0, 0, 2);
        return;
    case 14:
        func_8009E650(0x1B6, 0, 0, 2);
        func_8009E650(0x1B7, 0, 0, 2);
        func_8009E650(0x1B8, 0, 0, 2);
        func_8009E650(0x1B9, 0, 0, 2);
        func_8009E650(0x1BA, 0, 0, 2);
        func_8009E650(0x1BB, 0, 0, 2);
        func_8009E650(0x1BC, 0, 0, 2);
        return;
    case 15:
        func_8009E650(0x1BD, 0, 0, 2);
        func_8009E650(0x1BE, 0, 0, 2);
        func_8009E650(0x1BF, 0, 0, 2);
        func_8009E650(0x1C0, 0, 0, 2);
        return;
    case 16:
        func_8009E650(0x1C1, 0, 0, 2);
        func_8009E650(0x1C2, 0, 0, 2);
        func_8009E650(0x1C3, 0, 0, 2);
        return;
    case 17:
        func_8009E650(0x1C4, 0, 0, 2);
        func_8009E650(0x1C5, 0, 0, 2);
        func_8009E650(0x1C6, 0, 0, 2);
        func_8009E650(0x1C7, 0, 0, 2);
        func_8009E650(0x1C8, 0, 0, 2);
        func_8009E650(0x1C9, 0, 0, 2);
        func_8009E650(0x1CA, 0, 0, 2);
        func_8009E650(0x1CB, 0, 0, 2);
        func_8009E650(0x1CC, 0, 0, 2);
        return;
    case 18:
        func_8009E650(0x1CD, 0, 0, 2);
        return;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_80092688.s")
#endif

extern s8 D_8018ED91;

void func_80092C80(void) {
    D_8018ED91 = 1;
}

#ifdef NON_MATCHING
// Originally func_80092C90
// Some kind of lookup function, seems to return an index to be used
// to get a character's width in pixels
// This technically matches, but due to linker alignment shenanigans actually
// matching will have to wait
s32 get_ascii_char_width_index(char *character) {
    s32 index = 1;

    // Uppercase Letters
    if ((*character >= 0x61) && (*character < 0x7B)) {
        index = *character - 0x61;
    // Lowercase Letters
    } else if ((*character >= 0x41) && (*character < 0x5B)) {
        index = *character - 0x41;
    // Numbers
    } else if ((*character >= 0x30) && (*character < 0x3A)) {
        index = *character - 0x10;
    // Space
    } else if (*character == 0x20) {
        index = -1;
    // Interpreting characters as signed numbers, so check if the character is "negative"
    } else if (*character < 0) {
        switch (*character) {                          /* switch 1 */
        case -92:                                   /* switch 1 */
            // WARNING: Not sure about the arguments to the following 3 functions, its not clear
            // what they exepct
            index = func_80092E1C(character + 1);
            break;
        case -91:                                   /* switch 1 */
            index = func_80092DF8(character + 1);
            break;
        case -85:                                   /* switch 1 */
        case -93:                                   /* switch 1 */
        case -95:                                   /* switch 1 */
            index = func_80092EE4(character);
            break;
        }
    } else {
        switch (*character) {                          /* switch 2 */
        // !
        case 0x21:                                  /* switch 2 */
            index = 0x1A;
            break;
        // -
        case 0x2D:                                  /* switch 2 */
            index = 0x1B;
            break;
        // ?
        case 0x3F:                                  /* switch 2 */
            index = 0x1C;
            break;
        // '
        case 0x27:                                  /* switch 2 */
            index = 0x1D;
            break;
        // $
        case 0x24:                                  /* switch 2 */
            index = 0x1E;
            break;
        // .
        case 0x2E:                                  /* switch 2 */
            index = 0x1F;
            break;
        // "
        case 0x22:                                  /* switch 2 */
            index = 0x2A;
            break;
        // *
        case 0x2A:                                  /* switch 2 */
            index = 0x2B;
            break;
        // +
        case 0x2B:                                  /* switch 2 */
            index = 0x2C;
            break;
        // (
        case 0x28:                                  /* switch 2 */
            index = 0x2D;
            break;
        // ,
        case 0x2C:                                  /* switch 2 */
            index = 0x2E;
            break;
        default:                                    /* switch 2 */
            index = -2;
            break;
        }
    }
    return index;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/get_ascii_char_width_index.s")
#endif

s32 func_80092DF8(void) {
    return func_80092E1C() + 0x50;
}

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 func_80092E1C(s8 *arg0) {
    s32 temp_t6;

    temp_t6 = (*arg0 + 0x80) & 0xFF;
    if ((temp_t6 >= 0x21) && (temp_t6 < 0x2B)) {
        if ((temp_t6 % 2) != 0) {
            return ((temp_t6 - 0x21) / 2) + 0x7B;
        }
        return ((temp_t6 - 0x21) / 2) + 0x30;
    }
    if ((temp_t6 >= 0x2B) && (temp_t6 < 0x6E)) {
        return temp_t6 + 0xA;
    }
    if (temp_t6 != 0x6F) {
        if ((temp_t6 != 0x72) && (temp_t6 != 0x73)) {
            return -2;
        }
        return temp_t6 + 7;
    }
    return 0x78;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_80092E1C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
s32 func_80092EE4(void *arg0) {
    s32 temp_t6;
    s8 temp_a1;
    s32 phi_v1;

    temp_a1 = arg0->unk0;
    temp_t6 = (arg0->unk1 + 0x80) & 0xFF;
    phi_v1 = 2;
    if (temp_a1 != -0x5F) {
        if (temp_a1 != -0x5D) {
            if (temp_a1 != -0x55) {
                return 2;
            }
            if (temp_t6 == 0x2E) {
                phi_v1 = 0xE0;
            }
            /* Duplicate return node #31. Try simplifying control flow for better match */
            return phi_v1;
        }
        if ((temp_t6 >= 0x30) && (temp_t6 < 0x3A)) {
            return temp_t6 + 0xA5;
        }
        switch (temp_t6) {                          /* switch 2 */
        case 0x44:                                  /* switch 2 */
            return 0xDF;
        case 0x43:                                  /* switch 2 */
        case 0x63:                                  /* switch 2 */
            return 0xE0;
        case 0x4E:                                  /* switch 2 */
        case 0x6E:                                  /* switch 2 */
            return 0xE1;
        case 0x50:                                  /* switch 2 */
        case 0x70:                                  /* switch 2 */
            return 0xE2;
        case 0x52:                                  /* switch 2 */
        case 0x72:                                  /* switch 2 */
            return 0xE3;
        case 0x73:                                  /* switch 2 */
            return 0xE4;
        case 0x54:                                  /* switch 2 */
        case 0x74:                                  /* switch 2 */
            return 0xE5;
        case 0x53:                                  /* switch 2 */
            return 0xE6;
        case 0x56:                                  /* switch 2 */
        case 0x76:                                  /* switch 2 */
            return 0xE7;
        }
    } else {
        switch (temp_t6) {                          /* switch 1 */
        case 0x22:                                  /* switch 1 */
        case 0x24:                                  /* switch 1 */
            return 0xEA;
        case 0x23:                                  /* switch 1 */
            return 0xE9;
        case 0x25:                                  /* switch 1 */
            return 0xD0;
        case 0x2A:                                  /* switch 1 */
            return 0xE8;
        case 0x30:                                  /* switch 1 */
            return 0xEB;
        case 0x47:                                  /* switch 1 */
            return 0xD1;
        case 0x49:                                  /* switch 1 */
            return 0xD2;
        case 0x5C:                                  /* switch 1 */
            return 0xD3;
        case 0x3C:                                  /* switch 1 */
        case 0x3D:                                  /* switch 1 */
        case 0x5D:                                  /* switch 1 */
            return 0xD4;
        default:                                    /* switch 1 */
        default:                                    /* switch 2 */
            return phi_v1;
        }
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_80092EE4.s")
#endif

extern s16 gCharacterWidthMap[]; // D_800EF690

//Originally func_80093034
s32 get_string_width(char *buffer) {
    s32 width_index;
    s32 stringWidth = 0;

    if (*buffer != 0) {
        do {
            width_index = get_ascii_char_width_index(buffer);
            if (width_index >= 0) {
                stringWidth += gCharacterWidthMap[width_index];
            } else if (width_index == -1) {
                stringWidth += 7;
            }
            if (width_index >= 0x30) {
                buffer += 2;
            } else {
                buffer += 1;
            }
        } while (*buffer != 0);
    }
    return stringWidth;
}

extern s8 gTextColor;

void set_text_color(s32 arg0) {
    gTextColor = arg0;
}

void func_80093324(s32, s32, char*, s32, f32, f32);
UNUSED void func_800930E4(s32 arg0, s32 arg1, s32 *arg2) {
    set_text_color(TEXT_BLUE);
    func_80093324(arg0, arg1, arg2, 0, 1.0, 1.0);
}

void func_80099184(s32);
s32 segmented_to_virtual(u32*);
Gfx *func_8009BEF0(Gfx*, s32, f32, f32, s32, f32,f32);
void print_text1(s32, s32, char*, s32, f32, f32, s32);
void print_text2(s32, s32, char*, s32, f32, f32, s32);
extern Gfx D_020077A8[];
extern Gfx D_020077D8[];
extern s32 D_800E7E84[];
extern Gfx *gDisplayListHead;

// "tracking" is a uniform spacing between all characters in a given word
void print_text0(s32 column, s32 row, char *text, s32 tracking, f32 x_scale, f32 y_scale, s32 arg6) {
    s32 stringWidth = 0;
    s32 characterWidthIndex;

    gSPDisplayList(gDisplayListHead++, D_020077A8);
    if (*text != 0) {
        do{
            characterWidthIndex = get_ascii_char_width_index(text);
            if (characterWidthIndex >= 0) {
                func_80099184(segmented_to_virtual(D_800E7E84[characterWidthIndex]));
                gDisplayListHead = func_8009BEF0(gDisplayListHead, segmented_to_virtual(D_800E7E84[characterWidthIndex]), column + (stringWidth * x_scale), row, arg6, x_scale, y_scale);
                stringWidth += gCharacterWidthMap[characterWidthIndex] + tracking;
            }
            else if ((characterWidthIndex != -2) && (characterWidthIndex == -1)) {
                stringWidth += tracking + 7;
            }
            else{
                gSPDisplayList(gDisplayListHead++, D_020077D8);
                return;
            }
            if (characterWidthIndex >= 0x30) {
                text += 2;
            } else {
                text += 1;
            }
        } while(*text != 0);
    }
    gSPDisplayList(gDisplayListHead++, D_020077D8);
}

void func_80093324(s32 column, s32 row, char *text, s32 tracking, f32 x_scale, f32 y_scale) {
    print_text0(column, row, text, tracking, x_scale, y_scale, 1);
}

void func_80093358(s32 column, s32 row, char *text, s32 tracking, f32 x_scale, f32 y_scale) {
    print_text0(column, row, text, tracking, x_scale, y_scale, 2);
}

#ifdef NON_MATCHING
// "tracking" is a uniform spacing between all characters in a given word
void print_text1(s32 column, s32 row, char *text, s32 tracking, f32 x_scale, f32 y_scale, s32 arg6) {
    char *temp_string = text;
    s32 stringWidth = 0;
    s32 characterWidthIndex;

    if (*temp_string != 0) {
        do{
            characterWidthIndex = get_ascii_char_width_index(temp_string);
            if (characterWidthIndex >= 0) {
                stringWidth += ((gCharacterWidthMap[characterWidthIndex] + tracking) * x_scale);
            }
            else if ((characterWidthIndex != -2) && (characterWidthIndex == -1)) {
                stringWidth += ((tracking + 7) * x_scale);
            }
            else{
                return;
            }
            if (characterWidthIndex >= 0x30) {
                temp_string += 2;
            } else {
                temp_string += 1;
            }
        } while(*temp_string != 0);
    }

    switch(arg6) {
        case 1:
        case 3:
            column -= stringWidth;
            break;
        case 2:
        case 4:
            column -= stringWidth / 2;
            break;
        default:
            break;
    }

    if (arg6 < 3){
        arg6 = 1;
    }
    else{
        arg6 = 2;
    }

    gSPDisplayList(gDisplayListHead++, D_020077A8);
    if (*text != 0) {
        do{
            characterWidthIndex = get_ascii_char_width_index(text);
            if (characterWidthIndex >= 0) {
                func_80099184(segmented_to_virtual(D_800E7E84[characterWidthIndex]));
                gDisplayListHead = func_8009BEF0(gDisplayListHead, segmented_to_virtual(D_800E7E84[characterWidthIndex]), column, row, arg6, x_scale, y_scale);
                column += (gCharacterWidthMap[characterWidthIndex] + tracking);
                column *= x_scale;
            }
            else if ((characterWidthIndex != -2) && (characterWidthIndex == -1)) {
                column += (tracking + 7);
                column *= x_scale;
            }
            else{
                gSPDisplayList(gDisplayListHead++, D_020077D8);
                return;
            }
            if (characterWidthIndex >= 0x30) {
                text += 2;
            } else {
                text += 1;
            }
        } while(*text != 0);
    }
    gSPDisplayList(gDisplayListHead++, D_020077D8);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/print_text1.s")
#endif

void func_800936B8(s32 column, s32 row, char *text, s32 tracking, f32 x_scale, f32 y_scale) {
    print_text1(column, row, text, tracking, x_scale, y_scale, 1);
}

void draw_text(s32 column, s32 row, char *text, s32 tracking, f32 x_scale, f32 y_scale) {
    print_text1(column, row, text, tracking, x_scale, y_scale, 2);
}

void func_80093720(s32 column, s32 row, char *text, s32 tracking, f32 x_scale, f32 y_scale) {
    print_text1(column, row, text, tracking, x_scale, y_scale, 3);
}

void func_80093754(s32 column, s32 row, char *text, s32 tracking, f32 x_scale, f32 y_scale) {
    print_text1(column, row, text, tracking, x_scale, y_scale, 4);
}

void print_text2(s32 column, s32 row, char *text, s32 tracking, f32 x_scale, f32 y_scale, s32 arg6) {
    s32 temp_v0_3;
    s32 characterWidth;
    s32 characterWidthIndex;

    gSPDisplayList(gDisplayListHead++, D_020077A8);
    if (*text != 0) {
        do {
            characterWidthIndex = get_ascii_char_width_index(text);
            if (characterWidthIndex >= 0) {
                temp_v0_3 = segmented_to_virtual(D_800E7E84[characterWidthIndex]);
                func_80099184(temp_v0_3);
                gDisplayListHead = func_8009BEF0(gDisplayListHead, temp_v0_3, column - (gCharacterWidthMap[characterWidthIndex] / 2), row, arg6, x_scale, y_scale);
                if ((characterWidthIndex >= 0xD5) && (characterWidthIndex < 0xE0)) {
                    characterWidth = 0x20;
                } else {
                    characterWidth = 0xC;
                }
                column = column + (s32)((characterWidth + tracking) * x_scale);
            }
            else if ((characterWidthIndex != -2) && (characterWidthIndex == -1)) {
                column = column + (s32)((tracking + 7) * x_scale);
            }
            else{
                gSPDisplayList(gDisplayListHead++, D_020077D8);
                return;
            }
            if (characterWidthIndex >= 0x30) {
                text += 2;
            } else {
                text += 1;
            }
        } while(*text != 0);
    }

    gSPDisplayList(gDisplayListHead++, D_020077D8);
}

void func_800939C8(s32 column, s32 row, char *text, s32 tracking, f32 x_scale, f32 y_scale) {
    print_text2(column, row, text, tracking, x_scale, y_scale, 1);
}

void text_draw(s32 column, s32 row, char *text, s32 tracking, f32 x_scale, f32 y_scale) {
    print_text2(column, row, text, tracking, x_scale, y_scale, 2);
}

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_8009E2A8(s8, s32); // extern
extern ? D_800F0B1C;

void func_80093A30(s32 arg0) {
    func_8009E2A8(*(&D_800F0B1C + arg0), arg0);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_80093A30.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
? func_80093C1C(s8, u32);                           /* extern */
? func_800940EC(s8, u32);                           /* extern */
? func_8009C918(u32);                               /* extern */
static ? D_800F0B1C;                                /* unable to generate initializer; const */

void func_80093A5C(u32 arg0) {
    Gfx *temp_v1;

    if (D_8015F788 == 0) {
        func_8009C918(arg0);
    }
    switch (arg0) {
    case 0:
        func_800940EC(*(&D_800F0B1C + arg0), arg0);
        break;
    case 1:
    case 2:
    case 3:
    case 4:
        if (D_8015F788 == 0) {
            func_80093C1C(*(&D_800F0B1C + arg0), arg0);
        } else {
            func_800940EC(*(&D_800F0B1C + arg0), arg0);
        }
        break;
    case 8:
    case 9:
    case 10:
    case 11:
        if (D_8015F788 == 3) {
            func_800940EC(*(&D_800F0B1C + arg0), arg0);
        } else {
            func_80093C1C(*(&D_800F0B1C + arg0), arg0);
        }
        break;
    }
    temp_v1 = gDisplayListHead;
    gDisplayListHead = temp_v1 + 8;
    temp_v1->words.w0 = 0xB900031D;
    temp_v1->words.w1 = 0xF0A4000;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_80093A5C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
//? func_8009CA6C(void **); // extern
extern u8 D_02007F18;
extern u8 D_02007F48;
extern Gfx *gDisplayListHead;

void func_80093C1C(void) {
    gSPDisplayList(gDisplayListHead++, &D_02007F18);
    func_8009CA6C(&gDisplayListHead);
    gSPDisplayList(gDisplayListHead++, &D_02007F48);
}

#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_80093C1C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_8009CA6C(?); // extern
? func_800A54EC(); // extern
? func_800A8250(); // extern
extern ? D_02007F18;
extern s16 D_80164AF0;
extern s32 D_80165754;
extern ? D_802B8880;
extern void *gDisplayListHead;

void func_80093C98(s32 arg0) {
    void *temp_v0;
    void *temp_v0_2;
    void *temp_v0_3;
    void *temp_v0_4;

    temp_v0 = gDisplayListHead;
    gDisplayListHead = temp_v0 + 8;
    temp_v0->unk4 = &D_802B8880 & 0x1FFFFFFF;
    temp_v0->unk0 = 0x3800010;
    guOrtho(gGfxPool + (D_80164AF0 << 6) + 0xFAC0, 0.0f, 319.0f, 239.0f, 0.0f, -100.0f, 100.0f, 1.0f);
    temp_v0_2 = gDisplayListHead;
    gDisplayListHead = temp_v0_2 + 8;
    temp_v0_2->unk0 = 0x1030040;
    temp_v0_2->unk4 = (gGfxPool + (D_80164AF0 << 6) + 0xFAC0) & 0x1FFFFFFF;
    temp_v0_3 = gDisplayListHead;
    D_80164AF0 = D_80164AF0 + 1;
    gDisplayListHead = temp_v0_3 + 8;
    temp_v0_3->unk0 = 0x6000000;
    temp_v0_3->unk4 = &D_02007F18;
    temp_v0_4 = gDisplayListHead;
    gDisplayListHead = temp_v0_4 + 8;
    temp_v0_4->unk0 = 0xED000000;
    temp_v0_4->unk4 = 0x5003C0;
    func_800A8250();
    if (arg0 == 0) {
        func_800A54EC();
        func_8009CA6C(4);
        D_80165754 = D_80164AF0;
        D_80164AF0 = 0;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_80093C98.s")
#endif

void func_80093E20(void) {
    func_80093C98(0);
}

void func_80093E40(void) {
    func_80093C98(1);
}

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80092258(); // extern
? func_80099110(); // extern
? func_8009A344(); // extern
? func_8009E620(); // extern
extern s32 D_8018D9B0;
extern s32 D_8018D9B4;
extern s32 D_8018D9B8;
extern s32 D_8018D9BC;
extern ? D_8018E7AC;
extern ? D_8018E7B1;
extern s8 D_8018E838;
extern s8 D_8018ED91;

void func_80093E60(void) {
    u32 temp_v1;
    ? *phi_v1;

    D_8018D9B4 = func_802A7B70(0x2800);
    D_8018D9B0 = func_802A7B70(0x124F8);
    D_8018D9B8 = func_802A7B70(0x1000);
    D_8018D9BC = func_802A7B70(4);
    phi_v1 = &D_8018E7AC;
    do {
        temp_v1 = phi_v1 + 1;
        temp_v1->unk-1 = 0;
        phi_v1 = temp_v1;
    } while (temp_v1 < &D_8018E7B1);
    D_8018E838 = 0;
    D_8018E838 = 0;
    D_8018E838 = 0;
    D_8018E838 = 0;
    func_80099110();
    func_8009A344();
    func_8009E620();
    func_80092258();
    D_8018ED91 = 0;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_80093E60.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80092290(?, ? *, ? *); // extern
? func_80099A70(); // extern
? func_80099AEC(); // extern
? func_80099E54(); // extern
? func_80099EC4(); // extern
? func_8009C918(); // extern
? func_8009CA2C(); // extern
? func_800A8230(); // extern
extern ? D_02007F18;
extern ? D_02007F48;
extern s16 D_80164AF0;
extern ? D_8018E850;
extern ? D_8018E854;
extern ? D_8018E858;
extern ? D_8018E85C;
extern ? D_802B8880;
extern void *gDisplayListHead;

void func_80093F10(void) {
    void *temp_v0;
    void *temp_v0_2;
    void *temp_v0_3;
    void *temp_v0_4;
    void *temp_v0_5;

    temp_v0 = gDisplayListHead;
    gDisplayListHead = temp_v0 + 8;
    temp_v0->unk4 = &D_802B8880 & 0x1FFFFFFF;
    temp_v0->unk0 = 0x3800010;
    guOrtho(gGfxPool + (D_80164AF0 << 6) + 0xFAC0, 0.0f, 319.0f, 239.0f, 0.0f, -100.0f, 100.0f, 1.0f);
    temp_v0_2 = gDisplayListHead;
    gDisplayListHead = temp_v0_2 + 8;
    temp_v0_2->unk0 = 0x1030040;
    temp_v0_2->unk4 = (gGfxPool + (D_80164AF0 << 6) + 0xFAC0) & 0x1FFFFFFF;
    temp_v0_3 = gDisplayListHead;
    D_80164AF0 = D_80164AF0 + 1;
    gDisplayListHead = temp_v0_3 + 8;
    temp_v0_3->unk0 = 0x6000000;
    temp_v0_3->unk4 = &D_02007F18;
    temp_v0_4 = gDisplayListHead;
    gDisplayListHead = temp_v0_4 + 8;
    temp_v0_4->unk0 = 0xED000000;
    temp_v0_4->unk4 = 0x5003C0;
    func_80092290(4, &D_8018E850, &D_8018E858);
    func_80092290(5, &D_8018E854, &D_8018E85C);
    func_8009C918();
    func_80099A70();
    func_80099E54();
    func_800A8230();
    func_80099AEC();
    func_80099EC4();
    func_8009CA2C();
    temp_v0_5 = gDisplayListHead;
    gDisplayListHead = temp_v0_5 + 8;
    temp_v0_5->unk0 = 0x6000000;
    temp_v0_5->unk4 = &D_02007F48;
    D_80164AF0 = 0;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_80093F10.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80057CE4(); // extern
? func_80092148(); // extern
? func_80092290(?, ? *, ? *); // extern
? func_80099A70(); // extern
? func_80099AEC(); // extern
? func_80099E54(); // extern
? func_80099EC4(); // extern
? func_8009CA6C(s32); // extern
? func_800A8230(); // extern
extern ? D_02007F18;
extern ? D_02007F48;
extern s16 D_80164AF0;
extern ? D_8018E850;
extern ? D_8018E854;
extern ? D_8018E858;
extern ? D_8018E85C;
extern ? D_802B8880;
extern void *gDisplayListHead;

void func_800940EC(s32 arg0) {
    void *temp_v0;
    void *temp_v0_2;
    void *temp_v0_3;
    void *temp_v0_4;
    void *temp_v0_5;

    temp_v0 = gDisplayListHead;
    gDisplayListHead = temp_v0 + 8;
    temp_v0->unk4 = &D_802B8880 & 0x1FFFFFFF;
    temp_v0->unk0 = 0x3800010;
    temp_v0_2 = gDisplayListHead;
    gDisplayListHead = temp_v0_2 + 8;
    temp_v0_2->unk0 = 0xED000000;
    temp_v0_2->unk4 = 0x5003C0;
    guOrtho(gGfxPool + (D_80164AF0 << 6) + 0xFAC0, 0.0f, 319.0f, 239.0f, 0.0f, -100.0f, 100.0f, 1.0f);
    temp_v0_3 = gDisplayListHead;
    gDisplayListHead = temp_v0_3 + 8;
    temp_v0_3->unk0 = 0x1030040;
    temp_v0_3->unk4 = (gGfxPool + (D_80164AF0 << 6) + 0xFAC0) & 0x1FFFFFFF;
    temp_v0_4 = gDisplayListHead;
    D_80164AF0 = D_80164AF0 + 1;
    gDisplayListHead = temp_v0_4 + 8;
    temp_v0_4->unk0 = 0x6000000;
    temp_v0_4->unk4 = &D_02007F18;
    func_80092290(4, &D_8018E850, &D_8018E858);
    func_80092290(5, &D_8018E854, &D_8018E85C);
    func_80092148();
    func_80099A70();
    func_80099E54();
    func_800A8230();
    func_80099AEC();
    func_80099EC4();
    func_8009CA6C(arg0);
    temp_v0_5 = gDisplayListHead;
    gDisplayListHead = temp_v0_5 + 8;
    temp_v0_5->unk0 = 0x6000000;
    temp_v0_5->unk4 = &D_02007F48;
    func_80057CE4();
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800940EC.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern ? D_02007F60;
extern ? D_06009410;
extern f32 D_800E8530;
extern f32 D_800E8534;
extern f32 D_8018EDC4;
extern f32 D_8018EDC8;
extern f32 D_8018EDCC;
extern void *gDisplayListHead;

void func_800942D0(void) {
    ? *sp6C;
    Gfx *temp_s1;
    Gfx *temp_s1_2;
    Gfx *temp_s4;
    Mtx *temp_s1_3;
    Mtx *temp_s4_2;
    f32 temp_f26;
    s32 temp_s3;
    void *temp_v0;
    void *temp_v0_10;
    void *temp_v0_11;
    void *temp_v0_12;
    void *temp_v0_13;
    void *temp_v0_14;
    void *temp_v0_15;
    void *temp_v0_16;
    void *temp_v0_2;
    void *temp_v0_3;
    void *temp_v0_4;
    void *temp_v0_5;
    void *temp_v0_6;
    void *temp_v0_7;
    void *temp_v0_8;
    void *temp_v0_9;
    Mtx *phi_s1;
    s32 phi_s2;
    f32 phi_f26;
    s32 phi_s5;

    temp_v0 = gDisplayListHead;
    gDisplayListHead = temp_v0 + 8;
    temp_v0->unk0 = 0x1030040;
    temp_v0->unk4 = gGfxPool;
    temp_v0_2 = gDisplayListHead;
    gDisplayListHead = temp_v0_2 + 8;
    temp_v0_2->unk0 = 0x1020040;
    temp_s1 = &gGfxPool->buffer[6488];
    temp_v0_2->unk4 = &gGfxPool->buffer[56];
    guRotate(temp_s1, D_8018EDC8, 1.0f, 0.0f, 0.0f);
    temp_s4 = temp_s1 + 0x40;
    guRotate(temp_s4, D_8018EDCC, 0.0f, 1.0f, 0.0f);
    guScale(temp_s1 + 0x80, 1.0f, 1.0f, D_8018EDC4);
    temp_v0_3 = gDisplayListHead;
    gDisplayListHead = temp_v0_3 + 8;
    temp_v0_3->unk4 = temp_s1;
    temp_v0_3->unk0 = 0x1000040;
    temp_v0_4 = gDisplayListHead;
    temp_s1_2 = temp_s4 + 0x40;
    gDisplayListHead = temp_v0_4 + 8;
    temp_v0_4->unk4 = temp_s4;
    temp_v0_4->unk0 = 0x1000040;
    temp_v0_5 = gDisplayListHead;
    gDisplayListHead = temp_v0_5 + 8;
    temp_v0_5->unk4 = temp_s1_2;
    temp_v0_5->unk0 = 0x1040040;
    temp_v0_6 = gDisplayListHead;
    gDisplayListHead = temp_v0_6 + 8;
    temp_v0_6->unk0 = 0xB900031D;
    temp_v0_6->unk4 = 0x552078;
    temp_v0_7 = gDisplayListHead;
    gDisplayListHead = temp_v0_7 + 8;
    temp_v0_7->unk4 = 0;
    temp_v0_7->unk0 = 0xFB000000;
    temp_v0_8 = gDisplayListHead;
    gDisplayListHead = temp_v0_8 + 8;
    temp_v0_8->unk4 = &D_02007F60;
    temp_v0_8->unk0 = 0x6000000;
    temp_v0_9 = gDisplayListHead;
    gDisplayListHead = temp_v0_9 + 8;
    temp_v0_9->unk4 = 0;
    temp_v0_9->unk0 = 0xBD000000;
    phi_s1 = temp_s1_2 + 0x40;
    phi_s2 = 0;
    phi_s5 = 0xC0;
    if (D_800E8530 > 0.0f) {
        temp_f26 = D_800E8534;
        phi_f26 = temp_f26;
        if (temp_f26 > 10.0f) {
            phi_f26 = 10.0f;
        }
        sp6C = &D_06009410;
        do {
            guRotate(phi_s1, 0.0f, 1.0f, 0.0f, 0.0f);
            temp_s3 = phi_s2 + 1;
            temp_s4_2 = phi_s1 + 0x40;
            guRotate(temp_s4_2, temp_s3 * D_800E8530 * phi_f26, 0.0f, 1.0f, 0.0f);
            guScale(phi_s1 + 0x80, 1.0f, 1.0f, 2.0f);
            temp_v0_10 = gDisplayListHead;
            gDisplayListHead = temp_v0_10 + 8;
            temp_v0_10->unk4 = phi_s1;
            temp_v0_10->unk0 = 0x1040040;
            temp_v0_11 = gDisplayListHead;
            temp_s1_3 = temp_s4_2 + 0x40;
            gDisplayListHead = temp_v0_11 + 8;
            temp_v0_11->unk4 = temp_s4_2;
            temp_v0_11->unk0 = 0x1000040;
            temp_v0_12 = gDisplayListHead;
            gDisplayListHead = temp_v0_12 + 8;
            temp_v0_12->unk4 = temp_s1_3;
            temp_v0_12->unk0 = 0x1000040;
            temp_v0_13 = gDisplayListHead;
            gDisplayListHead = temp_v0_13 + 8;
            temp_v0_13->unk4 = 0x5049D8;
            temp_v0_13->unk0 = 0xB900031D;
            temp_v0_14 = gDisplayListHead;
            gDisplayListHead = temp_v0_14 + 8;
            temp_v0_14->unk4 = phi_s5 & 0xFF;
            temp_v0_14->unk0 = 0xFB000000;
            temp_v0_15 = gDisplayListHead;
            gDisplayListHead = temp_v0_15 + 8;
            temp_v0_15->unk0 = 0x6000000;
            temp_v0_15->unk4 = sp6C;
            temp_v0_16 = gDisplayListHead;
            gDisplayListHead = temp_v0_16 + 8;
            temp_v0_16->unk4 = 0;
            temp_v0_16->unk0 = 0xBD000000;
            phi_s1 = temp_s1_3 + 0x40;
            phi_s2 = temp_s3;
            phi_s5 += -0x10;
        } while (temp_s3 != 0xC);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800942D0.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800942D0(); // extern
? move_segment_table_to_dmem(); // extern
extern s32 D_8018EDC0;
extern void *gDisplayListHead;

void func_80094660(Mtx *arg0, ? arg1) {
    u16 sp56;
    void *temp_v0;
    void *temp_v0_2;
    void *temp_v0_3;
    void *temp_v0_4;
    void *temp_v0_5;

    move_segment_table_to_dmem();
    temp_v0 = gDisplayListHead;
    gDisplayListHead = temp_v0 + 8;
    temp_v0->unk4 = 0x80000;
    temp_v0->unk0 = 0xBA001301;
    guPerspective(arg0, &sp56, 45.0f, 1.3333334f, 100.0f, 12800.0f, 1.0f);
    temp_v0_2 = gDisplayListHead;
    gDisplayListHead = temp_v0_2 + 8;
    temp_v0_2->unk0 = 0xB4000000;
    temp_v0_2->unk4 = sp56;
    guLookAt(arg0 + 0x1C0, 0.0f, 0.0f, D_8018EDC0, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f);
    func_800942D0();
    temp_v0_3 = gDisplayListHead;
    gDisplayListHead = temp_v0_3 + 8;
    temp_v0_3->unk4 = 0;
    temp_v0_3->unk0 = 0xE7000000;
    temp_v0_4 = gDisplayListHead;
    gDisplayListHead = temp_v0_4 + 8;
    temp_v0_4->unk4 = 0;
    temp_v0_4->unk0 = 0xBA001301;
    temp_v0_5 = gDisplayListHead;
    gDisplayListHead = temp_v0_5 + 8;
    temp_v0_5->unk4 = 0x2000;
    temp_v0_5->unk0 = 0xBA000C02;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_80094660.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800B0004(); // extern
? move_segment_table_to_dmem(); // extern
extern ? D_02007650;
extern ? D_02007FC8;
extern s32 D_8018EDC0;
extern f32 D_8018EDC4;
extern f32 D_8018EDC8;
extern f32 D_8018EDCC;
extern f32 D_8018EDD0;
extern f32 D_8018EDD4;
extern f32 D_8018EDD8;
extern f32 D_8018EDDC;
extern void *gDisplayListHead;

void func_800947B4(s32 arg0, ? arg1) {
    u16 sp7E;
    Mtx *sp50;
    Mtx *sp4C;
    Mtx *sp48;
    Mtx *sp44;
    Mtx *sp40;
    Mtx *sp3C;
    Mtx *sp38;
    Mtx *temp_a0;
    Mtx *temp_a0_2;
    Mtx *temp_a0_3;
    Mtx *temp_a0_4;
    Mtx *temp_a0_5;
    Mtx *temp_a0_6;
    Mtx *temp_a0_7;
    f32 temp_f0;
    void *temp_v0;
    void *temp_v0_10;
    void *temp_v0_2;
    void *temp_v0_3;
    void *temp_v0_4;
    void *temp_v0_5;
    void *temp_v0_6;
    void *temp_v0_7;
    void *temp_v0_8;
    void *temp_v0_9;

    move_segment_table_to_dmem();
    temp_a0 = arg0 + 0x40;
    sp50 = temp_a0;
    guPerspective(temp_a0, &sp7E, 45.0f, 1.3333334f, 100.0f, 12800.0f, 1.0f);
    temp_v0 = gDisplayListHead;
    gDisplayListHead = temp_v0 + 8;
    temp_v0->unk0 = 0xB4000000;
    temp_v0->unk4 = sp7E;
    temp_a0_2 = arg0 + 0x200;
    sp4C = temp_a0_2;
    guLookAt(temp_a0_2, 0.0f, 0.0f, D_8018EDC0, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f);
    temp_a0_3 = arg0 + 0xCAC0;
    sp48 = temp_a0_3;
    guRotate(temp_a0_3, D_8018EDC8, 1.0f, 0.0f, 0.0f);
    temp_a0_4 = arg0 + 0xCB00;
    sp44 = temp_a0_4;
    guRotate(temp_a0_4, D_8018EDCC, 0.0f, 1.0f, 0.0f);
    temp_a0_5 = arg0 + 0xCB40;
    sp40 = temp_a0_5;
    guRotate(temp_a0_5, D_8018EDD0, 0.0f, 0.0f, 1.0f);
    temp_a0_6 = arg0 + 0xCB80;
    temp_f0 = D_8018EDC4;
    sp3C = temp_a0_6;
    guScale(temp_a0_6, temp_f0, temp_f0, temp_f0);
    temp_a0_7 = arg0 + 0xCBC0;
    sp38 = temp_a0_7;
    guTranslate(temp_a0_7, D_8018EDD4, D_8018EDD8, D_8018EDDC);
    temp_v0_2 = gDisplayListHead;
    gDisplayListHead = temp_v0_2 + 8;
    temp_v0_2->unk0 = 0x1030040;
    temp_v0_2->unk4 = sp50;
    temp_v0_3 = gDisplayListHead;
    gDisplayListHead = temp_v0_3 + 8;
    temp_v0_3->unk0 = 0x1020040;
    temp_v0_3->unk4 = sp4C;
    temp_v0_4 = gDisplayListHead;
    gDisplayListHead = temp_v0_4 + 8;
    temp_v0_4->unk0 = 0x1000040;
    temp_v0_4->unk4 = sp48;
    temp_v0_5 = gDisplayListHead;
    gDisplayListHead = temp_v0_5 + 8;
    temp_v0_5->unk0 = 0x1000040;
    temp_v0_5->unk4 = sp44;
    temp_v0_6 = gDisplayListHead;
    gDisplayListHead = temp_v0_6 + 8;
    temp_v0_6->unk0 = 0x1000040;
    temp_v0_6->unk4 = sp40;
    temp_v0_7 = gDisplayListHead;
    gDisplayListHead = temp_v0_7 + 8;
    temp_v0_7->unk0 = 0x1000040;
    temp_v0_7->unk4 = sp3C;
    temp_v0_8 = gDisplayListHead;
    gDisplayListHead = temp_v0_8 + 8;
    temp_v0_8->unk0 = 0x1000040;
    temp_v0_8->unk4 = sp38;
    temp_v0_9 = gDisplayListHead;
    gDisplayListHead = temp_v0_9 + 8;
    temp_v0_9->unk4 = &D_02007FC8;
    temp_v0_9->unk0 = 0x6000000;
    func_800B0004();
    temp_v0_10 = gDisplayListHead;
    gDisplayListHead = temp_v0_10 + 8;
    temp_v0_10->unk4 = &D_02007650;
    temp_v0_10->unk0 = 0x6000000;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800947B4.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
? func_80092290(?, ? *, ? *);                       /* extern */
? func_80093E40();                                  /* extern */
? func_80094C60();                                  /* extern */
? func_80095574();                                  /* extern */
? func_80099A70();                                  /* extern */
? func_80099AEC();                                  /* extern */
? func_8009C918();                                  /* extern */
? func_8009CA2C();                                  /* extern */
? func_800A8230();                                  /* extern */
? guOrtho(s32, f32, ?, ?, f32, f32, f32, f32);      /* extern */
extern ? D_8018E850;
extern ? D_8018E854;
extern ? D_8018E858;
extern ? D_8018E85C;
extern ? D_802B8880;
static ? D_02007650;                                /* unable to generate initializer */
static ? D_020076B0;                                /* unable to generate initializer */

void func_80094A64(s32 arg0) {
    Gfx *temp_v0;
    Gfx *temp_v0_2;
    Gfx *temp_v0_3;
    Gfx *temp_v0_4;
    Gfx *temp_v0_5;
    Gfx *temp_v0_6;
    s32 temp_t1;

    D_8018D120 = 0;
    D_80164AF0 = 0;
    temp_v0 = gDisplayListHead;
    gDisplayListHead = temp_v0 + 8;
    temp_v0->words.w1 = &D_802B8880 & 0x1FFFFFFF;
    temp_v0->words.w0 = 0x3800010;
    temp_v0_2 = gDisplayListHead;
    gDisplayListHead = temp_v0_2 + 8;
    temp_v0_2->words.w0 = 0xED000000;
    temp_v0_2->words.w1 = 0x5003C0;
    guOrtho(arg0, 0.0f, 0x439F8000, 0x436F0000, 0.0f, -100.0f, 100.0f, 1.0f);
    temp_v0_3 = gDisplayListHead;
    gDisplayListHead = temp_v0_3 + 8;
    temp_v0_3->words.w0 = 0x1030040;
    temp_v0_3->words.w1 = arg0;
    temp_v0_4 = gDisplayListHead;
    gDisplayListHead = temp_v0_4 + 8;
    temp_v0_4->words.w1 = &D_02007650;
    temp_v0_4->words.w0 = 0x6000000;
    func_80094C60();
    func_80092290(4, &D_8018E850, &D_8018E858);
    func_80092290(5, &D_8018E854, &D_8018E85C);
    func_80099A70();
    func_8009C918();
    temp_t1 = D_800E86A0;
    switch (temp_t1) {
    case 10:
        func_80095574();
        func_80093E40();
        break;
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 11:
    case 12:
    case 13:
        func_800A8230();
        func_80099AEC();
        break;
    }
    func_8009CA2C();
    temp_v0_5 = gDisplayListHead;
    D_8018E7A8 += 1;
    gDisplayListHead = temp_v0_5 + 8;
    temp_v0_5->words.w1 = 0;
    temp_v0_5->words.w0 = 0xE7000000;
    temp_v0_6 = gDisplayListHead;
    gDisplayListHead = temp_v0_6 + 8;
    temp_v0_6->words.w0 = 0x6000000;
    temp_v0_6->words.w1 = &D_020076B0;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_80094A64.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
? func_80092258();                                  /* extern */
? func_80099110();                                  /* extern */
? func_8009A344();                                  /* extern */
? func_8009B938();                                  /* extern */
? func_8009DF4C(?);                                 /* extern */
? func_8009DF6C(?);                                 /* extern */
? func_8009E620();                                  /* extern */
? func_8009E650(?, ?, ?, ?);                        /* extern */
? func_800B3F74(u32);                               /* extern */
? func_800B5F30();                                  /* extern */
? func_800B6014();                                  /* extern */

void func_80094C60(void) {
    s32 temp_v0;
    u32 temp_t7;
    s32 phi_v0;

    if (D_800E86A4 != 0) {
        func_80099110();
        func_8009A344();
        func_8009E620();
        func_8009B938();
        func_80092258();
        func_800B5F30();
        func_800B6014();
        func_800B3F74(D_800E86A0);
        temp_t7 = D_800E86A0;
        switch (temp_t7) {
        case 5:
            func_8009E650(0x23, 0, 0, 2);
            func_8009E650(0xF1, 0, 0, 4);
            func_8009E650(0xF0, 0, 0, 2);
            break;
        case 6:
            func_8009E650(0x23, 0, 0, 2);
            func_8009E650(0x8C, 0, 0, 6);
            func_8009E650(0x7C, 0, 0, 6);
            func_8009E650(0x7D, 0, 0, 6);
            func_8009E650(0x7E, 0, 0, 6);
            func_8009E650(0x7F, 0, 0, 6);
            func_8009E650(0x80, 0, 0, 6);
            func_8009E650(0x81, 0, 0, 6);
            func_8009E650(0x82, 0, 0, 6);
            func_8009E650(0x83, 0, 0, 6);
            func_8009E650(0x84, 0, 0, 6);
            func_8009E650(0x85, 0, 0, 6);
            func_8009E650(0x86, 0, 0, 6);
            func_8009E650(0x87, 0, 0, 6);
            func_8009E650(0x88, 0, 0, 6);
            func_8009E650(0x89, 0, 0, 6);
            func_8009E650(0x8A, 0, 0, 6);
            func_8009E650(0x8B, 0, 0, 6);
            func_8009E650(0x8D, 0, 0, 8);
            break;
        case 7:
            func_8009E650(0xE6, 0, 0, 8);
            func_8009E650(0xE7, 0, 0, 8);
            func_8009E650(0xE8, 0, 0, 8);
            func_8009E650(0xE9, 0, 0, 8);
            func_8009E650(0xEA, 0, 0, 8);
            break;
        case 8:
            func_8009E650(0xFA, 0, 0, 0);
            break;
        case 9:
            func_8009E650(0xDA, 0, 0, 0);
            func_8009E650(0xD2, 0, 0, 4);
            func_8009E650(0xD4, 0, 0, 6);
            func_8009E650(0xD3, 0, 0, 8);
            func_8009E650(0xD5, 0, 0, 0xA);
            func_8009E650(0xD6, 0, 0, 0xA);
            func_8009E650(0xD7, 0, 0, 0xA);
            func_8009E650(0xD8, 0, 0, 0xA);
            func_8009E650(0xD9, 0, 0, 0xA);
            break;
        case 10:
            func_8009E650(2, 0, 0, 4);
            func_8009E650(1, 0, 0, 0);
            func_8009E650(0xFB, 0, 0, 0);
            if ((gControllerBits & 1) != 0) {
                func_8009E650(3, 0, 0, 2);
            } else {
                func_8009E650(4, 0, 0, 2);
            }
            func_8009E650(5, 0, 0, 6);
            D_800DC51C = 0;
            D_8018EE08 = 0;
            break;
        case 11:
            func_8009E650(0x23, 0, 0, 2);
            func_8009E650(0xA, 0x15E, 0x11, 6);
            func_8009E650(0xE, 0x15E, 0x3E, 6);
            func_8009E650(0xD, 0x15E, 0x3E, 6);
            func_8009E650(0xC, 0x15E, 0x3E, 6);
            func_8009E650(0xB, 0x15E, 0x3E, 6);
            func_8009E650(0xF, 0x15E, 0xC8, 6);
            func_8009E650(0x11, 0x15E, 0xC8, 6);
            func_8009E650(0x10, 0x15E, 0xC8, 6);
            if (func_800B555C() != 0) {
                func_8009E650(0x15, 0, 0, 6);
            }
            func_8009E650(0x14, 0, 0, 6);
            func_8009E650(0x13, 0, 0, 6);
            func_8009E650(0x12, 0, 0, 6);
            func_8009E650(0x19, 0, 0, 6);
            func_8009E650(0x18, 0, 0, 6);
            func_8009E650(0x1B, 0, 0, 0xC);
            break;
        case 12:
            func_8009E650(0x24, 0, 0, 2);
            func_8009E650(0x2A, 0, 0, 6);
            func_8009E650(0x33, 0, 0, 6);
            func_8009E650(0x2B, 0, 0, 8);
            func_8009E650(0x2C, 0, 0, 8);
            func_8009E650(0x2D, 0, 0, 6);
            func_8009E650(0x2E, 0, 0, 6);
            func_8009E650(0x2F, 0, 0, 6);
            func_8009E650(0x30, 0, 0, 6);
            func_8009E650(0x31, 0, 0, 6);
            func_8009E650(0x32, 0, 0, 8);
            func_8009E650(0x34, 0, 0, 0xC);
            func_8009E650(0x35, 0, 0, 0xC);
            func_8009E650(0x36, 0, 0, 0xC);
            func_8009E650(0x37, 0, 0, 0xC);
            break;
        case 13:
            func_8009E650(0x25, 0, 0, 2);
            func_8009E650(0x52, 0, 0, 6);
            if (gModeSelection != BATTLE) {
                func_8009E650(0x53, 0, 0, 4);
                func_8009E650(0x54, 0, 0, 4);
                func_8009E650(0x55, 0, 0, 4);
                func_8009E650(0x56, 0, 0, 4);
                func_8009E650(0x58, 0, 0, 6);
                func_8009E650(0x59, 0, 0, 6);
                func_8009E650(0x5A, 0, 0, 6);
                func_8009E650(0x5B, 0, 0, 6);
            } else {
                func_8009E650(0x5C, 0, 0, 6);
                func_8009E650(0x6E, 0, 0, 6);
            }
            func_8009E650(0x64, 0, 0, 6);
            func_8009E650(0x5F, 0, 0, 6);
            func_8009E650(0x60, 0, 0, 6);
            func_8009E650(0x61, 0, 0, 6);
            func_8009E650(0x62, 0, 0, 6);
            func_8009E650(0x5D, 0, 0, 6);
            func_8009E650(0x5E, 0, 0, 8);
            temp_v0 = gModeSelection;
            phi_v0 = temp_v0;
            if (temp_v0 == TIME_TRIALS) {
                func_8009E650(0x65, 0, 0, 8);
                func_8009E650(0x66, 0, 0, 8);
                func_8009E650(0x69, 0, 0, 8);
                phi_v0 = gModeSelection;
            }
            if (phi_v0 == GRAND_PRIX) {
                func_8009E650(0x68, 0, 0, 8);
                func_8009E650(0x67, 0, 0, 5);
            }
            break;
        }
        if (D_800E86A4 != 2) {
            func_8009DF4C(0x14);
        } else {
            func_8009DF6C(0x14);
        }
        D_800E86A4 = 0;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_80094C60.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
? debug_print_str2(s32, ?, ? *, s16);               /* extern */
? func_80057778();                                  /* extern */
? func_8009E230();                                  /* extern */
? func_800A8230();                                  /* extern */
? func_800CA0A0();                                  /* extern */
? load_debug_font();                                /* extern */
? play_sound2(?);                                   /* extern */
? print_str_num(?, ?, ? *, s16);                    /* extern */
static ? D_020076E0;                                /* unable to generate initializer */
static ? gDebugCourseNames;                                /* unable to generate initializer; const */
static ? gDebugCharacterNames;                                /* unable to generate initializer; const */
static ? gDebugScreenModeNames;                                /* unable to generate initializer; const */
static ? gDebugSoundModeNames;                                /* unable to generate initializer; const */
s16 gCurrentCourseId;                               /* unable to generate initializer */

void func_80095574(void) {
    Gfx *temp_v1;
    s16 temp_a3;
    s16 temp_a3_2;
    s32 temp_v0_2;
    s8 temp_t8;
    s8 temp_v0;
    s32 phi_v0;
    s8 phi_v0_2;
    s32 phi_v0_3;

    if ((D_8018EE0C < 3) || (D_8018E7B0 != 0)) {
        func_800A8230();
    }
    temp_v0 = D_8018EDEF;
    phi_v0_2 = temp_v0;
    if (temp_v0 >= 2) {
        load_debug_font();
        debug_print_str2(0x50, 0x64, "debug_mode");
        temp_t8 = D_8018EDEF;
        switch (temp_t8) {
        case 2:
            debug_print_str2(0x46, 0x64, "*");
            break;
        case 3:
            debug_print_str2(0x46, 0x6E, "*");
            break;
        case 4:
            debug_print_str2(0x46, 0x78, "*");
            break;
        case 5:
            debug_print_str2(0x46, 0x82, "*");
            break;
        case 6:
            debug_print_str2(0x46, 0x8C, "*");
            break;
        case 7:
            debug_print_str2(0x46, 0x96, "*");
            break;
        }
        if (gEnableDebugMode != 0) {
            debug_print_str2(0xAA, 0x64, "on");
        } else {
            debug_print_str2(0xAA, 0x64, "off");
        }
        temp_a3 = gCurrentCourseId;
        if ((temp_a3 >= 0x14) || (temp_a3 < 0)) {
            gCurrentCourseId = 0;
        }
        print_str_num(0x50, 0x6E, "map_number", gCurrentCourseId);
        temp_a3_2 = gCurrentCourseId;
        if (temp_a3_2 < 0xA) {
            phi_v0 = 0;
        } else {
            phi_v0 = 8;
        }
        debug_print_str2(phi_v0 + 0xB9, 0x6E, gDebugCourseNames[temp_a3_2], temp_a3_2);
        debug_print_str2(0x50, 0x78, "screen_mode");
        debug_print_str2(0xAA, 0x78, *(&gDebugScreenModeNames + (D_8018EDF1 * 4)));
        debug_print_str2(0x50, 0x82, "player");
        debug_print_str2(0xAA, 0x82, *(&gDebugCharacterNames + (D_800E86A8 * 4)));
        debug_print_str2(0x50, 0x8C, "sound mode");
        debug_print_str2(0xAA, 0x8C, gDebugSoundModeNames[gSoundMode]);
        if (D_8018EDEF == 7) {
            debug_print_str2(0x50, 0x96, "push b to get all goldcup");
        }
        func_80057778();
        phi_v0_2 = D_8018EDEF;
    }
    if (phi_v0_2 == 1) {
        D_8018EE00 += 1;
    } else {
        D_8018EE00 = 3;
    }
    temp_v0_2 = D_8018EE00;
    phi_v0_3 = temp_v0_2;
    if (temp_v0_2 == 2) {
        play_sound2(0x49009009);
        phi_v0_3 = D_8018EE00;
    }
    if (phi_v0_3 >= 0x12D) {
        func_8009E230();
        func_800CA0A0();
    }
    temp_v1 = gDisplayListHead;
    gDisplayListHead = temp_v1 + 8;
    temp_v1->words.w0 = 0x6000000;
    temp_v1->words.w1 = &D_020076E0;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_80095574.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 func_80098C18(s32, s32, s32, s32, s32, s32); // extern
extern s32 D_8018E7A8;
extern s32 gDisplayListHead;

void func_800958D4(s32 arg0, s32 arg4, s32 arg5) {
    s32 temp_lo;
    s32 phi_v0;
    s32 phi_v0_2;

    temp_lo = ((D_8018E7A8 % arg5) << 9) / arg5;
    phi_v0 = temp_lo;
    if (temp_lo >= 0x101) {
        phi_v0 = 0x200 - temp_lo;
    }
    phi_v0_2 = phi_v0;
    if (phi_v0 >= 0x100) {
        phi_v0_2 = 0xFF;
    }
    gDisplayListHead = func_80098C18(gDisplayListHead, arg4, phi_v0_2, phi_v0_2, phi_v0_2, 0xFF);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800958D4.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800958D4(s32, s32); // extern

void func_800959A0(s32 arg4) {
    func_800958D4(arg4, 0x40);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800959A0.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800958D4(s32, s32); // extern

void func_800959CC(s32 arg4) {
    func_800958D4(arg4, 4);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800959CC.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern ? D_02007BB8;
extern ? D_800E84CC;
extern ? D_800E84EC;
extern ? D_800E850C;
extern s8 gTextColor;
extern s32 gGlobalTimer;

void *func_800959F8(void *arg0, s32 arg1) {
    s8 phi_v1;

    if (gTextColor < 4) {
        phi_v1 = gTextColor;
    } else {
        phi_v1 = ((gTextColor * 2) + (gGlobalTimer % 2)) - 4;
    }
    if (arg1 == &D_02007BB8) {
        arg0->unk0 = 0x6000000;
        arg0->unk4 = D_800E84CC[phi_v1];
        return arg0 + 8;
    }
    if (arg1 == 0x2007CD8) {
        arg0->unk0 = 0x6000000;
        arg0->unk4 = D_800E84EC[phi_v1];
        return arg0 + 8;
    }
    if (arg1 == 0x2007DF8) {
        arg0->unk0 = 0x6000000;
        arg0->unk4 = D_800E850C[phi_v1];
        arg0 += 8;
    }
    return arg0;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800959F8.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void func_80095AE0(void *arg0, f32 arg1, f32 arg2, f32 arg3, f32 arg4) {
    s32 sp14;
    s32 sp10;
    s32 spC;
    s32 sp8;
    s32 *temp_a2;
    s32 *temp_a3;
    s32 *temp_v0_2;
    s32 *temp_v1;
    s32 temp_v0;
    void *phi_v1;
    s32 phi_v0;

    phi_v1 = arg0;
    phi_v0 = 0;
    do {
        temp_v0 = phi_v0 + 4;
        phi_v1->unk0 = 0;
        phi_v1->unk4 = 0;
        phi_v1->unk8 = 0;
        phi_v1->unkC = 0;
        phi_v1 += 0x10;
        phi_v0 = temp_v0;
    } while (temp_v0 != 0x10);
    temp_v0_2 = &sp14;
    temp_v1 = &sp10;
    temp_a2 = &spC;
    temp_a3 = &sp8;
    sp14 = arg3 * 65536.0f;
    sp10 = arg4 * 65536.0f;
    spC = arg1 * 65536.0f;
    sp8 = arg2 * 65536.0f;
    arg0->unk0 = temp_v0_2->unk0;
    arg0->unk14 = 1;
    arg0->unkA = temp_v1->unk0;
    arg0->unk18 = temp_a2->unk0;
    arg0->unk1E = 1;
    arg0->unk1A = temp_a3->unk0;
    arg0->unk20 = temp_v0_2->unk2;
    arg0->unk2A = temp_v1->unk2;
    arg0->unk38 = temp_a2->unk2;
    arg0->unk3A = temp_a3->unk2;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_80095AE0.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void *func_800959F8(void *, ? *, void *, s32); // extern
? func_80095AE0(void *, s32, s32, s32, f32); // extern
? func_800CF774(? *); // extern
extern ? D_02007BB8;
extern ? D_02007CD8;
extern ? D_02007DF8;
extern ? D_800F0BCC;
extern ? D_800F0BEC;
extern s16 D_80164AF0;

void *func_80095BD0(void *arg0, s32 arg1, s32 arg2, s32 arg3, u32 arg4, s32 arg5, s32 arg6, f32 arg7) {
    void *sp28;
    s16 temp_v0;
    s32 temp_a3;
    s32 temp_v0_2;
    void *temp_s0;
    void *temp_s0_2;
    void *temp_s0_3;
    void *temp_s0_4;
    void *temp_s0_5;
    void *temp_s0_6;
    void *temp_s0_7;
    ? *phi_a1;

    temp_v0 = D_80164AF0;
    if (temp_v0 < 0x2F7) {
        sp28 = gGfxPool + (temp_v0 << 6) + 0xFAC0;
        if (temp_v0 < 0) {
            func_800CF774(&D_800F0BCC);
        }
        func_80095AE0(sp28, arg2, arg3, arg6, arg7);
        arg0->unk0 = 0x1020040;
        arg0->unk4 = (gGfxPool + (D_80164AF0 << 6) + 0xFAC0) & 0x1FFFFFFF;
        temp_s0_2 = arg0 + 8;
        D_80164AF0 = D_80164AF0 + 1;
        temp_s0_2->unk0 = (((arg4 >> 1) - 1) & 0xFFF) | 0xFD880000;
        temp_s0_3 = temp_s0_2 + 8;
        temp_s0_2->unk4 = arg1;
        temp_a3 = (((((arg4 + 1) >> 1) + 7) >> 3) & 0x1FF) << 9;
        temp_s0_4 = temp_s0_3 + 8;
        temp_s0_3->unk0 = temp_a3 | 0xF5880000;
        temp_s0_3->unk4 = 0x7000000;
        temp_s0_5 = temp_s0_4 + 8;
        temp_s0_4->unk0 = 0xE6000000;
        temp_s0_4->unk4 = 0;
        temp_s0_5->unk0 = 0xF4000000;
        temp_v0_2 = (arg5 * 4) & 0xFFF;
        temp_s0_6 = temp_s0_5 + 8;
        temp_s0_5->unk4 = (((arg4 * 2) & 0xFFF) << 0xC) | 0x7000000 | temp_v0_2;
        temp_s0_7 = temp_s0_6 + 8;
        temp_s0_6->unk0 = 0xE7000000;
        temp_s0 = temp_s0_7 + 8;
        temp_s0_6->unk4 = 0;
        temp_s0_7->unk4 = 0;
        temp_s0_7->unk0 = temp_a3 | 0xF5800000;
        temp_s0->unk0 = 0xF2000000;
        temp_s0->unk4 = (((arg4 * 4) & 0xFFF) << 0xC) | temp_v0_2;
        if (arg4 != 0x10) {
            if (arg4 != 0x1A) {
                if (arg4 != 0x1E) {
                    phi_a1 = &D_02007CD8;
                } else {
                    phi_a1 = &D_02007DF8;
                }
            } else {
                phi_a1 = &D_02007BB8;
            }
        } else {
            phi_a1 = &D_02007CD8;
        }
        return func_800959F8(temp_s0 + 8, phi_a1, temp_s0, temp_a3);
    }
    func_800CF774(&D_800F0BEC);
    return arg0;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_80095BD0.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void *func_80095E10(void *arg0, s8 arg1, s32 arg2, s32 arg3, s32 arg4, s32 arg5, s32 arg6, s32 arg7, s32 arg8, s32 arg9, s32 argA, u32 argB, u32 argC) {
    s32 sp7C;
    s32 sp70;
    s32 sp6C;
    s32 sp68;
    s32 sp64;
    u32 sp34;
    s32 temp_a2;
    s32 temp_a2_2;
    s32 temp_a2_3;
    s32 temp_lo;
    s32 temp_s2;
    s32 temp_s4;
    s32 temp_t1;
    s32 temp_t2;
    s32 temp_t3;
    s32 temp_t6;
    s32 temp_t7_2;
    s32 temp_v0;
    s32 temp_v0_2;
    s32 temp_v0_3;
    s32 temp_v1;
    s32 temp_v1_2;
    u32 temp_s5;
    u32 temp_t6_2;
    u32 temp_t7;
    void *temp_a0;
    void *temp_a0_10;
    void *temp_a0_2;
    void *temp_a0_3;
    void *temp_a0_4;
    void *temp_a0_5;
    void *temp_a0_6;
    void *temp_a0_7;
    void *temp_a0_8;
    void *temp_a0_9;
    u32 phi_t0;
    s32 phi_t0_2;
    s32 phi_v0;
    s32 phi_v0_2;
    s32 phi_a2;
    s32 phi_v0_3;
    s32 phi_v0_4;
    s32 phi_a1;
    s32 phi_a2_2;
    s32 phi_s3;
    u32 phi_v1;
    s32 phi_t0_3;
    s32 phi_a1_2;
    s32 phi_t1;
    void *phi_a0;
    s32 phi_t2;
    s32 phi_s2;
    s32 phi_t4;
    s32 phi_a3;
    s32 phi_t0_4;
    s32 phi_v1_2;
    s32 phi_a2_3;
    s32 phi_s1;
    s32 phi_s6;
    s32 phi_s7;
    s32 phi_fp;
    void *phi_a0_2;
    s32 phi_a2_4;
    void *phi_a0_3;
    s32 phi_s4;
    s32 phi_ra;
    void *phi_a0_4;

    sp68 = 0;
    sp64 = 0;
    phi_t0 = 1;
    phi_t0_2 = 1;
    phi_a0_2 = arg0;
    phi_a0_3 = arg0;
    if (argB >= 2) {
        do {
            temp_t7 = phi_t0 * 2;
            phi_t0 = temp_t7;
            phi_t0_2 = temp_t7;
        } while (temp_t7 < argB);
    }
    temp_lo = 0x400 / phi_t0_2;
    phi_a2 = temp_lo;
    phi_t0_3 = phi_t0_2;
    if (argC < (temp_lo / 2)) {
        phi_v0 = temp_lo / 2;
        do {
            temp_v0 = phi_v0 / 2;
            phi_v0 = temp_v0;
        } while (argC < temp_v0);
        sp6C = phi_v0;
        phi_a2 = phi_v0;
    }
    phi_v0_2 = phi_t0_2;
    phi_a2_2 = phi_a2;
    if (phi_t0_2 >= 2) {
        do {
            temp_t7_2 = phi_v0_2 / 2;
            sp68 += 1;
            phi_v0_2 = temp_t7_2;
        } while (temp_t7_2 >= 2);
    }
    phi_v0_3 = phi_a2;
    if (phi_a2 >= 2) {
        do {
            temp_t6 = phi_v0_3 / 2;
            sp64 += 1;
            phi_v0_3 = temp_t6;
        } while (temp_t6 >= 2);
    }
    phi_a1 = arg8;
    if (arg8 < 0) {
        arg4 -= arg8;
        phi_a1 = 0;
    } else if (((arg6 - arg4) + arg8) >= 0x141) {
        arg6 = (arg4 - arg8) + 0x140;
    }
    phi_v0_4 = arg5;
    phi_v1 = arg6;
    phi_ra = arg9;
    if (arg9 < 0) {
        phi_v0_4 = arg5 - arg9;
        phi_ra = 0;
    } else if (((arg7 - arg5) + arg9) >= 0xF1) {
        arg7 = (arg5 - arg9) + 0xF0;
    }
    if (arg6 < arg4) {

    } else if (arg7 < phi_v0_4) {

    } else {
        sp7C = phi_a1;
        phi_s3 = phi_v0_4;
        if (phi_v0_4 < arg7) {
            arg8 = phi_a1;
loop_24:
            temp_t6_2 = phi_a2_2 + phi_s3;
            sp34 = temp_t6_2;
            phi_a0 = phi_a0_3;
            phi_a0_2 = phi_a0_3;
            phi_a2_4 = phi_a2_2;
            phi_a0_4 = phi_a0_3;
            if (arg7 < temp_t6_2) {
                temp_s4 = arg7 - phi_s3;
                phi_s4 = temp_s4;
                if (temp_s4 != 0) {
                    goto block_28;
                }
            } else {
                phi_s4 = phi_a2_2;
block_28:
                phi_a1_2 = arg4;
                if (arg4 < phi_v1) {
                    arg6 = phi_v1;
                    sp6C = phi_a2_2;
                    sp70 = phi_t0_3;
loop_30:
                    temp_s5 = sp70 + phi_a1_2;
                    phi_s2 = sp70;
                    phi_v1 = arg6;
                    phi_a0_4 = phi_a0;
                    if (arg6 < temp_s5) {
                        temp_s2 = arg6 - phi_a1_2;
                        phi_s2 = temp_s2;
                        if (temp_s2 == 0) {
                            phi_a2_4 = sp6C;
                            phi_t0_3 = sp70;
                        } else {
                            arg6 = arg6;
                            temp_v0_2 = (arg1 & 7) << 0x15;
                            temp_a2 = (sp68 & 0xF) * 0x10;
                            temp_v1 = (sp64 & 0xF) << 0xE;
                            phi_t1 = temp_v0_2 | 0xFD000000 | 0x100000 | ((argB - 1) & 0xFFF);
                            phi_t2 = temp_v0_2 | 0xF5000000 | 0x100000;
                            phi_t4 = temp_v1 | 0x7000000 | temp_a2;
                            phi_a3 = (phi_s3 * 4) & 0xFFF;
                            phi_t0_4 = ((phi_s3 + phi_s4) * 4) & 0xFFF;
                            phi_v1_2 = temp_v1;
                            phi_a2_3 = temp_a2;
                            phi_s1 = ((phi_ra + phi_s4) * 4) & 0xFFF;
                            phi_s6 = (phi_ra * 4) & 0xFFF;
                            phi_s7 = (phi_s3 << 5) & 0xFFFF;
                            phi_fp = (arg2 << 0x10) | (arg3 & 0xFFFF);
                            goto block_35;
                        }
                    } else {
                        temp_v0_3 = (arg1 & 7) << 0x15;
                        temp_a2_2 = (sp68 & 0xF) * 0x10;
                        temp_v1_2 = (sp64 & 0xF) << 0xE;
                        phi_t1 = temp_v0_3 | 0xFD000000 | 0x100000 | ((argB - 1) & 0xFFF);
                        phi_t2 = temp_v0_3 | 0xF5000000 | 0x100000;
                        phi_t4 = temp_v1_2 | 0x7000000 | temp_a2_2;
                        phi_a3 = (phi_s3 * 4) & 0xFFF;
                        phi_t0_4 = ((phi_s3 + phi_s4) * 4) & 0xFFF;
                        phi_v1_2 = temp_v1_2;
                        phi_a2_3 = temp_a2_2;
                        phi_s1 = ((phi_ra + phi_s4) * 4) & 0xFFF;
                        phi_s6 = (phi_ra * 4) & 0xFFF;
                        phi_s7 = (phi_s3 << 5) & 0xFFFF;
                        phi_fp = (arg2 << 0x10) | (arg3 & 0xFFFF);
block_35:
                        phi_a0->unk0 = phi_t1;
                        temp_a2_3 = phi_a1_2 + phi_s2;
                        phi_a0->unk4 = argA;
                        temp_a0 = phi_a0 + 8;
                        temp_t3 = phi_t2 | ((((((temp_a2_3 - phi_a1_2) * 2) + 9) >> 3) & 0x1FF) << 9);
                        temp_a0_2 = temp_a0 + 8;
                        temp_t1 = ((phi_a1_2 * 4) & 0xFFF) << 0xC;
                        temp_a0->unk0 = temp_t3;
                        temp_a0->unk4 = phi_t4;
                        temp_a0_2->unk0 = 0xE6000000;
                        temp_a0_3 = temp_a0_2 + 8;
                        temp_t2 = ((temp_a2_3 * 4) & 0xFFF) << 0xC;
                        temp_a0_2->unk4 = 0;
                        temp_a0_3->unk0 = temp_t1 | 0xF4000000 | phi_a3;
                        temp_a0_4 = temp_a0_3 + 8;
                        temp_a0_3->unk4 = temp_t2 | 0x7000000 | phi_t0_4;
                        temp_a0_5 = temp_a0_4 + 8;
                        temp_a0_4->unk0 = 0xE7000000;
                        temp_a0_4->unk4 = 0;
                        temp_a0_6 = temp_a0_5 + 8;
                        temp_a0_5->unk4 = phi_v1_2 | phi_a2_3;
                        temp_a0_5->unk0 = temp_t3;
                        temp_a0_6->unk4 = temp_t2 | phi_t0_4;
                        temp_a0_6->unk0 = temp_t1 | 0xF2000000 | phi_a3;
                        temp_a0_7 = temp_a0_6 + 8;
                        temp_a0_7->unk0 = ((((arg8 + phi_s2) * 4) & 0xFFF) << 0xC) | 0xE4000000 | phi_s1;
                        temp_a0_8 = temp_a0_7 + 8;
                        temp_a0_7->unk4 = (((arg8 * 4) & 0xFFF) << 0xC) | phi_s6;
                        temp_a0_8->unk0 = 0xB3000000;
                        temp_a0_9 = temp_a0_8 + 8;
                        temp_a0_8->unk4 = (phi_a1_2 << 0x15) | phi_s7;
                        temp_a0_9->unk0 = 0xB2000000;
                        temp_a0_9->unk4 = phi_fp;
                        arg8 += sp70;
                        temp_a0_10 = temp_a0_9 + 8;
                        phi_a1_2 = temp_s5;
                        phi_a0 = temp_a0_10;
                        phi_a0_4 = temp_a0_10;
                        if (temp_s5 >= arg6) {
                            phi_a2_4 = sp6C;
                            phi_v1 = arg6;
                            phi_t0_3 = sp70;
                        } else {
                            goto loop_30;
                        }
                    }
                }
                arg8 = sp7C;
                phi_a2_2 = phi_a2_4;
                phi_s3 = sp34;
                phi_a0_2 = phi_a0_4;
                phi_a0_3 = phi_a0_4;
                phi_ra += phi_a2_4;
                if (sp34 < arg7) {
                    goto loop_24;
                }
            }
        }
    }
    return phi_a0_2;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_80095E10.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void *func_800963F0(void *arg0, s8 arg1, s32 arg2, s32 arg3, f32 arg4, f32 arg5, s32 arg6, s32 arg7, s32 arg8, s32 arg9, s32 argA, s32 argB, s32 argC, u32 argD, u32 argE) {
    s32 sp8C;
    s32 sp78;
    s32 sp74;
    s32 sp70;
    s32 sp6C;
    u32 sp34;
    f32 temp_f0;
    f32 temp_f0_2;
    f32 temp_f10;
    f32 temp_f8;
    s32 temp_a2;
    s32 temp_a2_2;
    s32 temp_a2_3;
    s32 temp_fp;
    s32 temp_lo;
    s32 temp_t1;
    s32 temp_t2;
    s32 temp_t3;
    s32 temp_t6;
    s32 temp_t7_2;
    s32 temp_v0;
    s32 temp_v0_2;
    s32 temp_v0_3;
    s32 temp_v1;
    s32 temp_v1_2;
    u32 temp_s2;
    u32 temp_s4;
    u32 temp_t7;
    u32 temp_t8;
    void *temp_a0;
    void *temp_a0_10;
    void *temp_a0_2;
    void *temp_a0_3;
    void *temp_a0_4;
    void *temp_a0_5;
    void *temp_a0_6;
    void *temp_a0_7;
    void *temp_a0_8;
    void *temp_a0_9;
    u32 phi_t0;
    s32 phi_t0_2;
    s32 phi_v0;
    s32 phi_v0_2;
    s32 phi_a3;
    s32 phi_v0_3;
    s32 phi_v0_4;
    s32 phi_ra;
    s32 phi_a1;
    s32 phi_a3_2;
    s32 phi_s3;
    u32 phi_a2;
    u32 phi_v1;
    s32 phi_t0_3;
    u32 phi_a1_2;
    s32 phi_fp;
    s32 phi_t1;
    void *phi_a0;
    s32 phi_t2;
    u32 phi_s2;
    s32 phi_t4;
    s32 phi_a3_3;
    s32 phi_t0_4;
    s32 phi_s0;
    s32 phi_ra_2;
    s32 phi_s1;
    s32 phi_s5;
    s32 phi_s6;
    s32 phi_s7;
    f32 phi_f12;
    f32 phi_f18;
    u32 phi_a2_2;
    void *phi_a0_2;
    void *phi_a0_3;
    f32 phi_f0;
    f32 phi_f16;
    f32 phi_f10;
    f32 phi_f8;
    void *phi_a0_4;

    sp70 = 0;
    sp6C = 0;
    phi_t0 = 1;
    phi_t0_2 = 1;
    phi_a0_2 = arg0;
    phi_a0_3 = arg0;
    if (argD >= 2) {
        do {
            temp_t7 = phi_t0 * 2;
            phi_t0 = temp_t7;
            phi_t0_2 = temp_t7;
        } while (temp_t7 < argD);
    }
    temp_lo = 0x400 / phi_t0_2;
    phi_a3 = temp_lo;
    phi_t0_3 = phi_t0_2;
    if (argE < (temp_lo / 2)) {
        phi_v0 = temp_lo / 2;
        do {
            temp_v0 = phi_v0 / 2;
            phi_v0 = temp_v0;
        } while (argE < temp_v0);
        sp74 = phi_v0;
        phi_a3 = phi_v0;
    }
    phi_v0_2 = phi_t0_2;
    phi_a3_2 = phi_a3;
    if (phi_t0_2 >= 2) {
        do {
            temp_t7_2 = phi_v0_2 / 2;
            sp70 += 1;
            phi_v0_2 = temp_t7_2;
        } while (temp_t7_2 >= 2);
    }
    phi_v0_3 = phi_a3;
    if (phi_a3 >= 2) {
        do {
            temp_t6 = phi_v0_3 / 2;
            sp6C += 1;
            phi_v0_3 = temp_t6;
        } while (temp_t6 >= 2);
    }
    phi_ra = argA;
    if (argA < 0) {
        arg6 -= argA;
        phi_ra = 0;
    } else {
        temp_f0 = argA + ((arg8 - arg6) * arg4);
        if (temp_f0 > 320.0f) {
            arg8 = arg8 - (temp_f0 - 320.0f);
        }
    }
    phi_v0_4 = arg7;
    phi_a1 = argB;
    phi_ra_2 = phi_ra;
    if (argB < 0) {
        phi_v0_4 = arg7 - argB;
        phi_a1 = 0;
    } else {
        temp_f0_2 = argB + ((arg9 - arg7) * arg5);
        if (temp_f0_2 > 240.0f) {
            arg9 = arg9 - (temp_f0_2 - 240.0f);
        }
    }
    phi_a2 = arg9;
    phi_v1 = arg8;
    if (arg8 < arg6) {

    } else if (arg9 < phi_v0_4) {

    } else {
        sp8C = phi_ra;
        arg2 = arg2 / arg4;
        arg3 = arg3 / arg5;
        phi_s3 = phi_v0_4;
        if (phi_v0_4 < arg9) {
            argB = phi_a1;
loop_24:
            temp_t8 = phi_a3_2 + phi_s3;
            sp34 = temp_t8;
            phi_a0 = phi_a0_3;
            phi_a2_2 = phi_a2;
            phi_a0_2 = phi_a0_3;
            phi_a0_4 = phi_a0_3;
            if (phi_a2 < temp_t8) {
                temp_fp = phi_a2 - phi_s3;
                phi_fp = temp_fp;
                if (temp_fp != 0) {
                    phi_f12 = argB;
                    phi_f18 = phi_a3_2 * arg5;
                    goto block_28;
                }
            } else {
                phi_fp = phi_a3_2;
                phi_f12 = argB;
                phi_f18 = phi_a3_2 * arg5;
block_28:
                phi_a1_2 = arg6;
                if (arg6 < phi_v1) {
                    sp74 = phi_a3_2;
                    sp78 = phi_t0_3;
loop_30:
                    temp_s4 = sp78 + phi_a1_2;
                    phi_a2_2 = arg9;
                    phi_v1 = arg8;
                    phi_a0_4 = phi_a0;
                    if (arg8 < temp_s4) {
                        temp_s2 = arg8 - phi_a1_2;
                        phi_s2 = temp_s2;
                        if (temp_s2 == 0) {
                            phi_a3_2 = sp74;
                            phi_t0_3 = sp78;
                        } else {
                            temp_v0_2 = (arg1 & 7) << 0x15;
                            temp_v1 = (sp6C & 0xF) << 0xE;
                            temp_a2 = (sp70 & 0xF) * 0x10;
                            temp_f10 = phi_fp;
                            phi_t1 = temp_v0_2 | 0xFD000000 | 0x100000 | ((argD - 1) & 0xFFF);
                            phi_t2 = temp_v0_2 | 0xF5000000 | 0x100000;
                            phi_t4 = temp_v1 | 0x7000000 | temp_a2;
                            phi_a3_3 = (phi_s3 * 4) & 0xFFF;
                            phi_t0_4 = ((phi_s3 + phi_fp) * 4) & 0xFFF;
                            phi_s0 = temp_v1 | temp_a2;
                            phi_s5 = (argB * 4) & 0xFFF;
                            phi_s6 = (phi_s3 << 5) & 0xFFFF;
                            phi_s7 = (arg2 << 0x10) | (arg3 & 0xFFFF);
                            phi_f0 = phi_ra_2;
                            phi_f16 = sp78 * arg4;
                            phi_f10 = temp_f10;
                            if (phi_fp < 0) {
                                phi_f10 = temp_f10 + 4294967296.0f;
                            }
                            phi_s1 = ((argB + (phi_f10 * arg5)) * 4) & 0xFFF;
                            goto block_39;
                        }
                    } else {
                        temp_v0_3 = (arg1 & 7) << 0x15;
                        temp_v1_2 = (sp6C & 0xF) << 0xE;
                        temp_a2_2 = (sp70 & 0xF) * 0x10;
                        temp_f8 = phi_fp;
                        phi_t1 = temp_v0_3 | 0xFD000000 | 0x100000 | ((argD - 1) & 0xFFF);
                        phi_t2 = temp_v0_3 | 0xF5000000 | 0x100000;
                        phi_s2 = sp78;
                        phi_t4 = temp_v1_2 | 0x7000000 | temp_a2_2;
                        phi_a3_3 = (phi_s3 * 4) & 0xFFF;
                        phi_t0_4 = ((phi_s3 + phi_fp) * 4) & 0xFFF;
                        phi_s0 = temp_v1_2 | temp_a2_2;
                        phi_s5 = (argB * 4) & 0xFFF;
                        phi_s6 = (phi_s3 << 5) & 0xFFFF;
                        phi_s7 = (arg2 << 0x10) | (arg3 & 0xFFFF);
                        phi_f0 = phi_ra_2;
                        phi_f16 = sp78 * arg4;
                        phi_f8 = temp_f8;
                        if (phi_fp < 0) {
                            phi_f8 = temp_f8 + 4294967296.0f;
                        }
                        phi_s1 = ((argB + (phi_f8 * arg5)) * 4) & 0xFFF;
block_39:
                        phi_a0->unk0 = phi_t1;
                        temp_a2_3 = phi_a1_2 + phi_s2;
                        phi_a0->unk4 = argC;
                        temp_a0 = phi_a0 + 8;
                        temp_t3 = phi_t2 | ((((((temp_a2_3 - phi_a1_2) * 2) + 9) >> 3) & 0x1FF) << 9);
                        temp_a0_2 = temp_a0 + 8;
                        temp_t1 = ((phi_a1_2 * 4) & 0xFFF) << 0xC;
                        temp_a0->unk0 = temp_t3;
                        temp_a0->unk4 = phi_t4;
                        temp_a0_2->unk0 = 0xE6000000;
                        temp_a0_3 = temp_a0_2 + 8;
                        temp_t2 = ((temp_a2_3 * 4) & 0xFFF) << 0xC;
                        temp_a0_2->unk4 = 0;
                        temp_a0_3->unk0 = temp_t1 | 0xF4000000 | phi_a3_3;
                        temp_a0_4 = temp_a0_3 + 8;
                        temp_a0_3->unk4 = temp_t2 | 0x7000000 | phi_t0_4;
                        temp_a0_5 = temp_a0_4 + 8;
                        temp_a0_6 = temp_a0_5 + 8;
                        temp_a0_4->unk0 = 0xE7000000;
                        temp_a0_4->unk4 = 0;
                        temp_a0_7 = temp_a0_6 + 8;
                        temp_a0_5->unk4 = phi_s0;
                        temp_a0_5->unk0 = temp_t3;
                        temp_a0_6->unk4 = temp_t2 | phi_t0_4;
                        temp_a0_6->unk0 = temp_t1 | 0xF2000000 | phi_a3_3;
                        temp_a0_8 = temp_a0_7 + 8;
                        temp_a0_9 = temp_a0_8 + 8;
                        temp_a0_7->unk0 = ((((phi_ra_2 + (phi_s2 * arg4)) * 4) & 0xFFF) << 0xC) | 0xE4000000 | phi_s1;
                        temp_a0_7->unk4 = (((phi_ra_2 * 4) & 0xFFF) << 0xC) | phi_s5;
                        temp_a0_8->unk0 = 0xB3000000;
                        temp_a0_8->unk4 = (phi_a1_2 << 0x15) | phi_s6;
                        temp_a0_9->unk0 = 0xB2000000;
                        temp_a0_9->unk4 = phi_s7;
                        temp_a0_10 = temp_a0_9 + 8;
                        phi_a1_2 = temp_s4;
                        phi_a0 = temp_a0_10;
                        phi_ra_2 = phi_f0 + phi_f16;
                        phi_a0_4 = temp_a0_10;
                        if (temp_s4 >= arg8) {
                            phi_a2_2 = arg9;
                            phi_a3_2 = sp74;
                            phi_v1 = arg8;
                            phi_t0_3 = sp78;
                        } else {
                            goto loop_30;
                        }
                    }
                }
                argB = phi_f12 + phi_f18;
                phi_s3 = sp34;
                phi_a2 = phi_a2_2;
                phi_a0_2 = phi_a0_4;
                phi_a0_3 = phi_a0_4;
                phi_ra_2 = sp8C;
                if (sp34 < phi_a2_2) {
                    goto loop_24;
                }
            }
        }
    }
    return phi_a0_2;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800963F0.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 *draw_box(void *, s32, u32, u32, u32, s32, s32, s32, s32); // extern
extern ? D_0B002A00;

void *func_80096CD8(void *arg0, s32 arg1, s32 arg2, u32 arg3, u32 arg4) {
    s32 spD4;
    s32 spD0;
    s32 spCC;
    s32 spC8;
    s32 spC4;
    u32 sp84;
    u32 sp80;
    u32 sp7C;
    u32 sp78;
    s32 sp58;
    s32 *temp_v0_3;
    s32 temp_a0;
    s32 temp_a1;
    s32 temp_a2;
    s32 temp_a3;
    s32 temp_lo;
    s32 temp_s1;
    s32 temp_s4;
    s32 temp_t5;
    s32 temp_t8;
    s32 temp_t8_2;
    s32 temp_v0;
    s32 temp_v0_2;
    s32 temp_v0_4;
    s32 temp_v0_5;
    s32 temp_v1;
    s32 temp_v1_2;
    s32 temp_v1_3;
    u32 temp_s3;
    u32 temp_t2;
    u32 temp_t4;
    u32 temp_t6;
    u32 temp_t7;
    void *temp_s0;
    void *temp_s0_10;
    void *temp_s0_11;
    void *temp_s0_2;
    void *temp_s0_3;
    void *temp_s0_4;
    void *temp_s0_5;
    void *temp_s0_6;
    void *temp_s0_7;
    void *temp_s0_8;
    void *temp_s0_9;
    u32 phi_ra;
    s32 phi_ra_2;
    s32 phi_v0;
    s32 phi_s1;
    s32 phi_s1_2;
    u32 phi_a1;
    s32 phi_s4;
    u32 phi_s2;
    u32 phi_fp;
    u32 phi_s3;
    u32 phi_s4_2;
    u32 phi_t4;
    u32 phi_t4_2;
    s32 phi_ra_3;
    u32 phi_s1_3;
    s32 phi_a1_2;
    void *phi_s0;
    s32 phi_t5;
    s32 phi_t3;
    s32 phi_s4_3;
    s32 phi_s6;
    s32 phi_s2_2;
    s32 phi_s3_2;
    s32 phi_s7;
    u32 phi_s3_3;
    void *phi_s0_2;
    s32 phi_ra_4;
    void *phi_s0_3;
    void *phi_s0_4;

    spC8 = 0;
    spC4 = 0;
    phi_ra = 1;
    phi_ra_2 = 1;
    phi_s4 = arg1;
    phi_s2 = arg2;
    phi_s0_2 = arg0;
    if (arg3 >= 2) {
        do {
            temp_t7 = phi_ra * 2;
            phi_ra = temp_t7;
            phi_ra_2 = temp_t7;
        } while (temp_t7 < arg3);
    }
    temp_lo = 0x400 / phi_ra_2;
    spCC = temp_lo;
    phi_a1 = arg4;
    if (arg4 < (temp_lo / 2)) {
        phi_v0 = temp_lo / 2;
        do {
            temp_v0 = phi_v0 / 2;
            phi_v0 = temp_v0;
        } while (arg4 < temp_v0);
        spCC = phi_v0;
    }
    phi_s1 = phi_ra_2;
    if (phi_ra_2 >= 2) {
        do {
            temp_t8 = phi_s1 / 2;
            spC8 += 1;
            phi_s1 = temp_t8;
        } while (temp_t8 >= 2);
    }
    phi_s1_2 = spCC;
    if (spCC >= 2) {
        do {
            temp_t8_2 = phi_s1_2 / 2;
            spC4 += 1;
            phi_s1_2 = temp_t8_2;
        } while (temp_t8_2 >= 2);
    }
    if (arg1 < 0) {
        arg3 -= arg1;
        phi_s4 = 0;
    } else if ((arg1 + arg3) >= 0x141) {
        arg3 = 0x140 - arg1;
    }
    phi_s4_2 = phi_s4;
    if (arg2 < 0) {
        phi_a1 = arg4 - arg2;
        phi_s2 = 0;
    } else if ((arg2 + arg4) >= 0xF1) {
        phi_a1 = 0xF0 - arg2;
    }
    if (arg3 == 0) {

    } else if (phi_a1 == 0) {

    } else {
        spD0 = phi_ra_2;
        temp_s3 = phi_s2 + phi_a1;
        temp_t4 = phi_s4 + arg3;
        sp84 = temp_t4;
        temp_v0_2 = random_int(0x64);
        temp_s1 = temp_v0_2;
        temp_v0_3 = draw_box(arg0, phi_s4, phi_s2, sp84, temp_s3, 0, 0, 0, temp_v0_2);
        temp_v1 = (temp_s1 + 0x96) & 0xFF;
        temp_v0_3->unk0 = 0xE7000000;
        temp_v0_3->unk8 = 0xB900031D;
        temp_v0_3->unkC = 0x504240;
        temp_v0_3->unk10 = 0xFA000000;
        temp_v0_3->unk4 = 0;
        temp_v0_3->unk14 = (temp_v1 << 0x18) | (temp_v1 << 0x10) | (temp_v1 << 8) | temp_v1;
        temp_v0_3->unk1C = 0xFF2FFFFF;
        temp_v0_3->unk18 = 0xFC119623;
        temp_s0 = temp_v0_3 + 0x20;
        phi_fp = phi_s2;
        phi_s3 = temp_s3;
        phi_t4 = temp_t4;
        phi_s0_2 = temp_s0;
        phi_ra_4 = phi_ra_2;
        phi_s0_3 = temp_s0;
        if (phi_s2 < temp_s3) {
loop_23:
            temp_t6 = spCC + phi_fp;
            sp7C = temp_t6;
            phi_t4_2 = phi_t4;
            phi_ra_3 = phi_ra_4;
            phi_s0 = phi_s0_3;
            phi_s3_3 = phi_s3;
            phi_s0_2 = phi_s0_3;
            phi_t5 = spCC;
            phi_s0_4 = phi_s0_3;
            if (phi_s3 < temp_t6) {
                temp_t5 = phi_s3 - phi_fp;
                phi_t5 = temp_t5;
                if (temp_t5 != 0) {
                    goto block_26;
                }
            } else {
block_26:
                phi_s1_3 = phi_s4_2;
                if (phi_s4_2 < phi_t4) {
                    sp80 = phi_s3;
                    arg1 = phi_s4_2;
loop_28:
                    temp_t2 = phi_ra_3 + phi_s1_3;
                    phi_t4 = phi_t4_2;
                    phi_s0_4 = phi_s0;
                    phi_ra_4 = phi_ra_3;
                    if (phi_t4_2 < temp_t2) {
                        temp_s4 = phi_t4_2 - phi_s1_3;
                        phi_s4_3 = temp_s4;
                        if (temp_s4 == 0) {
                            phi_s3_3 = sp80;
                            phi_s4_2 = arg1;
                        } else {
                            temp_v0_4 = (spC4 & 0xF) << 0xE;
                            temp_v1_2 = (spC8 & 0xF) * 0x10;
                            phi_a1_2 = ((arg3 - 1) & 0xFFF) | 0xFD700000;
                            phi_t3 = (phi_fp << 5) & 0xFFFF;
                            phi_s6 = temp_v0_4 | 0x7000000 | temp_v1_2;
                            phi_s2_2 = (phi_fp * 4) & 0xFFF;
                            phi_s3_2 = ((phi_fp + phi_t5) * 4) & 0xFFF;
                            phi_s7 = temp_v0_4 | temp_v1_2;
                            goto block_33;
                        }
                    } else {
                        temp_v0_5 = (spC4 & 0xF) << 0xE;
                        temp_v1_3 = (spC8 & 0xF) * 0x10;
                        phi_a1_2 = ((arg3 - 1) & 0xFFF) | 0xFD700000;
                        phi_t3 = (phi_fp << 5) & 0xFFFF;
                        phi_s4_3 = phi_ra_3;
                        phi_s6 = temp_v0_5 | 0x7000000 | temp_v1_3;
                        phi_s2_2 = (phi_fp * 4) & 0xFFF;
                        phi_s3_2 = ((phi_fp + phi_t5) * 4) & 0xFFF;
                        phi_s7 = temp_v0_5 | temp_v1_3;
block_33:
                        phi_s0->unk0 = phi_a1_2;
                        spD0 = phi_ra_3;
                        spD4 = phi_t5;
                        sp84 = phi_t4_2;
                        sp58 = phi_t3;
                        sp78 = temp_t2;
                        temp_s0_2 = phi_s0 + 8;
                        temp_a2 = phi_s1_3 + phi_s4_3;
                        phi_s0->unk4 = (random_int(0x80) * 2) + &D_0B002A00;
                        temp_s0_3 = temp_s0_2 + 8;
                        temp_a3 = ((((((temp_a2 - phi_s1_3) * 2) + 9) >> 3) & 0x1FF) << 9) | 0xF5700000;
                        temp_s0_2->unk0 = temp_a3;
                        temp_s0_2->unk4 = phi_s6;
                        temp_s0_3->unk0 = 0xE6000000;
                        temp_a1 = ((phi_s1_3 * 4) & 0xFFF) << 0xC;
                        temp_s0_3->unk4 = 0;
                        temp_s0_4 = temp_s0_3 + 8;
                        temp_a0 = ((temp_a2 * 4) & 0xFFF) << 0xC;
                        temp_s0_4->unk0 = temp_a1 | 0xF4000000 | phi_s2_2;
                        temp_s0_5 = temp_s0_4 + 8;
                        temp_s0_4->unk4 = temp_a0 | 0x7000000 | phi_s3_2;
                        temp_s0_6 = temp_s0_5 + 8;
                        temp_s0_5->unk0 = 0xE7000000;
                        temp_s0_5->unk4 = 0;
                        temp_s0_7 = temp_s0_6 + 8;
                        temp_s0_6->unk4 = phi_s7;
                        temp_s0_6->unk0 = temp_a3;
                        temp_s0_8 = temp_s0_7 + 8;
                        temp_s0_7->unk4 = temp_a0 | phi_s3_2;
                        temp_s0_7->unk0 = temp_a1 | 0xF2000000 | phi_s2_2;
                        temp_s0_9 = temp_s0_8 + 8;
                        temp_s0_8->unk4 = temp_a1 | phi_s2_2;
                        temp_s0_8->unk0 = temp_a0 | 0xE4000000 | phi_s3_2;
                        temp_s0_9->unk0 = 0xB3000000;
                        temp_s0_10 = temp_s0_9 + 8;
                        temp_s0_9->unk4 = (phi_s1_3 << 0x15) | phi_t3;
                        temp_s0_10->unk0 = 0xB2000000;
                        temp_s0_10->unk4 = 0x4000400;
                        temp_s0_11 = temp_s0_10 + 8;
                        phi_s1_3 = temp_t2;
                        phi_s0 = temp_s0_11;
                        phi_t4 = phi_t4_2;
                        phi_s0_4 = temp_s0_11;
                        phi_ra_4 = phi_ra_3;
                        if (temp_t2 >= phi_t4_2) {
                            phi_s3_3 = sp80;
                            phi_s4_2 = arg1;
                        } else {
                            goto loop_28;
                        }
                    }
                }
                phi_fp = sp7C;
                phi_s3 = phi_s3_3;
                phi_s0_2 = phi_s0_4;
                phi_s0_3 = phi_s0_4;
                if (sp7C < phi_s3_3) {
                    goto loop_23;
                }
            }
        }
    }
    return phi_s0_2;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_80096CD8.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern ? D_000FFF00;
extern ? D_0B002A00;
extern s32 gGlobalTimer;

void *func_80097274(void *arg0, s8 arg1, s32 arg2, s32 arg3, s32 arg4, s32 arg5, s32 arg6, s32 arg7, s32 arg8, s32 arg9, s32 argA, u32 argB, u32 argC) {
    s32 sp108;
    s32 sp104;
    s32 sp100;
    s32 spFC;
    s32 spF8;
    s32 spF4;
    s32 spF0;
    s32 spEC;
    u32 sp84;
    u32 sp80;
    s32 sp68;
    s32 sp50;
    s32 sp4C;
    s32 sp48;
    s32 sp44;
    s32 sp40;
    s32 temp_a0_2;
    s32 temp_a0_3;
    s32 temp_a0_4;
    s32 temp_a1;
    s32 temp_a3;
    s32 temp_lo;
    s32 temp_s1;
    s32 temp_s2;
    s32 temp_s5;
    s32 temp_s6;
    s32 temp_s7;
    s32 temp_t3;
    s32 temp_t3_2;
    s32 temp_t4;
    s32 temp_t6;
    s32 temp_t6_2;
    s32 temp_t7;
    s32 temp_t8;
    s32 temp_v0;
    s32 temp_v0_2;
    s32 temp_v0_3;
    s32 temp_v0_4;
    s32 temp_v1;
    s32 temp_v1_2;
    u32 temp_t6_3;
    u32 temp_t9;
    u32 temp_t9_2;
    void *temp_a0;
    void *temp_s0;
    void *temp_s0_10;
    void *temp_s0_11;
    void *temp_s0_12;
    void *temp_s0_13;
    void *temp_s0_14;
    void *temp_s0_15;
    void *temp_s0_16;
    void *temp_s0_17;
    void *temp_s0_18;
    void *temp_s0_19;
    void *temp_s0_20;
    void *temp_s0_21;
    void *temp_s0_22;
    void *temp_s0_2;
    void *temp_s0_3;
    void *temp_s0_4;
    void *temp_s0_5;
    void *temp_s0_6;
    void *temp_s0_7;
    void *temp_s0_8;
    void *temp_s0_9;
    u32 phi_t0;
    s32 phi_t0_2;
    s32 phi_v0;
    s32 phi_v0_2;
    s32 phi_v0_3;
    s32 phi_v0_4;
    s32 phi_a0;
    s32 phi_t3;
    s32 phi_t4;
    s32 phi_t5;
    u32 phi_v1;
    s32 phi_s4;
    s32 phi_t5_2;
    s32 phi_a1;
    void *phi_s0;
    s32 phi_a3;
    s32 phi_t3_2;
    s32 phi_t4_2;
    s32 phi_a2;
    s32 phi_s3;
    s32 phi_t2;
    s32 phi_ra;
    void *phi_s0_2;
    s32 phi_t3_3;
    s32 phi_t4_3;
    void *phi_s0_3;
    void *phi_s0_4;

    temp_s0_2 = arg0 + 8;
    arg0->unk0 = 0xE7000000;
    arg0->unk4 = 0;
    temp_s0_3 = temp_s0_2 + 8;
    temp_s0_2->unk0 = 0xBA001402;
    temp_s0_2->unk4 = &D_000FFF00;
    temp_s0_4 = temp_s0_3 + 8;
    temp_s0_3->unk0 = 0xBA001001;
    temp_s0_3->unk4 = 0;
    temp_s0_4->unk0 = 0xFA000000;
    temp_t7 = gGlobalTimer;
    temp_s0_5 = temp_s0_4 + 8;
    phi_t0 = 1;
    phi_t0_2 = 1;
    phi_t3 = 0;
    phi_t4 = 0;
    phi_t3_3 = 0;
    phi_t4_3 = 0;
    if ((temp_t7 < 0) && ((temp_t7 & 0xFF) != 0)) {

    }
    temp_s0_4->unk4 = temp_t7 & 0xFF & 0xFF;
    temp_s0_5->unk4 = 0x1FFC9238;
    temp_s0_5->unk0 = 0xFC2527FF;
    temp_s0 = temp_s0_5 + 8;
    phi_s0_2 = temp_s0;
    phi_s0_3 = temp_s0;
    if (argB >= 2) {
        do {
            temp_t9 = phi_t0 * 2;
            phi_t0 = temp_t9;
            phi_t0_2 = temp_t9;
        } while (temp_t9 < argB);
    }
    temp_lo = 0x400 / phi_t0_2;
    spF4 = temp_lo;
    if (argC < (temp_lo / 2)) {
        phi_v0 = temp_lo / 2;
        do {
            temp_v0 = phi_v0 / 2;
            phi_v0 = temp_v0;
        } while (argC < temp_v0);
        spF4 = phi_v0;
    }
    phi_v0_2 = phi_t0_2;
    if (phi_t0_2 >= 2) {
        do {
            temp_t6 = phi_v0_2 / 2;
            temp_t3 = phi_t3_3 + 1;
            phi_v0_2 = temp_t6;
            phi_t3 = temp_t3;
            phi_t3_3 = temp_t3;
        } while (temp_t6 >= 2);
    }
    phi_v0_3 = spF4;
    phi_a0 = arg8;
    if (spF4 >= 2) {
        do {
            temp_t8 = phi_v0_3 / 2;
            temp_t4 = phi_t4_3 + 1;
            phi_v0_3 = temp_t8;
            phi_t4 = temp_t4;
            phi_t4_3 = temp_t4;
        } while (temp_t8 >= 2);
    }
    if (arg8 < 0) {
        arg4 -= arg8;
        phi_a0 = 0;
    } else if (((arg6 - arg4) + arg8) >= 0x141) {
        arg6 = (arg4 - arg8) + 0x140;
    }
    temp_t6_2 = arg9;
    phi_v0_4 = arg5;
    phi_v1 = arg6;
    if (temp_t6_2 < 0) {
        arg9 = 0;
        phi_v0_4 = arg5 - temp_t6_2;
    } else if (((arg7 - arg5) + arg9) >= 0xF1) {
        arg7 = (arg5 - arg9) + 0xF0;
    }
    if (arg6 < arg4) {
        return temp_s0;
    }
    if (arg7 < phi_v0_4) {
        return temp_s0;
    }
    sp104 = phi_a0;
    phi_t5 = phi_v0_4;
    if (phi_v0_4 < arg7) {
        arg8 = phi_a0;
        spF8 = phi_t0_2;
        spF0 = phi_t3;
        spEC = phi_t4;
loop_27:
        temp_t6_3 = spF4 + phi_t5;
        sp84 = temp_t6_3;
        phi_t5_2 = phi_t5;
        phi_s0 = phi_s0_3;
        phi_s0_2 = phi_s0_3;
        phi_s0_4 = phi_s0_3;
        if (arg7 < temp_t6_3) {
            temp_v0_2 = arg7 - phi_t5;
            spFC = temp_v0_2;
            if (temp_v0_2 != 0) {
                goto block_31;
            }
        } else {
            spFC = spF4;
block_31:
            phi_s4 = arg4;
            if (arg4 < phi_v1) {
                arg6 = phi_v1;
loop_33:
                temp_t9_2 = spF8 + phi_s4;
                sp80 = temp_t9_2;
                phi_v1 = arg6;
                phi_s0_4 = phi_s0;
                if (arg6 < temp_t9_2) {
                    temp_t3_2 = arg6 - phi_s4;
                    phi_t3_2 = temp_t3_2;
                    if (temp_t3_2 != 0) {
                        arg6 = arg6;
                        temp_a0_2 = (arg1 & 7) << 0x15;
                        temp_v0_3 = (spEC & 0xF) << 0xE;
                        temp_v1 = (spF0 & 0xF) * 0x10;
                        sp4C = ((arg9 + spFC) * 4) & 0xFFF;
                        sp44 = (phi_t5_2 << 5) & 0xFFFF;
                        sp48 = (arg9 * 4) & 0xFFF;
                        sp40 = (arg2 << 0x10) | (arg3 & 0xFFFF);
                        phi_a1 = temp_a0_2 | 0xFD000000 | 0x100000 | ((argB - 1) & 0xFFF);
                        phi_a3 = temp_a0_2 | 0xF5000000 | 0x100000;
                        phi_t4_2 = temp_v0_3 | 0x7000000 | temp_v1;
                        phi_a2 = (phi_t5_2 * 4) & 0xFFF;
                        phi_s3 = ((phi_t5_2 + spFC) * 4) & 0xFFF;
                        phi_t2 = temp_v0_3 | temp_v1;
                        phi_ra = temp_v0_3 | 0x1000000 | temp_v1;
                        goto block_37;
                    }
                } else {
                    temp_a0_3 = (arg1 & 7) << 0x15;
                    temp_v0_4 = (spEC & 0xF) << 0xE;
                    temp_v1_2 = (spF0 & 0xF) * 0x10;
                    sp4C = ((arg9 + spFC) * 4) & 0xFFF;
                    sp44 = (phi_t5_2 << 5) & 0xFFFF;
                    sp48 = (arg9 * 4) & 0xFFF;
                    sp40 = (arg2 << 0x10) | (arg3 & 0xFFFF);
                    phi_a1 = temp_a0_3 | 0xFD000000 | 0x100000 | ((argB - 1) & 0xFFF);
                    phi_a3 = temp_a0_3 | 0xF5000000 | 0x100000;
                    phi_t3_2 = spF8;
                    phi_t4_2 = temp_v0_4 | 0x7000000 | temp_v1_2;
                    phi_a2 = (phi_t5_2 * 4) & 0xFFF;
                    phi_s3 = ((phi_t5_2 + spFC) * 4) & 0xFFF;
                    phi_t2 = temp_v0_4 | temp_v1_2;
                    phi_ra = temp_v0_4 | 0x1000000 | temp_v1_2;
block_37:
                    phi_s0->unk0 = phi_a1;
                    temp_a0_4 = phi_s4 + phi_t3_2;
                    phi_s0->unk4 = argA;
                    temp_s0_6 = phi_s0 + 8;
                    temp_s1 = phi_a3 | ((((((temp_a0_4 - phi_s4) * 2) + 9) >> 3) & 0x1FF) << 9);
                    temp_s0_7 = temp_s0_6 + 8;
                    temp_s0_6->unk0 = temp_s1;
                    temp_s0_6->unk4 = phi_t4_2;
                    temp_s0_7->unk0 = 0xE6000000;
                    temp_a3 = ((phi_s4 * 4) & 0xFFF) << 0xC;
                    temp_s0_8 = temp_s0_7 + 8;
                    temp_s2 = ((temp_a0_4 * 4) & 0xFFF) << 0xC;
                    temp_s0_7->unk4 = 0;
                    temp_s6 = temp_s2 | 0x7000000 | phi_s3;
                    temp_s0_9 = temp_s0_8 + 8;
                    temp_s5 = temp_a3 | 0xF4000000 | phi_a2;
                    temp_s0_8->unk0 = temp_s5;
                    temp_s0_8->unk4 = temp_s6;
                    temp_s0_10 = temp_s0_9 + 8;
                    temp_s0_9->unk0 = 0xE7000000;
                    temp_s0_11 = temp_s0_10 + 8;
                    temp_s0_9->unk4 = 0;
                    temp_s0_10->unk4 = phi_t2;
                    temp_s0_10->unk0 = temp_s1;
                    temp_s7 = temp_a3 | 0xF2000000 | phi_a2;
                    temp_s0_12 = temp_s0_11 + 8;
                    temp_s0_11->unk4 = temp_s2 | phi_s3;
                    temp_s0_11->unk0 = temp_s7;
                    temp_s0_12->unk0 = phi_a1;
                    sp50 = phi_ra;
                    sp108 = phi_t5_2;
                    sp68 = phi_t4_2;
                    sp100 = phi_t3_2;
                    temp_s0_13 = temp_s0_12 + 8;
                    temp_s0_12->unk4 = (random_int(0x80) * 2) + &D_0B002A00;
                    temp_s0_14 = temp_s0_13 + 8;
                    temp_a1 = temp_s1 | 0x100;
                    temp_s0_13->unk0 = temp_a1;
                    temp_s0_13->unk4 = phi_t4_2;
                    temp_s0_15 = temp_s0_14 + 8;
                    temp_s0_14->unk0 = 0xE6000000;
                    temp_s0_16 = temp_s0_15 + 8;
                    temp_s0_14->unk4 = 0;
                    temp_s0_15->unk4 = temp_s6;
                    temp_s0_15->unk0 = temp_s5;
                    temp_s0_17 = temp_s0_16 + 8;
                    temp_s0_16->unk0 = 0xE7000000;
                    temp_s0_16->unk4 = 0;
                    temp_s0_17->unk0 = temp_a1;
                    temp_s0_17->unk4 = phi_ra;
                    temp_s0_18 = temp_s0_17 + 8;
                    temp_s0_18->unk4 = temp_s2 | 0x1000000 | phi_s3;
                    temp_s0_18->unk0 = temp_s7;
                    temp_s0_19 = temp_s0_18 + 8;
                    temp_s0_19->unk0 = ((((arg8 + phi_t3_2) * 4) & 0xFFF) << 0xC) | 0xE4000000 | sp4C;
                    temp_s0_20 = temp_s0_19 + 8;
                    temp_s0_19->unk4 = (((arg8 * 4) & 0xFFF) << 0xC) | sp48;
                    temp_s0_20->unk0 = 0xB3000000;
                    temp_s0_21 = temp_s0_20 + 8;
                    temp_s0_20->unk4 = (phi_s4 << 0x15) | sp44;
                    temp_s0_21->unk0 = 0xB2000000;
                    temp_s0_22 = temp_s0_21 + 8;
                    temp_s0_21->unk4 = sp40;
                    arg8 += spF8;
                    phi_s4 = sp80;
                    phi_s0 = temp_s0_22;
                    phi_s0_4 = temp_s0_22;
                    if (sp80 >= arg6) {
                        phi_v1 = arg6;
                    } else {
                        goto loop_33;
                    }
                }
            }
            arg8 = sp104;
            arg9 += spF4;
            phi_t5 = sp84;
            phi_s0_2 = phi_s0_4;
            phi_s0_3 = phi_s0_4;
            if (sp84 < arg7) {
                goto loop_27;
            }
        }
    }
    temp_a0 = phi_s0_2 + 8;
    phi_s0_2->unk0 = 0xE7000000;
    phi_s0_2->unk4 = 0;
    temp_a0->unk0 = 0xBA001402;
    temp_a0->unk4 = 0;
    return temp_a0 + 8;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_80097274.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 *func_80095E10(void *, s8, ?, ?, s32, s32, s32, s32, s32, s32, s32, s32, s32); // extern

void *func_80097A14(void *arg0, s8 arg1, s32 arg2, s32 arg3, s32 arg4, s32 arg5, s32 arg6, s32 arg7, s32 arg8, s32 arg9, s32 argA) {
    s32 *temp_v0;
    void *temp_a0;

    temp_a0 = arg0 + 8;
    arg0->unk0 = 0xE7000000;
    arg0->unk4 = 0;
    temp_a0->unk4 = 0x200000;
    temp_a0->unk0 = 0xBA001402;
    temp_v0 = func_80095E10(temp_a0 + 8, arg1, 0x1000, 0x400, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, argA);
    temp_v0->unk0 = 0xE7000000;
    temp_v0->unk4 = 0;
    temp_v0->unk8 = 0xBA001402;
    temp_v0->unkC = 0;
    return temp_v0 + 0x10;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_80097A14.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void *func_80097AE4(void *arg0, s8 arg1, s32 arg2, s32 arg3, s32 arg4, s32 arg5) {
    s32 sp34;
    s32 temp_s1;
    s32 temp_s4;
    s32 temp_t1;
    s32 temp_t6;
    s32 temp_t7;
    s32 temp_t7_2;
    s32 temp_t8;
    s32 temp_t8_2;
    s32 temp_t8_3;
    s32 temp_t9;
    s32 temp_v1;
    void *temp_a0;
    void *temp_a0_10;
    void *temp_a0_11;
    void *temp_a0_12;
    void *temp_a0_13;
    void *temp_a0_14;
    void *temp_a0_15;
    void *temp_a0_16;
    void *temp_a0_17;
    void *temp_a0_18;
    void *temp_a0_19;
    void *temp_a0_20;
    void *temp_a0_2;
    void *temp_a0_3;
    void *temp_a0_4;
    void *temp_a0_5;
    void *temp_a0_6;
    void *temp_a0_7;
    void *temp_a0_8;
    void *temp_a0_9;
    void *phi_a0;
    s32 phi_a2;
    s32 phi_s0;
    s32 phi_s2;
    void *phi_a0_2;

    phi_a0 = arg0;
    phi_s0 = arg2;
    phi_s2 = arg3;
    phi_a0_2 = arg0;
    if (arg5 >= 0x20) {

    } else {
        temp_t8 = (arg1 & 7) << 0x15;
        temp_s4 = temp_t8 | 0xFD000000 | 0x100000 | 0x3F;
        temp_t8_2 = temp_t8 | 0xF5000000 | 0x100000 | 0x1200;
        sp34 = arg2;
        temp_t7 = (((0x8000 / (0x20 - arg5)) & 0xFFFF) << 0x10) | 0x400;
        phi_a2 = 0;
        do {
            temp_a0 = phi_a0 + 8;
            phi_a0->unk0 = temp_s4;
            phi_a0->unk4 = arg4;
            temp_a0_2 = temp_a0 + 8;
            temp_t6 = (phi_a2 * 4) & 0xFFF;
            temp_a0_3 = temp_a0_2 + 8;
            temp_a0->unk4 = 0x7014050;
            temp_a0->unk0 = temp_t8_2;
            temp_s1 = phi_a2 + 0x20;
            temp_t9 = (temp_s1 * 4) & 0xFFF;
            temp_a0_2->unk4 = 0;
            temp_a0_2->unk0 = 0xE6000000;
            temp_a0_4 = temp_a0_3 + 8;
            temp_a0_3->unk4 = temp_t9 | 0x7080000;
            temp_a0_3->unk0 = temp_t6 | 0xF4000000;
            temp_a0_5 = temp_a0_4 + 8;
            temp_a0_4->unk4 = 0;
            temp_a0_4->unk0 = 0xE7000000;
            temp_a0_5->unk4 = 0x14050;
            temp_a0_5->unk0 = temp_t8_2;
            temp_a0_6 = temp_a0_5 + 8;
            temp_v1 = phi_s0 + 0x20;
            temp_t1 = phi_s2 + 0x20;
            temp_a0_6->unk0 = temp_t6 | 0xF2000000;
            temp_a0_6->unk4 = temp_t9 | 0x80000;
            temp_t7_2 = (temp_t1 * 4) & 0xFFF;
            temp_a0_7 = temp_a0_6 + 8;
            temp_t8_3 = (phi_s2 * 4) & 0xFFF;
            temp_a0_7->unk0 = (((temp_v1 * 4) & 0xFFF) << 0xC) | 0xE4000000 | temp_t7_2;
            temp_a0_8 = temp_a0_7 + 8;
            temp_a0_7->unk4 = ((((phi_s0 + arg5) * 4) & 0xFFF) << 0xC) | temp_t8_3;
            temp_a0_9 = temp_a0_8 + 8;
            temp_a0_8->unk0 = 0xB3000000;
            temp_a0_10 = temp_a0_9 + 8;
            temp_a0_8->unk4 = 0;
            temp_a0_9->unk0 = 0xB2000000;
            temp_a0_9->unk4 = temp_t7;
            temp_a0_11 = temp_a0_10 + 8;
            temp_a0_10->unk4 = arg4;
            temp_a0_10->unk0 = temp_s4;
            temp_a0_12 = temp_a0_11 + 8;
            temp_a0_11->unk4 = 0x7014050;
            temp_a0_11->unk0 = temp_t8_2;
            temp_a0_13 = temp_a0_12 + 8;
            temp_a0_12->unk4 = 0;
            temp_a0_12->unk0 = 0xE6000000;
            temp_a0_14 = temp_a0_13 + 8;
            temp_a0_13->unk4 = temp_t9 | 0x7100000;
            temp_a0_13->unk0 = temp_t6 | 0xF4080000;
            temp_a0_15 = temp_a0_14 + 8;
            temp_a0_14->unk4 = 0;
            temp_a0_14->unk0 = 0xE7000000;
            temp_a0_15->unk4 = 0x14050;
            temp_a0_16 = temp_a0_15 + 8;
            temp_a0_15->unk0 = temp_t8_2;
            temp_a0_16->unk0 = temp_t6 | 0xF2080000;
            temp_a0_16->unk4 = temp_t9 | 0x100000;
            temp_a0_17 = temp_a0_16 + 8;
            temp_a0_17->unk0 = (((((temp_v1 - arg5) + 0x20) * 4) & 0xFFF) << 0xC) | 0xE4000000 | temp_t7_2;
            temp_a0_18 = temp_a0_17 + 8;
            temp_a0_17->unk4 = (((temp_v1 * 4) & 0xFFF) << 0xC) | temp_t8_3;
            temp_a0_19 = temp_a0_18 + 8;
            temp_a0_18->unk0 = 0xB3000000;
            temp_a0_18->unk4 = 0;
            temp_a0_19->unk0 = 0xB2000000;
            temp_a0_19->unk4 = temp_t7;
            temp_a0_20 = temp_a0_19 + 8;
            phi_a0 = temp_a0_20;
            phi_a2 = temp_s1;
            phi_s0 = sp34;
            phi_s2 = temp_t1;
            phi_a0_2 = temp_a0_20;
        } while (temp_s1 != 0x40);
    }
    return phi_a0_2;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_80097AE4.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void *func_80097E58(void *arg0, s8 arg1, ? arg2, u32 arg3, u32 arg5, s32 arg6, s32 arg7, s32 arg8, u32 arg9, s32 argB) {
    s32 spEC;
    s32 spDC;
    s32 sp80;
    s32 sp60;
    s32 sp5C;
    s32 sp40;
    s32 sp3C;
    s32 sp30;
    s32 temp_a1;
    s32 temp_a3;
    s32 temp_s0;
    s32 temp_t1;
    s32 temp_t2;
    s32 temp_t6;
    s32 temp_t6_2;
    s32 temp_t6_3;
    s32 temp_t7;
    s32 temp_t7_2;
    s32 temp_t7_3;
    s32 temp_t7_4;
    s32 temp_t8;
    s32 temp_t9;
    s32 temp_t9_2;
    s32 temp_v0;
    s32 temp_v1;
    s32 temp_v1_2;
    u32 temp_t0;
    u32 temp_t4;
    void *temp_a0;
    void *temp_a0_10;
    void *temp_a0_11;
    void *temp_a0_12;
    void *temp_a0_13;
    void *temp_a0_14;
    void *temp_a0_15;
    void *temp_a0_16;
    void *temp_a0_17;
    void *temp_a0_18;
    void *temp_a0_19;
    void *temp_a0_20;
    void *temp_a0_2;
    void *temp_a0_3;
    void *temp_a0_4;
    void *temp_a0_5;
    void *temp_a0_6;
    void *temp_a0_7;
    void *temp_a0_8;
    void *temp_a0_9;
    u32 phi_t4;
    s32 phi_s3;
    void *phi_a0;
    s32 phi_t2;
    s32 phi_s0;
    s32 phi_s2;
    s32 phi_v0;
    s32 phi_s4;
    s32 phi_s1;
    s32 phi_ra;
    s32 phi_s7;
    s32 phi_fp;
    s32 phi_s6;
    s32 phi_t3;
    s32 phi_s5;
    void *phi_a0_2;

    phi_a0 = arg0;
    phi_a0_2 = arg0;
    if (argB >= 0x20) {

    } else {
        temp_t0 = arg9 >> 1;
        temp_t7 = arg9 - temp_t0;
        sp80 = temp_t7;
        spDC = temp_t7;
        spEC = arg6;
        phi_t4 = arg3;
        phi_s4 = arg6;
        if (arg3 < arg5) {
loop_3:
            phi_a0_2 = phi_a0;
            if (arg5 < (phi_t4 + 0x20)) {
                temp_v0 = arg5 - phi_t4;
                phi_s2 = temp_v0;
                if (temp_v0 != 0) {
                    temp_t9 = (arg1 & 7) << 0x15;
                    temp_v1 = 0x20 - argB;
                    sp30 = argB;
                    temp_t6 = temp_t9 | 0xF5000000 | 0x100000;
                    sp60 = temp_t0 << 0x15;
                    temp_t6_2 = ((temp_t0 * 4) & 0xFFF) << 0xC;
                    sp5C = ((((sp80 << 5) << 0xA) / (sp80 * temp_v1)) << 0x10) | 0x400;
                    temp_t7_2 = ((arg9 * 4) & 0xFFF) << 0xC;
                    sp40 = temp_t6_2 | 0xF4000000;
                    sp3C = ((((temp_t0 << 5) << 0xA) / (temp_t0 * temp_v1)) << 0x10) | 0x400;
                    phi_s3 = temp_t9 | 0xFD000000 | 0x100000 | ((arg9 - 1) & 0xFFF);
                    phi_t2 = temp_t6 | (((((temp_t0 * 2) + 9) >> 3) & 0x1FF) << 9);
                    phi_s0 = temp_t6_2 | 0x7000000;
                    phi_v0 = temp_t6_2;
                    phi_s1 = (temp_t0 * argB) / 0x20;
                    phi_ra = temp_t6 | ((((((arg9 - temp_t0) * 2) + 9) >> 3) & 0x1FF) << 9);
                    phi_s7 = temp_t7_2 | 0x7000000;
                    phi_fp = temp_t6 | ((((((arg9 - temp_t0) * 2) + 9) >> 3) & 0x1FF) << 9);
                    phi_s6 = temp_t6_2 | 0xF2000000;
                    phi_t3 = temp_t7_2;
                    phi_s5 = (spDC * temp_v1) / 0x20;
                    goto block_7;
                }
            } else {
                temp_v1_2 = 0x20 - argB;
                temp_t8 = (arg1 & 7) << 0x15;
                sp30 = argB;
                temp_t7_3 = temp_t8 | 0xF5000000 | 0x100000;
                sp60 = temp_t0 << 0x15;
                temp_t7_4 = ((temp_t0 * 4) & 0xFFF) << 0xC;
                sp5C = ((((sp80 << 5) << 0xA) / (sp80 * temp_v1_2)) << 0x10) | 0x400;
                temp_t6_3 = ((arg9 * 4) & 0xFFF) << 0xC;
                sp40 = temp_t7_4 | 0xF4000000;
                sp3C = ((((temp_t0 << 5) << 0xA) / (temp_t0 * temp_v1_2)) << 0x10) | 0x400;
                phi_s3 = temp_t8 | 0xFD000000 | 0x100000 | ((arg9 - 1) & 0xFFF);
                phi_t2 = temp_t7_3 | (((((temp_t0 * 2) + 9) >> 3) & 0x1FF) << 9);
                phi_s0 = temp_t7_4 | 0x7000000;
                phi_s2 = 0x20;
                phi_v0 = temp_t7_4;
                phi_s1 = (temp_t0 * argB) / 0x20;
                phi_ra = temp_t7_3 | ((((((arg9 - temp_t0) * 2) + 9) >> 3) & 0x1FF) << 9);
                phi_s7 = temp_t6_3 | 0x7000000;
                phi_fp = temp_t7_3 | ((((((arg9 - temp_t0) * 2) + 9) >> 3) & 0x1FF) << 9);
                phi_s6 = temp_t7_4 | 0xF2000000;
                phi_t3 = temp_t6_3;
                phi_s5 = (spDC * temp_v1_2) / 0x20;
block_7:
                phi_a0->unk0 = phi_s3;
                temp_a0 = phi_a0 + 8;
                phi_a0->unk4 = arg8;
                temp_a0->unk4 = 0x7014050;
                temp_a0_2 = temp_a0 + 8;
                temp_a0->unk0 = phi_t2;
                temp_t9_2 = (phi_t4 * 4) & 0xFFF;
                temp_a0_3 = temp_a0_2 + 8;
                temp_a0_2->unk0 = 0xE6000000;
                temp_a3 = ((phi_t4 + phi_s2) * 4) & 0xFFF;
                temp_a0_2->unk4 = 0;
                temp_a0_3->unk0 = temp_t9_2 | 0xF4000000;
                temp_a0_4 = temp_a0_3 + 8;
                temp_a0_3->unk4 = phi_s0 | temp_a3;
                temp_a0_5 = temp_a0_4 + 8;
                temp_a0_4->unk0 = 0xE7000000;
                temp_a0_4->unk4 = 0;
                temp_a0_6 = temp_a0_5 + 8;
                temp_a0_5->unk4 = 0x14050;
                temp_a0_5->unk0 = phi_t2;
                temp_a0_6->unk4 = phi_v0 | temp_a3;
                temp_a0_6->unk0 = temp_t9_2 | 0xF2000000;
                temp_s0 = phi_s4 + temp_t0;
                temp_t1 = ((arg7 + phi_s2) * 4) & 0xFFF;
                temp_a0_7 = temp_a0_6 + 8;
                temp_a0_7->unk0 = (((temp_s0 * 4) & 0xFFF) << 0xC) | 0xE4000000 | temp_t1;
                temp_t2 = (arg7 * 4) & 0xFFF;
                temp_a0_7->unk4 = ((((phi_s1 + phi_s4) * 4) & 0xFFF) << 0xC) | temp_t2;
                temp_a0_8 = temp_a0_7 + 8;
                temp_a1 = (phi_t4 << 5) & 0xFFFF;
                temp_a0_9 = temp_a0_8 + 8;
                temp_a0_8->unk0 = 0xB3000000;
                temp_a0_8->unk4 = temp_a1;
                temp_a0_9->unk0 = 0xB2000000;
                temp_a0_10 = temp_a0_9 + 8;
                temp_a0_9->unk4 = sp3C;
                temp_a0_10->unk0 = phi_s3;
                temp_a0_11 = temp_a0_10 + 8;
                temp_a0_10->unk4 = arg8;
                temp_a0_12 = temp_a0_11 + 8;
                temp_a0_11->unk4 = 0x7014050;
                temp_a0_11->unk0 = phi_ra;
                temp_a0_12->unk0 = 0xE6000000;
                temp_a0_12->unk4 = 0;
                temp_a0_13 = temp_a0_12 + 8;
                temp_a0_14 = temp_a0_13 + 8;
                temp_a0_13->unk0 = sp40 | temp_t9_2;
                temp_a0_13->unk4 = phi_s7 | temp_a3;
                temp_a0_15 = temp_a0_14 + 8;
                temp_a0_14->unk0 = 0xE7000000;
                temp_a0_14->unk4 = 0;
                temp_a0_15->unk4 = 0x14050;
                temp_a0_16 = temp_a0_15 + 8;
                temp_a0_15->unk0 = phi_fp;
                temp_a0_16->unk0 = phi_s6 | temp_t9_2;
                temp_a0_16->unk4 = phi_t3 | temp_a3;
                temp_a0_17 = temp_a0_16 + 8;
                temp_a0_17->unk0 = ((((phi_s5 + temp_s0) * 4) & 0xFFF) << 0xC) | 0xE4000000 | temp_t1;
                temp_a0_17->unk4 = (((temp_s0 * 4) & 0xFFF) << 0xC) | temp_t2;
                temp_a0_18 = temp_a0_17 + 8;
                temp_a0_18->unk0 = 0xB3000000;
                temp_a0_19 = temp_a0_18 + 8;
                temp_a0_18->unk4 = sp60 | temp_a1;
                temp_a0_19->unk0 = 0xB2000000;
                temp_t4 = phi_t4 + 0x20;
                temp_a0_20 = temp_a0_19 + 8;
                temp_a0_19->unk4 = sp5C;
                arg7 += 0x20;
                phi_t4 = temp_t4;
                phi_a0 = temp_a0_20;
                phi_s4 = spEC;
                phi_a0_2 = temp_a0_20;
                if (temp_t4 < arg5) {
                    goto loop_3;
                }
            }
        }
    }
    return phi_a0_2;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_80097E58.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
f32 sins(s32); // extern
f32 coss(s32); // extern
extern s32 D_8018D9B0;
extern u32 D_8018E7B8;
extern s32 D_8018E7D0;

void *func_800987D0(void *arg0, u32 arg1, u32 arg2, u32 arg3, u32 arg4, s32 arg5, s32 arg6, s32 arg8) {
    u32 sp60;
    s32 sp5C;
    f32 temp_f0;
    f32 temp_f18;
    f32 temp_f24;
    f32 temp_f2;
    f32 temp_f6;
    f64 temp_f10;
    s32 temp_a3;
    s32 temp_f4;
    s32 temp_f6_2;
    s32 temp_t1;
    s32 temp_t4;
    s32 temp_t8;
    s32 temp_t8_2;
    s32 temp_v0_2;
    s32 temp_v0_3;
    u32 temp_t2;
    u32 temp_t9;
    u32 temp_v0;
    u32 temp_v0_4;
    void *temp_s0;
    void *temp_s0_10;
    void *temp_s0_2;
    void *temp_s0_3;
    void *temp_s0_4;
    void *temp_s0_5;
    void *temp_s0_6;
    void *temp_s0_7;
    void *temp_s0_8;
    void *temp_s0_9;
    u32 phi_v0;
    u32 phi_v0_2;
    void *phi_s0;
    u32 phi_a2;
    s32 phi_t5;
    f32 phi_f6;
    f64 phi_f10;
    u32 phi_v0_3;
    void *phi_s0_2;
    void *phi_s0_3;
    void *phi_s0_4;

    temp_v0 = D_8018E7B8;
    phi_v0 = temp_v0;
    phi_s0_2 = arg0;
    phi_s0_3 = arg0;
    if (temp_v0 == 0) {
        D_8018E7B8 = 1;
        phi_v0 = 1;
    }
    temp_f24 = sins((((D_8018E7D0 * 0x4E20) / phi_v0) % 0x4E20) & 0xFFFF);
    temp_f0 = coss((((D_8018E7D0 * 0x4E20) / D_8018E7B8) % 0x4E20) & 0xFFFF);
    temp_t8 = D_8018E7D0;
    temp_f6 = temp_t8;
    phi_f6 = temp_f6;
    phi_t5 = arg5;
    if (temp_t8 < 0) {
        phi_f6 = temp_f6 + 4294967296.0f;
    }
    temp_t9 = D_8018E7B8;
    temp_f10 = temp_t9;
    phi_f10 = temp_f10;
    if (temp_t9 < 0) {
        phi_f10 = temp_f10 + 4294967296.0;
    }
    sp5C = arg5;
    temp_f18 = ((phi_f6 * 0.5) / phi_f10) + 1.0;
    phi_v0_2 = arg2;
    if (arg2 < arg4) {
        do {
            phi_s0 = phi_s0_3;
            phi_a2 = arg1;
            phi_v0_3 = phi_v0_2;
            phi_s0_4 = phi_s0_3;
            if (arg1 < arg3) {
                sp60 = phi_v0_2;
                temp_v0_2 = arg6 - 0x78;
                temp_t8_2 = (phi_v0_2 * 4) & 0xFFF;
                temp_t4 = ((phi_v0_2 + 0x20) * 4) & 0xFFF;
                do {
                    phi_s0->unk0 = ((arg8 - 1) & 0xFFF) | 0xFD100000;
                    temp_s0 = phi_s0 + 8;
                    phi_s0->unk4 = D_8018D9B0;
                    temp_s0_2 = temp_s0 + 8;
                    temp_a3 = (((((arg1 * 0 * 2) + 0x49) >> 3) & 0x1FF) << 9) | 0xF5100000;
                    temp_t1 = ((phi_a2 * 4) & 0xFFF) << 0xC;
                    temp_t2 = phi_a2 + 0x20;
                    temp_s0_3 = temp_s0_2 + 8;
                    temp_s0->unk0 = temp_a3;
                    temp_s0->unk4 = 0x7014050;
                    temp_v0_3 = ((temp_t2 * 4) & 0xFFF) << 0xC;
                    temp_s0_2->unk4 = 0;
                    temp_s0_2->unk0 = 0xE6000000;
                    temp_s0_3->unk0 = temp_t1 | 0xF4000000 | temp_t8_2;
                    temp_s0_4 = temp_s0_3 + 8;
                    temp_s0_3->unk4 = temp_v0_3 | 0x7000000 | temp_t4;
                    temp_s0_5 = temp_s0_4 + 8;
                    temp_s0_4->unk4 = 0;
                    temp_s0_4->unk0 = 0xE7000000;
                    temp_s0_5->unk4 = 0x14050;
                    temp_s0_5->unk0 = temp_a3;
                    temp_s0_6 = temp_s0_5 + 8;
                    temp_f2 = phi_t5 - 0xA0;
                    temp_s0_6->unk4 = temp_v0_3 | temp_t4;
                    temp_s0_6->unk0 = temp_t1 | 0xF2000000 | temp_t8_2;
                    temp_s0_7 = temp_s0_6 + 8;
                    temp_s0_8 = temp_s0_7 + 8;
                    temp_s0_9 = temp_s0_8 + 8;
                    temp_s0_10 = temp_s0_9 + 8;
                    temp_f6_2 = (((temp_f2 * temp_f0) + (temp_f24 * temp_v0_2)) * temp_f18) + 160.0f;
                    temp_f4 = (((-temp_f24 * temp_f2) + (temp_f0 * temp_v0_2)) * temp_f18) + 120.0f;
                    temp_s0_7->unk0 = ((((temp_f6_2 + 0x20) * 4) & 0xFFF) << 0xC) | 0xE4000000 | (((temp_f4 + 0x20) * 4) & 0xFFF);
                    temp_s0_7->unk4 = (((temp_f6_2 * 4) & 0xFFF) << 0xC) | ((temp_f4 * 4) & 0xFFF);
                    temp_s0_8->unk0 = 0xB3000000;
                    temp_s0_8->unk4 = 0;
                    temp_s0_9->unk0 = 0xB2000000;
                    temp_s0_9->unk4 = 0x4000400;
                    phi_s0 = temp_s0_10;
                    phi_a2 = temp_t2;
                    phi_t5 += 0x20;
                    phi_s0_4 = temp_s0_10;
                } while (temp_t2 < arg3);
                phi_v0_3 = sp60;
            }
            temp_v0_4 = phi_v0_3 + 0x20;
            arg6 += 0x20;
            phi_v0_2 = temp_v0_4;
            phi_s0_2 = phi_s0_4;
            phi_s0_3 = phi_s0_4;
            phi_t5 = sp5C;
        } while (temp_v0_4 < arg4);
    }
    return phi_s0_2;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800987D0.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80091B64(s32 *, s32 *); // extern
extern ? D_02008030;
extern ? D_02008058;

void *func_80098C18(void *arg0, s32 arg1, s32 arg2, s32 arg3, s32 arg4, s32 arg5, s32 arg6, u32 arg7, s32 arg8) {
    s32 temp_a0;
    void *temp_a1;
    void *temp_v1;

    arg5 &= 0xFF;
    arg6 &= 0xFF;
    arg7 &= 0xFF;
    arg8 &= 0xFF;
    if (arg3 < arg1) {
        func_80091B64(&arg1, &arg3);
    }
    if (arg4 < arg2) {
        func_80091B64(&arg2, &arg4);
    }
    if ((arg1 >= 0x140) || (arg2 >= 0xF0)) {
        return arg0;
    }
    if (arg1 < 0) {
        arg1 = 0;
    }
    if (arg2 < 0) {
        arg2 = 0;
    }
    if ((arg3 < 0) || (arg4 < 0)) {
        return arg0;
    }
    if (arg3 >= 0x140) {
        arg3 = 0x13F;
    }
    if (arg4 >= 0xF0) {
        arg4 = 0xEF;
    }
    arg0->unk4 = &D_02008030;
    arg0->unk0 = 0x6000000;
    arg0->unk8 = 0xF7000000;
    temp_a0 = ((arg5 << 8) & 0xF800) | ((arg6 * 8) & 0x7C0) | ((arg7 >> 2) & 0x3E) | (arg8 & 1);
    arg0->unkC = (temp_a0 << 0x10) | temp_a0;
    temp_a1 = arg0 + 8 + 8;
    temp_a1->unk0 = ((arg3 & 0x3FF) << 0xE) | 0xF6000000 | ((arg4 & 0x3FF) * 4);
    temp_v1 = temp_a1 + 8;
    temp_a1->unk4 = ((arg1 & 0x3FF) << 0xE) | ((arg2 & 0x3FF) * 4);
    temp_v1->unk4 = &D_02008058;
    temp_v1->unk0 = 0x6000000;
    return temp_v1 + 8;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_80098C18.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80091B64(s32 *, s32 *); // extern
extern ? D_02008008;

void *draw_box(void *arg0, s32 arg1, s32 arg2, s32 arg3, s32 arg4, s32 arg5, s32 arg6, s32 arg7, s32 arg8) {
    void *temp_a0;
    void *temp_v1;

    arg5 &= 0xFF;
    arg6 &= 0xFF;
    arg7 &= 0xFF;
    arg8 &= 0xFF;
    if (arg3 < arg1) {
        func_80091B64(&arg1, &arg3);
    }
    if (arg4 < arg2) {
        func_80091B64(&arg2, &arg4);
    }
    if ((arg1 >= 0x140) || (arg2 >= 0xF0)) {
        return arg0;
    }
    if (arg1 < 0) {
        arg1 = 0;
    }
    if (arg2 < 0) {
        arg2 = 0;
    }
    if ((arg3 < 0) || (arg4 < 0)) {
        return arg0;
    }
    if (arg3 >= 0x141) {
        arg3 = 0x140;
    }
    if (arg4 >= 0xF1) {
        arg4 = 0xF0;
    }
    arg0->unk4 = &D_02008008;
    arg0->unk0 = 0x6000000;
    arg0->unk8 = 0xFA000000;
    arg0->unkC = (arg5 << 0x18) | ((arg6 & 0xFF) << 0x10) | ((arg7 & 0xFF) << 8) | (arg8 & 0xFF);
    temp_a0 = arg0 + 8 + 8;
    temp_a0->unk0 = ((arg3 & 0x3FF) << 0xE) | 0xF6000000 | ((arg4 & 0x3FF) * 4);
    temp_v1 = temp_a0 + 8;
    temp_a0->unk4 = ((arg1 & 0x3FF) << 0xE) | ((arg2 & 0x3FF) * 4);
    temp_v1->unk0 = 0xE7000000;
    temp_v1->unk4 = 0;
    return temp_v1 + 8;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/draw_box.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80098C18(s32, s32, s32, s32, s32); // extern

void func_80098FC8(s32 arg4) {
    func_80098C18(arg4, 0, 0, 0, 0xFF);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_80098FC8.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern OSMesgQueue gDmaMesgQueue;
extern ? _textures_0aSegmentRomStart;

void dma_copy_base_729a30(s32 arg0, u32 arg1, void *arg2) {
    ? sp30;
    void *sp2C;

    osInvalDCache(arg2, arg1);
    osPiStartDma(&sp30, 0, 0, (arg0 & 0xFFFFFF) + &_textures_0aSegmentRomStart, arg2, arg1, &gDmaMesgQueue);
    osRecvMesg(&gDmaMesgQueue, &sp2C, 1);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/dma_copy_base_729a30.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern OSMesgQueue gDmaMesgQueue;
extern ? _textures_0bSegmentRomStart;

void dma_copy_base_7fa3c0(s32 arg0, u32 arg1, void *arg2) {
    ? sp30;
    void *sp2C;

    osInvalDCache(arg2, arg1);
    osPiStartDma(&sp30, 0, 0, (arg0 & 0xFFFFFF) + &_textures_0bSegmentRomStart, arg2, arg1, &gDmaMesgQueue);
    osRecvMesg(&gDmaMesgQueue, &sp2C, 1);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/dma_copy_base_7fa3c0.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern s32 D_8018E110;
extern s32 D_8018E758;

void func_80099110(void) {
    D_8018E110 = 0;
    D_8018E758 = 0;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_80099110.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern ? gSegmentTable;

s32 segmented_to_virtual(u32 arg0) {
    return *(&gSegmentTable + ((arg0 >> 0x18) * 4)) + (arg0 & 0xFFFFFF) + 0x80000000;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/segmented_to_virtual.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern ? gSegmentTable;

s32 segmented_to_virtual_dupe(u32 arg0) {
    return *(&gSegmentTable + ((arg0 >> 0x18) * 4)) + (arg0 & 0xFFFFFF) + 0x80000000;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/segmented_to_virtual_dupe.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? dma_copy_base_729a30(s32, s32, u8 *); // extern
void *segmented_to_virtual(); // extern
extern s32 D_8018D9B0;
extern u8 *D_8018D9B4;
extern s32 D_8018E110;
extern ? D_8018E118;
extern s32 D_8018E758;

void func_80099184(void) {
    s32 temp_a0;
    s32 temp_t3;
    s32 temp_t6;
    s32 temp_v0_2;
    s32 temp_v1;
    u16 temp_v0_3;
    void *temp_v0;
    s32 phi_v0;
    void *phi_s1;
    s32 phi_a1;
    s32 phi_a1_2;
    s32 phi_a1_3;

    temp_v0 = segmented_to_virtual();
    phi_s1 = temp_v0;
    if (temp_v0->unk4 != 0) {
        do {
            temp_v1 = D_8018E758;
            phi_v0 = 0;
            phi_a1 = 0;
            if (temp_v1 > 0) {
loop_4:
                temp_v0_2 = phi_v0 + 1;
                phi_v0 = temp_v0_2;
                if (*(&D_8018E118 + (phi_v0 * 8)) == phi_s1->unk4) {
                    phi_a1 = 1;
                } else if (temp_v0_2 < temp_v1) {
                    goto loop_4;
                }
            }
            if (phi_a1 == 0) {
                temp_a0 = phi_s1->unk4;
                if (phi_s1->unk0 == 3) {
                    temp_v0_3 = phi_s1->unk10;
                    phi_a1_2 = 0x1000;
                    if (temp_v0_3 != 0) {
                        phi_a1_2 = temp_v0_3 & 0xFFFF;
                    }
                    phi_a1_3 = phi_a1_2;
                    if ((phi_a1_2 % 8) != 0) {
                        phi_a1_3 = (((phi_a1_2 / 8) * 8) + 8) & 0xFFFF;
                    }
                    dma_copy_base_729a30(temp_a0, phi_a1_3, D_8018D9B4);
                    mio0decode(D_8018D9B4, (D_8018E110 * 2) + D_8018D9B0);
                } else {
                    dma_copy_base_729a30(temp_a0, phi_s1->unkA * phi_s1->unk8 * 2, (D_8018E110 * 2) + D_8018D9B0);
                }
                *(&D_8018E118 + (D_8018E758 * 8)) = phi_s1->unk4;
                (&D_8018E118 + (D_8018E758 * 8))->unk4 = D_8018E110;
                D_8018E758 = D_8018E758 + 1;
                temp_t3 = D_8018E110 + (phi_s1->unkA * phi_s1->unk8);
                temp_t6 = temp_t3;
                D_8018E110 = temp_t3;
                D_8018E110 = ((temp_t6 / 8) * 8) + 8;
            }
            phi_s1 += 0x14;
        } while (phi_s1->unk18 != 0);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_80099184.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800996BC(?); // extern

void func_8009969C(void) {
    func_800996BC(1);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009969C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? dma_copy_base_729a30(s32, s32, u8 *); // extern
? dma_copy_base_7fa3c0(s32, s32, u8 *); // extern
void *segmented_to_virtual(); // extern
? tkmk00decode(u8 *, s32, s32, ?); // extern
extern s32 D_8018D9B0;
extern u8 *D_8018D9B4;
extern s32 D_8018D9B8;
extern s32 D_8018E110;
extern ? D_8018E118;
extern s32 D_8018E758;

void func_800996BC(s32 arg1) {
    s32 temp_t0;
    s32 temp_t1;
    s32 temp_v0_2;
    s32 temp_v1;
    u16 temp_v0_3;
    void *temp_v0;
    s32 phi_v0;
    void *phi_s0;
    s32 phi_a1;
    s32 phi_a1_2;
    s32 phi_a1_3;
    ? phi_v0_2;

    temp_v0 = segmented_to_virtual();
    phi_s0 = temp_v0;
    if (temp_v0->unk4 != 0) {
        do {
            temp_v1 = D_8018E758;
            phi_v0 = 0;
            phi_a1 = 0;
            if (temp_v1 > 0) {
loop_4:
                temp_v0_2 = phi_v0 + 1;
                phi_v0 = temp_v0_2;
                if (*(&D_8018E118 + (phi_v0 * 8)) == phi_s0->unk4) {
                    phi_a1 = 1;
                } else if (temp_v0_2 < temp_v1) {
                    goto loop_4;
                }
            }
            if ((phi_a1 == 0) || (arg1 > 0)) {
                temp_v0_3 = phi_s0->unk10;
                phi_a1_2 = 0x1000;
                if (temp_v0_3 != 0) {
                    phi_a1_2 = temp_v0_3 & 0xFFFF;
                }
                phi_a1_3 = phi_a1_2;
                if ((phi_a1_2 % 8) != 0) {
                    phi_a1_3 = (((phi_a1_2 / 8) * 8) + 8) & 0xFFFF;
                }
                if (arg1 != -1) {
                    if (arg1 != 0) {
                        if (arg1 != 1) {
                            if (arg1 != 2) {

                            } else {
                                goto block_19;
                            }
                        } else {
                            goto block_18;
                        }
                    } else {
block_19:
                        dma_copy_base_7fa3c0(phi_s0->unk4, phi_a1_3, D_8018D9B4);
                    }
                } else {
block_18:
                    dma_copy_base_729a30(phi_s0->unk4, phi_a1_3, D_8018D9B4);
                }
                if (arg1 != -1) {
                    if (arg1 != 0) {
                        if (arg1 != 1) {
                            if (arg1 != 2) {

                            } else {
                                goto block_26;
                            }
                        } else {
                            goto block_25;
                        }
                    } else {
block_26:
                        phi_v0_2 = 1;
                        if (phi_s0->unk0 == 1) {
                            phi_v0_2 = 0xBE;
                        }
                        tkmk00decode(D_8018D9B4, D_8018D9B8, (D_8018E110 * 2) + D_8018D9B0, phi_v0_2);
                    }
                } else {
block_25:
                    mio0decode(D_8018D9B4, (D_8018E110 * 2) + D_8018D9B0);
                }
                *(&D_8018E118 + (D_8018E758 * 8)) = phi_s0->unk4;
                (&D_8018E118 + (D_8018E758 * 8))->unk4 = D_8018E110;
                D_8018E758 = D_8018E758 + 1;
                temp_t0 = D_8018E110 + (phi_s0->unkA * phi_s0->unk8);
                temp_t1 = temp_t0;
                D_8018E110 = temp_t0;
                D_8018E110 = ((temp_t1 / 8) * 8) + 8;
            }
            phi_s0 += 0x14;
        } while (phi_s0->unk18 != 0);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800996BC.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? dma_copy_base_729a30(s32, s32, u8 *); // extern
void *segmented_to_virtual(); // extern
extern u8 *D_8018D9B4;

void func_80099958(s32 arg1, s32 arg2) {
    s32 temp_a0;
    s32 temp_t6;
    u16 temp_v0_2;
    u8 *temp_s2;
    void *temp_v0;
    void *phi_s0;
    s32 phi_a1;
    s32 phi_a0;
    s32 phi_a1_2;

    temp_v0 = segmented_to_virtual();
    temp_t6 = temp_v0->unk4;
    phi_s0 = temp_v0;
    phi_a0 = temp_t6;
    if (temp_t6 != 0) {
        temp_s2 = &D_802BFB80[(arg2 << 0x10) + ((arg1 / 2) << 0xF) + ((arg1 % 2) << 0xD) + 0x4000];
        do {
            temp_v0_2 = phi_s0->unk10;
            phi_a1 = 0x1400;
            if (temp_v0_2 != 0) {
                phi_a1 = temp_v0_2 & 0xFFFF;
            }
            phi_a1_2 = phi_a1;
            if ((phi_a1 % 8) != 0) {
                phi_a1_2 = (((phi_a1 / 8) * 8) + 8) & 0xFFFF;
            }
            dma_copy_base_729a30(phi_a0, phi_a1_2, D_8018D9B4);
            mio0decode(D_8018D9B4, temp_s2);
            temp_a0 = phi_s0->unk18;
            phi_s0 += 0x14;
            phi_a0 = temp_a0;
        } while (temp_a0 != 0);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_80099958.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern s32 D_8018E060;

void func_80099A70(void) {
    s32 temp_v0;
    s32 phi_v0;

    D_8018E060 = 0;
    phi_v0 = 0;
    do {
        temp_v0 = phi_v0 + 4;
        phi_v0 = temp_v0;
    } while (temp_v0 != 0x10);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_80099A70.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 segmented_to_virtual(); // extern
extern s32 D_8018E060;

void func_80099A94(s32 arg1) {
    s32 *sp1C;
    s32 *temp_v1;
    s32 *phi_v1;
    s32 *phi_v1_2;

    phi_v1 = &D_8018E060;
    phi_v1_2 = &D_8018E060;
    if (D_8018E060 != 0) {
        do {
            temp_v1 = phi_v1 + 8;
            phi_v1 = temp_v1;
            phi_v1_2 = temp_v1;
        } while (phi_v1->unk8 != 0);
    }
    sp1C = phi_v1_2;
    phi_v1_2->unk0 = segmented_to_virtual();
    phi_v1_2->unk4 = arg1;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_80099A94.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern OSMesgQueue gDmaMesgQueue;
extern s32 D_8018D9B0;
extern void *D_8018D9B4;
extern void *D_8018E060;
extern ? D_8018E118;
extern ? _textures_0aSegmentRomStart;

void func_80099AEC(void) {
    ? sp6C;
    void *sp68;
    s32 sp60;
    ? *sp58;
    s32 temp_t7;
    u16 temp_v1;
    u16 temp_v1_2;
    u16 temp_v1_3;
    void *temp_s1;
    void *temp_s2;
    void *temp_v0;
    void *temp_v0_2;
    s32 phi_s0;
    u32 phi_s0_2;
    void **phi_s1;
    s32 phi_s0_3;
    u32 phi_s0_4;
    s8 phi_s5;
    s32 phi_s0_5;
    u32 phi_s0_6;
    s8 phi_s5_2;
    s8 phi_s5_3;

    if (D_800DC50C == 4) {
        sp60 = 0x500;
    } else {
        sp60 = 0x1000;
    }
    temp_s2 = D_8018E060;
    phi_s1 = &D_8018E060;
    phi_s5_3 = 0;
    if (temp_s2 != 0) {
        temp_v1 = temp_s2->unk10;
        phi_s0 = 0x1400;
        phi_s0_3 = 0x1400;
        phi_s0_5 = 0x1400;
        if (temp_v1 != 0) {
            phi_s0 = temp_v1;
        }
        phi_s0_2 = phi_s0;
        if ((phi_s0 % 8) != 0) {
            phi_s0_2 = ((phi_s0 / 8) * 8) + 8;
        }
        osInvalDCache(D_8018D9B4, phi_s0_2);
        sp58 = &_textures_0aSegmentRomStart;
        osPiStartDma(&sp6C, 0, 0, &_textures_0aSegmentRomStart + (temp_s2->unk4 & 0xFFFFFF), D_8018D9B4, phi_s0_2, &gDmaMesgQueue);
        osRecvMesg(&gDmaMesgQueue, &sp68, 1);
loop_9:
        temp_v0 = phi_s1->unk8;
        phi_s5 = phi_s5_3;
        if (temp_v0 == 0) {
            phi_s5 = phi_s5_3 + 1;
        } else {
            temp_v1_2 = temp_v0->unk10;
            temp_t7 = sp60 * 4;
            if (temp_v1_2 != 0) {
                phi_s0_3 = temp_v1_2;
            }
            phi_s0_4 = phi_s0_3;
            if ((phi_s0_3 % 8) != 0) {
                phi_s0_4 = ((phi_s0_3 / 8) * 8) + 8;
            }
            osInvalDCache(temp_t7 + D_8018D9B4, phi_s0_4);
            osPiStartDma(&sp6C, 0, 0, sp58 + (temp_v0->unk4 & 0xFFFFFF), temp_t7 + D_8018D9B4, phi_s0_4, &gDmaMesgQueue);
        }
        mio0decode(D_8018D9B4, (((phi_s1->unk4 * 8) + &D_8018E118)->unk4 * 2) + D_8018D9B0);
        phi_s1->unk0 = 0;
        temp_s1 = phi_s1 + 8;
        phi_s5_2 = phi_s5;
        if (phi_s5 == 0) {
            osRecvMesg(&gDmaMesgQueue, &sp68, 1);
            temp_v0_2 = temp_s1->unk8;
            if (temp_v0_2 == 0) {
                phi_s5_2 = phi_s5 + 1;
            } else {
                temp_v1_3 = temp_v0_2->unk10;
                if (temp_v1_3 != 0) {
                    phi_s0_5 = temp_v1_3;
                }
                phi_s0_6 = phi_s0_5;
                if ((phi_s0_5 % 8) != 0) {
                    phi_s0_6 = ((phi_s0_5 / 8) * 8) + 8;
                }
                osInvalDCache(D_8018D9B4, phi_s0_6);
                osPiStartDma(&sp6C, 0, 0, sp58 + (temp_v0_2->unk4 & 0xFFFFFF), D_8018D9B4, phi_s0_6, &gDmaMesgQueue);
            }
            mio0decode((sp60 * 4) + D_8018D9B4, (((temp_s1->unk4 * 8) + &D_8018E118)->unk4 * 2) + D_8018D9B0);
            temp_s1->unk0 = 0;
            phi_s1 = temp_s1 + 8;
            phi_s5_3 = phi_s5_2;
            if (phi_s5_2 == 0) {
                osRecvMesg(&gDmaMesgQueue, &sp68, 1);
                goto loop_9;
            }
        }
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_80099AEC.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern s32 D_8018E0E8;

void func_80099E54(void) {
    D_8018E0E8 = 0;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_80099E54.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 segmented_to_virtual(); // extern
extern s32 D_8018E0E8;

void func_80099E60(s32 arg1, s32 arg2) {
    s32 *sp1C;
    s32 *temp_v1;
    s32 *phi_v1;
    s32 *phi_v1_2;

    phi_v1 = &D_8018E0E8;
    phi_v1_2 = &D_8018E0E8;
    if (D_8018E0E8 != 0) {
        do {
            temp_v1 = phi_v1 + 8;
            phi_v1 = temp_v1;
            phi_v1_2 = temp_v1;
        } while (phi_v1->unk8 != 0);
    }
    sp1C = phi_v1_2;
    phi_v1_2->unk0 = segmented_to_virtual();
    phi_v1_2->unk4 = arg1;
    phi_v1_2->unk6 = arg2;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_80099E60.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern OSMesgQueue gDmaMesgQueue;
extern void *D_8018D9B4;
extern void *D_8018E0E8;
extern ? _textures_0aSegmentRomStart;

void func_80099EC4(void) {
    ? sp68;
    void *sp64;
    s16 temp_v0_2;
    s16 temp_v0_4;
    u16 temp_v1;
    u16 temp_v1_2;
    u16 temp_v1_3;
    void *temp_s1;
    void *temp_s2;
    void *temp_v0;
    void *temp_v0_3;
    s32 phi_s0;
    u32 phi_s0_2;
    void **phi_s1;
    s32 phi_s0_3;
    u32 phi_s0_4;
    s8 phi_s4;
    s32 phi_s0_5;
    u32 phi_s0_6;
    s8 phi_s4_2;
    s8 phi_s4_3;

    temp_s2 = D_8018E0E8;
    phi_s1 = &D_8018E0E8;
    phi_s4_3 = 0;
    if (temp_s2 != 0) {
        temp_v1 = temp_s2->unk10;
        phi_s0 = 0x1400;
        phi_s0_3 = 0x1400;
        phi_s0_5 = 0x1400;
        if (temp_v1 != 0) {
            phi_s0 = temp_v1;
        }
        phi_s0_2 = phi_s0;
        if ((phi_s0 % 8) != 0) {
            phi_s0_2 = ((phi_s0 / 8) * 8) + 8;
        }
        osInvalDCache(D_8018D9B4, phi_s0_2);
        osPiStartDma(&sp68, 0, 0, &_textures_0aSegmentRomStart + (temp_s2->unk4 & 0xFFFFFF), D_8018D9B4, phi_s0_2, &gDmaMesgQueue);
        osRecvMesg(&gDmaMesgQueue, &sp64, 1);
loop_6:
        temp_v0 = phi_s1->unk8;
        phi_s4 = phi_s4_3;
        if (temp_v0 == 0) {
            phi_s4 = phi_s4_3 + 1;
        } else {
            temp_v1_2 = temp_v0->unk10;
            if (temp_v1_2 != 0) {
                phi_s0_3 = temp_v1_2;
            }
            phi_s0_4 = phi_s0_3;
            if ((phi_s0_3 % 8) != 0) {
                phi_s0_4 = ((phi_s0_3 / 8) * 8) + 8;
            }
            osInvalDCache(D_8018D9B4 + 0x1400, phi_s0_4);
            osPiStartDma(&sp68, 0, 0, &_textures_0aSegmentRomStart + (temp_v0->unk4 & 0xFFFFFF), D_8018D9B4 + 0x1400, phi_s0_4, &gDmaMesgQueue);
        }
        temp_v0_2 = phi_s1->unk4;
        mio0decode(D_8018D9B4, D_802BFB80 + (phi_s1->unk6 << 0x10) + ((temp_v0_2 / 2) << 0xF) + ((temp_v0_2 % 2) << 0xD) + 0x4000);
        phi_s1->unk0 = 0;
        temp_s1 = phi_s1 + 8;
        phi_s4_2 = phi_s4;
        if (phi_s4 == 0) {
            osRecvMesg(&gDmaMesgQueue, &sp64, 1);
            temp_v0_3 = temp_s1->unk8;
            if (temp_v0_3 == 0) {
                phi_s4_2 = phi_s4 + 1;
            } else {
                temp_v1_3 = temp_v0_3->unk10;
                if (temp_v1_3 != 0) {
                    phi_s0_5 = temp_v1_3;
                }
                phi_s0_6 = phi_s0_5;
                if ((phi_s0_5 % 8) != 0) {
                    phi_s0_6 = ((phi_s0_5 / 8) * 8) + 8;
                }
                osInvalDCache(D_8018D9B4, phi_s0_6);
                osPiStartDma(&sp68, 0, 0, &_textures_0aSegmentRomStart + (temp_v0_3->unk4 & 0xFFFFFF), D_8018D9B4, phi_s0_6, &gDmaMesgQueue);
            }
            temp_v0_4 = temp_s1->unk4;
            mio0decode(D_8018D9B4 + 0x1400, D_802BFB80 + (temp_s1->unk6 << 0x10) + ((temp_v0_4 / 2) << 0xF) + ((temp_v0_4 % 2) << 0xD) + 0x4000);
            temp_s1->unk0 = 0;
            phi_s1 = temp_s1 + 8;
            phi_s4_3 = phi_s4_2;
            if (phi_s4_2 == 0) {
                osRecvMesg(&gDmaMesgQueue, &sp64, 1);
                goto loop_6;
            }
        }
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_80099EC4.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern ? D_8018DEE0;
extern ? D_8018E060;

void func_8009A344(void) {
    ? *temp_v1;
    ? *phi_v1;

    phi_v1 = &D_8018DEE0;
    do {
        temp_v1 = phi_v1 + 0x60;
        temp_v1->unk-3C = 0;
        temp_v1->unk-24 = 0;
        temp_v1->unk-C = 0;
        temp_v1->unk-54 = 0;
        phi_v1 = temp_v1;
    } while (temp_v1 != &D_8018E060);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009A344.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_8009969C(s32, s32, s32 *); // extern
s32 *segmented_to_virtual_dupe(); // extern
extern ? D_8018DEE0;
extern s32 D_8018E758;

s32 func_8009A374(s32 *arg0) {
    s32 sp24;
    void *sp1C;
    ? *temp_v1;
    s32 *temp_a2;
    s32 *temp_v0;
    s32 temp_a0;
    s32 temp_a1;
    s32 temp_t8;
    void *temp_v1_2;
    s32 phi_a1;
    ? *phi_v1;
    s32 phi_a1_2;
    s32 *phi_a2;

    temp_v0 = segmented_to_virtual_dupe();
    temp_a2 = temp_v0;
    phi_a1 = 0;
    phi_a1_2 = 0;
    phi_a2 = temp_a2;
    if (D_8018DEE0.unkC != 0) {
        phi_v1 = &D_8018DEE0;
loop_2:
        temp_a1 = phi_a1 + 1;
        temp_v1 = phi_v1 + 0x18;
        phi_a1 = temp_a1;
        phi_v1 = temp_v1;
        phi_a1_2 = temp_a1;
        if (temp_a1 >= 0x10) {
loop_3:
            goto loop_3;
        }
        if (temp_v1->unkC == 0) {
            goto block_5;
        }
        goto loop_2;
    }
block_5:
    temp_t8 = phi_a1_2 * 0x18;
    temp_v1_2 = &D_8018DEE0 + temp_t8;
    temp_v1_2->unk0 = temp_v0;
    temp_v1_2->unk4 = -1;
    temp_v1_2->unk8 = 0;
    temp_v1_2->unkC = 0x80000000;
    temp_v1_2->unk10 = D_8018E758;
    if (*temp_v0 != 0) {
        arg0 = temp_a2;
        sp24 = phi_a1_2;
        sp1C = temp_v1_2;
        func_8009969C(*temp_a2, phi_a1_2, temp_a2);
        phi_a2 = arg0;
    }
    temp_a0 = phi_a2->unk8;
    if (temp_a0 != 0) {
        sp1C = &D_8018DEE0 + temp_t8;
        sp24 = phi_a1_2;
        func_8009969C(temp_a0, phi_a1_2, phi_a2);
    } else {
        sp24 = phi_a1_2;
        sp1C = &D_8018DEE0 + temp_t8;
        func_8009969C(phi_a2->unk0, phi_a1_2, phi_a2);
    }
    (&D_8018DEE0 + temp_t8)->unk14 = 0;
    return sp24;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009A374.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80099958(s32, s32, ?, s32); // extern
s32 *segmented_to_virtual_dupe(); // extern
extern ? D_8018DEE0;
extern s32 D_8018E758;

s32 func_8009A478(s32 arg1) {
    s32 sp2C;
    void *sp24;
    ? *temp_v1;
    s32 *temp_s0;
    s32 *temp_v0;
    s32 temp_a0;
    s32 temp_a3;
    s32 temp_t8;
    void *temp_v1_2;
    s32 phi_a3;
    ? *phi_v1;
    s32 phi_a3_2;

    temp_v0 = segmented_to_virtual_dupe();
    temp_s0 = temp_v0;
    phi_a3 = 0;
    phi_a3_2 = 0;
    if (D_8018DEE0.unkC != 0) {
        phi_v1 = &D_8018DEE0;
loop_2:
        temp_a3 = phi_a3 + 1;
        temp_v1 = phi_v1 + 0x18;
        phi_a3 = temp_a3;
        phi_v1 = temp_v1;
        phi_a3_2 = temp_a3;
        if (temp_a3 >= 0x10) {
loop_3:
            goto loop_3;
        }
        if (temp_v1->unkC == 0) {
            goto block_5;
        }
        goto loop_2;
    }
block_5:
    temp_t8 = phi_a3_2 * 0x18;
    temp_v1_2 = &D_8018DEE0 + temp_t8;
    temp_v1_2->unk0 = temp_v0;
    temp_v1_2->unk4 = -1;
    temp_v1_2->unk8 = 0;
    temp_v1_2->unkC = 0x80000000;
    temp_v1_2->unk10 = D_8018E758;
    if (temp_v0->unk0 != 0) {
        sp2C = phi_a3_2;
        sp24 = temp_v1_2;
        func_80099958(temp_s0->unk0, arg1, 0, phi_a3_2);
    }
    temp_a0 = temp_s0->unk8;
    if (temp_a0 != 0) {
        sp24 = &D_8018DEE0 + temp_t8;
        sp2C = phi_a3_2;
        func_80099958(temp_a0, arg1, 1, phi_a3_2);
    } else {
        sp2C = phi_a3_2;
        sp24 = &D_8018DEE0 + temp_t8;
        func_80099958(temp_s0->unk0, arg1, 1, phi_a3_2);
    }
    (&D_8018DEE0 + temp_t8)->unk14 = 0;
    return sp2C;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009A478.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80099A94(s32, s32); // extern
s32 segmented_to_virtual(s32, s32); // extern
s32 segmented_to_virtual_dupe(?); // extern
extern ? D_8018DEE0;

void func_8009A594(s32 arg0, s32 arg1, ? arg2) {
    s32 temp_v0;
    s32 temp_v0_2;
    void *temp_s0;

    temp_v0 = segmented_to_virtual_dupe(arg2);
    temp_s0 = (arg0 * 0x18) + &D_8018DEE0;
    temp_s0->unk0 = temp_v0;
    temp_s0->unk4 = arg1;
    temp_s0->unk8 = ((arg1 * 8) + temp_v0)->unk4;
    temp_v0_2 = segmented_to_virtual(*(temp_v0 + (arg1 * 8)), arg1);
    if (temp_s0->unk14 != 0) {
        func_80099A94(temp_v0_2, temp_s0->unk10);
        temp_s0->unk14 = 0;
        return;
    }
    func_80099A94(temp_v0_2, temp_s0->unk10 + 1);
    temp_s0->unk14 = 1;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009A594.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80099E60(s32, s32, s32); // extern
s32 segmented_to_virtual(s32, s32); // extern
s32 segmented_to_virtual_dupe(?); // extern
extern ? D_8018DEE0;

void func_8009A640(s32 arg0, s32 arg1, s32 arg2, ? arg3) {
    void *sp1C;
    s32 temp_a0;
    s32 temp_a2;
    s32 temp_v0;
    void *temp_v1;

    temp_v0 = segmented_to_virtual_dupe(arg3);
    temp_v1 = (arg0 * 0x18) + &D_8018DEE0;
    temp_v1->unk0 = temp_v0;
    temp_v1->unk4 = arg1;
    temp_v1->unk8 = ((arg1 * 8) + temp_v0)->unk4;
    sp1C = temp_v1;
    temp_a0 = segmented_to_virtual(*(temp_v0 + (arg1 * 8)), arg1);
    temp_a2 = temp_v1->unk14 ^ 1;
    temp_v1->unk14 = temp_a2;
    func_80099E60(temp_a0, arg2, temp_a2);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009A640.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_8009A878(void *); // extern
s32 func_8009C434(s32, void *, s32, s32, s32); // extern
extern ? D_8018DEE0;
extern s32 gDisplayListHead;

void func_8009A76C(s32 arg0, s32 arg1, s32 arg2, s32 arg3) {
    void *sp20;
    void *temp_t8;

    temp_t8 = (arg0 * 0x18) + &D_8018DEE0;
    sp20 = temp_t8;
    if (temp_t8->unkC & 0x80000000) {
        func_8009A878(temp_t8);
        gDisplayListHead = func_8009C434(gDisplayListHead, sp20, arg1, arg2, arg3);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009A76C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_8009A944(void *, s32); // extern
s32 func_8009C708(s32, void *, s32, s32, s32, s32); // extern
extern ? D_8018DEE0;
extern s32 gDisplayListHead;

void func_8009A7EC(s32 arg0, s32 arg1, s32 arg2, s32 arg3, s32 arg4) {
    void *sp20;
    void *temp_t8;

    temp_t8 = (arg0 * 0x18) + &D_8018DEE0;
    sp20 = temp_t8;
    if (temp_t8->unkC & 0x80000000) {
        func_8009A944(temp_t8, arg3);
        gDisplayListHead = func_8009C708(gDisplayListHead, sp20, arg1, arg2, arg3, arg4);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009A7EC.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80099A94(s32, s32); // extern
s32 segmented_to_virtual(s32); // extern

s32 func_8009A878(void *arg0) {
    s32 *temp_v0;
    s32 temp_t1;
    s32 temp_t3;
    s32 temp_t8;
    s32 temp_v0_2;
    s32 temp_v1;
    s32 *phi_v0;

    temp_v1 = arg0->unk0;
    if (arg0->unk4 < 0) {
        arg0->unk4 = 0;
        arg0->unk8 = 0;
    }
    temp_t8 = arg0->unk8 - 1;
    arg0->unk8 = temp_t8;
    if (temp_t8 <= 0) {
        temp_t1 = arg0->unk4 + 1;
        temp_t3 = temp_t1 * 8;
        arg0->unk4 = temp_t1;
        temp_v0 = temp_v1 + temp_t3;
        phi_v0 = temp_v0;
        if (*temp_v0 == 0) {
            arg0->unk4 = 0;
            phi_v0 = temp_v1 + (0 * 8);
        }
        arg0->unk8 = phi_v0->unk4;
        temp_v0_2 = segmented_to_virtual(phi_v0->unk0);
        if (arg0->unk14 != 0) {
            func_80099A94(temp_v0_2, arg0->unk10);
            arg0->unk14 = 0;
        } else {
            func_80099A94(temp_v0_2, arg0->unk10 + 1);
            arg0->unk14 = 1;
        }
    }
    return *(arg0->unk0 + (arg0->unk4 * 8));
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009A878.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80099E60(s32, s32, s32, void *); // extern
s32 segmented_to_virtual(s32, void *); // extern

s32 func_8009A944(void *arg0, s32 arg1) {
    s32 *temp_v0;
    s32 temp_a0;
    s32 temp_a2;
    s32 temp_t1;
    s32 temp_t3;
    s32 temp_t8;
    s32 temp_v1;
    void *temp_a3;
    s32 *phi_v0;
    void *phi_a3;

    temp_a3 = arg0;
    temp_v1 = arg0->unk0;
    phi_a3 = temp_a3;
    if (arg0->unk4 < 0) {
        arg0->unk4 = 0;
        arg0->unk8 = 0;
    }
    temp_t8 = temp_a3->unk8 - 1;
    temp_a3->unk8 = temp_t8;
    if (temp_t8 <= 0) {
        temp_t1 = temp_a3->unk4 + 1;
        temp_t3 = temp_t1 * 8;
        temp_a3->unk4 = temp_t1;
        temp_v0 = temp_v1 + temp_t3;
        phi_v0 = temp_v0;
        if (*temp_v0 == 0) {
            temp_a3->unk4 = 0;
            phi_v0 = temp_v1 + (0 * 8);
        }
        temp_a3->unk8 = phi_v0->unk4;
        arg0 = temp_a3;
        temp_a0 = segmented_to_virtual(phi_v0->unk0, temp_a3);
        temp_a2 = arg0->unk14 ^ 1;
        arg0->unk14 = temp_a2;
        func_80099E60(temp_a0, arg1, temp_a2, arg0);
        phi_a3 = arg0;
    }
    return *(phi_a3->unk0 + (phi_a3->unk4 * 8));
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009A944.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
f64 func_800917B0(f64, f64); // extern
extern s32 D_8018D9B0;
extern ? D_8018E118;

void func_8009B0A4(s32 arg0, s32 arg1) {
    ? sp48;
    ? *temp_s1;
    f64 temp_f10;
    f64 temp_f6;
    s16 *temp_a3_2;
    s32 temp_s0_2;
    s32 temp_t5;
    s32 temp_v1;
    u16 *temp_a3;
    u16 temp_v0_2;
    u16 temp_v0_3;
    u16 temp_v0_4;
    u32 temp_s0;
    u32 temp_v1_2;
    u32 temp_v1_3;
    u32 temp_v1_4;
    void *temp_v0;
    s32 phi_s0;
    f64 phi_f10;
    f64 phi_f6;
    ? *phi_s1;
    u32 phi_v1;
    u16 *phi_a3;
    u32 phi_v1_2;
    u32 phi_v1_3;
    s32 phi_s0_2;

    temp_f6 = arg1;
    phi_s0 = 0;
    phi_f6 = temp_f6;
    phi_s0_2 = 0;
    if (arg1 < 0) {
        phi_f6 = temp_f6 + 4294967296.0;
    }
    phi_s1 = &sp48;
    do {
        temp_f10 = phi_s0;
        phi_f10 = temp_f10;
        if (phi_s0 < 0) {
            phi_f10 = temp_f10 + 4294967296.0;
        }
        temp_s0 = phi_s0 + 1;
        temp_s1 = phi_s1 + 4;
        temp_s1->unk-4 = func_800917B0(phi_f10 * 0.03125, (phi_f6 * 1.5 * 0.00390625) + 0.25);
        phi_s0 = temp_s0;
        phi_s1 = temp_s1;
    } while (temp_s0 < 0x20);
    temp_v0 = (arg0 * 8) + &D_8018E118;
    temp_v1 = temp_v0->unk4;
    temp_t5 = temp_v0->unkC - temp_v1;
    temp_a3 = (temp_v1 * 2) + D_8018D9B0;
    phi_a3 = temp_a3;
    if (temp_t5 != 0) {
        if ((temp_t5 & 1) != 0) {
            temp_v0_2 = *temp_a3;
            temp_v1_2 = *(&sp48 + ((((((temp_v0_2 & 0xF800) >> 0xB) * 0x55) + (((temp_v0_2 & 0x7C0) >> 6) * 0x4B) + (((temp_v0_2 & 0x3E) >> 1) * 0x5F)) >> 8) * 4)) * 32.0f;
            phi_v1 = temp_v1_2;
            phi_s0_2 = 1;
            if (temp_v1_2 >= 0x20) {
                phi_v1 = 0x1F;
            }
            *temp_a3 = (phi_v1 * 0x842) + (temp_v0_2 & 1);
            phi_a3 = temp_a3 + 2;
            if (temp_t5 != 1) {
                goto block_11;
            }
        } else {
block_11:
            do {
                temp_v0_3 = phi_a3->unk0;
                temp_s0_2 = phi_s0_2 + 2;
                temp_v1_3 = *(&sp48 + ((((((temp_v0_3 & 0xF800) >> 0xB) * 0x55) + (((temp_v0_3 & 0x7C0) >> 6) * 0x4B) + (((temp_v0_3 & 0x3E) >> 1) * 0x5F)) >> 8) * 4)) * 32.0f;
                phi_v1_2 = temp_v1_3;
                phi_s0_2 = temp_s0_2;
                if (temp_v1_3 >= 0x20) {
                    phi_v1_2 = 0x1F;
                }
                temp_v0_4 = phi_a3->unk2;
                phi_a3->unk0 = (phi_v1_2 * 0x842) + (temp_v0_3 & 1);
                temp_a3_2 = phi_a3 + 2;
                temp_v1_4 = *(&sp48 + ((((((temp_v0_4 & 0xF800) >> 0xB) * 0x55) + (((temp_v0_4 & 0x7C0) >> 6) * 0x4B) + (((temp_v0_4 & 0x3E) >> 1) * 0x5F)) >> 8) * 4)) * 32.0f;
                phi_v1_3 = temp_v1_4;
                if (temp_v1_4 >= 0x20) {
                    phi_v1_3 = 0x1F;
                }
                *temp_a3_2 = (phi_v1_3 * 0x842) + (temp_v0_4 & 1);
                phi_a3 = temp_a3_2 + 2;
            } while (temp_s0_2 != temp_t5);
        }
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009B0A4.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern s32 D_8018D9B0;
extern ? D_8018E11C;

void func_8009B538(s32 arg0, s32 arg1, s32 arg2, s32 arg3, s32 arg4) {
    s32 temp_a0;
    s32 temp_v1;
    s32 temp_v1_2;
    u16 *temp_v0;
    u16 *temp_v0_2;
    u16 *temp_v0_3;
    u16 temp_a2;
    u16 temp_a2_2;
    u16 temp_a2_3;
    u16 temp_a2_4;
    u16 temp_a2_5;
    u32 temp_t6;
    u32 temp_t8;
    u32 temp_t8_2;
    u32 temp_t9;
    u32 temp_t9_2;
    u16 *phi_v0;
    s32 phi_v1;
    u16 *phi_v0_2;
    s32 phi_v1_2;

    temp_v0 = (*(&D_8018E11C + (arg0 * 8)) * 2) + D_8018D9B0;
    phi_v0 = temp_v0;
    phi_v1 = 0;
    phi_v0_2 = temp_v0;
    phi_v1_2 = 0;
    if (arg1 != 0) {
        temp_a0 = arg1 & 3;
        if (temp_a0 != 0) {
            do {
                temp_a2 = *phi_v0;
                temp_v1 = phi_v1 + 1;
                temp_v0_2 = phi_v0 + 2;
                temp_t9 = ((((temp_a2 & 0xF800) >> 0xB) * 0x4D) + (((temp_a2 & 0x7C0) >> 6) * 0x96) + (((temp_a2 & 0x3E) >> 1) * 0x1D)) >> 8;
                temp_v0_2->unk-2 = (((arg2 * temp_t9) >> 8) << 0xB) + (((arg3 * temp_t9) >> 8) << 6) + (((arg4 * temp_t9) >> 8) * 2) + (temp_a2 & 1);
                phi_v0 = temp_v0_2;
                phi_v1 = temp_v1;
                phi_v0_2 = temp_v0_2;
                phi_v1_2 = temp_v1;
            } while (temp_a0 != temp_v1);
            if (temp_v1 != arg1) {
                goto block_5;
            }
        } else {
block_5:
            do {
                temp_a2_2 = *phi_v0_2;
                temp_v1_2 = phi_v1_2 + 4;
                temp_v0_3 = phi_v0_2 + 8;
                temp_a2_3 = temp_v0_3->unk-6;
                temp_t8 = ((((temp_a2_2 & 0xF800) >> 0xB) * 0x4D) + (((temp_a2_2 & 0x7C0) >> 6) * 0x96) + (((temp_a2_2 & 0x3E) >> 1) * 0x1D)) >> 8;
                temp_v0_3->unk-8 = (((arg2 * temp_t8) >> 8) << 0xB) + (((arg3 * temp_t8) >> 8) << 6) + (((arg4 * temp_t8) >> 8) * 2) + (temp_a2_2 & 1);
                temp_a2_4 = temp_v0_3->unk-4;
                temp_t6 = ((((temp_a2_3 & 0xF800) >> 0xB) * 0x4D) + (((temp_a2_3 & 0x7C0) >> 6) * 0x96) + (((temp_a2_3 & 0x3E) >> 1) * 0x1D)) >> 8;
                temp_v0_3->unk-6 = (((arg2 * temp_t6) >> 8) << 0xB) + (((arg3 * temp_t6) >> 8) << 6) + (((arg4 * temp_t6) >> 8) * 2) + (temp_a2_3 & 1);
                temp_a2_5 = temp_v0_3->unk-2;
                temp_t9_2 = ((((temp_a2_4 & 0xF800) >> 0xB) * 0x4D) + (((temp_a2_4 & 0x7C0) >> 6) * 0x96) + (((temp_a2_4 & 0x3E) >> 1) * 0x1D)) >> 8;
                temp_v0_3->unk-4 = (((arg2 * temp_t9_2) >> 8) << 0xB) + (((arg3 * temp_t9_2) >> 8) << 6) + (((arg4 * temp_t9_2) >> 8) * 2) + (temp_a2_4 & 1);
                temp_t8_2 = ((((temp_a2_5 & 0xF800) >> 0xB) * 0x4D) + (((temp_a2_5 & 0x7C0) >> 6) * 0x96) + (((temp_a2_5 & 0x3E) >> 1) * 0x1D)) >> 8;
                temp_v0_3->unk-2 = (((arg2 * temp_t8_2) >> 8) << 0xB) + (((arg3 * temp_t8_2) >> 8) << 6) + (((arg4 * temp_t8_2) >> 8) * 2) + (temp_a2_5 & 1);
                phi_v0_2 = temp_v0_3;
                phi_v1_2 = temp_v1_2;
            } while (temp_v1_2 != arg1);
        }
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009B538.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern s32 D_8018D9B0;
extern ? D_8018E118;
extern s32 D_8018E758;

s32 func_8009B8C4(s32 arg0) {
    s32 sp4;
    s32 temp_a1;
    s32 temp_v1;
    ? *phi_a2;
    s32 phi_v1;
    s32 phi_v0;

    temp_a1 = D_8018E758;
    phi_v1 = 0;
    phi_v0 = 0;
    if (temp_a1 > 0) {
        phi_a2 = &D_8018E118;
loop_2:
        temp_v1 = phi_v1 + 1;
        phi_v1 = temp_v1;
        if (arg0 == phi_a2->unk0) {
            sp4 = phi_a2->unk4;
            phi_v0 = 1;
        } else {
            phi_a2 += 8;
            if (temp_v1 < temp_a1) {
                goto loop_2;
            }
        }
    }
    if (phi_v0 != 0) {
        return (sp4 * 2) + D_8018D9B0;
    }
    return 0;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009B8C4.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern s32 D_8018D9C0;
extern s32 D_8018E75C;
extern s32 D_8018E760;

void func_8009B938(void) {
    D_8018E75C = D_8018D9C0;
    D_8018E760 = 0;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009B938.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 segmented_to_virtual(); // extern
extern s32 D_8018E75C;
extern s32 D_8018E760;
extern ? D_8018E768;

void func_8009B954(void) {
    void *temp_v1;

    temp_v1 = (D_8018E760 * 8) + &D_8018E768;
    temp_v1->unk0 = segmented_to_virtual();
    temp_v1->unk4 = D_8018E75C;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009B954.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern void *D_8018E75C;
extern s32 D_8018E760;

void func_8009B998(void) {
    void *temp_v1;

    temp_v1 = D_8018E75C;
    D_8018E75C = temp_v1 + 8;
    temp_v1->unk4 = 0;
    temp_v1->unk0 = 0xB8000000;
    D_8018E760 = D_8018E760 + 1;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009B998.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void *segmented_to_virtual(?); // extern
extern ? D_8018E768;
extern ? D_8018E7A8;

void *func_8009B9D0(void *arg0, ? arg1) {
    s32 sp34;
    s32 sp2C;
    ? *temp_s0;
    void *temp_t0;
    void *temp_v0;
    ? *phi_s0;
    void *phi_v0;

    sp2C = 0;
    phi_s0 = &D_8018E768;
loop_1:
    temp_v0 = segmented_to_virtual(arg1);
    phi_v0 = temp_v0;
    if (temp_v0 == phi_s0->unk0) {
        sp2C = 1;
        sp34 = phi_s0->unk4;
    } else {
        temp_s0 = phi_s0 + 8;
        phi_s0 = temp_s0;
        if (temp_s0 != &D_8018E7A8) {
            goto loop_1;
        }
    }
    temp_t0 = arg0;
    if (sp2C != 0) {
        arg0 = temp_t0 + 8;
        temp_t0->unk0 = 0x6000000;
        temp_t0->unk4 = sp34;
        phi_v0 = arg0;
    }
    return phi_v0;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009B9D0.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
void *func_80095E10(void *, s8, ?, ?, s32, s32, s32, s32, s32, s32, s32, s32, s32); /* extern */
void *func_800987D0(void *, ?, ?, u16, s32, s32, s32, s32, s32, s32); /* extern */
void *segmented_to_virtual(s32);                    /* extern */
static ? D_02007708;                                /* unable to generate initializer */
static ? D_02007728;                                /* unable to generate initializer */
static ? D_02007748;                                /* unable to generate initializer */
static ? D_02007768;                                /* unable to generate initializer */
static ? D_02007788;                                /* unable to generate initializer */

void *func_8009BA74(void *arg0, s32 arg1, s32 arg2, s32 arg3) {
    s32 temp_v0_2;
    u16 temp_s1;
    u16 temp_s1_2;
    u16 temp_t7;
    u16 temp_v0_3;
    u16 temp_v0_4;
    void *temp_v0;
    void *phi_s2;
    void *phi_s0;
    void *phi_s0_2;
    s8 phi_s4;
    void *phi_s0_3;
    void *phi_s0_4;
    void *phi_v0;

    temp_v0 = segmented_to_virtual(arg1);
    phi_s2 = temp_v0;
    phi_s0 = arg0;
    phi_s0_3 = arg0;
    if (temp_v0->unk4 != 0) {
        do {
            temp_t7 = phi_s2->unk0;
            phi_s4 = 0;
            switch (temp_t7) {
            case 0:
                phi_s0->unk0 = 0x6000000;
                phi_s0->unk4 = &D_02007708;
                phi_s0_2 = phi_s0 + 8;
                break;
            case 1:
                phi_s0->unk0 = 0x6000000;
                phi_s0->unk4 = &D_02007728;
                phi_s0_2 = phi_s0 + 8;
                break;
            case 2:
                phi_s0->unk4 = &D_02007748;
                phi_s0->unk0 = 0x6000000;
                phi_s0_2 = phi_s0 + 8;
                break;
            case 3:
                phi_s0->unk4 = &D_02007768;
                phi_s0->unk0 = 0x6000000;
                phi_s0_2 = phi_s0 + 8;
                phi_s4 = 3;
                break;
            case 4:
                phi_s0->unk4 = &D_02007788;
                phi_s0->unk0 = 0x6000000;
                phi_s0_2 = phi_s0 + 8;
                break;
            default:
                phi_s0->unk0 = 0x6000000;
                phi_s0->unk4 = &D_02007728;
                phi_s0_2 = phi_s0 + 8;
                break;
            }
            temp_v0_2 = func_8009B8C4(phi_s2->unk4);
            phi_s0_4 = phi_s0_2;
            if (temp_v0_2 != 0) {
                if (D_8018E7B0 != 4) {
                    temp_s1 = phi_s2->unk8;
                    temp_v0_3 = phi_s2->unkA;
                    phi_v0 = func_80095E10(phi_s0_2, phi_s4, 0x400, 0x400, 0, 0, temp_s1, temp_v0_3, phi_s2->unkC + arg2, phi_s2->unkE + arg3, temp_v0_2, temp_s1, temp_v0_3);
                } else {
                    temp_v0_4 = phi_s2->unkA;
                    temp_s1_2 = phi_s2->unk8;
                    phi_v0 = func_800987D0(phi_s0_2, 0, 0, temp_s1_2, temp_v0_4, phi_s2->unkC + arg2, phi_s2->unkE + arg3, temp_v0_2, temp_s1_2, temp_v0_4);
                }
                phi_s0_4 = phi_v0;
            }
            phi_s2 += 0x14;
            phi_s0 = phi_s0_4;
            phi_s0_3 = phi_s0_4;
        } while (phi_s2->unk18 != 0);
    }
    return phi_s0_3;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009BA74.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void *func_80097274(void *, ?, ?, ?, s32, s32, s32, s32, s32, s32, s32, s32, s32, s32); // extern
void *func_80097A14(void *, ?, ?, ?, s32, s32, s32, s32, s32, s32, s32); // extern
void *func_80097AE4(void *, ?, s32, s32, s32, s32); // extern
void *func_80097E58(void *, ?, ?, ?, s32, s32, s32, s32, s32, s32, s32, s32); // extern
s32 func_8009B8C4(s32); // extern
void *segmented_to_virtual(?); // extern
extern ? D_02007708;
extern ? D_02007728;

void *func_8009BC9C(void *arg0, ? arg1, s32 arg2, s32 arg3, s32 arg4, s32 arg5) {
    s16 temp_v0_2;
    s32 temp_v0_3;
    u16 temp_v0_4;
    u16 temp_v0_5;
    u16 temp_v0_6;
    u16 temp_v1;
    u16 temp_v1_2;
    u16 temp_v1_3;
    void *temp_v0;
    void *phi_s0;
    void *phi_s1;
    void *phi_s1_2;
    void *phi_s1_3;
    void *phi_s1_4;
    void *phi_v0;

    temp_v0 = segmented_to_virtual(arg1);
    phi_s0 = temp_v0;
    phi_s1 = arg0;
    phi_s1_3 = arg0;
    if (temp_v0->unk4 != 0) {
        do {
            temp_v0_2 = phi_s0->unk0;
            phi_s1_2 = phi_s1;
            if (temp_v0_2 != 0) {
                if (temp_v0_2 != 1) {

                } else {
                    phi_s1->unk4 = &D_02007728;
                    phi_s1->unk0 = 0x6000000;
                    phi_s1_2 = phi_s1 + 8;
                }
            } else {
                phi_s1->unk0 = 0x6000000;
                phi_s1->unk4 = &D_02007708;
                phi_s1_2 = phi_s1 + 8;
            }
            temp_v0_3 = func_8009B8C4(phi_s0->unk4);
            phi_s1_4 = phi_s1_2;
            if (temp_v0_3 != 0) {
                if (arg4 != 1) {
                    if (arg4 != 2) {
                        if (arg4 != 3) {
                            if (arg4 != 4) {

                            } else {
                                temp_v0_4 = phi_s0->unk8;
                                temp_v1 = phi_s0->unkA;
                                phi_v0 = func_80097274(phi_s1_2, 0, 0x400, 0x400, 0, 0, temp_v0_4, temp_v1, phi_s0->unkC + arg2, phi_s0->unkE + arg3, temp_v0_3, temp_v0_4, temp_v1, arg5);
                                goto block_17;
                            }
                        } else {
                            temp_v0_5 = phi_s0->unk8;
                            temp_v1_2 = phi_s0->unkA;
                            phi_v0 = func_80097A14(phi_s1_2, 0, 0, 0, temp_v0_5, temp_v1_2, phi_s0->unkC + arg2, phi_s0->unkE + arg3, temp_v0_3, temp_v0_5, temp_v1_2);
                            goto block_17;
                        }
                    } else {
                        temp_v0_6 = phi_s0->unk8;
                        temp_v1_3 = phi_s0->unkA;
                        phi_v0 = func_80097E58(phi_s1_2, 0, 0, 0, temp_v0_6, temp_v1_3, phi_s0->unkC + arg2, phi_s0->unkE + arg3, temp_v0_3, temp_v0_6, temp_v1_3, arg5);
                        goto block_17;
                    }
                } else {
                    phi_v0 = func_80097AE4(phi_s1_2, 0, phi_s0->unkC + arg2, phi_s0->unkE + arg3, temp_v0_3, arg5);
block_17:
                    phi_s1_4 = phi_v0;
                }
            }
            phi_s0 += 0x14;
            phi_s1 = phi_s1_4;
            phi_s1_3 = phi_s1_4;
        } while (phi_s0->unk18 != 0);
    }
    return phi_s1_3;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009BC9C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void *func_80095BD0(void *, s32, f32, f32, s32, s32, f32, f32); // extern
s32 func_8009B8C4(s32); // extern
void *segmented_to_virtual(?); // extern
extern ? D_020077F8;
extern ? D_02007818;

void *func_8009BEF0(void *arg0, ? arg1, f32 arg2, f32 arg3, s32 arg4, f32 arg5, f32 arg6) {
    f32 temp_f0;
    f32 temp_f0_2;
    f32 temp_f10;
    f32 temp_f16;
    f32 temp_f16_2;
    f32 temp_f16_3;
    f32 temp_f18;
    f32 temp_f4;
    f32 temp_f6;
    f32 temp_f6_2;
    s32 temp_a1;
    s32 temp_v0_2;
    u16 temp_t0;
    u16 temp_t1;
    u16 temp_t2;
    u16 temp_t5;
    u16 temp_t6;
    u16 temp_t7;
    u16 temp_t8;
    u16 temp_t9;
    void *temp_s0;
    void *temp_v0;
    void *phi_s0;
    f32 phi_f6;
    f32 phi_f16;
    f32 phi_f6_2;
    f32 phi_f16_2;
    s32 phi_v0;
    void *phi_s1;
    f32 phi_f16_3;
    f32 phi_f4;
    f32 phi_f18;
    f32 phi_f10;
    void *phi_s1_2;
    s32 phi_v0_2;
    void *phi_s1_3;
    s32 phi_v0_3;
    void *phi_v0_4;
    s32 phi_v0_5;

    temp_v0 = segmented_to_virtual(arg1);
    phi_s0 = temp_v0;
    phi_s1 = arg0;
    phi_s1_2 = arg0;
    if (temp_v0->unk4 != 0) {
        do {
            temp_t7 = phi_s0->unkC;
            temp_f6 = temp_t7;
            phi_f6 = temp_f6;
            phi_s1_3 = phi_s1;
            phi_v0_5 = 0;
            if (temp_t7 < 0) {
                phi_f6 = temp_f6 + 4294967296.0f;
            }
            temp_f0 = phi_f6 + arg2;
            if (temp_f0 > 320.0f) {
                phi_v0_5 = 1;
            }
            temp_t8 = phi_s0->unk8;
            temp_f16 = temp_t8;
            phi_f16 = temp_f16;
            phi_v0_3 = phi_v0_5;
            if (temp_t8 < 0) {
                phi_f16 = temp_f16 + 4294967296.0f;
            }
            if ((temp_f0 + (phi_f16 * arg5)) < 0.0f) {
                phi_v0_3 = phi_v0_5 + 1;
            }
            temp_t9 = phi_s0->unkE;
            temp_f6_2 = temp_t9;
            phi_f6_2 = temp_f6_2;
            phi_v0_2 = phi_v0_3;
            if (temp_t9 < 0) {
                phi_f6_2 = temp_f6_2 + 4294967296.0f;
            }
            temp_f0_2 = phi_f6_2 + arg3;
            if (temp_f0_2 < 0.0f) {
                phi_v0_2 = phi_v0_3 + 1;
            }
            temp_t0 = phi_s0->unkA;
            temp_f16_2 = temp_t0;
            phi_f16_2 = temp_f16_2;
            phi_v0 = phi_v0_2;
            if (temp_t0 < 0) {
                phi_f16_2 = temp_f16_2 + 4294967296.0f;
            }
            if ((temp_f0_2 - (phi_f16_2 * arg6)) > 240.0f) {
                phi_v0 = phi_v0_2 + 1;
            }
            if (phi_v0 != 0) {

            } else {
                temp_v0_2 = func_8009B8C4(phi_s0->unk4);
                temp_a1 = temp_v0_2;
                if (temp_v0_2 != 0) {
                    if (arg4 != 1) {
                        if (arg4 != 2) {

                        } else {
                            phi_s1->unk0 = 0x6000000;
                            phi_s1->unk4 = &D_02007818;
                            temp_t5 = phi_s0->unkC;
                            temp_f16_3 = temp_t5;
                            phi_f16_3 = temp_f16_3;
                            if (temp_t5 < 0) {
                                phi_f16_3 = temp_f16_3 + 4294967296.0f;
                            }
                            temp_t6 = phi_s0->unkE;
                            temp_f4 = temp_t6;
                            phi_f4 = temp_f4;
                            if (temp_t6 < 0) {
                                phi_f4 = temp_f4 + 4294967296.0f;
                            }
                            phi_v0_4 = func_80095BD0(phi_s1 + 8, temp_a1, phi_f16_3 + arg2, phi_f4 + arg3, phi_s0->unk8, phi_s0->unkA, arg5, arg6);
                            goto block_34;
                        }
                    } else {
                        phi_s1->unk0 = 0x6000000;
                        phi_s1->unk4 = &D_020077F8;
                        temp_t1 = phi_s0->unkC;
                        temp_f18 = temp_t1;
                        phi_f18 = temp_f18;
                        if (temp_t1 < 0) {
                            phi_f18 = temp_f18 + 4294967296.0f;
                        }
                        temp_t2 = phi_s0->unkE;
                        temp_f10 = temp_t2;
                        phi_f10 = temp_f10;
                        if (temp_t2 < 0) {
                            phi_f10 = temp_f10 + 4294967296.0f;
                        }
                        phi_v0_4 = func_80095BD0(phi_s1 + 8, temp_a1, phi_f18 + arg2, phi_f10 + arg3, phi_s0->unk8, phi_s0->unkA, arg5, arg6);
block_34:
                        phi_s1_3 = phi_v0_4;
                    }
                }
            }
            temp_s0 = phi_s0 + 0x14;
            phi_s0 = temp_s0;
            phi_s1 = phi_s1_3;
            phi_s1_2 = phi_s1_3;
        } while (temp_s0->unk4 != 0);
    }
    return phi_s1_2;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009BEF0.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void *func_800963F0(void *, s8, ?, ?, f32, f32, s32, s32, s32, s32, s32, s32, s32, s32, s32); // extern
s32 func_8009B8C4(s32); // extern
void *segmented_to_virtual(?); // extern
extern ? D_02007708;
extern ? D_02007728;
extern ? D_02007768;
extern f32 D_800F1074;

void *func_8009C204(void *arg0, ? arg1, s32 arg2, s32 arg3, s32 arg4) {
    f32 temp_f22;
    s16 temp_v0_2;
    s32 temp_v0_3;
    u16 temp_v0_4;
    u16 temp_v0_5;
    u16 temp_v1;
    u16 temp_v1_2;
    void *temp_v0;
    void *phi_s1;
    void *phi_s0;
    void *phi_s0_2;
    s8 phi_s2;
    void *phi_s0_3;
    void *phi_s0_4;
    void *phi_v0;

    temp_v0 = segmented_to_virtual(arg1);
    phi_s1 = temp_v0;
    phi_s0 = arg0;
    phi_s0_3 = arg0;
    if (temp_v0->unk4 != 0) {
        temp_f22 = D_800F1074;
        do {
            temp_v0_2 = phi_s1->unk0;
            phi_s2 = 0;
            if (temp_v0_2 != 0) {
                if (temp_v0_2 != 1) {
                    if (temp_v0_2 != 3) {
                        phi_s0->unk0 = 0x6000000;
                        phi_s0->unk4 = &D_02007728;
                        phi_s0_2 = phi_s0 + 8;
                    } else {
                        phi_s0->unk4 = &D_02007768;
                        phi_s0->unk0 = 0x6000000;
                        phi_s0_2 = phi_s0 + 8;
                        phi_s2 = 3;
                    }
                } else {
                    phi_s0->unk0 = 0x6000000;
                    phi_s0->unk4 = &D_02007728;
                    phi_s0_2 = phi_s0 + 8;
                }
            } else {
                phi_s0->unk0 = 0x6000000;
                phi_s0->unk4 = &D_02007708;
                phi_s0_2 = phi_s0 + 8;
            }
            temp_v0_3 = func_8009B8C4(phi_s1->unk4);
            phi_s0_4 = phi_s0_2;
            if (arg4 != 2) {
                if (arg4 != 3) {

                } else {
                    temp_v0_4 = phi_s1->unk8;
                    temp_v1 = phi_s1->unkA;
                    phi_v0 = func_800963F0(phi_s0_2, phi_s2, 0x400, 0x400, temp_f22, 0.5f, 0, 0, temp_v0_4, temp_v1, phi_s1->unkC + arg2, phi_s1->unkE + arg3, temp_v0_3, temp_v0_4, temp_v1);
                    goto block_14;
                }
            } else {
                temp_v0_5 = phi_s1->unk8;
                temp_v1_2 = phi_s1->unkA;
                phi_v0 = func_800963F0(phi_s0_2, phi_s2, 0x400, 0x400, 0.5f, 0.5f, 0, 0, temp_v0_5, temp_v1_2, phi_s1->unkC + arg2, phi_s1->unkE + arg3, temp_v0_3, temp_v0_5, temp_v1_2);
block_14:
                phi_s0_4 = phi_v0;
            }
            phi_s1 += 0x14;
            phi_s0 = phi_s0_4;
            phi_s0_3 = phi_s0_4;
        } while (phi_s1->unk18 != 0);
    }
    return phi_s0_3;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009C204.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void *func_80095E10(void *, s8, ?, ?, s32, s32, s32, s32, s32, s32, s32, s32, s32); // extern
void *func_800963F0(void *, s8, ?, ?, f32, f32, s32, s32, s32, s32, s32, s32, s32, s32, s32); // extern
void *func_80097E58(void *, s8, ?, ?, s32, s32, s32, s32, s32, s32, s32, s32); // extern
void *segmented_to_virtual(s32); // extern
extern ? D_02007708;
extern ? D_02007728;
extern ? D_02007768;
extern s32 D_8018D9B0;
extern ? D_8018E11C;
extern ? D_8018E124;

void *func_8009C434(void *arg0, void *arg1, s32 arg2, s32 arg3, s32 arg4) {
    s16 temp_v0_2;
    u16 temp_v0_3;
    u16 temp_v0_4;
    u16 temp_v0_5;
    u16 temp_v1;
    u16 temp_v1_2;
    u16 temp_v1_3;
    void *temp_v0;
    void *phi_s0;
    void *phi_s1;
    void *phi_s1_2;
    s8 phi_t1;
    s32 phi_t0;
    void *phi_s1_3;
    void *phi_s1_4;
    void *phi_v0;

    temp_v0 = segmented_to_virtual(*(arg1->unk0 + (arg1->unk4 * 8)));
    phi_s0 = temp_v0;
    phi_s1 = arg0;
    phi_s1_3 = arg0;
    if (temp_v0->unk4 != 0) {
        do {
            temp_v0_2 = phi_s0->unk0;
            phi_t1 = 0;
            if (temp_v0_2 != 0) {
                if (temp_v0_2 != 1) {
                    if (temp_v0_2 != 3) {
                        phi_s1->unk0 = 0x6000000;
                        phi_s1->unk4 = &D_02007728;
                        phi_s1_2 = phi_s1 + 8;
                    } else {
                        phi_s1->unk4 = &D_02007768;
                        phi_s1->unk0 = 0x6000000;
                        phi_s1_2 = phi_s1 + 8;
                        phi_t1 = 3;
                    }
                } else {
                    phi_s1->unk0 = 0x6000000;
                    phi_s1->unk4 = &D_02007728;
                    phi_s1_2 = phi_s1 + 8;
                }
            } else {
                phi_s1->unk0 = 0x6000000;
                phi_s1->unk4 = &D_02007708;
                phi_s1_2 = phi_s1 + 8;
            }
            phi_s1_4 = phi_s1_2;
            if (arg1->unk14 != 0) {
                phi_t0 = *(&D_8018E124 + (arg1->unk10 * 8));
            } else {
                phi_t0 = *(&D_8018E11C + (arg1->unk10 * 8));
            }
            if (arg4 >= 0) {
                temp_v0_3 = phi_s0->unk8;
                temp_v1 = phi_s0->unkA;
                phi_v0 = func_80097E58(phi_s1_2, phi_t1, 0, 0, temp_v0_3, temp_v1, phi_s0->unkC + arg2, phi_s0->unkE + arg3, (phi_t0 * 2) + D_8018D9B0, temp_v0_3, temp_v1, arg4);
                goto block_18;
            }
            if (arg4 != -2) {
                if (arg4 == -1) {
                    temp_v0_4 = phi_s0->unk8;
                    temp_v1_2 = phi_s0->unkA;
                    phi_v0 = func_80095E10(phi_s1_2, phi_t1, 0x400, 0x400, 0, 0, temp_v0_4, temp_v1_2, phi_s0->unkC + arg2, phi_s0->unkE + arg3, (phi_t0 * 2) + D_8018D9B0, temp_v0_4, temp_v1_2);
                    goto block_18;
                }
            } else {
                temp_v0_5 = phi_s0->unk8;
                temp_v1_3 = phi_s0->unkA;
                phi_v0 = func_800963F0(phi_s1_2, phi_t1, 0x400, 0x400, 0.5f, 0.5f, 0, 0, temp_v0_5, temp_v1_3, phi_s0->unkC + arg2, phi_s0->unkE + arg3, (phi_t0 * 2) + D_8018D9B0, temp_v0_5, temp_v1_3);
block_18:
                phi_s1_4 = phi_v0;
            }
            phi_s0 += 0x14;
            phi_s1 = phi_s1_4;
            phi_s1_3 = phi_s1_4;
        } while (phi_s0->unk18 != 0);
    }
    return phi_s1_3;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009C434.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void *func_80097E58(void *, s8, ?, ?, s32, s32, s32, s32, u8 *, s32, s32, s32); // extern
void *segmented_to_virtual(s32); // extern
extern ? D_02007708;
extern ? D_02007728;
extern ? D_02007748;
extern ? D_02007768;

void *func_8009C708(void *arg0, void *arg1, s32 arg2, s32 arg3, s32 arg4, s32 arg5) {
    s16 temp_v0_2;
    u16 temp_v0_3;
    u16 temp_v1;
    void *temp_v0;
    void *phi_s1;
    void *phi_s0;
    void *phi_s0_2;
    s8 phi_t0;
    void *phi_s0_3;
    void *phi_s0_4;

    temp_v0 = segmented_to_virtual(*(arg1->unk0 + (arg1->unk4 * 8)));
    phi_s1 = temp_v0;
    phi_s0 = arg0;
    phi_s0_3 = arg0;
    if (temp_v0->unk4 != 0) {
        do {
            temp_v0_2 = phi_s1->unk0;
            phi_t0 = 0;
            if (temp_v0_2 != 0) {
                if (temp_v0_2 != 1) {
                    if (temp_v0_2 != 2) {
                        if (temp_v0_2 != 3) {
                            phi_s0->unk0 = 0x6000000;
                            phi_s0->unk4 = &D_02007728;
                            phi_s0_2 = phi_s0 + 8;
                        } else {
                            phi_s0->unk4 = &D_02007768;
                            phi_s0->unk0 = 0x6000000;
                            phi_s0_2 = phi_s0 + 8;
                            phi_t0 = 3;
                        }
                    } else {
                        phi_s0->unk4 = &D_02007748;
                        phi_s0->unk0 = 0x6000000;
                        phi_s0_2 = phi_s0 + 8;
                    }
                } else {
                    phi_s0->unk0 = 0x6000000;
                    phi_s0->unk4 = &D_02007728;
                    phi_s0_2 = phi_s0 + 8;
                }
            } else {
                phi_s0->unk0 = 0x6000000;
                phi_s0->unk4 = &D_02007708;
                phi_s0_2 = phi_s0 + 8;
            }
            phi_s0_4 = phi_s0_2;
            if (arg5 >= 0) {
                temp_v0_3 = phi_s1->unk8;
                temp_v1 = phi_s1->unkA;
                phi_s0_4 = func_80097E58(phi_s0_2, phi_t0, 0, 0, temp_v0_3, temp_v1, phi_s1->unkC + arg2, phi_s1->unkE + arg3, &D_802BFB80[(arg1->unk14 << 0x10) + ((arg4 / 2) << 0xF) + ((arg4 % 2) << 0xD) + 0x4000], temp_v0_3, temp_v1, arg5);
            }
            phi_s1 += 0x14;
            phi_s0 = phi_s0_4;
            phi_s0_3 = phi_s0_4;
        } while (phi_s1->unk18 != 0);
    }
    return phi_s0_3;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009C708.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern s16 D_8015F4AC;
extern s16 D_8015F4AE;
extern s16 D_8015F4B0;
extern s16 D_8015F4B2;
extern s16 D_8015F4EC;
extern s16 D_8015F4EE;
extern s16 D_8015F4F0;
extern s16 D_8015F4F2;
extern s16 D_8015F52C;
extern s16 D_8015F52E;
extern s16 D_8015F530;
extern s16 D_8015F532;
extern s16 D_8015F56C;
extern s16 D_8015F56E;
extern s16 D_8015F570;
extern s16 D_8015F572;
extern ? D_8018E7E8;
extern s16 D_8018E7F0;
extern s16 D_8018E7F8;
extern s16 D_8018E802;
extern ? D_8018E810;
extern s16 D_8018E818;
extern s16 D_8018E822;
extern s16 D_8018E828;

void func_8009C918(void) {
    D_8018E7E8.unk0 = D_8015F4B0;
    D_8018E7E8.unk0 = D_8015F4B2;
    D_8018E810.unk0 = D_8015F4AC;
    D_8018E810.unk0 = D_8015F4AE;
    D_8018E7F0 = D_8015F4F2;
    D_8018E7F0 = D_8015F4F0;
    D_8018E818 = D_8015F4EE;
    D_8018E818 = D_8015F4EC;
    D_8018E7F8 = D_8015F532;
    D_8018E7F8 = D_8015F530;
    D_8018E822 = D_8015F52C;
    D_8018E822 = D_8015F52E;
    D_8018E802 = D_8015F570;
    D_8018E802 = D_8015F572;
    D_8018E828 = D_8015F56E;
    D_8018E828 = D_8015F56C;
    D_8018E7E8.unk20 = 0xA0;
    D_8018E7E8.unk22 = 0x78;
    D_8018E810.unk20 = 0x140;
    D_8018E810.unk22 = 0xF0;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009C918.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_8009CA6C(s32); // extern

void func_8009CA2C(void) {
    s32 temp_s0;
    s32 phi_s0;

    phi_s0 = 0;
    do {
        func_8009CA6C(phi_s0);
        temp_s0 = phi_s0 + 1;
        phi_s0 = temp_s0;
    } while (temp_s0 != 5);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009CA2C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
? func_8009CDDC(s32, ?, s32);                       /* extern */
? func_8009CDFC(s32, ?, s32);                       /* extern */
? func_8009D958(s32, ?, s32);                       /* extern */
? func_8009D978(s32, ?, s32);                       /* extern */
? func_8009D998(s32, ?, s32);                       /* extern */
? func_8009DAA8(Gfx **, ?, s32);                    /* extern */
? func_8009DB8C(Gfx **, ?, s32);                    /* extern */
s32 func_800AAF30(?);                               /* extern */
extern ? D_0D0076F8;
extern ? D_8018E7AC;

void func_8009CA6C(s32 arg0) {
    Gfx *temp_v1;
    u8 temp_t0;
    ? phi_a1;

    if ((arg0 == 4) || ((arg0 = arg0, (func_800AAF30(0xAA) == 0)) && (arg0 = arg0, (func_800AAF30(0xAB) == 0)) && (arg0 = arg0, (func_800AAF30(0xB9) == 0)) && (arg0 = arg0, (func_800AAF30(0xBA) == 0)) && (arg0 = arg0, (func_800AAF30(0xAC) == 0)) && (arg0 = arg0, (func_800AAF30(0xB0) == 0)))) {
        temp_v1 = gDisplayListHead;
        gDisplayListHead = temp_v1 + 8;
        temp_v1->words.w0 = 0x6000000;
        temp_v1->words.w1 = &D_0D0076F8;
        phi_a1 = 0;
        if ((arg0 != 4) && (D_800DC5FC != 0)) {
            phi_a1 = 1;
        }
        temp_t0 = *(&D_8018E7AC + arg0);
        switch (temp_t0) {
        case 1:
            func_8009CDDC(arg0, phi_a1, arg0);
            return;
        case 2:
            func_8009D958(arg0, phi_a1, arg0);
            return;
        case 3:
            func_8009DB8C(&gDisplayListHead, phi_a1, arg0);
            return;
        case 4:
            func_8009DAA8(&gDisplayListHead, phi_a1, arg0);
            return;
        case 5:
            func_8009D998(arg0, phi_a1, arg0);
            return;
        case 7:
            func_8009D978(arg0, phi_a1, arg0);
            return;
        case 8:
            func_8009CDFC(arg0, phi_a1, arg0);
            /* Duplicate return node #19. Try simplifying control flow for better match */
            return;
        }
    } else {
    default:
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009CA6C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 draw_box(s32, s32, s32, s32, s32, s32, s32, s32, s32); // extern
extern ? D_800E7AE8;
extern ? D_8015F480;
extern ? D_8018E7AC;
extern ? D_8018E7B8;
extern ? D_8018E7D0;
extern ? D_8018E7E8;
extern ? D_8018E810;
extern s8 D_8018EE0C;
extern s32 gDisplayListHead;

void func_8009CBE4(s32 arg0, s32 arg1, s32 arg2) {
    u32 *sp40;
    u32 *sp3C;
    s32 temp_t0;
    s32 temp_t1;
    s32 temp_v0;
    s32 temp_v0_2;
    s32 temp_v0_4;
    s32 temp_v1_3;
    u32 *temp_t4;
    u32 *temp_t9;
    u32 temp_t6;
    void *temp_a0;
    void *temp_a0_2;
    void *temp_v0_3;
    void *temp_v0_5;
    void *temp_v1;
    void *temp_v1_2;
    s16 phi_t2;
    s32 phi_t5;
    s16 phi_t3;
    s32 phi_ra;

    temp_v0 = gModeSelection;
    if ((temp_v0 == GRAND_PRIX) || (temp_v0 == TIME_TRIALS)) {
        temp_v0_4 = arg0 * 8;
        temp_v1_2 = temp_v0_4 + &D_8018E7E8;
        temp_a0_2 = temp_v0_4 + &D_8018E810;
        phi_t2 = temp_v1_2->unk0;
        phi_t5 = temp_a0_2->unk0;
        phi_t3 = temp_v1_2->unk2;
        phi_ra = temp_a0_2->unk2;
    } else {
        temp_v0_2 = arg0 * 8;
        if (arg0 >= 4) {
            temp_v1 = temp_v0_2 + &D_8018E7E8;
            temp_a0 = temp_v0_2 + &D_8018E810;
            phi_t2 = temp_v1->unk0;
            phi_t5 = temp_a0->unk0;
            phi_t3 = temp_v1->unk2;
            phi_ra = temp_a0->unk2;
        } else {
            temp_v0_3 = (arg0 << 6) + &D_8015F480;
            phi_t2 = temp_v0_3->unk30;
            phi_t5 = temp_v0_3->unk2C;
            phi_t3 = temp_v0_3->unk32;
            phi_ra = temp_v0_3->unk2E;
        }
    }
    temp_v0_5 = (arg2 * 8) + &D_800E7AE8;
    temp_t1 = arg0 * 4;
    temp_t4 = temp_t1 + &D_8018E7D0;
    temp_v1_3 = phi_t5 / 2;
    temp_t0 = phi_ra / 2;
    temp_t9 = temp_t1 + &D_8018E7B8;
    sp3C = temp_t9;
    sp40 = temp_t4;
    gDisplayListHead = draw_box(gDisplayListHead, phi_t2 - temp_v1_3, phi_t3 - temp_t0, temp_v1_3 + phi_t2, temp_t0 + phi_t3, temp_v0_5->unk0, temp_v0_5->unk2, temp_v0_5->unk4, 0xFF - ((*temp_t4 * 0xFF) / *temp_t9));
    if ((arg1 == 0) && (temp_t6 = *temp_t4 + 1, *temp_t4 = temp_t6, ((temp_t6 < *sp3C) == 0))) {
        if (D_800DC50C == 4) {
            *(&D_8018E7AC + arg0) = 6;
            return;
        }
        *(&D_8018E7AC + arg0) = 0;
        D_8018EE0C = 0;
        // Duplicate return node #11. Try simplifying control flow for better match
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009CBE4.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_8009CBE4(?); // extern

void func_8009CDDC(void) {
    func_8009CBE4(0);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009CDDC.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_8009CBE4(?); // extern

void func_8009CDFC(void) {
    func_8009CBE4(1);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009CDFC.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800C3448(?); // extern
extern u8 gSoundMode;

void func_8009CE1C(void) {
    if ((gSoundMode != 3) && (gPlayerCountSelection1 >= 2)) {
        func_800C3448(0xE0000002);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009CE1C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
? func_8000F124(s8, s32);                           /* extern */
? func_8009CE1C(s32 *, s32, s32);                   /* extern */
void *func_800AAF30(?, s32, s32);                   /* extern */
? func_80290338();                                  /* extern */
? func_80290360();                                  /* extern */
? func_80290388();                                  /* extern */
? func_802903B0();                                  /* extern */
extern ? D_8018E7AC;
extern ? D_8018E7B0;
static ? gCupSelectionByCourseId;                                /* unable to generate initializer; const */
static ? D_800E86A8;                                /* unable to generate initializer; const */
static ? gPerCupIndexByCourseId;                                /* unable to generate initializer; const */
s16 D_800DC644;                                     /* unable to generate initializer */
s16 gCurrentCourseId;                               /* unable to generate initializer */

void func_8009CE64(s32 *arg0, s32 arg2, s32 arg3) {
    s32 sp28;
    s8 *sp18;
    s16 temp_a0;
    s16 temp_a0_2;
    s32 temp_t6;
    s32 temp_t6_2;
    s32 temp_v0;
    s32 temp_v0_7;
    s32 temp_v0_8;
    s32 temp_v1;
    s32 temp_v1_2;
    s32 temp_v1_3;
    s32 temp_v1_5;
    s32 temp_v1_6;
    s32 temp_v1_8;
    s8 *temp_v0_2;
    s8 temp_v1_4;
    s8 temp_v1_7;
    s8 temp_v1_9;
    u32 temp_t9;
    void *temp_v0_3;
    void *temp_v0_4;
    void *temp_v0_5;
    void *temp_v0_6;
    s32 phi_a1;
    s32 phi_a1_2;
    s32 phi_a1_3;
    s32 phi_t7;
    s32 *phi_a0;
    s32 phi_a2;
    s32 phi_v0;

    temp_v0 = D_800DC50C;
    phi_a1 = 0;
    phi_a1_2 = 0;
    phi_a1_3 = 0;
    phi_a0 = arg0;
    phi_a2 = arg3;
    phi_a2 = arg3;
    phi_a2 = arg3;
    if (temp_v0 == 5) {
        temp_v1 = gCCSelection;
        if ((temp_v1 != CC_150) && (temp_v1 != CC_EXTRA)) {

        } else if ((D_802874F5 < 3) && (gCupSelection == SPECIAL_CUP)) {
            phi_a1 = 1;
        }
        if (phi_a1 != 0) {
            D_80287550 = 9;
            D_800DC644 = 8;
            return;
        }
        D_80287550 = 1;
        D_800E86A0 = 0xB;
        return;
    }
    if (temp_v0 == 4) {
        temp_v0_2 = arg0 + &D_8018E7AC;
        if (*temp_v0_2 == 2) {
            if (temp_v0_2 != &D_8018E7B0) {
                *temp_v0_2 = 5;
                return;
            }
            sp18 = temp_v0_2;
            sp28 = 0;
            temp_v0_3 = func_800AAF30(0xB0, 0, 2);
            if (temp_v0_3 != 0) {
                temp_v1_2 = temp_v0_3->unk4;
                if (temp_v1_2 != 0xA) {
                    if (temp_v1_2 != 0xB) {
                        if (temp_v1_2 != 0xC) {
                            if (temp_v1_2 != 0xD) {

                            }
                            func_80290338();
                            return;
                        }
                        func_80290360();
                        return;
                    }
                    func_80290388();
                    return;
                }
                func_802903B0();
                return;
            }
            sp28 = 0;
            temp_v0_4 = func_800AAF30(0xAC, 0);
            if (temp_v0_4 != 0) {
                temp_v1_3 = temp_v0_4->unk4;
                if (temp_v1_3 != 0xB) {
                    if (temp_v1_3 != 0xC) {

                    }
                    func_80290338();
                    return;
                }
                func_802903B0();
                D_8016556E = 1;
                return;
            }
            sp28 = 0;
            temp_v0_5 = func_800AAF30(0xC7, 0);
            if (temp_v0_5 != 0) {
                temp_t6 = temp_v0_5->unk4;
                switch (temp_t6) {                  /* switch 1 */
                case 12:                            /* switch 1 */
                    func_802903B0();
                    phi_a1_2 = 1;
                    break;
                case 13:                            /* switch 1 */
                case 22:                            /* switch 1 */
                case 42:                            /* switch 1 */
                    func_80290388();
                    phi_a1_2 = 1;
                    break;
                case 14:                            /* switch 1 */
                case 23:                            /* switch 1 */
                case 43:                            /* switch 1 */
                    func_80290360();
                    phi_a1_2 = 1;
                    break;
                case 15:                            /* switch 1 */
                case 24:                            /* switch 1 */
                case 32:                            /* switch 1 */
                case 44:                            /* switch 1 */
                    func_80290338();
                    phi_a1_2 = 1;
                    break;
                default:                            /* switch 1 */
                    *sp18 = 5;
                    break;
                }
                phi_a1_3 = phi_a1_2;
                if (phi_a1_2 != 0) {
                    D_800DC5FC = 0;
                }
            }
            temp_v0_6 = func_800AAF30(0xBD, phi_a1_3);
            if (temp_v0_6 != 0) {
                temp_t6_2 = temp_v0_6->unk4;
                switch (temp_t6_2) {                /* switch 2 */
                case 11:                            /* switch 2 */
                    D_8015F892 = 1;
                    D_8015F890 = 0;
                    func_802903B0();
                    return;
                case 12:                            /* switch 2 */
                    D_8015F892 = 0;
                    D_8015F890 = 0;
                    func_80290388();
                    return;
                case 13:                            /* switch 2 */
                    D_8015F892 = 0;
                    D_8015F890 = 0;
                    func_80290360();
                    return;
                case 14:                            /* switch 2 */
                    D_8015F892 = 0;
                    D_8015F890 = 0;
                    func_80290338();
                    return;
                case 15:                            /* switch 2 */
                    D_8015F892 = 0;
                    D_8015F890 = 1;
                    func_802903B0();
                    return;
                }
            } else {
                *sp18 = 5;
            }
        } else {
            /* Duplicate return node #115. Try simplifying control flow for better match */
        }
    } else {
        *(&D_8018E7AC + arg0) = 0;
        if (D_8018EDEF != 0x40) {
            temp_t9 = D_8018EDE0;
            switch (temp_t9) {                      /* switch 3 */
            case 0:                                 /* switch 3 */
                temp_v0_7 = D_800E86A0;
                phi_t7 = temp_v0_7 + 1;
                phi_a0 = &D_800E86A0;
                phi_a2 = 2;
                phi_a2 = 2;
                if (temp_v0_7 == 8) {
                    D_800E86A0 = 0xA;
                    D_800E86A4 = 2;
                } else {
block_74:
                    D_800E86A0 = phi_t7;
                    phi_a0 = &D_800E86A0;
                }
                break;
            case 1:                                 /* switch 3 */
                D_800E86A0 += -1;
                phi_a0 = &D_800E86A0;
                break;
            // Setting up game state for title screen demos
            case 2:                                 /* switch 3 */
                D_800DC51C = 1;
                D_8018EE08 = 1;
                D_800DC524 = 4;
                gCCSelection = CC_100;
                switch (gNextDemoId) {                /* switch 4 */
                case DEMO_ONE:                             /* switch 4 */
                    gCurrentCourseId = COURSE_MARIO_RACEWAY;
                    D_800DC530 = 0;
                    gPlayerCountSelection1 = 1;
                    D_8018EDF3 = 1;
                    D_800E86A8[0] = MARIO;
                    gModeSelection = GRAND_PRIX;
                    break;
                case DEMO_TWO:                             /* switch 4 */
                    gCurrentCourseId = COURSE_CHOCO_MOUNTAIN;
                    D_800DC530 = 1;
                    gPlayerCountSelection1 = 2;
                    D_8018EDF3 = 2;
                    D_800E86A8[0] = YOSHI;
                    D_800E86A8[1] = DK;
                    gModeSelection = VERSUS;
                    phi_a2 = 2;
                    break;
                case DEMO_THREE:                             /* switch 4 */
                    gCurrentCourseId = COURSE_KALAMARI_DESERT;
                    D_800DC530 = 0;
                    gPlayerCountSelection1 = 1;
                    D_8018EDF3 = 1;
                    D_800E86A8[0] = LUIGI;
                    gModeSelection = GRAND_PRIX;
                    break;
                case DEMO_FOUR:                             /* switch 4 */
                    gCurrentCourseId = COURSE_WARIO_STADIUM;
                    D_800DC530 = 3;
                    gPlayerCountSelection1 = 3;
                    D_8018EDF3 = 3;
                    D_800E86A8[0] = WARIO;
                    D_800E86A8[1] = YOSHI;
                    D_800E86A8[2] = BOWSER;
                    gModeSelection = VERSUS;
                    phi_a2 = 2;
                    break;
                case DEMO_FIVE:                             /* switch 4 */
                    gCurrentCourseId = COURSE_BOWSER_CASTLE;
                    D_800DC530 = 0;
                    gPlayerCountSelection1 = 1;
                    D_8018EDF3 = 1;
                    D_800E86A8[0] = BOWSER;
                    gModeSelection = GRAND_PRIX;
                    phi_a2 = 2;
                    break;
                case DEMO_SIX:                             /* switch 4 */
                    gCurrentCourseId = COURSE_SHERBET_LAND;
                    D_800DC530 = 3;
                    gPlayerCountSelection1 = 4;
                    D_8018EDF3 = 4;
                    D_800E86A8[0] = MARIO;
                    D_800E86A8[1] = LUIGI;
                    D_800E86A8[2] = PEACH;
                    D_800E86A8[3] = TOAD;
                    gModeSelection = VERSUS;
                    phi_a2 = 2;
                    break;
                }
                gNextDemoId += 1;
                if (gNextDemoId >= NUM_DEMOS) {
                    gNextDemoId = DEMO_ONE;
                }
                gCupSelection = gCupSelectionByCourseId[gCurrentCourseId];
                D_800DC540 = gCupSelection;
                gCupCourseSelection = gPerCupIndexByCourseId[gCurrentCourseId];
                phi_a0 = gCurrentCourseId;
                break;
            case 3:                                 /* switch 3 */
                temp_v1_5 = D_800E86A0;
                phi_a0 = &D_800E86A0;
                if (temp_v1_5 != 6) {
                    if (temp_v1_5 == 0xB) {
                        D_800E86A0 = 6;
                    }
                } else {
                    D_800E86A0 = 0xB;
                }
                break;
            case 4:                                 /* switch 3 */
                temp_v1_6 = D_800E86A0;
                phi_t7 = 0xB;
                phi_a0 = &D_800E86A0;
                if (temp_v1_6 != 5) {
                    if (temp_v1_6 == 0xB) {
                        D_800E86A0 = 5;
                    }
                } else {
                    goto block_74;
                }
                break;
            }
            if (D_800E86A4 == 0) {
                D_800E86A4 = 1;
            }
            if (D_800E86A0 >= 0xE) {
                D_800DC524 = 4;
                if (gModeSelection == TIME_TRIALS) {
                    D_8018EDFB = 1;
                }
                func_8009CE1C(phi_a0, 1, phi_a2);
            }
            D_8018EE0C = 0;
            return;
        }
        temp_v1_7 = D_8018EDFA;
        if (temp_v1_7 != 1) {
            if ((temp_v1_7 != 2) && (temp_v1_7 != 3)) {
                D_800DC524 = 4;
                if (gModeSelection == TIME_TRIALS) {
                    D_8018EDFB = 1;
                }
            } else {
                D_800DC524 = 9;
                D_800DC644 = 8;
            }
        } else {
            D_800DC524 = 5;
        }
        func_8000F124(1, 2);
        if ((D_800DC530 == 3) && ((temp_v1_8 = gModeSelection, (temp_v1_8 == 0)) || (temp_v1_8 == 1))) {
            gModeSelection = VERSUS;
        }
        temp_a0_2 = gCurrentCourseId;
        if ((temp_a0_2 != 0xF) && (temp_a0_2 != 0x10) && (temp_a0_2 != 0x11) && (temp_a0_2 != 0x13)) {
            temp_v0_8 = gModeSelection;
            phi_v0 = temp_v0_8;
            if (temp_v0_8 == 3) {
                gModeSelection = GRAND_PRIX;
                phi_v0 = 0;
            }
            if ((phi_v0 == 2) && (gPlayerCountSelection1 == 1)) {
                gModeSelection = GRAND_PRIX;
            }
        } else {
            gModeSelection = BATTLE;
            if (gPlayerCountSelection1 == 1) {
                D_8018EDF3 = 2;
                D_800DC530 = 1;
                gPlayerCountSelection1 = D_8018EDF3;
            }
        }
        gCupSelection = gCupSelectionByCourseId[gCurrentCourseId];
        temp_v1_9 = D_8018EDFA;
        D_800DC540 = gCupSelection;
        gCupCourseSelection = gPerCupIndexByCourseId[gCurrentCourseId];
        if (temp_v1_9 != 1) {
            if (temp_v1_9 != 2) {
                if (temp_v1_9 != 3) {
                    if (gCCSelection == CC_EXTRA) {
                        gIsMirrorMode = 1;
                        return;
                    }
                    gIsMirrorMode = 0;
                    /* Duplicate return node #115. Try simplifying control flow for better match */
                    return;
                }
                gCCSelection = CC_EXTRA;
                return;
            }
            gCCSelection = CC_50;
            return;
        }
    default:                                        /* switch 2 */
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009CE64.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 draw_box(s32, s32, s32, s32, s32, s32, s32, s32, u32); // extern
? func_8009CE64(s32); // extern
extern ? D_800E7AE8;
extern ? D_8015F480;
extern ? D_8018E7B8;
extern ? D_8018E7D0;
extern ? D_8018E7E8;
extern ? D_8018E810;
extern s32 gDisplayListHead;

void func_8009D77C(s32 arg0, s32 arg1, s32 arg2) {
    s32 sp44;
    u32 *sp3C;
    u32 *sp38;
    s32 temp_t8;
    s32 temp_v0;
    s32 temp_v0_2;
    s32 temp_v0_4;
    s32 temp_v0_5;
    s32 temp_v1_3;
    u32 *temp_t1;
    u32 *temp_t5;
    u32 temp_lo;
    u32 temp_t6;
    void *temp_a0;
    void *temp_a0_2;
    void *temp_v0_3;
    void *temp_v0_6;
    void *temp_v1;
    void *temp_v1_2;
    s16 phi_t3;
    s32 phi_ra;
    s16 phi_t4;
    u32 phi_t2;

    temp_v0 = gModeSelection;
    if ((temp_v0 == GRAND_PRIX) || (temp_v0 == TIME_TRIALS)) {
        temp_v0_4 = arg0 * 8;
        temp_a0_2 = temp_v0_4 + &D_8018E810;
        temp_v1_2 = temp_v0_4 + &D_8018E7E8;
        sp44 = temp_a0_2->unk2;
        phi_t3 = temp_v1_2->unk0;
        phi_ra = temp_a0_2->unk0;
        phi_t4 = temp_v1_2->unk2;
    } else if (arg0 >= 4) {
        temp_v0_2 = arg0 * 8;
        temp_a0 = temp_v0_2 + &D_8018E810;
        temp_v1 = temp_v0_2 + &D_8018E7E8;
        sp44 = temp_a0->unk2;
        phi_t3 = temp_v1->unk0;
        phi_ra = temp_a0->unk0;
        phi_t4 = temp_v1->unk2;
    } else {
        temp_v0_3 = (arg0 << 6) + &D_8015F480;
        sp44 = temp_v0_3->unk2E;
        phi_t3 = temp_v0_3->unk30;
        phi_ra = temp_v0_3->unk2C;
        phi_t4 = temp_v0_3->unk32;
    }
    temp_v0_5 = arg0 * 4;
    temp_t1 = temp_v0_5 + &D_8018E7D0;
    temp_t5 = temp_v0_5 + &D_8018E7B8;
    temp_lo = (*temp_t1 * 0xFF) / *temp_t5;
    phi_t2 = temp_lo;
    if (temp_lo >= 0x100) {
        phi_t2 = 0xFF;
    }
    temp_v1_3 = phi_ra / 2;
    temp_t8 = sp44 / 2;
    temp_v0_6 = (arg2 * 8) + &D_800E7AE8;
    sp3C = temp_t1;
    sp38 = temp_t5;
    gDisplayListHead = draw_box(gDisplayListHead, phi_t3 - temp_v1_3, phi_t4 - temp_t8, temp_v1_3 + phi_t3, temp_t8 + phi_t4, temp_v0_6->unk0, temp_v0_6->unk2, temp_v0_6->unk4, phi_t2);
    if (arg1 == 0) {
        temp_t6 = *temp_t1 + 1;
        *temp_t1 = temp_t6;
        if ((*temp_t5 + 1) < temp_t6) {
            func_8009CE64(arg0);
        }
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009D77C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_8009D77C(?); // extern

void func_8009D958(void) {
    func_8009D77C(0);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009D958.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_8009D77C(?); // extern

void func_8009D978(void) {
    func_8009D77C(1);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009D978.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 draw_box(s32, s32, s32, s32, s32, s32, s32, s32, s32); // extern
extern ? D_8015F480;
extern ? D_8018E7E8;
extern ? D_8018E810;
extern s32 gDisplayListHead;

void func_8009D998(s32 arg0) {
    s32 temp_v0;
    s32 temp_v0_2;
    s32 temp_v0_4;
    s32 temp_v0_5;
    s32 temp_v1_3;
    void *temp_a0;
    void *temp_a0_2;
    void *temp_v0_3;
    void *temp_v1;
    void *temp_v1_2;
    s16 phi_t0;
    s32 phi_t2;
    s16 phi_t1;
    s32 phi_t3;

    temp_v0 = gModeSelection;
    if ((temp_v0 == GRAND_PRIX) || (temp_v0 == TIME_TRIALS)) {
        temp_v0_4 = arg0 * 8;
        temp_v1_2 = temp_v0_4 + &D_8018E7E8;
        temp_a0_2 = temp_v0_4 + &D_8018E810;
        phi_t0 = temp_v1_2->unk0;
        phi_t2 = temp_a0_2->unk0;
        phi_t1 = temp_v1_2->unk2;
        phi_t3 = temp_a0_2->unk2;
    } else {
        temp_v0_2 = arg0 * 8;
        if (arg0 >= 4) {
            temp_v1 = temp_v0_2 + &D_8018E7E8;
            temp_a0 = temp_v0_2 + &D_8018E810;
            phi_t0 = temp_v1->unk0;
            phi_t2 = temp_a0->unk0;
            phi_t1 = temp_v1->unk2;
            phi_t3 = temp_a0->unk2;
        } else {
            temp_v0_3 = (arg0 << 6) + &D_8015F480;
            phi_t0 = temp_v0_3->unk30;
            phi_t2 = temp_v0_3->unk2C;
            phi_t1 = temp_v0_3->unk32;
            phi_t3 = temp_v0_3->unk2E;
        }
    }
    temp_v0_5 = phi_t2 / 2;
    temp_v1_3 = phi_t3 / 2;
    gDisplayListHead = draw_box(gDisplayListHead, phi_t0 - temp_v0_5, phi_t1 - temp_v1_3, temp_v0_5 + phi_t0, temp_v1_3 + phi_t1, 0, 0, 0, 0xFF);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009D998.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void *draw_box(void *, ?, ?, ?, s32, s32, s32, s32, u32); // extern
? func_8009CE64(?, ? *); // extern
extern u32 D_8018E7C8;
extern ? D_8018E7D0;
extern void *gDisplayListHead;

void func_8009DAA8(void) {
    u32 temp_lo;
    u32 temp_t8;
    void *temp_v1;
    u32 phi_t0;

    temp_t8 = D_8018E7D0.unk10 + 1;
    D_8018E7D0.unk10 = temp_t8;
    if (temp_t8 >= (D_8018E7C8 + 1)) {
        func_8009CE64(4, &D_8018E7D0);
    }
    temp_v1 = gDisplayListHead;
    gDisplayListHead = temp_v1 + 8;
    temp_v1->unk4 = 0;
    temp_v1->unk0 = 0xE7000000;
    temp_lo = (D_8018E7D0.unk10 * 0xFF) / D_8018E7C8;
    phi_t0 = temp_lo;
    if (temp_lo >= 0x100) {
        phi_t0 = 0xFF;
    }
    gDisplayListHead = draw_box(gDisplayListHead, 0, 0, 0x140, 0xF0, 0, 0, 0, phi_t0);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009DAA8.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void *draw_box(void *, ?, ?, ?, s32, s32, s32, s32, u32); // extern
? func_8009CE64(?); // extern
extern s32 D_8018D9B8;
extern u32 D_8018E7C8;
extern ? D_8018E7D0;
extern void *gDisplayListHead;

void func_8009DB8C(void) {
    s32 temp_s0;
    s32 temp_s0_2;
    s32 temp_s0_3;
    s32 temp_t4;
    s32 temp_t5;
    u32 temp_lo;
    u32 temp_t7;
    u32 temp_v0;
    u32 temp_v0_2;
    void *temp_a0;
    void *temp_a1;
    void *temp_a1_2;
    void *temp_a1_3;
    void *temp_v0_3;
    void *temp_v1;
    s32 phi_s0;
    s32 phi_s0_2;
    u32 phi_v0;
    u32 phi_s3;
    s32 phi_s0_3;
    u32 phi_v1;
    u32 phi_s3_2;

    temp_t7 = D_8018E7D0.unk10 + 1;
    D_8018E7D0.unk10 = temp_t7;
    temp_v0 = D_8018E7C8;
    phi_v0 = temp_v0;
    if (temp_t7 >= temp_v0) {
        phi_s0 = 0;
        if (temp_t7 == temp_v0) {
            do {
                *(D_8018D9B8 + phi_s0) = 1;
                (D_8018D9B8 + phi_s0)->unk1 = 1;
                (D_8018D9B8 + phi_s0)->unk2 = 1;
                temp_s0 = phi_s0 + 4;
                (D_8018D9B8 + phi_s0)->unk3 = 1;
                phi_s0 = temp_s0;
            } while (temp_s0 != 0x4B0);
        } else {
            func_8009CE64(4);
        }
        goto block_14;
    }
    phi_s0_2 = 0;
    phi_s0_2 = 0;
    phi_s3_2 = 0;
    if ((0x4B0 / temp_v0) != 0) {
        do {
            phi_s3 = phi_s3_2;
            if ((*(D_8018D9B8 + phi_s0_2) == 0) && (random_int(((0x4B0 - D_8018E7D0.unk10) / phi_v0) & 0xFFFF) == 0)) {
                *(D_8018D9B8 + phi_s0_2) = 1;
                phi_s3 = phi_s3_2 + 1;
            }
            temp_v0_2 = D_8018E7C8;
            temp_s0_2 = phi_s0_2 + 1;
            phi_v0 = temp_v0_2;
            phi_s0_2 = temp_s0_2;
            phi_s3_2 = phi_s3;
            if (temp_s0_2 >= 0x4B0) {

            }
        } while (phi_s3 < (0x4B0 / temp_v0_2));
block_14:
    }
    temp_v0_3 = gDisplayListHead;
    gDisplayListHead = temp_v0_3 + 8;
    temp_v0_3->unk4 = 0;
    temp_v0_3->unk0 = 0xE7000000;
    temp_v1 = gDisplayListHead;
    gDisplayListHead = temp_v1 + 8;
    temp_v1->unk0 = 0xB900031D;
    temp_v1->unk4 = 0x504240;
    temp_a0 = gDisplayListHead;
    gDisplayListHead = temp_a0 + 8;
    temp_a0->unk4 = 0xFF;
    temp_a0->unk0 = 0xFA000000;
    temp_a1 = gDisplayListHead;
    gDisplayListHead = temp_a1 + 8;
    temp_a1->unk4 = 0xFFFDF6FB;
    temp_a1->unk0 = 0xFCFFFFFF;
    phi_s0_3 = 0;
    do {
        if (*(D_8018D9B8 + phi_s0_3) != 0) {
            temp_a1_2 = gDisplayListHead;
            temp_t4 = (phi_s0_3 % 0x28) * 8;
            gDisplayListHead = temp_a1_2 + 8;
            temp_t5 = (phi_s0_3 / 0x28) * 8;
            temp_a1_2->unk4 = ((temp_t4 & 0x3FF) << 0xE) | ((temp_t5 & 0x3FF) * 4);
            temp_a1_2->unk0 = (((temp_t4 + 8) & 0x3FF) << 0xE) | 0xF6000000 | (((temp_t5 + 8) & 0x3FF) * 4);
        }
        temp_s0_3 = phi_s0_3 + 1;
        phi_s0_3 = temp_s0_3;
    } while (temp_s0_3 != 0x4B0);
    temp_a1_3 = gDisplayListHead;
    gDisplayListHead = temp_a1_3 + 8;
    temp_a1_3->unk4 = 0;
    temp_a1_3->unk0 = 0xE7000000;
    temp_lo = (D_8018E7D0.unk10 * 0xFF) / D_8018E7C8;
    phi_v1 = temp_lo;
    if (temp_lo >= 0x100) {
        phi_v1 = 0xFF;
    }
    gDisplayListHead = draw_box(gDisplayListHead, 0, 0, 0x140, 0xF0, 0, 0, 0, phi_v1);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009DB8C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern ? D_8018E7AC;
extern ? D_8018E7B8;
extern s32 D_8018E7E0;

void func_8009DEF8(u32 arg0, s8 arg1) {
    s8 temp_v0;
    u32 phi_a0;

    phi_a0 = arg0;
    if (arg0 == 0) {
        phi_a0 = 1;
    }
    temp_v0 = D_8018E7AC.unk4;
    if ((temp_v0 != 1) && (temp_v0 != 6)) {
        D_8018E7AC.unk4 = arg1;
        D_8018E7B8.unk10 = phi_a0;
        if (phi_a0 >= 0x100) {
            D_8018E7B8.unk10 = 0xFF;
        }
        D_8018E7E0 = 0;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009DEF8.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_8009DEF8(?); // extern

void func_8009DF4C(void) {
    func_8009DEF8(1);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009DF4C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_8009DEF8(?); // extern

void func_8009DF6C(void) {
    func_8009DEF8(8);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009DF6C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern ? D_8018E7AC;
extern ? D_8018E7B8;
extern s32 D_8018E7E0;

void func_8009DF8C(u32 arg0, s8 arg1) {
    s8 temp_v0;
    u32 phi_a0;

    phi_a0 = arg0;
    if (arg0 == 0) {
        phi_a0 = 1;
    }
    temp_v0 = D_8018E7AC.unk4;
    if ((temp_v0 != 2) && (temp_v0 != 5)) {
        D_8018E7AC.unk4 = arg1;
        D_8018E7B8.unk10 = phi_a0;
        if (phi_a0 >= 0x100) {
            D_8018E7B8.unk10 = 0xFF;
        }
        D_8018E7E0 = 0;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009DF8C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_8009DF8C(?); // extern

void func_8009DFE0(void) {
    func_8009DF8C(2);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009DFE0.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_8009DF8C(?); // extern

void func_8009E000(void) {
    func_8009DF8C(7);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009E000.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern ? D_8018E7AC;
extern ? D_8018E7B8;
extern ? D_8018E7D0;

void func_8009E020(s32 arg0, u32 arg1) {
    s32 temp_v0_2;
    s8 *temp_v1;
    s8 temp_v0;
    u32 *temp_a2;
    u32 phi_a1;

    phi_a1 = arg1;
    if (arg1 == 0) {
        phi_a1 = 1;
    }
    temp_v1 = arg0 + &D_8018E7AC;
    temp_v0 = *temp_v1;
    if ((temp_v0 != 1) && (temp_v0 != 6)) {
        temp_v0_2 = arg0 * 4;
        temp_a2 = temp_v0_2 + &D_8018E7B8;
        *temp_v1 = 1;
        *temp_a2 = phi_a1;
        if (phi_a1 >= 0x100) {
            *temp_a2 = 0xFF;
        }
        *(&D_8018E7D0 + temp_v0_2) = 0;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009E020.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern ? D_8018E7AC;
extern ? D_8018E7B8;
extern ? D_8018E7D0;

void func_8009E088(s32 arg0, u32 arg1) {
    s32 temp_v0_2;
    s8 *temp_v1;
    s8 temp_v0;
    u32 *temp_a2;
    u32 phi_a1;

    phi_a1 = arg1;
    if (arg1 == 0) {
        phi_a1 = 1;
    }
    temp_v1 = arg0 + &D_8018E7AC;
    temp_v0 = *temp_v1;
    if ((temp_v0 != 2) && (temp_v0 != 5)) {
        temp_v0_2 = arg0 * 4;
        temp_a2 = temp_v0_2 + &D_8018E7B8;
        *temp_v1 = 2;
        *temp_a2 = phi_a1;
        if (phi_a1 >= 0x100) {
            *temp_a2 = 0xFF;
        }
        *(&D_8018E7D0 + temp_v0_2) = 0;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009E088.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern s32 D_8018D9B8;
extern ? D_8018E7AC;
extern ? D_8018E7B8;
extern s32 D_8018E7E0;

void func_8009E0F0(u32 arg0) {
    s32 temp_v0;
    s32 phi_v0;

    if (D_8018E7AC.unk4 != 3) {
        D_8018E7AC.unk4 = 3;
        D_8018E7B8.unk10 = arg0;
        if (arg0 >= 0x100) {
            D_8018E7B8.unk10 = 0xFF;
        }
        D_8018E7E0 = 0;
        phi_v0 = 0;
        do {
            *(D_8018D9B8 + phi_v0) = 0;
            (D_8018D9B8 + phi_v0)->unk1 = 0;
            (D_8018D9B8 + phi_v0)->unk2 = 0;
            temp_v0 = phi_v0 + 4;
            (D_8018D9B8 + phi_v0)->unk3 = 0;
            phi_v0 = temp_v0;
        } while (temp_v0 != 0x4B0);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009E0F0.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_8009DFE0(?); // extern
extern s32 D_8018EDE0;

void func_8009E1C0(void) {
    func_8009DFE0(0xA);
    D_8018EDE0 = 0;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009E1C0.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_8009E000(?); // extern
extern s32 D_8018EDE0;

void func_8009E1E4(void) {
    func_8009E000(0xA);
    D_8018EDE0 = 0;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009E1E4.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_8009DFE0(?); // extern
extern s32 D_8018EDE0;

void func_8009E208(void) {
    func_8009DFE0(0xA);
    D_8018EDE0 = 1;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009E208.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_8009DFE0(?); // extern
extern s32 D_8018EDE0;

void func_8009E230(void) {
    func_8009DFE0(0xA);
    D_8018EDE0 = 2;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009E230.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_8009DFE0(?); // extern
extern s32 D_8018EDE0;

void func_8009E258(void) {
    func_8009DFE0(0xA);
    D_8018EDE0 = 3;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009E258.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_8009DFE0(?); // extern
extern s32 D_8018EDE0;

void func_8009E280(void) {
    func_8009DFE0(0xA);
    D_8018EDE0 = 4;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009E280.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_8009E2F0(); // extern
extern ? D_8018E838;

void func_8009E2A8(s32 arg0) {
    s8 *temp_v1;
    s8 temp_v0;

    temp_v1 = arg0 + &D_8018E838;
    temp_v0 = *temp_v1;
    if (temp_v0 != 0) {
        if (temp_v0 != 1) {
            *temp_v1 = 0;
            return;
        }
        func_8009E2F0();
        // Duplicate return node #4. Try simplifying control flow for better match
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009E2A8.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 draw_box(s32, s32, s32, s32, u32, s32, s32, s32, s32); // extern
extern ? D_800E7AC8;
extern ? D_800F0B28;
extern ? D_8018E7E8;
extern ? D_8018E810;
extern s8 D_8018E838;
extern ? D_8018E840;
extern s32 gDisplayListHead;

void func_8009E2F0(s32 arg0) {
    s32 sp38;
    f32 temp_f4;
    f64 temp_f6;
    s16 temp_t2;
    s16 temp_t2_2;
    s16 temp_t4;
    s32 temp_t6;
    s32 temp_t6_2;
    s32 temp_t7_2;
    s32 temp_t7_3;
    s32 temp_t8;
    s32 temp_v1;
    s8 temp_t7;
    u16 temp_t6_3;
    u32 *temp_s0;
    u32 temp_ra;
    u32 temp_t7_4;
    void *temp_t0;
    void *temp_t0_2;
    void *temp_t1;
    void *temp_t1_2;
    void *temp_v0;
    f32 phi_f4;
    f64 phi_f6;

    temp_s0 = (arg0 * 4) + &D_8018E840;
    temp_ra = *temp_s0;
    temp_t7 = *(&D_800F0B28 + temp_ra);
    sp38 = temp_t7;
    if (temp_t7 != 0) {
        if (temp_ra < 0x1B) {
            temp_v1 = arg0 * 8;
            temp_t1 = temp_v1 + &D_8018E810;
            temp_t0 = temp_v1 + &D_8018E7E8;
            temp_t4 = temp_t0->unk2;
            temp_t2 = temp_t0->unk0;
            temp_t6 = temp_t1->unk0 / 2;
            temp_t8 = temp_t1->unk2 / 2;
            temp_v0 = (temp_t7 * 8) + &D_800E7AC8;
            gDisplayListHead = draw_box(gDisplayListHead, temp_t2 - temp_t6, temp_t4 - temp_t8, temp_t2 + temp_t6, temp_t4 + temp_t8, temp_v0->unk0, temp_v0->unk2, temp_v0->unk4, temp_v0->unk6);
        } else {
            temp_t7_2 = 0x26 - temp_ra;
            temp_f6 = temp_t7_2;
            phi_f6 = temp_f6;
            if (temp_t7_2 < 0) {
                phi_f6 = temp_f6 + 4294967296.0;
            }
            temp_t6_2 = arg0 * 8;
            temp_t1_2 = temp_t6_2 + &D_8018E810;
            temp_t0_2 = temp_t6_2 + &D_8018E7E8;
            temp_t2_2 = temp_t0_2->unk0;
            temp_t7_3 = temp_t1_2->unk0 / 2;
            temp_t6_3 = ((sp38 * 8) + &D_800E7AC8)->unk6;
            temp_f4 = temp_t6_3;
            phi_f4 = temp_f4;
            if (temp_t6_3 < 0) {
                phi_f4 = temp_f4 + 4294967296.0f;
            }
            gDisplayListHead = draw_box(gDisplayListHead, temp_t2_2 - temp_t7_3, temp_t0_2->unk2 - (temp_t1_2->unk2 / 2), temp_t2_2 + temp_t7_3, phi_f4 * (phi_f6 / 11.0));
        }
    }
    temp_t7_4 = *temp_s0 + 1;
    *temp_s0 = temp_t7_4;
    if (temp_t7_4 >= 0x26) {
        D_8018E838 = 0;
        D_8018E838 = 0;
        D_8018E838 = 0;
        D_8018E838 = 0;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009E2F0.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_8009E5FC(s32); // extern

void func_8009E5BC(void) {
    s32 temp_s0;
    s32 phi_s0;

    phi_s0 = 0;
    do {
        func_8009E5FC(phi_s0);
        temp_s0 = phi_s0 + 1;
        phi_s0 = temp_s0;
    } while (temp_s0 != 4);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009E5BC.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern ? D_8018E838;
extern ? D_8018E840;

void func_8009E5FC(s32 arg0) {
    *(&D_8018E838 + arg0) = 1;
    *(&D_8018E840 + (arg0 * 4)) = 0;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009E5FC.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern ? D_8018D9E0;
extern ? D_8018DEE0;

void func_8009E620(void) {
    ? *temp_v1;
    ? *phi_v1;

    phi_v1 = &D_8018D9E0;
    do {
        temp_v1 = phi_v1 + 0xA0;
        temp_v1->unk-78 = 0;
        temp_v1->unk-50 = 0;
        temp_v1->unk-28 = 0;
        temp_v1->unk-A0 = 0;
        phi_v1 = temp_v1;
    } while (temp_v1 != &D_8018DEE0);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009E620.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
? func_8006EE44(s8);                                /* extern */
? func_8006EF60();                                  /* extern */
? func_80099184(? *, s8);                           /* extern */
? func_800996BC(? *, ?, s8);                        /* extern */
? func_8009B0A4(?, ?);                              /* extern */
? func_8009B538(?, ?, u16, u16, s32);               /* extern */
s32 func_8009B8C4(? *);                             /* extern */
? func_8009B954(? *);                               /* extern */
? func_8009B998();                                  /* extern */
s32 *func_8009BA74(s32 *, ? *, s32, s32);           /* extern */
? func_800B559C(s32);                               /* extern */
? func_800B6708();                                  /* extern */
s32 random_int(?, s8);                              /* extern */
? *segmented_to_virtual(void *, s8);                /* extern */
s32 segmented_to_virtual_dupe(? *, s8, s8, s32);    /* extern */
extern ? D_801640F4;
extern ? D_8018D9E0;
extern ? D_8018EE10;
extern ? D_802874D8;
extern ? gTexture7ED50C;
static ? D_02000000;                                /* unable to generate initializer */
static ? D_02000028;                                /* unable to generate initializer */
static ? D_02000050;                                /* unable to generate initializer */
static ? D_02000078;                                /* unable to generate initializer */
static ? D_020000A0;                                /* unable to generate initializer */
static ? D_020000C8;                                /* unable to generate initializer */
static ? D_020000F0;                                /* unable to generate initializer */
static ? D_02000118;                                /* unable to generate initializer */
static ? D_02000140;                                /* unable to generate initializer */
static ? D_02000168;                                /* unable to generate initializer */
static ? D_02000190;                                /* unable to generate initializer */
static ? D_020001B8;                                /* unable to generate initializer */
static ? D_020001E0;                                /* unable to generate initializer */
static ? D_02000208;                                /* unable to generate initializer */
static ? D_02000230;                                /* unable to generate initializer */
static ? D_02000258;                                /* unable to generate initializer */
static ? D_02000280;                                /* unable to generate initializer */
static ? D_020002A8;                                /* unable to generate initializer */
static ? D_020002D0;                                /* unable to generate initializer */
static ? D_020002F8;                                /* unable to generate initializer */
static ? D_02000320;                                /* unable to generate initializer */
static ? D_02000348;                                /* unable to generate initializer */
static ? D_02000370;                                /* unable to generate initializer */
static ? D_02000398;                                /* unable to generate initializer */
static ? D_020003C0;                                /* unable to generate initializer */
static ? D_020003E8;                                /* unable to generate initializer */
static ? D_02000410;                                /* unable to generate initializer */
static ? D_02000438;                                /* unable to generate initializer */
static ? D_02000460;                                /* unable to generate initializer */
static ? D_02000488;                                /* unable to generate initializer */
static ? D_020004B0;                                /* unable to generate initializer */
static ? D_020004D8;                                /* unable to generate initializer */
static ? D_02000500;                                /* unable to generate initializer */
static ? D_02000528;                                /* unable to generate initializer */
static ? D_02000550;                                /* unable to generate initializer */
static ? D_02000578;                                /* unable to generate initializer */
static ? D_020005A0;                                /* unable to generate initializer */
static ? D_020005C8;                                /* unable to generate initializer */
static ? D_020005F0;                                /* unable to generate initializer */
static ? D_02000618;                                /* unable to generate initializer */
static ? D_02000640;                                /* unable to generate initializer */
static ? D_02000668;                                /* unable to generate initializer */
static ? D_02000690;                                /* unable to generate initializer */
static ? D_020006B8;                                /* unable to generate initializer */
static ? D_020006E0;                                /* unable to generate initializer */
static ? D_02000708;                                /* unable to generate initializer */
static ? D_02000730;                                /* unable to generate initializer */
static ? D_02000758;                                /* unable to generate initializer */
static ? D_02000780;                                /* unable to generate initializer */
static ? D_020007A8;                                /* unable to generate initializer */
static ? D_020007D0;                                /* unable to generate initializer */
static ? D_020007F8;                                /* unable to generate initializer */
static ? D_02000820;                                /* unable to generate initializer */
static ? D_02000848;                                /* unable to generate initializer */
static ? D_02000870;                                /* unable to generate initializer */
static ? D_02000898;                                /* unable to generate initializer */
static ? D_020008C0;                                /* unable to generate initializer */
static ? D_020008E8;                                /* unable to generate initializer */
static ? D_02000910;                                /* unable to generate initializer */
static ? D_02000938;                                /* unable to generate initializer */
static ? D_02000960;                                /* unable to generate initializer */
static ? D_02000988;                                /* unable to generate initializer */
static ? D_020009B0;                                /* unable to generate initializer */
static ? D_020009D8;                                /* unable to generate initializer */
static ? D_02000A00;                                /* unable to generate initializer */
static ? D_02000A28;                                /* unable to generate initializer */
static ? D_02000A50;                                /* unable to generate initializer */
static ? D_02000A78;                                /* unable to generate initializer */
static ? D_02000AA0;                                /* unable to generate initializer */
static ? D_02000AC8;                                /* unable to generate initializer */
static ? D_02000AF0;                                /* unable to generate initializer */
static ? D_02000B18;                                /* unable to generate initializer */
static ? D_02000B40;                                /* unable to generate initializer */
static ? D_02000B68;                                /* unable to generate initializer */
static ? D_02000B90;                                /* unable to generate initializer */
static ? D_02000BB8;                                /* unable to generate initializer */
static ? D_02000BE0;                                /* unable to generate initializer */
static ? D_02000C08;                                /* unable to generate initializer */
static ? D_02000C30;                                /* unable to generate initializer */
static ? D_02000C58;                                /* unable to generate initializer */
static ? D_02000C80;                                /* unable to generate initializer */
static ? D_02000CA8;                                /* unable to generate initializer */
static ? D_02000CD0;                                /* unable to generate initializer */
static ? D_02000CF8;                                /* unable to generate initializer */
static ? D_02000D20;                                /* unable to generate initializer */
static ? D_02000D48;                                /* unable to generate initializer */
static ? D_02000D70;                                /* unable to generate initializer */
static ? D_02000D98;                                /* unable to generate initializer */
static ? D_02000DC0;                                /* unable to generate initializer */
static ? D_02000DE8;                                /* unable to generate initializer */
static ? D_02000E10;                                /* unable to generate initializer */
static ? D_02000E38;                                /* unable to generate initializer */
static ? D_02000E60;                                /* unable to generate initializer */
static ? D_02000E88;                                /* unable to generate initializer */
static ? D_02000EB0;                                /* unable to generate initializer */
static ? D_02000ED8;                                /* unable to generate initializer */
static ? D_02000F00;                                /* unable to generate initializer */
static ? D_02000F28;                                /* unable to generate initializer */
static ? D_02000F50;                                /* unable to generate initializer */
static ? D_02000F78;                                /* unable to generate initializer */
static ? D_02000FA0;                                /* unable to generate initializer */
static ? D_02000FC8;                                /* unable to generate initializer */
static ? D_02000FF0;                                /* unable to generate initializer */
static ? D_02001018;                                /* unable to generate initializer */
static ? D_02001040;                                /* unable to generate initializer */
static ? D_02001068;                                /* unable to generate initializer */
static ? D_02001090;                                /* unable to generate initializer */
static ? D_020010B8;                                /* unable to generate initializer */
static ? D_020014C8;                                /* unable to generate initializer */
static ? D_02001540;                                /* unable to generate initializer */
static ? D_0200157C;                                /* unable to generate initializer */
static ? D_020015A4;                                /* unable to generate initializer */
static ? D_020015CC;                                /* unable to generate initializer */
static ? D_02001630;                                /* unable to generate initializer */
static ? D_02001658;                                /* unable to generate initializer */
static ? D_020016BC;                                /* unable to generate initializer */
static ? D_020016E4;                                /* unable to generate initializer */
static ? D_0200170C;                                /* unable to generate initializer */
static ? D_02001734;                                /* unable to generate initializer */
static ? D_0200175C;                                /* unable to generate initializer */
static ? D_02001784;                                /* unable to generate initializer */
static ? D_020017AC;                                /* unable to generate initializer */
static ? D_020017D4;                                /* unable to generate initializer */
static ? D_020017FC;                                /* unable to generate initializer */
static ? D_02001824;                                /* unable to generate initializer */
static ? D_0200184C;                                /* unable to generate initializer */
static ? D_02001874;                                /* unable to generate initializer */
static ? D_0200198C;                                /* unable to generate initializer */
static ? D_0200199C;                                /* unable to generate initializer */
static ? D_020019AC;                                /* unable to generate initializer */
static ? D_020019BC;                                /* unable to generate initializer */
static ? D_020019CC;                                /* unable to generate initializer */
static ? D_020019DC;                                /* unable to generate initializer */
static void D_02001FA4;                             /* unable to generate initializer */
static ? D_020045E8;                                /* unable to generate initializer */
static ? D_02004610;                                /* unable to generate initializer */
static void D_02004638;                             /* unable to generate initializer */
static void D_02004A0C;                             /* unable to generate initializer */
static void D_02004A34;                             /* unable to generate initializer */
static ? D_02004B4C;                                /* unable to generate initializer */
static ? D_02004B74;                                /* unable to generate initializer */
static ? D_800E7248;                                /* unable to generate initializer; const */
static ? D_800E7268;                                /* unable to generate initializer; const */
static ? D_800E74E8;                                /* unable to generate initializer; const */
static void *D_800E7AF8[0x6C] = {
    &D_02000000,
    &D_02000028,
    &D_02000050,
    &D_02000078,
    &D_020000A0,
    &D_020000C8,
    &D_020000F0,
    &D_02000118,
    &D_02000140,
    &D_02000168,
    &D_02000190,
    &D_020001B8,
    &D_020001E0,
    &D_02000208,
    &D_02000230,
    &D_02000258,
    &D_02000280,
    &D_020002A8,
    &D_020002D0,
    &D_020002F8,
    &D_02000320,
    &D_02000348,
    &D_02000370,
    &D_02000398,
    &D_020003C0,
    &D_020003E8,
    &D_02000410,
    &D_02000438,
    &D_02000460,
    &D_02000488,
    &D_020004B0,
    &D_020004D8,
    &D_02000500,
    &D_02000528,
    &D_02000550,
    &D_02000578,
    &D_020005A0,
    &D_020005C8,
    &D_020005F0,
    &D_02000618,
    &D_02000640,
    &D_02000668,
    &D_02000690,
    &D_020006B8,
    &D_020006E0,
    &D_02000708,
    &D_02000730,
    &D_02000758,
    &D_02000780,
    &D_020007A8,
    &D_020007D0,
    &D_020007F8,
    &D_02000820,
    &D_02000848,
    &D_02000870,
    &D_02000898,
    &D_020008C0,
    &D_020008E8,
    &D_02000910,
    &D_02000938,
    &D_02000960,
    &D_02000988,
    &D_020009B0,
    &D_020009D8,
    &D_02000A00,
    &D_02000A28,
    &D_02000A50,
    &D_02000A78,
    &D_02000AA0,
    &D_02000AC8,
    &D_02000AF0,
    &D_02000B18,
    &D_02000B40,
    &D_02000B68,
    &D_02000B90,
    &D_02000BB8,
    &D_02000BE0,
    &D_02000C08,
    &D_02000C30,
    &D_02000C58,
    &D_02000C80,
    &D_02000CA8,
    &D_02000CD0,
    &D_02000CF8,
    &D_02000D20,
    &D_02000D48,
    &D_02000D70,
    &D_02000D98,
    &D_02000DC0,
    &D_02000DE8,
    &D_02000E10,
    &D_02000E38,
    &D_02000E60,
    &D_02000E88,
    &D_02000EB0,
    &D_02000ED8,
    &D_02000F00,
    &D_02000F28,
    &D_02000F50,
    &D_02000F78,
    &D_02000FA0,
    &D_02000FC8,
    &D_02000FF0,
    &D_02001018,
    &D_02001040,
    &D_02001068,
    &D_02001090,
    &D_020010B8,
}; /* const */
static ? D_800E7CA8;                                /* unable to generate initializer; const */
static void *D_800E7D0C[0xA] = {
    &D_020016BC,
    &D_020016E4,
    &D_0200170C,
    &D_02001734,
    &D_0200175C,
    &D_02001784,
    &D_020017AC,
    &D_020017D4,
    &D_020017FC,
    &D_02001824,
}; /* const */
static ? *D_800E7D34[6] = {
    &D_0200198C,
    &D_0200199C,
    &D_020019AC,
    &D_020019BC,
    &D_020019CC,
    &D_020019DC,
}; /* const */
static ? D_800E7D4C;                                /* unable to generate initializer; const */
static ? D_800E7D54;                                /* unable to generate initializer; const */
static ? D_800E7D74;                                /* unable to generate initializer; const */
static ? D_800E7DC4;                                /* unable to generate initializer; const */
static ? D_800E7E20;                                /* unable to generate initializer; const */
static ? D_800E7E34;                                /* unable to generate initializer; const */
static ? D_800E7FF0;                                /* unable to generate initializer; const */
static ? D_800E80A0;                                /* unable to generate initializer; const */
static ? D_800E8114;                                /* unable to generate initializer; const */
static ? D_800E817C;                                /* unable to generate initializer; const */
static ? D_800E81E4;                                /* unable to generate initializer; const */
static ? D_800E822C;                                /* unable to generate initializer; const */
static ? D_800E8234;                                /* unable to generate initializer; const */
static ? D_800E8274;                                /* unable to generate initializer; const */
static ? D_800E8294;                                /* unable to generate initializer; const */
static ? D_800E8320;                                /* unable to generate initializer; const */
static ? D_800E8420;                                /* unable to generate initializer; const */
static ? D_800E85F7;                                /* unable to generate initializer; const */
static s8 D_800E86A8 = 0;                           /* const */
static ? D_800EFD64;                                /* unable to generate initializer; const */
static ? gCupCourseOrder;                            /* unable to generate initializer; const */

void func_8009E650(s32 arg0, s32 arg1, s32 arg2, s8 arg3) {
    void *sp7C;
    s32 *sp6C;
    s32 sp3C;
    void **sp24;
    s32 sp20;
    s32 *temp_v0_2;
    s32 *temp_v1_10;
    s32 *temp_v1_11;
    s32 *temp_v1_12;
    s32 *temp_v1_4;
    s32 *temp_v1_5;
    s32 *temp_v1_6;
    s32 *temp_v1_7;
    s32 *temp_v1_8;
    s32 *temp_v1_9;
    s32 temp_a3;
    s32 temp_t8;
    s32 temp_t9;
    s32 temp_v0;
    s32 temp_v0_4;
    s32 temp_v0_5;
    s32 temp_v0_6;
    s32 temp_v0_7;
    s32 temp_v1;
    s32 temp_v1_14;
    s32 temp_v1_15;
    s32 temp_v1_16;
    s32 temp_v1_2;
    s8 temp_a1;
    s8 temp_a1_2;
    s8 temp_t7;
    s8 temp_v0_8;
    void **temp_v0_10;
    void **temp_v1_13;
    void **temp_v1_3;
    void *temp_v0_3;
    void *temp_v0_9;
    ? *phi_ra;
    s32 phi_v0;
    s32 phi_v0_2;
    s32 phi_v1;
    ? *phi_a0;
    void **phi_v1_2;
    void **phi_v1_3;
    s8 phi_v1_4;
    s32 phi_v1_5;
    void **phi_a2;
    ? *phi_a0_2;

    phi_ra = &D_8018D9E0;
    phi_v0 = 0;
    phi_v0_2 = 0;
loop_1:
    temp_v0 = phi_v0 + 1;
    phi_v0 = temp_v0;
    if (phi_ra->unk0 != 0) {
        if (temp_v0 >= 0x21) {
loop_3:
            goto loop_3;
        }
        phi_ra += 0x28;
        goto loop_1;
    }
    phi_ra->unk4 = 0;
    phi_ra->unk8 = 0;
    phi_ra->unkC = arg1;
    phi_ra->unk10 = arg2;
    phi_ra->unk14 = arg3;
    phi_ra->unk15 = 1;
    phi_ra->unk1C = 0;
    phi_ra->unk20 = 0;
    phi_ra->unk0 = arg0;
    phi_v1_4 = 1;
    if (arg0 >= 0xFC) {
        if (arg0 >= 0x131) {
            switch (arg0);                          /* switch 1; jump table: jpt_800F1160 */
            /* Duplicate return node #87. Try simplifying control flow for better match */
            return;
        }
        if (arg0 != 0x130) {
            return;
        }
        temp_a1 = *(&D_800EFD64 + D_802874D8.unk1E);
        if (D_802874D8.unk1D >= 3) {
            phi_v0_2 = 1;
        }
        temp_v1 = temp_a1 * 4;
        phi_v1 = temp_v1;
        if (phi_v0_2 != 0) {
            temp_v1_2 = temp_a1 * 4;
            phi_v1 = temp_v1_2;
            phi_a0 = *(&D_800E8420 + temp_v1_2);
        } else {
            phi_a0 = *(&D_800E8320 + temp_v1);
        }
        sp7C = phi_ra;
        sp20 = phi_v1;
        phi_ra->unk18 = func_8009A478(segmented_to_virtual_dupe(phi_a0, temp_a1, arg3), 0);
        func_800996BC(segmented_to_virtual(*(&D_800E7D54 + phi_v1)), 0);
        /* Duplicate return node #87. Try simplifying control flow for better match */
        return;
    }
    if (arg0 >= 0x38) {
        switch (arg0) {                             /* switch 2 */
        case 0xFA:                                  /* switch 2 */
            D_8018ED94 = 0;
            D_800E8530 = 0.0f;
            D_800E8534 = 3.0f;
            D_8018EDC0 = 0x9C4;
            D_8018EDC8 = 0.0f;
            D_8018EDCC = -270.0f;
            D_8018EDD0 = 0.0f;
            D_8018EDD4 = 0.0f;
            D_8018EDD8 = 0.0f;
            D_8018EDDC = 0.0f;
            D_8018EDC4 = 3.0f;
            phi_ra->unk1C = -1;
            phi_ra->unk20 = 1;
            return;
        case 0xFB:                                  /* switch 2 */
            D_8018EDC0 = 0x708;
            D_8018EDC8 = -51.0f;
            D_8018EDCC = -12.0f;
            D_8018EDD0 = -18.0f;
            D_8018EDD4 = -270.0f;
            D_8018EDD8 = 750.0f;
            D_8018EDDC = 0.0f;
            D_8018EDC4 = 1.0f;
            phi_ra->unk1C = -1;
            phi_ra->unk20 = 1;
            return;
        case 0xD2:                                  /* switch 2 */
            sp7C = phi_ra;
            func_800996BC(&D_020014C8, 0, arg3);
            func_8009B954(&D_020014C8);
            D_8018E75C = func_8009BA74(D_8018E75C, &D_020014C8, phi_ra->unkC, phi_ra->unk10);
            func_8009B998();
            return;
        case 0xD3:                                  /* switch 2 */
            sp7C = phi_ra;
            func_800996BC(&D_02001540, 0, arg3);
            func_8009B954(&D_02001540);
            D_8018E75C = func_8009BA74(D_8018E75C, &D_02001540, phi_ra->unkC, phi_ra->unk10);
            func_8009B998();
            return;
        case 0xD4:                                  /* switch 2 */
            sp7C = phi_ra;
            func_800996BC(&D_0200157C, 0, arg3);
            func_80099184(&D_02001874);
            phi_ra->unk10 = 0x69;
            phi_v1_2 = D_800E7AF8;
            do {
                sp24 = phi_v1_2;
                func_80099184(segmented_to_virtual(*phi_v1_2));
                temp_v1_3 = phi_v1_2 + 4;
                phi_v1_2 = temp_v1_3;
            } while (temp_v1_3 != D_800E7D0C);
            return;
        case 0xD5:                                  /* switch 2 */
            sp7C = phi_ra;
            func_80099184(&D_020015A4, arg3);
            func_8009B954(&D_020015A4);
            temp_v0_2 = func_8009BA74(D_8018E75C, &D_020015A4, phi_ra->unkC, phi_ra->unk10);
            D_8018E75C = temp_v0_2;
            D_8018E75C = temp_v0_2 + 8;
            *temp_v0_2 = -0x2900000;
            sp6C = temp_v0_2;
            sp6C->unk4 = func_8009B8C4(&gTexture7ED50C);
            temp_v1_4 = D_8018E75C;
            D_8018E75C = temp_v1_4 + 8;
            temp_v1_4->unk0 = -0xA900000;
            temp_v1_4->unk4 = 0x7080200;
            temp_v1_5 = D_8018E75C;
            D_8018E75C = temp_v1_5 + 8;
            temp_v1_5->unk4 = 0;
            temp_v1_5->unk0 = -0x1A000000;
            temp_v1_6 = D_8018E75C;
            D_8018E75C = temp_v1_6 + 8;
            temp_v1_6->unk4 = 0x74FF020;
            temp_v1_6->unk0 = -0xD000000;
            temp_v1_7 = D_8018E75C;
            D_8018E75C = temp_v1_7 + 8;
            temp_v1_7->unk4 = 0;
            temp_v1_7->unk0 = -0x19000000;
            temp_v1_8 = D_8018E75C;
            D_8018E75C = temp_v1_8 + 8;
            temp_v1_8->unk0 = -0xA8F8000;
            temp_v1_8->unk4 = 0x80200;
            temp_v1_9 = D_8018E75C;
            D_8018E75C = temp_v1_9 + 8;
            temp_v1_9->unk0 = -0xE000000;
            temp_v1_9->unk4 = 0x3FC010;
            temp_v1_10 = D_8018E75C;
            D_8018E75C = temp_v1_10 + 8;
            temp_v1_10->unk4 = 0x802C0;
            temp_v1_10->unk0 = -0x1BB7FD2C;
            temp_v1_11 = D_8018E75C;
            D_8018E75C = temp_v1_11 + 8;
            temp_v1_11->unk4 = 0x80;
            temp_v1_11->unk0 = 0xB3000000;
            temp_v1_12 = D_8018E75C;
            D_8018E75C = temp_v1_12 + 8;
            temp_v1_12->unk0 = 0xB2000000;
            temp_v1_12->unk4 = 0x400FC00;
            sp7C = phi_ra;
            func_8009B998();
            func_80099184(&D_020015CC);
            func_8009B954(&D_020015CC);
            D_8018E75C = func_8009BA74(D_8018E75C, &D_020015CC, phi_ra->unkC, phi_ra->unk10);
            func_8009B998();
            func_80099184(&D_02001630);
            func_8009B954(&D_02001630);
            D_8018E75C = func_8009BA74(D_8018E75C, &D_02001630, phi_ra->unkC, phi_ra->unk10);
            func_8009B998();
            func_80099184(&D_02001658);
            func_8009B954(&D_02001658);
            D_8018E75C = func_8009BA74(D_8018E75C, &D_02001658, phi_ra->unkC, phi_ra->unk10);
            func_8009B998();
            return;
        case 0xD6:                                  /* switch 2 */
            sp7C = phi_ra;
            phi_ra->unk18 = func_8009A374(segmented_to_virtual_dupe(*D_800E7D34, arg3));
            return;
        case 0xD7:                                  /* switch 2 */
            phi_v1_3 = D_800E7D0C;
            do {
                sp24 = phi_v1_3;
                func_80099184(segmented_to_virtual(*phi_v1_3));
                temp_v1_13 = phi_v1_3 + 4;
                phi_v1_3 = temp_v1_13;
            } while (temp_v1_13 != D_800E7D34);
            return;
        case 0xD8:                                  /* switch 2 */
        case 0xD9:                                  /* switch 2 */
            func_80099184(&D_0200184C, arg3);
            return;
        case 0xA0:                                  /* switch 2 */
        case 0xA1:                                  /* switch 2 */
            sp7C = phi_ra;
            phi_ra->unk18 = func_8009A374(segmented_to_virtual_dupe(*(&D_800E80A0 + (arg0 * 4)), arg3));
            return;
        case 0x5D:                                  /* switch 2 */
            phi_ra->unk1C = 0x20;
            /* fallthrough */
        case 0x52:                                  /* switch 2 */
        case 0x53:                                  /* switch 2 */
        case 0x54:                                  /* switch 2 */
        case 0x55:                                  /* switch 2 */
        case 0x56:                                  /* switch 2 */
        case 0x58:                                  /* switch 2 */
        case 0x59:                                  /* switch 2 */
        case 0x5A:                                  /* switch 2 */
        case 0x5B:                                  /* switch 2 */
        case 0x5C:                                  /* switch 2 */
            func_800996BC(segmented_to_virtual(*(&D_800E817C + (arg0 * 4)), arg3), 0);
            return;
        case 0x5F:                                  /* switch 2 */
        case 0x60:                                  /* switch 2 */
        case 0x61:                                  /* switch 2 */
        case 0x62:                                  /* switch 2 */
            sp7C = phi_ra;
            phi_ra->unk18 = func_8009A374(segmented_to_virtual_dupe(*(&D_800E7E34 + (*(&gCupCourseOrder - 0xBE + (phi_ra->unk0 * 2)) * 4)), arg3));
            return;
        case 0x5E:                                  /* switch 2 */
            sp7C = phi_ra;
            phi_ra->unk20 = random_int(4, arg3) + 2;
            return;
        case 0x65:                                  /* switch 2 */
        case 0x66:                                  /* switch 2 */
            temp_v0_3 = (arg0 * 8) + &D_800E7248;
            phi_ra->unkC = temp_v0_3->unk-328;
            phi_ra->unk10 = temp_v0_3->unk-326;
            return;
        case 0x67:                                  /* switch 2 */
            phi_ra->unk1C = gCupSelection;
            sp7C = phi_ra;
            temp_v0_4 = func_800B54C0(gCupSelection, gCCSelection, arg2);
            temp_v1_14 = temp_v0_4;
            phi_ra->unk20 = temp_v0_4;
            phi_ra->unk18 = func_8009A374(segmented_to_virtual_dupe(*(&D_800E7E20 + (((gCCSelection / 2) * 0x10) + -(temp_v1_14 * 4)))));
            phi_ra->unkC = D_800E7268.unk0;
            phi_ra->unk10 = D_800E7268.unk2;
            return;
        case 0x68:                                  /* switch 2 */
            sp7C = phi_ra;
            func_800996BC(segmented_to_virtual(*(&D_800E8294 + (gCCSelection * 4)), arg3), 0);
            phi_ra->unkC = 0x37;
            phi_ra->unk10 = 0xC3;
            return;
        case 0x69:                                  /* switch 2 */
            func_800996BC(segmented_to_virtual(&D_02004A0C, arg3), 0);
            if (func_800B5B94() == 0) {
                func_800B6708();
                return;
            }
            D_8018EE10.unk4 = 0;
            D_8018EE10.unk84 = 0;
            return;
        case 0x78:                                  /* switch 2 */
        case 0x79:                                  /* switch 2 */
        case 0x7A:                                  /* switch 2 */
        case 0x7B:                                  /* switch 2 */
            func_800996BC(segmented_to_virtual(*(&D_800E8114 + (arg0 * 4)), arg3), 0);
            return;
        case 0x8C:                                  /* switch 2 */
            func_800996BC(segmented_to_virtual(&D_02004A34, arg3), 0);
            if (func_800B5B94() == 0) {
                func_800B6708();
                return;
            }
            D_8018EE10.unk4 = 0;
            D_8018EE10.unk84 = 0;
            return;
        case 0x8D:                                  /* switch 2 */
            func_80099184(segmented_to_virtual(&D_02001FA4, arg3));
            return;
        case 0x7C:                                  /* switch 2 */
        case 0x7D:                                  /* switch 2 */
        case 0x7E:                                  /* switch 2 */
        case 0x7F:                                  /* switch 2 */
        case 0x80:                                  /* switch 2 */
        case 0x81:                                  /* switch 2 */
        case 0x82:                                  /* switch 2 */
        case 0x83:                                  /* switch 2 */
        case 0x84:                                  /* switch 2 */
        case 0x85:                                  /* switch 2 */
        case 0x86:                                  /* switch 2 */
        case 0x87:                                  /* switch 2 */
        case 0x88:                                  /* switch 2 */
        case 0x89:                                  /* switch 2 */
        case 0x8A:                                  /* switch 2 */
        case 0x8B:                                  /* switch 2 */
            sp7C = phi_ra;
            temp_v0_5 = phi_ra->unk0 - 0x7C;
            func_800996BC(segmented_to_virtual(*(&D_800E7D74 + (*(&gCupCourseOrder + (((temp_v0_5 / 4) * 8) + ((temp_v0_5 % 4) * 2))) * 4)), arg3), -1);
            temp_v0_6 = phi_ra->unk0 - 0x7C;
            func_800996BC(segmented_to_virtual(*(&D_800E7DC4 + (*(&gCupCourseOrder + (((temp_v0_6 / 4) * 8) + ((temp_v0_6 % 4) * 2))) * 4))), 0);
            func_800996BC(segmented_to_virtual(&D_02004A0C), 0);
            return;
        case 0xB1:                                  /* switch 2 */
        case 0xB2:                                  /* switch 2 */
        case 0xB3:                                  /* switch 2 */
        case 0xB4:                                  /* switch 2 */
            temp_v0_7 = gModeSelection;
            temp_a1_2 = *(&D_800EFD64 + *(&D_800E85F7 + arg0));
            temp_a3 = arg0 - 0xB1;
            phi_v1_4 = 0;
            if (temp_v0_7 != VERSUS) {
                if (temp_v0_7 != BATTLE) {
                    phi_a2 = arg0 * 4;
                } else {
                    temp_t8 = arg0 * 4;
                    phi_a2 = temp_t8;
                    phi_a2 = temp_t8;
                    if (arg0 != (D_800DC5E8 + 0xB1)) {
                        goto block_63;
                    }
                }
            } else {
                temp_t9 = arg0 * 4;
                phi_a2 = temp_t9;
                phi_a2 = temp_t9;
                if (*(&D_801640F4 + temp_t9) != 0) {
block_63:
                }
            }
            if (phi_v1_4 != 0) {
                temp_v1_15 = temp_a1_2 * 4;
                phi_v1_5 = temp_v1_15;
                phi_a0_2 = *(&D_800E8420 + temp_v1_15);
            } else {
                temp_v1_16 = temp_a1_2 * 4;
                phi_v1_5 = temp_v1_16;
                phi_a0_2 = *(&D_800E8320 + temp_v1_16);
            }
            sp7C = phi_ra;
            sp20 = phi_v1_5;
            sp24 = phi_a2;
            sp3C = temp_a3;
            phi_ra->unk18 = func_8009A478(segmented_to_virtual_dupe(phi_a0_2, temp_a1_2, phi_a2, temp_a3), sp3C);
            func_800996BC(segmented_to_virtual(*(&D_800E7D54 + phi_v1_5)), 0);
            func_80099184(segmented_to_virtual(*(&D_800E7FF0 + phi_a2)));
            return;
        case 0xBB:                                  /* switch 2 */
            sp7C = phi_ra;
            phi_ra->unk1C = func_800B5020(D_8018CA78, D_800E86A8, arg2);
            phi_ra->unk20 = func_800B5218();
            if (D_80162DD4 != 1) {
                sp7C = phi_ra;
                if (func_800051C4() >= 0x3C01) {
                    D_80162DD4 = 1;
                }
            }
            if ((phi_ra->unk1C == 0) || (phi_ra->unk20 != 0)) {
                func_800B559C((gCupSelection * 4) + gCupCourseSelection);
                return;
            }
            /* Duplicate return node #87. Try simplifying control flow for better match */
            return;
        case 0xE6:                                  /* switch 2 */
            temp_v0_8 = D_8018EDF7;
            sp7C = phi_ra;
            phi_ra->unk18 = func_8009A374(segmented_to_virtual_dupe(*(&D_800E7E34 + (*(&gCupCourseOrder + (((temp_v0_8 / 4) * 8) + ((temp_v0_8 % 4) * 2))) * 4)), arg3));
            phi_ra->unk1C = D_8018EDF7;
            func_800996BC(segmented_to_virtual(&D_02004A0C), 0);
            func_8006EF60();
            if (func_800B5B94() == 0) {
                func_800B6708();
                return;
            }
            D_8018EE10.unk4 = 0;
            D_8018EE10.unk84 = 0;
            return;
        case 0xF0:                                  /* switch 2 */
            phi_ra->unk4 = gSoundMode;
            return;
        case 0xF1:                                  /* switch 2 */
            func_800996BC(segmented_to_virtual(&D_02004638, arg3), 0);
            return;
        case 0xBE:                                  /* switch 2 */
            D_8018ED90 = 0;
            return;
        }
    } else {
        switch (arg0) {                             /* switch 3 */
        case 0x1:                                   /* switch 3 */
            func_800996BC(*(&D_800E7D4C + (func_800B555C(arg0) * 4)), 0);
            return;
        case 0x2:                                   /* switch 3 */
            func_8006EE44(arg3);
            D_8018E110 += 0x10000;
            func_80099184(&D_020045E8);
            return;
        case 0x3:                                   /* switch 3 */
            func_80099184(&D_02004610, arg3);
            return;
        case 0x23:                                  /* switch 3 */
        case 0x24:                                  /* switch 3 */
        case 0x25:                                  /* switch 3 */
            func_800996BC(*(&D_800E7D4C + (func_800B555C(arg0) * 4)), 0);
            func_800996BC(&D_02004B74, 0);
            func_8009B0A4(0, 0x19);
            temp_v0_9 = (arg0 * 8) + &D_800E74E8;
            func_8009B538(0, 0x12C00, temp_v0_9->unk-118, temp_v0_9->unk-116, temp_v0_9->unk-114);
            return;
        case 0xF:                                   /* switch 3 */
            phi_ra->unk1C = 0x20;
            /* fallthrough */
        case 0xA:                                   /* switch 3 */
        case 0x10:                                  /* switch 3 */
        case 0x11:                                  /* switch 3 */
        case 0x12:                                  /* switch 3 */
        case 0x13:                                  /* switch 3 */
        case 0x14:                                  /* switch 3 */
        case 0x15:                                  /* switch 3 */
        case 0x16:                                  /* switch 3 */
        case 0x17:                                  /* switch 3 */
        case 0x18:                                  /* switch 3 */
        case 0x19:                                  /* switch 3 */
            func_800996BC(segmented_to_virtual(*(&D_800E822C + (arg0 * 4)), arg3), 0);
            return;
        case 0xB:                                   /* switch 3 */
        case 0xC:                                   /* switch 3 */
        case 0xD:                                   /* switch 3 */
        case 0xE:                                   /* switch 3 */
            temp_v0_10 = (arg0 * 8) + &D_800E8234;
            sp24 = temp_v0_10;
            func_800996BC(segmented_to_virtual(temp_v0_10->unk-58, arg3), 0);
            func_80099184(segmented_to_virtual(sp24->unk-54));
            return;
        case 0x2A:                                  /* switch 3 */
            func_800996BC(&D_02004B4C, 0, arg3);
            return;
        case 0x33:                                  /* switch 3 */
            sp7C = phi_ra;
            func_800996BC(&D_02004B74, 0, arg3);
            phi_ra->unk1C = 0x20;
            return;
        case 0x34:                                  /* switch 3 */
        case 0x35:                                  /* switch 3 */
        case 0x36:                                  /* switch 3 */
        case 0x37:                                  /* switch 3 */
            func_80099184(segmented_to_virtual(*(&D_800E81E4 + (arg0 * 4)), arg3));
            return;
        case 0x2B:                                  /* switch 3 */
        case 0x2C:                                  /* switch 3 */
        case 0x2D:                                  /* switch 3 */
        case 0x2E:                                  /* switch 3 */
        case 0x2F:                                  /* switch 3 */
        case 0x30:                                  /* switch 3 */
        case 0x31:                                  /* switch 3 */
        case 0x32:                                  /* switch 3 */
            sp7C = phi_ra;
            temp_t7 = arg0 * 4;
            sp24 = temp_t7;
            phi_ra->unk18 = func_8009A374(segmented_to_virtual_dupe(*(&D_800E8274 + temp_t7), temp_t7, arg3));
            func_800996BC(segmented_to_virtual(*(&D_800E7CA8 + sp24)), 0);
            return;
        default:                                    /* switch 3 */
        default:                                    /* switch 2 */
            return;
        }
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009E650.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
void *draw_box(void *, s32, s32, s32, s32, s32, s32, s32, s32); /* extern */
? draw_text(s32, s32, ? *, ?, f32, f32);            /* extern */
? func_8004C8D4(s16, s16);                          /* extern */
s32 get_string_width(? *);                             /* extern */
? func_80093324(s32, s32, ? *, s32, f32, f32);      /* extern */
? func_800936B8(s32, s32, ? *, s32, f32, f32);      /* extern */
? func_800939C8(?, ?, ? *, ?, f32, f32);            /* extern */
? func_80094660(s32, s32);                          /* extern */
? func_800947B4(s32, s32);                          /* extern */
void *func_800959A0(void *, s32, s32, s32, s32);    /* extern */
void *func_800959CC(void *, s32, s32, s32, s32);    /* extern */
void *func_80096CD8(void *, ?, ?, ?, s32);          /* extern */
void *func_80098C18(void *, s32, s32, s32, s32, s32, s32, s32, s32); /* extern */
? func_8009A76C(s32, s32, s32, s32);                /* extern */
? func_8009A7EC(s32, s32, s32, s32, s32);           /* extern */
void *func_8009B9D0(void *, ? *);                   /* extern */
void *func_8009BA74(void *, ? *, s32, s32);         /* extern */
void *func_8009BC9C(void *, ? *, s32, s32, s32, s32); /* extern */
? func_800A09E0(void *);                            /* extern */
? func_800A0AD0(void *);                            /* extern */
? func_800A0B80(void *);                            /* extern */
? func_800A0DFC(s32);                               /* extern */
? func_800A0EB8(void *, s32);                       /* extern */
? func_800A0FA4(void *, s32);                       /* extern */
? func_800A10CC(void *);                            /* extern */
? func_800A11D0(void *, s32, s32);                  /* extern */
? func_800A12BC(void *, ? *);                       /* extern */
? func_800A143C(void *, s32);                       /* extern */
? func_800A1500(void *);                            /* extern */
? func_800A15EC(void *);                            /* extern */
? func_800A1780(void *);                            /* extern */
? func_800A1924(void *);                            /* extern */
? func_800A1A20(void *);                            /* extern */
? func_800A1BE0(void *);                            /* extern */
? func_800A1DE0(void *);                            /* extern */
? func_800A1F30(void *);                            /* extern */
? func_800A1FB0(void *);                            /* extern */
? func_800A2D1C(void *);                            /* extern */
? func_800A2EB8(void *);                            /* extern */
? func_800A34A8(void *);                            /* extern */
? func_800A3C84(void *);                            /* extern */
? func_800A3E60(void *);                            /* extern */
? func_800A4A24(void *);                            /* extern */
? func_800A4B38(void *);                            /* extern */
? func_800A5738(void *);                            /* extern */
? func_800A6034(void *);                            /* extern */
? func_800A6154(void *);                            /* extern */
? func_800A638C(void *);                            /* extern */
? func_800A70E8(void *);                            /* extern */
? func_800A7258(void *);                            /* extern */
? func_800A72FC(void *);                            /* extern */
? func_800A7448(void *);                            /* extern */
? func_800A75A0(void *);                            /* extern */
? func_800A761C(void *);                            /* extern */
? func_800A7790(void *);                            /* extern */
? get_time_record_minutes(s32, ? *);                          /* extern */
? get_time_record_seconds(s32, ? *);                          /* extern */
? get_time_record_centiseconds(s32, ? *);                          /* extern */
? func_800A8270(s32, void *);                       /* extern */
? func_800A8564(void *);                            /* extern */
? func_800A86E8(void *);                            /* extern */
? func_800A874C(void *);                            /* extern */
? func_800A890C(s32, void *);                       /* extern */
? func_800A8A98(void *);                            /* extern */
? func_800A8CA4(void *);                            /* extern */
? func_800A8E14(void *);                            /* extern */
? func_800A8EC0(void *);                            /* extern */
? func_800A8F48(void *);                            /* extern */
? func_800A90D4(s32, void *);                       /* extern */
s32 func_800B4EB4(?, ?);                            /* extern */
s32 func_800B555C(s32);                             /* extern */
? *segmented_to_virtual(s32, s8, s32);              /* extern */
? set_text_color(s32);                              /* extern */
extern s32 D_800DC540;
extern s32 D_800DC548;
extern ? D_8018EDE8;
extern s8 D_8018EDED;
extern s8 D_8018EDF3;
extern s8 D_802874F6;
extern ? gCharacterSelections;
extern void *gDisplayListHead;
extern s32 gGfxPool;
extern s32 gGlobalTimer;
static ? D_020014C8;                                /* unable to generate initializer */
static ? D_02001540;                                /* unable to generate initializer */
static ? D_020015A4;                                /* unable to generate initializer */
static ? D_020015CC;                                /* unable to generate initializer */
static ? D_02001630;                                /* unable to generate initializer */
static ? D_02001658;                                /* unable to generate initializer */
static ? D_020045E8;                                /* unable to generate initializer */
static ? D_02004610;                                /* unable to generate initializer */
static ? D_02004638;                                /* unable to generate initializer */
static ? D_02004660;                                /* unable to generate initializer */
static ? D_0200487C;                                /* unable to generate initializer */
static ? D_02004A34;                                /* unable to generate initializer */
static ? D_02004B4C;                                /* unable to generate initializer */
static ? D_02004B74;                                /* unable to generate initializer */
static ? D_02004E80;                                /* unable to generate initializer */
static s16 gCurrentCourseId;                        /* type too large by 2; unable to generate initializer */
static ? D_800E7500;                                /* unable to generate initializer; const */
static ? D_800E7524;                                /* unable to generate initializer; const */
static ? *D_800E7574[8] = {
    "mario raceway",
    "choco mountain",
    "bowser's castle",
    "banshee boardwalk",
    "yoshi valley",
    "frappe snowland",
    "koopa troopa beach",
    "royal raceway",
}; /* const */
static ? D_800E7594;                                /* unable to generate initializer; const */
static ? *D_800E77A0[2] = { "CONNECT A CONTROLLER TO SOCKET 1,", "THEN POWER ON AGAIN" }; /* const */
static ? D_800E77A8;                                /* unable to generate initializer; const */
static ? D_800E7CA8;                                /* unable to generate initializer; const */
static ? D_800E7D4C;                                /* unable to generate initializer; const */
static ? D_800E7D54;                                /* unable to generate initializer; const */
static ? D_800E817C;                                /* unable to generate initializer; const */
static ? D_800E824C;                                /* unable to generate initializer; const */
static ? D_800E8254;                                /* unable to generate initializer; const */
static ? D_800E8294;                                /* unable to generate initializer; const */
static ? D_800E86A8;                                /* unable to generate initializer; const */
static ? D_800E86AB;                                /* unable to generate initializer; const */
static ? D_800E86AD;                                /* unable to generate initializer; const */
static ? D_800EFD64;                                /* unable to generate initializer; const */
static ? D_800F2B70;                                /* unable to generate initializer; const */

void func_8009F5E0(void *arg0) {
    s32 spAC;
    s32 spA8;
    ? *sp9C;
    ? sp80;
    s32 sp58;
    f32 sp4C;
    s32 sp44;
    ? **sp40;
    s32 sp3C;
    f32 sp38;
    ? **temp_v0_8;
    s32 temp_a0;
    s32 temp_a0_2;
    s32 temp_a0_3;
    s32 temp_a1;
    s32 temp_a1_2;
    s32 temp_a1_3;
    s32 temp_a1_4;
    s32 temp_a1_5;
    s32 temp_a1_6;
    s32 temp_a1_7;
    s32 temp_a2_2;
    s32 temp_a2_3;
    s32 temp_a2_4;
    s32 temp_a2_6;
    s32 temp_a2_8;
    s32 temp_a2_9;
    s32 temp_t0;
    s32 temp_t1;
    s32 temp_t2;
    s32 temp_t4;
    s32 temp_t5;
    s32 temp_t8;
    s32 temp_t9;
    s32 temp_v0_10;
    s32 temp_v0_13;
    s32 temp_v0_5;
    s32 temp_v0_6;
    s32 temp_v0_7;
    s32 temp_v0_9;
    s32 temp_v1_3;
    s32 temp_v1_4;
    s32 temp_v1_5;
    s32 temp_v1_6;
    s32 temp_v1_8;
    s8 temp_a2;
    s8 temp_a2_5;
    s8 temp_a2_7;
    s8 temp_v0_11;
    s8 temp_v0_12;
    s8 temp_v0_4;
    s8 temp_v1_7;
    void *temp_v0;
    void *temp_v0_2;
    void *temp_v0_3;
    void *temp_v1;
    void *temp_v1_2;
    f32 phi_f0;
    void *phi_v0;
    s32 phi_t0;
    ? **phi_v0_2;
    s32 phi_v1;
    s32 phi_t0_2;
    s32 phi_v1_2;
    s32 phi_a2;
    s8 phi_a2_2;
    s32 phi_a1;
    void *phi_v0_3;
    s32 phi_a2_3;
    s32 phi_a2_4;

    if (arg0->unk15 != 0) {
        temp_v1 = gDisplayListHead;
        gDisplayListHead = temp_v1 + 8;
        temp_v1->unk4 = 0;
        temp_v1->unk0 = 0xE7000000;
        temp_t0 = arg0->unk0;
        phi_t0_2 = temp_t0;
        if (temp_t0 >= 0x10F) {
            if (temp_t0 >= 0x131) {
                switch (temp_t0) {                  /* switch 1 */
                    func_800A7790(arg0);
                    break;
                }
                /* Duplicate return node #135. Try simplifying control flow for better match */
                return;
            }
            switch (temp_t0) {                      /* switch 2 */
            case 0x12B:                             /* switch 2 */
                func_800A7258(arg0);
                return;
            case 0x12C:                             /* switch 2 */
                func_800A72FC(arg0);
                return;
            case 0x12D:                             /* switch 2 */
                func_800A7448(arg0);
                return;
            case 0x12E:                             /* switch 2 */
                func_800A75A0(arg0);
                return;
            case 0x12F:                             /* switch 2 */
                func_800A761C(arg0);
                return;
            case 0x130:                             /* switch 2 */
                if (arg0->unk4 != 0) {
                    temp_a2 = *(&D_800EFD64 + D_802874F6);
                    gDisplayListHead = func_8009BA74(gDisplayListHead, segmented_to_virtual(*(&D_800E7D54 + (temp_a2 * 4)), temp_a2), arg0->unkC, arg0->unk10);
                    func_8009A7EC(arg0->unk18, arg0->unkC, arg0->unk10, 0, arg0->unk1C);
                    return;
                }
                /* Duplicate return node #135. Try simplifying control flow for better match */
                return;
            }
        } else if (temp_t0 >= 0x38) {
            switch (temp_t0) {                      /* switch 3 */
            case 0xFA:                              /* switch 3 */
                func_80094660(gGfxPool, arg0->unk1C);
                return;
            case 0xFB:                              /* switch 3 */
                func_800947B4(gGfxPool, arg0->unk1C);
                return;
            case 0xD2:                              /* switch 3 */
                gDisplayListHead = func_8009B9D0(gDisplayListHead, &D_020014C8);
                return;
            case 0xD3:                              /* switch 3 */
                gDisplayListHead = func_8009B9D0(gDisplayListHead, &D_02001540);
                return;
            case 0xD4:                              /* switch 3 */
                func_800A09E0(arg0);
                func_800A0AD0(arg0);
                func_800A0B80(arg0);
                return;
            case 0xD5:                              /* switch 3 */
                temp_v1_2 = gDisplayListHead;
                gDisplayListHead = temp_v1_2 + 8;
                temp_v1_2->unk4 = 0xFF;
                temp_v1_2->unk0 = 0xFA000000;
                temp_v0 = func_8009B9D0(gDisplayListHead, &D_020015A4);
                gDisplayListHead = temp_v0;
                gDisplayListHead = temp_v0 + 8;
                temp_v0->unk4 = 0x320000FF;
                temp_v0->unk0 = 0xFA000000;
                temp_v0_2 = func_8009B9D0(gDisplayListHead, &D_020015CC);
                gDisplayListHead = temp_v0_2;
                gDisplayListHead = temp_v0_2 + 8;
                temp_v0_2->unk4 = 0x3200FF;
                temp_v0_2->unk0 = 0xFA000000;
                temp_v0_3 = func_8009B9D0(gDisplayListHead, &D_02001630);
                gDisplayListHead = temp_v0_3;
                gDisplayListHead = temp_v0_3 + 8;
                temp_v0_3->unk4 = 0x323200FF;
                temp_v0_3->unk0 = 0xFA000000;
                gDisplayListHead = func_8009B9D0(gDisplayListHead, &D_02001658);
                return;
            case 0xD6:                              /* switch 3 */
                func_8009A76C(arg0->unk0, arg0->unk0, arg0->unk0, -1);
                return;
            case 0xD7:                              /* switch 3 */
                func_800A0DFC(temp_t0);
                return;
            case 0xD8:                              /* switch 3 */
            case 0xD9:                              /* switch 3 */
                func_800A0EB8(arg0, temp_t0 - 0xD8);
                return;
            case 0x58:                              /* switch 3 */
            case 0x59:                              /* switch 3 */
            case 0x5A:                              /* switch 3 */
            case 0x5B:                              /* switch 3 */
            case 0x5C:                              /* switch 3 */
                func_800A8A98(arg0);
                gDisplayListHead = func_8009BA74(gDisplayListHead, segmented_to_virtual(*(&D_800E817C + (arg0->unk0 * 4))), arg0->unkC, arg0->unk10);
                func_800A8CA4(arg0);
                return;
            case 0x52:                              /* switch 3 */
                gDisplayListHead = func_8009BA74(gDisplayListHead, segmented_to_virtual(*(&D_800E817C + (temp_t0 * 4))), arg0->unkC, arg0->unk10);
                return;
            case 0x5F:                              /* switch 3 */
            case 0x60:                              /* switch 3 */
            case 0x61:                              /* switch 3 */
            case 0x62:                              /* switch 3 */
                func_800A1500(arg0);
                return;
            case 0x53:                              /* switch 3 */
            case 0x54:                              /* switch 3 */
            case 0x55:                              /* switch 3 */
            case 0x56:                              /* switch 3 */
                temp_a0 = temp_t0 - 0x53;
                spAC = temp_a0;
                func_800A890C(temp_a0, arg0);
                func_800A143C(arg0, spAC);
                return;
            case 0x5D:                              /* switch 3 */
                func_800A8564(arg0);
                gDisplayListHead = func_8009BC9C(gDisplayListHead, &D_02004E80, arg0->unkC, arg0->unk10, 2, arg0->unk1C);
                return;
            case 0x65:                              /* switch 3 */
            case 0x66:                              /* switch 3 */
                if (temp_t0 == 0x65) {
                    phi_f0 = 0.6f;
                } else {
                    phi_f0 = 0.8f;
                }
                sp4C = phi_f0;
                func_800A86E8(arg0);
                set_text_color(TEXT_YELLOW);
                func_80093324(arg0->unkC + 8, arg0->unk10 + 0x10, *(&D_800E7594 + (arg0->unk0 * 4)), 0, phi_f0, 0.8f);
                func_800A874C(arg0);
                return;
            case 0x6E:                              /* switch 3 */
                func_800A8E14(arg0);
                return;
            case 0x67:                              /* switch 3 */
                func_800A8EC0(arg0);
                return;
            case 0x68:                              /* switch 3 */
                temp_a1 = arg0->unkC;
                temp_a2_2 = arg0->unk10;
                gDisplayListHead = func_80098C18(gDisplayListHead, temp_a1, temp_a2_2, temp_a1 + 0x3F, temp_a2_2 + 0x11, 1, 1, 1, 0xFF);
                gDisplayListHead = func_8009BA74(gDisplayListHead, segmented_to_virtual(*(&D_800E8294 + (D_800DC548 * 4))), arg0->unkC, arg0->unk10);
                return;
            case 0x69:                              /* switch 3 */
                func_800A8F48(arg0);
                return;
            case 0x78:                              /* switch 3 */
            case 0x79:                              /* switch 3 */
            case 0x7A:                              /* switch 3 */
            case 0x7B:                              /* switch 3 */
                temp_a0_2 = temp_t0 - 0x78;
                spAC = temp_a0_2;
                func_800A90D4(temp_a0_2, arg0);
                func_800A143C(arg0, spAC);
                return;
            case 0x8C:                              /* switch 3 */
                temp_v0_4 = D_8018EDED;
                if ((temp_v0_4 >= 5) && (spAC == (temp_t0 - spA8))) {
                    if (temp_v0_4 >= 6) {
                        temp_a1_2 = arg0->unkC;
                        temp_a2_3 = arg0->unk10;
                        phi_v0 = func_80098C18(gDisplayListHead, temp_a1_2, temp_a2_3, temp_a1_2 + 0x3F, temp_a2_3 + 0x11, 0xFF, 0xF9, 0xDC, 0xFF);
                    } else {
                        temp_v1_3 = arg0->unk10;
                        temp_v0_5 = arg0->unkC;
                        phi_v0 = func_800959A0(gDisplayListHead, temp_v0_5, temp_v1_3, temp_v0_5 + 0x3F, temp_v1_3 + 0x11);
                    }
                } else {
                    temp_a1_3 = arg0->unkC;
                    temp_a2_4 = arg0->unk10;
                    phi_v0 = func_80098C18(gDisplayListHead, temp_a1_3, temp_a2_4, temp_a1_3 + 0x3F, temp_a2_4 + 0x11, 1, 1, 1, 0xFF);
                }
                gDisplayListHead = phi_v0;
                gDisplayListHead = func_8009BA74(gDisplayListHead, &D_02004A34, arg0->unkC, arg0->unk10);
                set_text_color(TEXT_YELLOW);
                func_800936B8(0x125, 0x1C, "a BUTTON*SEE DATA  B BUTTON*EXIT", 0, 0.55f, 0.55f);
                return;
            case 0x8D:                              /* switch 3 */
                func_800A1780(arg0);
                return;
            case 0x7C:                              /* switch 3 */
            case 0x7D:                              /* switch 3 */
            case 0x7E:                              /* switch 3 */
            case 0x7F:                              /* switch 3 */
            case 0x80:                              /* switch 3 */
            case 0x81:                              /* switch 3 */
            case 0x82:                              /* switch 3 */
            case 0x83:                              /* switch 3 */
            case 0x84:                              /* switch 3 */
            case 0x85:                              /* switch 3 */
            case 0x86:                              /* switch 3 */
            case 0x87:                              /* switch 3 */
            case 0x88:                              /* switch 3 */
            case 0x89:                              /* switch 3 */
            case 0x8A:                              /* switch 3 */
            case 0x8B:                              /* switch 3 */
                func_800A15EC(arg0);
                return;
            case 0x96:                              /* switch 3 */
                set_text_color(TEXT_BLUE_GREEN_RED_CYCLE_1);
                func_800936B8(arg0->unkC, arg0->unk10, *(&D_800E7500 + (D_800DC540 * 4)), arg0->unk1C, arg0->unk24, 1.0f);
                return;
            case 0x97:                              /* switch 3 */
                set_text_color(TEXT_BLUE_GREEN_RED_CYCLE_2);
                func_80093324(arg0->unkC, arg0->unk10, *(&D_800E7524 + (gCurrentCourseId * 4)), arg0->unk1C, arg0->unk24, 1.0f);
                return;
            case 0x98:                              /* switch 3 */
                func_800A2D1C(arg0);
                return;
            case 0x5E:                              /* switch 3 */
                gDisplayListHead = func_80096CD8(gDisplayListHead, 0x19, 0x72, 0x7C, 0x4A);
                return;
            case 0xAA:                              /* switch 3 */
                func_800A2EB8(arg0);
                return;
            case 0xAB:                              /* switch 3 */
                func_800A34A8(arg0);
                return;
            case 0xAC:                              /* switch 3 */
                func_800A6154(arg0);
                return;
            case 0xAF:                              /* switch 3 */
                func_800A6034(arg0);
                return;
            case 0xB0:                              /* switch 3 */
                func_800A638C(arg0);
                return;
            case 0xB1:                              /* switch 3 */
            case 0xB2:                              /* switch 3 */
            case 0xB3:                              /* switch 3 */
            case 0xB4:                              /* switch 3 */
                temp_v0_6 = temp_t0 - 0xB1;
                if (arg0->unk4 != 0) {
                    temp_a2_5 = *(&D_800EFD64 + *(&D_800E86A8 + temp_v0_6));
                    spA8 = temp_v0_6;
                    gDisplayListHead = func_8009BA74(gDisplayListHead, segmented_to_virtual(*(&D_800E7D54 + (temp_a2_5 * 4)), temp_a2_5), arg0->unkC, arg0->unk10);
                    func_8009A7EC(arg0->unk18, arg0->unkC, arg0->unk10, spA8, arg0->unk1C);
                    func_800A11D0(arg0, spA8, 0xFF);
                    return;
                }
                /* Duplicate return node #135. Try simplifying control flow for better match */
                return;
            case 0xB9:                              /* switch 3 */
                func_800A3C84(arg0);
                return;
            case 0xBA:                              /* switch 3 */
                func_800A3E60(arg0);
                return;
            case 0xBC:                              /* switch 3 */
                func_800A4A24(arg0);
                return;
            case 0xC7:                              /* switch 3 */
                func_800A4B38(arg0);
                return;
            case 0xBD:                              /* switch 3 */
                func_800A5738(arg0);
                return;
            case 0xE6:                              /* switch 3 */
                func_800A1924(arg0);
                return;
            case 0xE7:                              /* switch 3 */
                func_800A1A20(arg0);
                return;
            case 0xE8:                              /* switch 3 */
                func_800A1BE0(arg0);
                return;
            case 0xE9:                              /* switch 3 */
                func_800A1DE0(arg0);
                return;
            case 0xEA:                              /* switch 3 */
                func_800A1F30(arg0);
                return;
            case 0xF0:                              /* switch 3 */
                func_800A1FB0(arg0);
                return;
            case 0xF1:                              /* switch 3 */
                gDisplayListHead = func_8009BA74(gDisplayListHead, &D_02004638, arg0->unkC, arg0->unk10);
                return;
            case 0x10E:                             /* switch 3 */
                func_800A70E8(arg0);
                return;
            }
        } else {
            switch (temp_t0) {                      /* switch 4 */
            case 0x1:                               /* switch 4 */
                gDisplayListHead = func_8009BA74(gDisplayListHead, *(&D_800E7D4C + (func_800B555C(temp_t0) * 4)), arg0->unk0, arg0->unk0);
                return;
            case 0x2:                               /* switch 4 */
                func_8004C8D4(arg0->unk0 + 0xA0, arg0->unk0 + 0x47);
                gDisplayListHead = func_8009BA74(gDisplayListHead, &D_020045E8, arg0->unk0, arg0->unk0);
                return;
            case 0x3:                               /* switch 4 */
                if (((gGlobalTimer / 8) % 3) != 0) {
                    gDisplayListHead = func_8009BA74(gDisplayListHead, &D_02004610, arg0->unk0, arg0->unk0);
                    return;
                }
                /* Duplicate return node #135. Try simplifying control flow for better match */
                return;
            case 0x5:                               /* switch 4 */
                temp_t4 = ((get_string_width(*D_800E7574) + 5) * 0.9f) / 2;
                gDisplayListHead = draw_box(gDisplayListHead, 0xA0 - temp_t4, 0x7B, temp_t4 + 0xA0, 0xA4, 0, 0, 0, 0x96);
                set_text_color(TEXT_GREEN);
                draw_text(0x9B, 0x8C, *D_800E7574, 0, 0.9f, 0.9f);
                temp_v1_4 = func_800B4EB4(0, 7) & 0xFFFFF;
                if (temp_v1_4 < 0x1EAA) {
                    set_text_color(gGlobalTimer % 2);
                } else if (temp_v1_4 < 0x2329) {
                    set_text_color(gGlobalTimer % 3);
                } else {
                    set_text_color(TEXT_YELLOW);
                }
                get_time_record_minutes(temp_v1_4, &sp80);
                func_800939C8(0x77, 0xA0, &sp80, 0, 1.0f, 1.0f);
                func_80093324(0x8B, 0xA0, "'", 0, 1.0f, 1.0f);
                get_time_record_seconds(temp_v1_4, &sp80);
                func_800939C8(0x94, 0xA0, &sp80, 0, 1.0f, 1.0f);
                func_80093324(0xA7, 0xA0, "\"", 0, 1.0f, 1.0f);
                get_time_record_centiseconds(temp_v1_4, &sp80);
                func_800939C8(0xB4, 0xA0, &sp80, 0, 1.0f, 1.0f);
                return;
            case 0x4:                               /* switch 4 */
                sp58 = get_string_width(D_800E77A0->unk0);
                temp_v0_7 = get_string_width(D_800E77A0->unk4);
                phi_t0 = sp58;
                if (sp58 < temp_v0_7) {
                    phi_t0 = temp_v0_7;
                }
                temp_t2 = (phi_t0 * 0.75f) / 2;
                temp_t5 = (((0.75f * 2.0f) + 0.5) * 16.0) / 2;
                gDisplayListHead = draw_box(gDisplayListHead, 0xA0 - temp_t2, 0xB6 - temp_t5, temp_t2 + 0xA0, temp_t5 + 0xB6, 0, 0, 0, 0x96);
                set_text_color(TEXT_BLUE_GREEN_RED_CYCLE_1);
                sp38 = 0xB4;
                sp3C = 0xA0 - (1.0f * 0.75f);
                phi_v0_2 = D_800E77A0;
                phi_v1 = 0;
                do {
                    sp40 = phi_v0_2;
                    sp44 = phi_v1;
                    draw_text(sp3C, sp38 + (phi_v1 * 0.75f), *phi_v0_2, 0, 0.75f, 0.75f);
                    temp_v0_8 = phi_v0_2 + 4;
                    phi_v0_2 = temp_v0_8;
                    phi_v1 += 0x12;
                } while (temp_v0_8 != &D_800E77A8);
                return;
            case 0x23:                              /* switch 4 */
            case 0x24:                              /* switch 4 */
            case 0x25:                              /* switch 4 */
                gDisplayListHead = func_8009BC9C(gDisplayListHead, *(&D_800E7D4C + (func_800B555C(temp_t0) * 4)), arg0->unkC, arg0->unk10, 3, 0);
                return;
            case 0xA:                               /* switch 4 */
                gDisplayListHead = func_8009BA74(gDisplayListHead, &D_02004660, arg0->unkC, arg0->unk10);
                return;
            case 0xB:                               /* switch 4 */
            case 0xC:                               /* switch 4 */
            case 0xD:                               /* switch 4 */
            case 0xE:                               /* switch 4 */
                temp_a0_3 = temp_t0 - 0xB;
                spAC = temp_a0_3;
                func_800A8270(temp_a0_3, arg0);
                func_800A0FA4(arg0, spAC);
                return;
            case 0xF:                               /* switch 4 */
                func_800A8564(arg0);
                gDisplayListHead = func_8009BC9C(gDisplayListHead, &D_0200487C, arg0->unkC, arg0->unk10, 2, arg0->unk1C);
                return;
            case 0x10:                              /* switch 4 */
            case 0x11:                              /* switch 4 */
                temp_v1_5 = arg0->unk1C;
                phi_v1_2 = temp_v1_5;
                if (temp_v1_5 < 0x20) {
                    temp_t9 = (temp_v1_5 * 0x3A) / 64;
                    if ((temp_t0 - 0xF) == D_8018EDED) {
                        temp_v0_9 = arg0->unkC;
                        temp_v1_6 = arg0->unk10;
                        gDisplayListHead = func_800959CC(gDisplayListHead, temp_v0_9 + temp_t9, temp_v1_6, (temp_v0_9 - temp_t9) + 0x39, temp_v1_6 + 0x12);
                    } else {
                        temp_v0_10 = arg0->unkC;
                        temp_a2_6 = arg0->unk10;
                        gDisplayListHead = func_80098C18(gDisplayListHead, temp_v0_10 + temp_t9, temp_a2_6, (temp_v0_10 - temp_t9) + 0x39, temp_a2_6 + 0x12, 1, 1, 1, 0xFF);
                    }
                    phi_t0_2 = arg0->unk0;
                    phi_v1_2 = arg0->unk1C;
                }
                temp_t8 = phi_t0_2 - 0xA;
                spA8 = temp_t8;
                gDisplayListHead = func_8009BC9C(gDisplayListHead, *(&D_800E8254 + (temp_t8 * 4)), arg0->unkC, arg0->unk10, 2, phi_v1_2);
                return;
            case 0x12:                              /* switch 4 */
            case 0x13:                              /* switch 4 */
            case 0x14:                              /* switch 4 */
            case 0x15:                              /* switch 4 */
            case 0x16:                              /* switch 4 */
            case 0x17:                              /* switch 4 */
            case 0x18:                              /* switch 4 */
            case 0x19:                              /* switch 4 */
                temp_v0_11 = D_8018EDF3;
                temp_v1_7 = *(&D_800E86AB + temp_v0_11);
                temp_a2_7 = *(&D_800E86AD + ((temp_v0_11 * 3) + temp_v1_7));
                temp_a1_4 = *(&D_800F2B70 + ((temp_v0_11 * 0xC) + (temp_v1_7 * 4)));
                phi_a2 = temp_a2_7;
                phi_a2_2 = temp_a2_7;
                phi_a1 = temp_a1_4;
                switch (temp_t0) {                  /* switch 5 */
                case 18:                            /* switch 5 */
                case 19:                            /* switch 5 */
                case 20:                            /* switch 5 */
                case 21:                            /* switch 5 */
                    if ((temp_a1_4 != 0) && (temp_a1_4 != 2)) {
                        phi_a2 = -1;
                    }
                    spA8 = 0x12;
                    spAC = phi_a2;
                    sp9C = segmented_to_virtual(*(&D_800E824C + (temp_t0 * 4)), temp_a1_4, phi_a2);
                    phi_a2_2 = phi_a2;
block_58:
                    phi_a1 = spA8;
                    break;
                case 22:                            /* switch 5 */
                case 23:                            /* switch 5 */
                    if (temp_a1_4 != 2) {
                        phi_a2_2 = -1;
                    } else {
                        spA8 = 0x16;
                        spAC = temp_a2_7;
                        sp9C = segmented_to_virtual(*(&D_800E824C + (temp_t0 * 4)), 0x16, temp_a2_7);
                        phi_a2_2 = temp_a2_7;
                        goto block_58;
                    }
                    break;
                case 24:                            /* switch 5 */
                case 25:                            /* switch 5 */
                    if (temp_a1_4 != 1) {
                        phi_a2_2 = -1;
                    } else {
                        spA8 = 0x18;
                        spAC = temp_a2_7;
                        sp9C = segmented_to_virtual(*(&D_800E824C + (temp_t0 * 4)), 0x18, temp_a2_7);
                        phi_a2_2 = temp_a2_7;
                        goto block_58;
                    }
                    break;
                }
                if (phi_a2_2 != -1) {
                    temp_v0_12 = D_8018EDED;
                    if ((temp_v0_12 >= 5) && (phi_a2_2 == (arg0->unk0 - phi_a1))) {
                        if (temp_v0_12 >= 6) {
                            temp_a1_5 = arg0->unkC;
                            temp_a2_8 = arg0->unk10;
                            phi_v0_3 = func_80098C18(gDisplayListHead, temp_a1_5, temp_a2_8, temp_a1_5 + 0x3F, temp_a2_8 + 0x11, 0xFF, 0xF9, 0xDC, 0xFF);
                        } else {
                            temp_v1_8 = arg0->unk10;
                            temp_v0_13 = arg0->unkC;
                            phi_v0_3 = func_800959A0(gDisplayListHead, temp_v0_13, temp_v1_8, temp_v0_13 + 0x3F, temp_v1_8 + 0x11);
                        }
                    } else {
                        temp_a1_6 = arg0->unkC;
                        temp_a2_9 = arg0->unk10;
                        phi_v0_3 = func_80098C18(gDisplayListHead, temp_a1_6, temp_a2_9, temp_a1_6 + 0x3F, temp_a2_9 + 0x11, 1, 1, 1, 0xFF);
                    }
                    gDisplayListHead = phi_v0_3;
                    gDisplayListHead = func_8009BA74(gDisplayListHead, sp9C, arg0->unkC, arg0->unk10);
                    return;
                }
                /* Duplicate return node #135. Try simplifying control flow for better match */
                return;
            case 0x1B:                              /* switch 4 */
                func_800A10CC(arg0);
                return;
            case 0x2A:                              /* switch 4 */
                gDisplayListHead = func_8009BA74(gDisplayListHead, &D_02004B4C, arg0->unkC, arg0->unk10);
                return;
            case 0x34:                              /* switch 4 */
            case 0x35:                              /* switch 4 */
            case 0x36:                              /* switch 4 */
            case 0x37:                              /* switch 4 */
                temp_a1_7 = temp_t0 - 0x34;
                if (*(&gCharacterSelections + temp_a1_7) != 0) {
                    if (*(&D_8018EDE8 + temp_a1_7) == 0) {
                        phi_a2_3 = 0xFF;
                    } else {
                        temp_t1 = gGlobalTimer % 16;
                        if (temp_t1 >= 8) {
                            phi_a2_4 = (temp_t1 * -8) + 0x80;
                        } else {
                            phi_a2_4 = temp_t1 * 8;
                        }
                        phi_a2_3 = phi_a2_4 + 0xBF;
                    }
                    func_800A11D0(arg0, temp_a1_7, phi_a2_3);
                    return;
                }
                /* Duplicate return node #135. Try simplifying control flow for better match */
                return;
            case 0x33:                              /* switch 4 */
                func_800A8564(arg0);
                gDisplayListHead = func_8009BC9C(gDisplayListHead, &D_02004B74, arg0->unkC, arg0->unk10, 2, arg0->unk1C);
                return;
            case 0x2B:                              /* switch 4 */
            case 0x2C:                              /* switch 4 */
            case 0x2D:                              /* switch 4 */
            case 0x2E:                              /* switch 4 */
            case 0x2F:                              /* switch 4 */
            case 0x30:                              /* switch 4 */
            case 0x31:                              /* switch 4 */
            case 0x32:                              /* switch 4 */
                func_800A12BC(arg0, segmented_to_virtual(*(&D_800E7CA8 + (temp_t0 * 4))));
            case 0xA0:                              /* switch 3 */
            case 0xA1:                              /* switch 3 */
                func_8009A76C(arg0->unk18, arg0->unkC, arg0->unk10, arg0->unk1C);
                return;
            }
        }
    } else {
    default:                                        /* switch 4 */
    default:                                        /* switch 3 */
    default:                                        /* switch 2 */
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_8009F5E0.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 func_8009BA74(s32, s32, s32, s32); // extern
s32 segmented_to_virtual(s32, s32); // extern
extern ? D_800E7AF8;
extern s32 gDisplayListHead;

void func_800A08D8(s32 arg0, s32 arg1, s32 arg2) {
    s32 temp_a3;
    s32 temp_t6;
    s32 phi_a3;

    temp_a3 = arg0 & 0xFF;
    if (temp_a3 >= 0x10) {
        temp_t6 = (temp_a3 - 0x10) & 0xFF;
        phi_a3 = temp_t6;
        if (temp_t6 < 0x85) {
            if (temp_t6 >= 0x32) {
                phi_a3 = 0x2B;
            }
            gDisplayListHead = func_8009BA74(gDisplayListHead, segmented_to_virtual(*(&D_800E7AF8 + (phi_a3 * 4)), phi_a3), arg1, arg2);
        }
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A08D8.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800A08D8(s32, s32, ?); // extern

s32 func_800A095C(s8 *arg0, s32 arg1, s32 arg2, ? arg3) {
    s32 temp_s1;
    s8 temp_v0;
    s8 *phi_s2;
    s32 phi_s0;
    s32 phi_s1;
    s32 phi_s3;
    s32 phi_s3_2;
    s32 phi_s3_3;

    phi_s2 = arg0;
    phi_s0 = arg2;
    phi_s1 = arg1;
    phi_s3 = 0;
    phi_s3_3 = 0;
    if (arg1 != 0) {
        do {
            temp_v0 = *phi_s2;
            phi_s3_2 = phi_s3_3;
            if (temp_v0 != 0) {
                phi_s3_2 = phi_s3_3 + 1;
            }
            func_800A08D8(temp_v0 & 0xFF, phi_s0, arg3);
            temp_s1 = phi_s1 - 1;
            phi_s2 += 1;
            phi_s0 += 8;
            phi_s1 = temp_s1;
            phi_s3 = phi_s3_2;
            phi_s3_3 = phi_s3_2;
        } while (temp_s1 != 0);
    }
    return phi_s3;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A095C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void *func_8009BA74(void *, ? *, ?, s32); // extern
extern ? D_0200157C;
extern s8 D_800E86D0;
extern void *gDisplayListHead;

void func_800A09E0(void *arg0) {
    s32 temp_s0;
    void *temp_v1;
    s32 phi_s0;

    temp_v1 = gDisplayListHead;
    gDisplayListHead = temp_v1 + 8;
    temp_v1->unk0 = 0xED000000;
    temp_v1->unk4 = 0x4FC308;
    phi_s0 = 0;
    do {
        if ((D_800E86D0 != 0) || ((phi_s0 != 0) && (phi_s0 != 8))) {
            gDisplayListHead = func_8009BA74(gDisplayListHead, &D_0200157C, 0x20, (phi_s0 * 0xA) + arg0->unk10);
        }
        temp_s0 = phi_s0 + 1;
        phi_s0 = temp_s0;
    } while (temp_s0 != 9);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A09E0.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void *func_8009BA74(void *, ? *, ?, s32); // extern
void *func_800AAEF4(?); // extern
extern ? D_02001874;
extern s8 D_800E86C0;
extern void *gDisplayListHead;
extern s8 gPlayerCountSelection2;

void func_800A0AD0(s32 arg0) {
    s8 temp_v1;
    void *temp_t1;
    void *temp_v1_2;

    temp_v1 = gPlayerCountSelection2;
    temp_t1 = func_800AAEF4(0xDA);
    if ((temp_v1 != 1) && (temp_v1 != 2)) {
        temp_v1_2 = gDisplayListHead;
        gDisplayListHead = temp_v1_2 + 8;
        temp_v1_2->unk0 = 0xFA000000;
        temp_v1_2->unk4 = ((temp_t1->unk20 & 0xFF) << 0x10) | 0xFF000000 | 0xFF;
        gDisplayListHead = func_8009BA74(gDisplayListHead, &D_02001874, 0x24, (D_800E86C0 * 0xA) + 0x7C);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A0AD0.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800A08D8(u8, s32, s32); // extern
s32 func_800A095C(void *, ?, ?, s32); // extern
extern s8 D_800E86C4;
extern ? D_8018E938;
extern ? D_8018EB34;
extern void *gDisplayListHead;

void func_800A0B80(void *arg0) {
    s32 temp_a2;
    s32 temp_lo;
    s32 temp_s1;
    s32 temp_s1_2;
    s32 temp_s2;
    s32 temp_s5;
    s8 temp_v0;
    s8 temp_v0_2;
    void *temp_s4;
    void *temp_v1;
    void *temp_v1_2;
    s8 *phi_s6;
    s32 phi_s5;
    s32 phi_s0;
    s32 phi_s1;

    temp_v1 = gDisplayListHead;
    gDisplayListHead = temp_v1 + 8;
    temp_v1->unk4 = 0x32FF;
    temp_v1->unk0 = 0xFA000000;
    phi_s6 = &D_800E86C4;
    phi_s5 = 0;
    do {
        temp_v0 = *phi_s6;
        if (temp_v0 != 0) {
            temp_s1 = phi_s5 * 0xA;
            temp_a2 = arg0->unk10 + temp_s1 + 1;
            if (temp_v0 < 0xA) {
                func_800A08D8((temp_v0 + 0x10) & 0xFF, 0x32, temp_a2);
            } else {
                func_800A08D8(((temp_v0 % 0xA) + 0x10) & 0xFF, 0x35, temp_a2);
                func_800A08D8(0x11, 0x2F, arg0->unk10 + temp_s1 + 1);
            }
            temp_v0_2 = *phi_s6;
            temp_s2 = arg0->unk10 + temp_s1 + 1;
            if (*(&D_8018EB34 + (temp_v0_2 * 4)) == 0) {
                temp_s4 = (temp_v0_2 << 5) - 0x20 + &D_8018E938;
                temp_s1_2 = func_800A095C(temp_s4 + 0xE, 0x10, 0x4F, temp_s2) * 8;
                if (temp_s4->unkA != 0) {
                    func_800A08D8(0x3C, temp_s1_2 + 0x4F, temp_s2);
                    func_800A08D8(temp_s4->unkA, temp_s1_2 + 0x57, temp_s2);
                }
                phi_s0 = (temp_s4->unk0 + 0xFF) >> 8;
                phi_s1 = 0x10;
                do {
                    func_800A08D8(((phi_s0 % 0xA) + 0x10) & 0xFF, phi_s1 + 0xFD, temp_s2);
                    temp_lo = phi_s0 / 0xA;
                    phi_s0 = temp_lo;
                    phi_s1 += -8;
                } while (temp_lo != 0);
            }
        }
        temp_s5 = phi_s5 + 1;
        phi_s6 += 1;
        phi_s5 = temp_s5;
    } while (temp_s5 != 9);
    temp_v1_2 = gDisplayListHead;
    gDisplayListHead = temp_v1_2 + 8;
    temp_v1_2->unk0 = 0xED000000;
    temp_v1_2->unk4 = 0x4FC3BC;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A0B80.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 func_8009BA74(s32, s32, s32, ?); // extern
s32 segmented_to_virtual(s32); // extern
extern ? D_800E7D0C;
extern s32 D_8018EB80;
extern s32 gDisplayListHead;

void func_800A0DFC(void) {
    s32 temp_lo;
    s32 phi_s0;
    s32 phi_s1;

    phi_s0 = D_8018EB80;
    phi_s1 = 0x110;
    do {
        temp_lo = phi_s0 / 0xA;
        gDisplayListHead = func_8009BA74(gDisplayListHead, segmented_to_virtual(*(&D_800E7D0C + ((phi_s0 % 0xA) * 4))), phi_s1, 0xB8);
        phi_s0 = temp_lo;
        phi_s1 += -9;
    } while (temp_lo != 0);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A0DFC.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void *func_8009BA74(void *, ? *, s16, s16); // extern
void *func_800AAEF4(?); // extern
extern ? D_0200184C;
extern ? D_800E7278;
extern void *gDisplayListHead;
extern s8 gPlayerCountSelection2;

void func_800A0EB8(s32 arg0, s32 arg1) {
    s8 temp_v0;
    void *temp_t0;
    void *temp_t3;
    void *temp_v0_2;
    s32 phi_t1;

    temp_t3 = func_800AAEF4(0xDA);
    if (arg1 == 0) {
        if (gPlayerCountSelection2 == 2) {
            phi_t1 = 1;
        } else {
            phi_t1 = 0;
        }
        goto block_7;
    }
    temp_v0 = gPlayerCountSelection2;
    if ((temp_v0 == 3) || (temp_v0 == 4)) {
        phi_t1 = ((arg1 * 2) + temp_v0) - 3;
block_7:
        temp_t0 = gDisplayListHead;
        gDisplayListHead = temp_t0 + 8;
        temp_t0->unk0 = 0xFA000000;
        temp_t0->unk4 = ((temp_t3->unk20 & 0xFF) << 0x10) | 0xFF000000 | 0xFF;
        temp_v0_2 = (phi_t1 * 8) + &D_800E7278;
        gDisplayListHead = func_8009BA74(gDisplayListHead, &D_0200184C, temp_v0_2->unk0, temp_v0_2->unk2);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A0EB8.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
static ? D_800E8234;                                /* unable to generate initializer; const */

void func_800A0FA4(void *arg0, s32 arg1) {
    u32 temp_t6;
    void *temp_s1;
    void *temp_s1_2;
    s32 phi_v0;

    temp_t6 = arg0->unk4;
    switch (temp_t6) {
    case 0:
    case 2:
    case 3:
        temp_s1 = (arg1 * 8) + &D_800E8234;
        gDisplayListHead = func_8009BA74(gDisplayListHead, segmented_to_virtual(temp_s1->unk0), arg0->unkC, arg0->unk10);
        phi_v0 = func_8009BA74(gDisplayListHead, segmented_to_virtual(temp_s1->unk4), arg0->unkC, arg0->unk10);
block_4:
        gDisplayListHead = phi_v0;
        break;
    case 1:
    case 4:
        temp_s1_2 = (arg1 * 8) + &D_800E8234;
        gDisplayListHead = func_8009BC9C(gDisplayListHead, segmented_to_virtual(temp_s1_2->unk0), arg0->unkC, arg0->unk10, 2, arg0->unk1C);
        phi_v0 = func_8009BC9C(gDisplayListHead, segmented_to_virtual(temp_s1_2->unk4), arg0->unkC, arg0->unk10, 2, arg0->unk1C);
        goto block_4;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A0FA4.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
/*
Failed to decompile function func_800A10CC:

Label L800A1114 refers to a delay slot; this is currently not supported.
Please modify the assembly to work around it (e.g. copy the instruction
to all jump sources and move the label, or add a nop to the delay slot).
*/
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A10CC.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void *func_8009BA74(void *, s32, s32, s32); // extern
s32 segmented_to_virtual(s32, s32); // extern
extern ? D_800E74A8;
extern ? D_800E82B4;
extern void *gDisplayListHead;

void func_800A11D0(void *arg0, s32 arg1, s32 arg2) {
    s32 temp_a3;
    void *temp_v0;
    void *temp_v0_2;
    void *temp_v1;

    temp_v0 = gDisplayListHead;
    gDisplayListHead = temp_v0 + 8;
    temp_v1 = (arg1 * 8) + &D_800E74A8;
    temp_v0->unk0 = 0xFA000000;
    temp_v0->unk4 = (temp_v1->unk0 << 0x18) | ((temp_v1->unk2 & 0xFF) << 0x10) | ((temp_v1->unk4 & 0xFF) << 8) | (temp_v1->unk6 & 0xFF);
    temp_v0_2 = gDisplayListHead;
    temp_a3 = arg2 & 0xFF;
    gDisplayListHead = temp_v0_2 + 8;
    temp_v0_2->unk0 = 0xFB000000;
    temp_v0_2->unk4 = (temp_a3 << 0x18) | (temp_a3 << 0x10) | (temp_a3 << 8);
    gDisplayListHead = func_8009BA74(gDisplayListHead, segmented_to_virtual(*(&D_800E82B4 + (arg1 * 4)), temp_a3), arg0->unkC, arg0->unk10);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A11D0.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
void func_800A12BC(void *arg0) {
    u32 temp_t6;
    s32 phi_v0;

    temp_t6 = arg0->unk4;
    switch (temp_t6) {
    case 0:
    case 2:
    case 4:
        phi_v0 = func_8009BA74(gDisplayListHead, MIPS2C_ERROR(Read from unset register $a1), arg0->unkC);
block_4:
        gDisplayListHead = phi_v0;
        break;
    case 1:
    case 3:
        phi_v0 = func_8009BC9C(gDisplayListHead, MIPS2C_ERROR(Read from unset register $a1), arg0->unkC, arg0->unk10, 2, arg0->unk1C);
        goto block_4;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A12BC.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
static ? D_800E82C8;                                /* unable to generate initializer; const */

void func_800A143C(void *arg0, s32 arg1) {
    u32 temp_t6;
    s32 phi_v0;

    temp_t6 = arg0->unk4;
    switch (temp_t6) {
    case 0:
    case 2:
    case 3:
        phi_v0 = func_8009BA74(gDisplayListHead, segmented_to_virtual(*(&D_800E82C8 + (arg1 * 4))), arg0->unkC, arg0->unk10);
block_4:
        gDisplayListHead = phi_v0;
        break;
    case 1:
    case 4:
        phi_v0 = func_8009BC9C(gDisplayListHead, segmented_to_virtual(*(&D_800E82C8 + (arg1 * 4))), arg0->unkC, arg0->unk10, 2, arg0->unk1C);
        goto block_4;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A143C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_8009A76C(s32, s16, s16, ?); // extern
void *func_800AAEF4(?); // extern
extern ? D_800E7168;

void func_800A1500(void *arg0) {
    s32 sp1C;
    s32 temp_v1;
    void *temp_v0;
    void *temp_v0_2;
    s32 phi_a1;

    sp1C = 0;
    temp_v0 = func_800AAEF4(0x64);
    temp_v1 = temp_v0->unk4;
    phi_a1 = sp1C;
    if ((temp_v1 != 0) && (temp_v1 != 1)) {
        if (temp_v1 != 2) {
            if (temp_v1 != 3) {

            } else {
                goto block_7;
            }
        } else if (arg0->unk0 != ((temp_v0->unk1C % 4) + 0x5F)) {
block_7:
            phi_a1 = 1;
        }
    }
    if (phi_a1 != 0) {
        if (phi_a1 != 1) {
            return;
        }
        temp_v0_2 = (arg0->unk0 * 8) - 0x2F8 + &D_800E7168;
        func_8009A76C(arg0->unk18, temp_v0_2->unk0, temp_v0_2->unk2, -2);
        return;
    }
    func_8009A76C(arg0->unk18, 0x17, 0x70, -1);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A1500.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 draw_box(s32, s32, s32, s32, s32, s32, s32, s32, s32); // extern
s32 func_800959A0(s32, s32, s32, s32, s32); // extern
s32 func_8009C204(s32, s32, s32, s32, s32); // extern
s32 func_800B639C(s32); // extern
s32 segmented_to_virtual(? *, s32); // extern
extern ? D_02004A0C;
extern ? D_800E7D74;
extern ? D_800E7DC4;
extern ? gCupCourseOrder;
extern s32 gDisplayListHead;

void func_800A15EC(void *arg0) {
    s32 sp44;
    s32 temp_a1;
    s32 temp_s1;
    s32 temp_s1_2;
    s32 temp_v0;
    s32 temp_v0_2;
    s32 temp_v1;
    s32 temp_v1_2;

    temp_v0 = arg0->unk0 - 0x7C;
    temp_a1 = *(&gCupCourseOrder + (((temp_v0 / 4) * 8) + ((temp_v0 % 4) * 2))) * 4;
    sp44 = temp_a1;
    temp_v0_2 = func_8009C204(gDisplayListHead, segmented_to_virtual(*(&D_800E7D74 + temp_a1), temp_a1), arg0->unkC, arg0->unk10, 2);
    gDisplayListHead = temp_v0_2;
    temp_v1 = arg0->unk10;
    temp_s1 = arg0->unkC;
    gDisplayListHead = draw_box(temp_v0_2, temp_s1, temp_v1 + 0x27, temp_s1 + 0x40, temp_v1 + 0x30, 0, 0, 0, 0xFF);
    gDisplayListHead = func_8009C204(gDisplayListHead, segmented_to_virtual(*(&D_800E7DC4 + sp44)), arg0->unkC, arg0->unk10 + 0x27, 3);
    if (func_800B639C(arg0->unk0 - 0x7C) >= 0) {
        temp_v1_2 = arg0->unk10;
        temp_s1_2 = arg0->unkC;
        gDisplayListHead = func_800959A0(gDisplayListHead, temp_s1_2 + 0x20, temp_v1_2, temp_s1_2 + 0x3F, temp_v1_2 + 9);
        gDisplayListHead = func_8009C204(gDisplayListHead, segmented_to_virtual(&D_02004A0C), arg0->unkC + 0x20, arg0->unk10, 2);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A15EC.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void *func_8009BA74(void *, s32, s32, s32); // extern
s32 segmented_to_virtual(? *, void *, s32, s32); // extern
extern ? D_02001FA4;
extern ? D_800E74D0;
extern void *gDisplayListHead;

void func_800A1780(void *arg0) {
    s32 temp_a2;
    s32 temp_a3;
    s32 temp_v0;
    void *temp_a1;
    void *temp_t0;
    void *temp_v1;

    temp_a3 = arg0->unk20;
    temp_v1 = &D_800E74D0 + (temp_a3 * 8);
    temp_v0 = arg0->unk1C;
    temp_a2 = 0x100 - temp_v0;
    temp_a1 = &D_800E74D0 + (((temp_a3 + 1) % 3) * 8);
    temp_t0 = gDisplayListHead;
    gDisplayListHead = temp_t0 + 8;
    temp_t0->unk0 = 0xFA000000;
    temp_t0->unk4 = ((((temp_v1->unk0 * temp_a2) + (temp_a1->unk0 * temp_v0)) / 0x100) << 0x18) | (((((temp_v1->unk2 * temp_a2) + (temp_a1->unk2 * temp_v0)) / 0x100) & 0xFF) << 0x10) | (((((temp_v1->unk4 * temp_a2) + (temp_a1->unk4 * temp_v0)) / 0x100) & 0xFF) << 8) | ((((temp_v1->unk6 * temp_a2) + (temp_a1->unk6 * temp_v0)) / 0x100) & 0xFF);
    gDisplayListHead = func_8009BA74(gDisplayListHead, segmented_to_virtual(&D_02001FA4, temp_a1, temp_a2, temp_a3), arg0->unkC, arg0->unk10);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A1780.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_8004EF9C(s16); // extern
void *func_800959A0(void *, ?, ?, ?, s32); // extern
? func_8009A76C(s32, ?, ?, ?); // extern
void *func_8009BA74(void *, ? *, ?, ?); // extern
s32 func_800B639C(s8); // extern
extern ? D_02004A0C;
extern s8 D_8018EDF7;
extern ? gCupCourseOrder;
extern void *gDisplayListHead;

void func_800A1924(void *arg0) {
    s8 temp_v0_2;
    void *temp_v0;
    void *temp_v0_3;

    func_8009A76C(arg0->unk18, 0x17, 0x84, -1);
    if (func_800B639C(D_8018EDF7) >= 0) {
        temp_v0 = func_800959A0(gDisplayListHead, 0x57, 0x84, 0x96, 0x95);
        gDisplayListHead = temp_v0;
        gDisplayListHead = func_8009BA74(temp_v0, &D_02004A0C, 0x57, 0x84);
    }
    temp_v0_2 = D_8018EDF7;
    func_8004EF9C(*(&gCupCourseOrder + (((temp_v0_2 / 4) * 8) + ((temp_v0_2 % 4) * 2))));
    temp_v0_3 = gDisplayListHead;
    gDisplayListHead = temp_v0_3 + 8;
    temp_v0_3->unk4 = 0x2000;
    temp_v0_3->unk0 = 0xBA000C02;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A1924.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? draw_text(?, s32, s32, ?, f32, f32); // extern
? func_80093324(?, s32, ? *, ?, f32, f32); // extern
? func_800936B8(?, s32, s32, ?, f32, f32); // extern
? func_800A474C(s32, ?, s32); // extern
? set_text_color(?); // extern
extern ? D_800E7574;
extern ? *D_800E7728;
extern ? *D_800E772C;
extern ? D_800E77D8;
extern ? D_800E77E4;
extern s8 D_8018EDF7;
extern ? gCupCourseOrder;

void func_800A1A20(void *arg0) {
    s16 temp_s1;
    s32 temp_s0;
    s32 temp_s0_2;
    s8 temp_v0;
    s32 phi_s0;
    s32 phi_s1;

    temp_v0 = D_8018EDF7;
    temp_s1 = *(&gCupCourseOrder + (((temp_v0 / 4) * 8) + ((temp_v0 % 4) * 2)));
    arg0->unkC = 0x14;
    set_text_color(TEXT_BLUE_GREEN_RED_CYCLE_1);
    temp_s0 = temp_s1 * 4;
    draw_text(0x69, arg0->unk10 + 0x19, *(&D_800E7574 + temp_s0), 0, 0.75f, 0.75f);
    set_text_color(TEXT_RED);
    func_80093324(0x2D, arg0->unk10 + 0x28, &D_800E77D8, 0, 0.75f, 0.75f);
    func_800936B8(0xA5, arg0->unk10 + 0x28, *(&D_800E77E4 + temp_s0), 1, 0.75f, 0.75f);
    set_text_color(TEXT_YELLOW);
    func_80093324(0xA0, arg0->unk10 + 0x86, D_800E7728, 0, 0.75f, 0.75f);
    phi_s0 = 0;
    phi_s1 = 0;
    do {
        set_text_color(TEXT_RED);
        func_800A474C(phi_s0, 0x96, arg0->unk10 + phi_s1 + 0x92);
        temp_s0_2 = phi_s0 + 1;
        phi_s0 = temp_s0_2;
        phi_s1 += 0xD;
    } while (temp_s0_2 != 5);
    set_text_color(TEXT_YELLOW);
    func_80093324(0xA0, arg0->unk10 + 0xD5, D_800E772C, 0, 0.75f, 0.75f);
    func_800A474C(5, 0x96, arg0->unk10 + 0xE1);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A1A20.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80093324(?, s32, s32, ?, f32, f32); // extern
? func_80093358(?, s32, s32, ?, f32, f32); // extern
? func_800A66A8(s32, s16 *); // extern
s32 func_800B639C(s8); // extern
? set_text_color(?); // extern
extern s32 D_800E7834;
extern f32 D_800F1B54;
extern ? D_8018EB90;
extern s8 D_8018EDF7;
extern s8 D_8018EDF8;
extern void *gDisplayListHead;

void func_800A1BE0(s32 arg0) {
    s16 sp7A;
    s16 sp78;
    f32 temp_f20;
    s32 temp_s0;
    s8 temp_v0;
    void *temp_v1;
    s32 phi_s0;
    s32 phi_s1;
    s32 phi_s4;
    s32 *phi_s3;
    ? phi_s2;

    temp_v0 = D_8018EDF7;
    temp_f20 = D_800F1B54;
    phi_s0 = 0;
    phi_s4 = 0x3F;
    phi_s3 = &D_800E7834;
    do {
        phi_s1 = 0;
        if (phi_s0 == D_8018EDF8) {
            phi_s2 = TEXT_BLUE_GREEN_RED_CYCLE_2;
        } else {
            phi_s2 = TEXT_GREEN;
            if (phi_s0 != 1) {
                if (phi_s0 != 2) {

                } else if (func_800B639C(D_8018EDF7) < 0) {
                    goto block_9;
                }
            } else if ((((temp_v0 / 4) * 0x60) + ((temp_v0 % 4) * 0x18) + &D_8018EB90)->unk12 == 0) {
block_9:
                phi_s1 = 1;
            }
        }
        if (phi_s1 != 0) {
            set_text_color(TEXT_BLUE);
            temp_v1 = gDisplayListHead;
            gDisplayListHead = temp_v1 + 8;
            temp_v1->unk4 = 0x96;
            temp_v1->unk0 = 0xFA000000;
            func_80093358(0x25, phi_s4, *phi_s3, 0, temp_f20, temp_f20);
        } else {
            set_text_color(phi_s2);
            func_80093324(0x25, phi_s4, *phi_s3, 0, temp_f20, temp_f20);
        }
        temp_s0 = phi_s0 + 1;
        phi_s0 = temp_s0;
        phi_s4 += 0xD;
        phi_s3 += 4;
    } while (temp_s0 != 3);
    sp78 = 0x1F;
    sp7A = (D_8018EDF8 * 0xD) + 0x3A;
    func_800A66A8(arg0, &sp78);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A1BE0.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80093324(?, s32, s32, ?, f32, f32); // extern
? func_800A66A8(s32, s16 *); // extern
? set_text_color(?); // extern
extern s32 D_800E7840;
extern ? D_800E7848;
extern f32 D_800F1B58;
extern s8 D_8018EDF8;
extern s8 D_8018EDF9;

void func_800A1DE0(s32 arg0) {
    s16 sp5A;
    s16 sp58;
    f32 temp_f20;
    s32 temp_s0;
    s32 temp_s2;
    s32 phi_s0;
    s32 phi_s1;
    s32 phi_s2;
    ? phi_a0;
    s32 phi_s1_2;
    s32 *phi_s0_2;

    set_text_color(TEXT_GREEN);
    temp_f20 = D_800F1B58;
    phi_s0 = 0x3C;
    phi_s1 = 0;
    do {
        func_80093324(0x1B, phi_s0, (&D_800E7848 + (D_8018EDF8 * 0xC) + phi_s1)->unk-C, 0, temp_f20, temp_f20);
        temp_s0 = phi_s0 + 0xD;
        phi_s0 = temp_s0;
        phi_s1 += 4;
    } while (temp_s0 < 0x63);
    phi_s2 = 0;
    phi_s1_2 = 0x6E;
    phi_s0_2 = &D_800E7840;
    do {
        phi_a0 = TEXT_GREEN;
        if (phi_s2 == D_8018EDF9) {
            phi_a0 = TEXT_BLUE_GREEN_RED_CYCLE_2;
        }
        set_text_color(phi_a0);
        func_80093324(0x43, phi_s1_2, *phi_s0_2, 0, temp_f20, temp_f20);
        temp_s2 = phi_s2 + 1;
        phi_s2 = temp_s2;
        phi_s1_2 += 0xD;
        phi_s0_2 += 4;
    } while (temp_s2 != 2);
    sp58 = 0x3B;
    sp5A = (D_8018EDF9 * 0xD) + 0x66;
    func_800A66A8(arg0, &sp58);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A1DE0.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80093324(?, s32, s32, ?, f32, f32); // extern
? set_text_color(?); // extern
extern s32 D_800E7860;

void func_800A1F30(s32 arg0) {
    s32 temp_s0;
    s32 phi_s0;
    s32 *phi_s1;

    set_text_color(TEXT_RED);
    phi_s0 = 0x49;
    phi_s1 = &D_800E7860;
    do {
        func_80093324(0x2A, phi_s0, *phi_s1, 0, 0.75f, 0.75f);
        temp_s0 = phi_s0 + 0x10;
        phi_s0 = temp_s0;
        phi_s1 += 4;
    } while (temp_s0 != 0x69);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A1F30.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
Gfx *draw_box(Gfx *, ?, ?, ?, s32, s32, s32, s32, s32); /* extern */
? draw_text(s32, s32, ? *, ?, f32, f32);            /* extern */
? func_800921C0(s32, s32, ?);                       /* extern */
? func_80092224(s32, s32, ?);                       /* extern */
? func_80093324(s16, s16, ? *, ?, f32, f32);        /* extern */
? func_800A66A8(void *, s16 *);                     /* extern */
? convert_number_to_ascii(s32, ? *);                          /* extern */
? set_text_color(s32);                              /* extern */
extern ? D_8018EE10;
static ? D_800E75C4;                                /* unable to generate initializer; const */
static ? gSoundModeNames;                                /* unable to generate initializer; const */
static ? *D_800E7840[2] = { "quit", "erase" };      /* const */
static ? *D_800E7868[4] = {
    "RETURN TO GAME SELECT",
    "SOUND MODE",
    "COPY N64 CONTROLLER PAK",
    "ERASE ALL DATA",
}; /* const */
static ? *D_800E7878[3] = { "ALL SAVED DATA WILL BE", "PERMANENTLY ERASED.", "ARE YOU REALLY SURE?" }; /* const */
static ? *D_800E7884[3] = { "", "ALL SAVED DATA", "HAS BEEN NOW ERASED." }; /* const */
static ? D_800E7890;                                /* unable to generate initializer; const */
static ? D_800E78D0;                                /* unable to generate initializer; const */
static ? D_800E7900;                                /* unable to generate initializer; const */
static ? *D_800E7918[2] = { "CONTROLLER 1", "CONTROLLER 2" }; /* const */
static ? D_800E7920;                                /* unable to generate initializer; const */
static ? *D_800E7928[2] = { "CURRENT DATA WILL BE ERASED,", "IS THIS OK?" }; /* const */
static ? *D_800E7930[2] = { "QUIT", "COPY" };       /* const */
static ? D_800E7938;                                /* unable to generate initializer; const */
static ? *D_800E7A44 = "NO DATA";                   /* const */
static ? *D_800E7A48[3] = { "CREATING ", "MARIO KART 64 ", "GAME DATA" }; /* const */
static ? D_800E7A54;                                /* unable to generate initializer; const */
static ? gCupCourseOrder;                            /* unable to generate initializer; const */

void func_800A1FB0(void *arg0) {
    s16 spE2;
    s16 spE0;
    ? spB9;
    ? spB8;
    ? spA9;
    ? spA8;
    ? sp99;
    ? sp98;
    s32 sp88;
    ? **sp84;
    ? **sp78;
    ? **temp_s0_4;
    ? **temp_s1;
    ? **temp_s1_2;
    ? **temp_s1_3;
    ? **temp_v0_3;
    s16 temp_s0;
    s16 temp_s0_2;
    s16 temp_s0_3;
    s16 temp_s3;
    s16 temp_s3_3;
    s32 temp_a0;
    s32 temp_a0_2;
    s32 temp_a0_3;
    s32 temp_s1_4;
    s32 temp_s1_5;
    s32 temp_s1_6;
    s32 temp_s2;
    s32 temp_s2_2;
    s32 temp_s2_3;
    s32 temp_s3_2;
    s8 temp_v0;
    s8 temp_v0_2;
    s8 temp_v0_4;
    s8 temp_v1;
    s8 temp_v1_2;
    s32 phi_a0;
    s32 phi_s2;
    s16 phi_s0;
    ? **phi_s1;
    s16 phi_s0_2;
    ? **phi_s1_2;
    s32 phi_a0_2;
    s32 phi_s2_2;
    s16 phi_s0_3;
    ? **phi_s1_3;
    s16 phi_s0_4;
    ? **phi_s1_4;
    s16 phi_s0_5;
    ? **phi_s1_5;
    s16 phi_s0_6;
    ? **phi_s1_6;
    s16 phi_s0_7;
    ? **phi_s1_7;
    s16 phi_s0_8;
    ? **phi_s1_8;
    s32 phi_s4;
    s16 phi_s3;
    s32 phi_s5;
    s32 phi_s0_9;
    s16 phi_s6;
    s16 phi_s2_3;
    void *phi_v1;
    s32 phi_s1_9;
    ? **phi_s0_10;
    s16 phi_s3_2;
    s32 phi_s0_11;
    s16 phi_s6_2;
    s16 phi_s2_4;
    void *phi_v1_2;
    s32 phi_s2_5;
    s16 phi_s1_10;
    ? **phi_s3_3;
    s16 phi_s3_4;
    s32 phi_s0_12;
    s16 phi_s6_3;
    s16 phi_s2_6;
    void *phi_v1_3;
    s8 phi_v1_4;
    gDisplayListHead = draw_box(gDisplayListHead, 0, 0, 0x140, 0xF0, 0, 0, 0, 0x64);
    temp_v1 = D_8018EDEC;
    phi_v1_4 = temp_v1;
    switch (temp_v1) {                              /* switch 1 */
    case 0x15:                                      /* switch 1 */
    case 0x16:                                      /* switch 1 */
    case 0x17:                                      /* switch 1 */
    case 0x18:                                      /* switch 1 */
        phi_a0 = temp_v1 - 0x15;
        phi_s2 = 0;
        phi_s0 = 0x55;
        phi_s1 = D_800E7868;
        do {
            func_80092224(phi_a0, phi_s2, TEXT_YELLOW);
            func_80093324(0x32, phi_s0, *phi_s1, 0, 0.9f, 1.0f);
            temp_a0 = D_8018EDEC - 0x15;
            phi_a0 = temp_a0;
            phi_s1 += 4;
            if (phi_s2 == temp_a0) {
                spE0 = 0x32;
                spE2 = phi_s0;
            }
            temp_s2 = phi_s2 + 1;
            phi_s2 = temp_s2;
            phi_s0 += 0x23;
        } while (temp_s2 != 4);
        set_text_color(TEXT_GREEN);
        draw_text(0xE6, 0x78, gSoundModeNames[gSoundMode], 0, 1.0f, 1.0f);
block_98:
        phi_v1_4 = D_8018EDEC;
        break;
    case 0x1E:                                      /* switch 1 */
    case 0x1F:                                      /* switch 1 */
        set_text_color(TEXT_YELLOW);
        phi_s0_2 = 0x55;
        phi_s1_2 = D_800E7878;
        do {
            func_80093324(0x28, phi_s0_2, *phi_s1_2, 0, 1.0f, 1.0f);
            temp_s1 = phi_s1_2 + 4;
            phi_s0_2 += 0x14;
            phi_s1_2 = temp_s1;
        } while (temp_s1 < D_800E7884);
        phi_a0_2 = D_8018EDEC - 0x1E;
        phi_s2_2 = 0;
        phi_s0_3 = 0x96;
        phi_s1_3 = D_800E7840;
        do {
            func_80092224(phi_a0_2, phi_s2_2, TEXT_GREEN);
            func_80093324(0x84, phi_s0_3, *phi_s1_3, 0, 1.0f, 1.0f);
            temp_v1_2 = D_8018EDEC;
            temp_a0_2 = temp_v1_2 - 0x1E;
            phi_a0_2 = temp_a0_2;
            phi_s1_3 += 4;
            phi_v1_4 = temp_v1_2;
            if (phi_s2_2 == temp_a0_2) {
                spE0 = 0x84;
                spE2 = phi_s0_3;
            }
            temp_s2_2 = phi_s2_2 + 1;
            phi_s2_2 = temp_s2_2;
            phi_s0_3 += 0x19;
        } while (temp_s2_2 != 2);
        break;
    case 0x20:                                      /* switch 1 */
        set_text_color(TEXT_YELLOW);
        phi_s0_4 = 0x55;
        phi_s1_4 = D_800E7884;
        do {
            func_80093324(0x32, phi_s0_4, *phi_s1_4, 0, 1.0f, 1.0f);
            temp_s1_2 = phi_s1_4 + 4;
            phi_s0_4 += 0x14;
            phi_s1_4 = temp_s1_2;
        } while (temp_s1_2 != &D_800E7890);
        goto block_98;
    case 0x2A:                                      /* switch 1 */
    case 0x2B:                                      /* switch 1 */
    case 0x2C:                                      /* switch 1 */
    case 0x2D:                                      /* switch 1 */
        set_text_color(TEXT_RED);
        phi_s0_5 = 0x55;
        phi_s1_5 = ((D_8018EDEC - 0x2A) * 0xC) + &D_800E78D0;
        do {
            func_80093324(0x32, phi_s0_5, *phi_s1_5, 0, 0.9f, 0.9f);
            temp_s0 = phi_s0_5 + 0x14;
            phi_s0_5 = temp_s0;
            phi_s1_5 += 4;
        } while (temp_s0 != 0x91);
        goto block_98;
    case 0x34:                                      /* switch 1 */
    case 0x35:                                      /* switch 1 */
    case 0x36:                                      /* switch 1 */
    case 0x37:                                      /* switch 1 */
        set_text_color(TEXT_RED);
        phi_s0_6 = 0x55;
        phi_s1_6 = ((D_8018EDEC - 0x34) * 0x10) + &D_800E7890;
        do {
            func_80093324(0x23, phi_s0_6, *phi_s1_6, 0, 0.8f, 0.8f);
            temp_s0_2 = phi_s0_6 + 0x14;
            phi_s0_6 = temp_s0_2;
            phi_s1_6 += 4;
        } while (temp_s0_2 != 0xA5);
        goto block_98;
    case 0x41:                                      /* switch 1 */
    case 0x42:                                      /* switch 1 */
        set_text_color(TEXT_RED);
        phi_s0_7 = 0x55;
        phi_s1_7 = ((D_8018EDEC - 0x41) * 0xC) + &D_800E7900;
        do {
            func_80093324(0x41, phi_s0_7, *phi_s1_7, 0, 0.9f, 0.9f);
            temp_s0_3 = phi_s0_7 + 0x14;
            phi_s0_7 = temp_s0_3;
            phi_s1_7 += 4;
        } while (temp_s0_3 != 0x91);
        goto block_98;
    case 0x46:                                      /* switch 1 */
    case 0x47:                                      /* switch 1 */
        set_text_color(TEXT_YELLOW);
        phi_s0_8 = 0x55;
        phi_s1_8 = D_800E7A48;
        do {
            func_80093324(0x50, phi_s0_8, *phi_s1_8, 0, 1.0f, 1.0f);
            temp_s1_3 = phi_s1_8 + 4;
            phi_s0_8 += 0x14;
            phi_s1_8 = temp_s1_3;
        } while (temp_s1_3 != &D_800E7A54);
        goto block_98;
    case 0x28:                                      /* switch 1 */
    case 0x29:                                      /* switch 1 */
    case 0x32:                                      /* switch 1 */
    case 0x33:                                      /* switch 1 */
        phi_s5 = 0x28;
        if ((temp_v1 != 0x28) && (temp_v1 != 0x29)) {
            phi_s5 = 0x32;
            if ((temp_v1 != 0x32) && (phi_s4 = spC0, (temp_v1 != 0x33))) {
                phi_s5 = spC4;
            } else {
                phi_s4 = 1;
            }
        } else {
            phi_s4 = 0;
        }
        set_text_color(phi_s4 + 1);
        draw_text(0xA0, 0x55, *(&D_800E7920 + (phi_s4 * 4)), 0, 0.6f, 0.6f);
        sp88 = 0x5C;
        sp78 = (phi_s4 * 0x89) + 0x2A;
        sp84 = D_800E7918;
        phi_s3 = 0x2A;
        phi_s6 = 0x20;
        do {
            set_text_color(TEXT_YELLOW);
            draw_text(sp88, 0x7D, *sp84, 0, 0.75f, 0.75f);
            phi_s0_9 = 0;
            phi_s2_3 = 0x96;
loop_38:
            if (phi_s3 != sp78) {
                func_800921C0(D_8018EDEC - phi_s5, phi_s0_9, TEXT_GREEN);
                if (phi_s0_9 == (D_8018EDEC - phi_s5)) {
                    spE0 = phi_s6;
                    spE2 = phi_s2_3;
                }
            } else if ((phi_s4 != 0) && (phi_s0_9 == arg0->unk20)) {
                set_text_color(gGlobalTimer % 3);
            } else {
                set_text_color(TEXT_GREEN);
            }
            temp_s1_4 = phi_s0_9 + 1;
            convert_number_to_ascii(temp_s1_4, &spB8);
            func_80093324(phi_s6, phi_s2_3, &spB9, 0, 0.6f, 0.6f);
            if (phi_s3 == 0x2A) {
                phi_v1 = (phi_s0_9 << 7) + &D_8018EE10;
            } else {
                phi_v1 = D_8018D9C0 + (phi_s0_9 << 7);
            }
            if (phi_v1->unk4 == 0) {
                func_80093324(phi_s3, phi_s2_3, D_800E7A44, 0, 0.5f, 0.5f);
            } else {
                temp_v0 = phi_v1->unk5;
                func_80093324(phi_s3, phi_s2_3, *(&D_800E75C4 + (*(&gCupCourseOrder + (((temp_v0 / 4) * 8) + ((temp_v0 % 4) * 2))) * 4)), 0, 0.5f, 0.5f);
            }
            phi_s0_9 = temp_s1_4;
            phi_s2_3 += 0x1E;
            if (temp_s1_4 != 2) {
                goto loop_38;
            }
            temp_s3 = phi_s3 + 0x89;
            sp84 += 4;
            sp88 += 0x82;
            phi_s3 = temp_s3;
            phi_s6 += 0x89;
        } while (temp_s3 != 0x13C);
        goto block_98;
    case 0x38:                                      /* switch 1 */
    case 0x39:                                      /* switch 1 */
        set_text_color(TEXT_RED);
        phi_s1_9 = 0x4D;
        phi_s0_10 = D_800E7928;
        do {
            draw_text(0xA0, phi_s1_9, *phi_s0_10, 0, 0.8f, 0.8f);
            temp_s0_4 = phi_s0_10 + 4;
            phi_s1_9 += 0x14;
            phi_s0_10 = temp_s0_4;
        } while (temp_s0_4 < D_800E7930);
        sp88 = 0x5C;
        sp84 = D_800E7918;
        phi_s3_2 = 0x2A;
        phi_s6_2 = 0x20;
        do {
            set_text_color(TEXT_YELLOW);
            draw_text(sp88, 0x7D, *sp84, 0, 0.75f, 0.75f);
            phi_s0_11 = 0;
            phi_s2_4 = 0x96;
loop_58:
            if (phi_s3_2 == 0x2A) {
                if (phi_s0_11 == arg0->unk1C) {
                    set_text_color(gGlobalTimer % 3);
                } else {
                    set_text_color(TEXT_GREEN);
                }
            } else if (phi_s0_11 == arg0->unk20) {
                set_text_color(gGlobalTimer % 3);
            } else {
                set_text_color(TEXT_GREEN);
            }
            temp_s1_5 = phi_s0_11 + 1;
            convert_number_to_ascii(temp_s1_5, &spA8);
            func_80093324(phi_s6_2, phi_s2_4, &spA9, 0, 0.6f, 0.6f);
            if (phi_s3_2 == 0x2A) {
                phi_v1_2 = (phi_s0_11 << 7) + &D_8018EE10;
            } else {
                phi_v1_2 = D_8018D9C0 + (phi_s0_11 << 7);
            }
            if (phi_v1_2->unk4 == 0) {
                func_80093324(phi_s3_2, phi_s2_4, D_800E7A44, 0, 0.5f, 0.5f);
            } else {
                temp_v0_2 = phi_v1_2->unk5;
                func_80093324(phi_s3_2, phi_s2_4, *(&D_800E75C4 + (*(&gCupCourseOrder + (((temp_v0_2 / 4) * 8) + ((temp_v0_2 % 4) * 2))) * 4)), 0, 0.5f, 0.5f);
            }
            phi_s0_11 = temp_s1_5;
            phi_s2_4 += 0x1E;
            if (temp_s1_5 != 2) {
                goto loop_58;
            }
            temp_s3_2 = phi_s3_2 + 0x89;
            sp84 += 4;
            sp88 += 0x82;
            phi_s3_2 = temp_s3_2;
            phi_s6_2 += 0x89;
        } while (temp_s3_2 < 0x13C);
        phi_s2_5 = 0;
        phi_s1_10 = 0x6E;
        phi_s3_3 = D_800E7930;
        do {
            temp_a0_3 = D_8018EDEC - 0x38;
            if (phi_s2_5 == temp_a0_3) {
                spE0 = phi_s1_10;
                spE2 = 0xD2;
            }
            func_800921C0(temp_a0_3, temp_s1_5, TEXT_YELLOW);
            func_80093324(phi_s1_10, 0xD2, *phi_s3_3, 0, 0.75f, 0.75f);
            temp_s2_3 = phi_s2_5 + 1;
            phi_s2_5 = temp_s2_3;
            phi_s1_10 += 0x32;
            phi_s3_3 += 4;
        } while (temp_s2_3 != 2);
        goto block_98;
    case 0x3A:                                      /* switch 1 */
    case 0x3B:                                      /* switch 1 */
    case 0x3C:                                      /* switch 1 */
        set_text_color(TEXT_RED);
        temp_v0_3 = (((temp_v1 - 0x3A) / 2) * 4) + &D_800E7938;
        sp78 = temp_v0_3;
        draw_text(0xA0, 0x55, *temp_v0_3, 0, 1.0f, 1.0f);
        sp88 = 0x5C;
        sp84 = D_800E7918;
        phi_s3_4 = 0x2A;
        phi_s6_3 = 0x20;
        do {
            set_text_color(TEXT_YELLOW);
            draw_text(sp88, 0x7D, *sp84, 0, 0.75f, 0.75f);
            phi_s0_12 = 0;
            phi_s2_6 = 0x96;
loop_80:
            if (phi_s3_4 == 0x2A) {
                if (phi_s0_12 == arg0->unk1C) {
                    if (sp78 == &D_800E7938) {
                        set_text_color(TEXT_RED);
                    } else {
                        set_text_color(gGlobalTimer % 3);
                    }
                } else {
                    set_text_color(TEXT_GREEN);
                }
            } else if (phi_s0_12 == arg0->unk20) {
                set_text_color(TEXT_RED);
            } else {
                set_text_color(TEXT_GREEN);
            }
            temp_s1_6 = phi_s0_12 + 1;
            convert_number_to_ascii(temp_s1_6, &sp98);
            func_80093324(phi_s6_3, phi_s2_6, &sp99, 0, 0.6f, 0.6f);
            if (phi_s3_4 == 0x2A) {
                phi_v1_3 = (phi_s0_12 << 7) + &D_8018EE10;
            } else {
                phi_v1_3 = D_8018D9C0 + (phi_s0_12 << 7);
            }
            if (phi_v1_3->unk4 == 0) {
                func_80093324(phi_s3_4, phi_s2_6, D_800E7A44, 0, 0.5f, 0.5f);
            } else {
                temp_v0_4 = phi_v1_3->unk5;
                func_80093324(phi_s3_4, phi_s2_6, *(&D_800E75C4 + (*(&gCupCourseOrder + (((temp_v0_4 / 4) * 8) + ((temp_v0_4 % 4) * 2))) * 4)), 0, 0.5f, 0.5f);
            }
            phi_s0_12 = temp_s1_6;
            phi_s2_6 += 0x1E;
            if (temp_s1_6 != 2) {
                goto loop_80;
            }
            temp_s3_3 = phi_s3_4 + 0x89;
            sp84 += 4;
            sp88 += 0x82;
            phi_s3_4 = temp_s3_3;
            phi_s6_3 += 0x89;
        } while (temp_s3_3 != 0x13C);
        goto block_98;
    }
    switch (phi_v1_4) {                             /* switch 2 */
    case 0x28:                                      /* switch 2 */
    case 0x29:                                      /* switch 2 */
    case 0x32:                                      /* switch 2 */
    case 0x33:                                      /* switch 2 */
    case 0x38:                                      /* switch 2 */
    case 0x39:                                      /* switch 2 */
        spE0 += -5;
        spE2 += -6;
        break;
    default:                                        /* switch 2 */
        spE0 += -0xA;
        spE2 += -8;
        break;
    }
    func_800A66A8(arg0, &spE0);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A1FB0.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 func_80098FC8(s32, ?, s32, ?, s32); // extern
extern s8 D_8018EE08;
extern s32 gDisplayListHead;

void func_800A2D1C(void *arg0) {
    s32 temp_t0;
    s32 temp_t8;
    s32 temp_v0;
    s32 temp_v0_2;
    s32 temp_v0_3;
    s32 temp_v0_4;

    temp_v0 = D_80164A28;
    if (temp_v0 != 1) {
        if (temp_v0 != 2) {
            if ((gModeSelection != GRAND_PRIX) || (gPlayerCountSelection1 != 1) || (D_8018EE08 != 0)) {
                goto block_13;
            }
            temp_t8 = arg0->unk1C - 2;
            arg0->unk1C = temp_t8;
            if (temp_t8 > 0) {
                temp_v0_2 = func_80098FC8(gDisplayListHead, 0, 0, 0x13F, temp_t8);
                gDisplayListHead = temp_v0_2;
                gDisplayListHead = func_80098FC8(temp_v0_2, 0, 0xEF - arg0->unk1C, 0x13F, 0xEF);
                return;
            }
            goto block_13;
        }
        temp_t0 = arg0->unk1C - 2;
        arg0->unk1C = temp_t0;
        if (temp_t0 > 0) {
            temp_v0_3 = func_80098FC8(gDisplayListHead, 0, 0, 0x13F, temp_t0);
            gDisplayListHead = temp_v0_3;
            gDisplayListHead = func_80098FC8(temp_v0_3, 0, 0xEF - arg0->unk1C, 0x13F, 0xEF);
            return;
        }
block_13:
        arg0->unk0 = 0;
        return;
    }
    temp_v0_4 = func_80098FC8(gDisplayListHead, 0, 0, 0x13F, 0x28);
    gDisplayListHead = temp_v0_4;
    gDisplayListHead = func_80098FC8(temp_v0_4, 0, 0xC7, 0x13F, 0xEF);
    arg0->unk1C = 0x28;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A2D1C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? draw_text(s32, s32, s32, ?, f32, f32); // extern
s32 get_string_width(s32); // extern
? func_80093324(s32, s32, ? *, ?, f32, f32); // extern
? func_800A32B4(s32, s32, s8, s32); // extern
? convert_number_to_ascii(s32, ? *); // extern
? set_text_color(s32); // extern
extern s32 D_800DC540;
extern ? D_800E7500;
extern ? D_800E76CC;
extern ? D_800E86AB;
extern ? D_800E86AD;
extern ? D_800F0C1C;
extern ? D_800F0C24;
extern f32 D_800F1C90;
extern f32 D_800F1C94;
extern f32 D_800F1C98;
extern f32 D_800F1C9C;
extern f32 D_800F1CA0;
extern s16 D_80164360;
extern s16 D_80164368;
extern ? D_80164370;
extern s8 gCupSelection;
extern s32 gGlobalTimer;
extern ? gPlayers;

void func_800A2EB8(void *arg0) {
    s8 sp74;
    s8 sp70;
    ? sp69;
    ? sp68;
    f32 temp_f0;
    f32 temp_f0_2;
    f32 temp_f0_3;
    f32 temp_f0_4;
    s16 *temp_s0;
    s32 temp_s0_2;
    s32 temp_s2;
    s32 temp_s2_2;
    s8 *temp_s1;
    s8 temp_v0;
    s16 *phi_s0;
    s8 *phi_s1;
    s16 *phi_s0_2;
    s32 phi_a0;
    s32 phi_s3;
    s8 *phi_s1_2;
    s32 phi_s2;
    s16 *phi_s0_3;
    s32 phi_a0_2;
    s32 phi_s3_2;
    s8 *phi_s1_3;
    s32 phi_s2_2;

    phi_s0 = &D_80164360;
    phi_s1 = &sp70;
    do {
        temp_s0 = phi_s0 + 2;
        temp_s1 = phi_s1 + 1;
        temp_s1->unk-1 = (&gPlayers + (*phi_s0 * 0xDD8))->unk254;
        phi_s0 = temp_s0;
        phi_s1 = temp_s1;
    } while (temp_s0 < &D_80164370);
    // "Results"
    set_text_color(TEXT_BLUE_GREEN_RED_CYCLE_1);
    func_80093324(arg0->unkC + 0x1E, arg0->unk10 + 0x19, &D_800F0C1C, 0, 1.0f, 1.0f);
    // "Round"
    set_text_color(TEXT_BLUE_GREEN_RED_CYCLE_2);
    temp_f0 = D_800F1C90;
    func_80093324(arg0->unkC + 0x2C, arg0->unk10 + 0x28, &D_800F0C24, 0, temp_f0, temp_f0);
    // Convert index of current course in the cup order into a round number
    convert_number_to_ascii(gCupCourseSelection + 1, &sp68);
    // Print previously converted round number
    temp_f0_2 = D_800F1C94;
    func_80093324(arg0->unkC + 0x57, arg0->unk10 + 0x28, &sp69, 0, temp_f0_2, temp_f0_2);
    phi_s0_2 = &D_80164360;
    phi_s3 = 0;
    phi_s1_2 = &sp70;
    phi_s2 = 0;
    // Print rank 1, 2, 3 and 4  3-lap times
    do {
        if (*phi_s0_2 < D_8018EDF3) {
            phi_a0 = gGlobalTimer % 3;
        } else {
            phi_a0 = TEXT_YELLOW;
        }
        set_text_color(phi_a0);
        func_800A32B4(arg0->unkC + 7, arg0->unk10 + phi_s3 + 0x38, *phi_s1_2, phi_s2);
        temp_s2 = phi_s2 + 1;
        phi_s0_2 += 2;
        phi_s3 += 0x10;
        phi_s1_2 += 1;
        phi_s2 = temp_s2;
    } while (temp_s2 < 4);
    phi_s0_3 = &D_80164368;
    phi_s3_2 = 0x40;
    phi_s1_3 = &sp74;
    phi_s2_2 = 4;
    // Print rank 5, 6, 7 and 8  3-lap times
    do {
        if (*phi_s0_3 < D_8018EDF3) {
            phi_a0_2 = gGlobalTimer % 3;
        } else {
            phi_a0_2 = TEXT_YELLOW;
        }
        set_text_color(phi_a0_2);
        func_800A32B4(0xBE - arg0->unkC, arg0->unk10 + phi_s3_2 + 0x5A, *phi_s1_3, phi_s2_2);
        temp_s2_2 = phi_s2_2 + 1;
        phi_s0_3 += 2;
        phi_s3_2 += 0x10;
        phi_s1_3 += 1;
        phi_s2_2 = temp_s2_2;
    } while (temp_s2_2 != 8);
    // Print Cup name
    set_text_color(TEXT_BLUE_GREEN_RED_CYCLE_2);
    temp_s0_2 = ((get_string_width(*(&D_800E7500 + (gCupSelection * 4))) + 8) * D_800F1C98) / 2.0f;
    temp_f0_3 = D_800F1C9C;
    // Some very complicated way to print the cup name and CC mode
    draw_text((-(((get_string_width(*(&D_800E76CC + (gCCSelection * 4))) + 8) * temp_f0_3) / 2.0f) - arg0->unkC) + 0xF5, arg0->unk10 + 0xE1, *(&D_800E7500 + (D_800DC540 * 4)), 0, temp_f0_3, temp_f0_3);
    temp_v0 = D_8018EDF3;
    temp_f0_4 = D_800F1CA0;
    // Print CC mode again?
    draw_text((temp_s0_2 - arg0->unkC) + 0xF5, arg0->unk10 + 0xE1, *(&D_800E76CC + (*(&D_800E86AD + ((temp_v0 * 3) + *(&D_800E86AB + temp_v0))) * 4)), 0, temp_f0_4, temp_f0_4);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A2EB8.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80093324(s32, ?, ? *, ?, f32, f32); // extern
? func_800939C8(s32, ?, ? *, ?, f32, f32); // extern
? convert_number_to_ascii(s32, ? *); // extern
extern ? D_800E76A8;
extern ? D_800F0C2C;
extern ? D_800F0C30;
extern f32 D_800F1CA4;
extern f32 D_800F1CA8;
extern ? gTimePlayerLastTouchedFinishLine;
extern ? D_80164360;

void func_800A32B4(s32 arg0, ? arg1, s32 arg2, s32 arg3) {
    f32 sp50;
    s8 sp3F;
    s8 sp3E;
    ? sp3D;
    ? sp3C;
    f32 temp_f20;
    f32 temp_f4;

    temp_f4 = *(&gTimePlayerLastTouchedFinishLine + (*(&D_80164360 + (arg3 * 2)) * 4));
    sp50 = temp_f4;
    // Convert arg3 (some index) into a rank string
    // This is a little wonky.
    // sp3c becomes "0x30, rank#, \0"
    convert_number_to_ascii(arg3 + 1, &sp3C);
    temp_f20 = D_800F1CA4;
    // change the \0 to a "."
    sp3E = 0x2E;
    // add a new termnitator
    sp3F = 0;
    // Print rank string
    func_800939C8(arg0 - 1, arg1, &sp3D, -4, temp_f20, temp_f20);
    // Print character name (arg2 is almost certainly characterId)
    func_80093324(arg0 + 0xA, arg1, *(&D_800E76A8 + (arg2 * 4)), 0, D_800F1CA8, temp_f20);
    // Get minutes
    convert_number_to_ascii(sp50 / 60.0f, &sp3C);
    // Print minutes
    func_800939C8(arg0 + 0x42, arg1, &sp3C, 0, temp_f20, temp_f20);
    // Get seconds
    convert_number_to_ascii(temp_f4 % 0x3C, &sp3C);
    // Print '
    func_80093324(arg0 + 0x4E, arg1, &D_800F0C2C, 0, temp_f20, temp_f20);
    // Print seconds
    func_800939C8(arg0 + 0x56, arg1, &sp3C, 0, temp_f20, temp_f20);
    // Get centiseconds
    convert_number_to_ascii((sp50 * 100.0) % 0x64, &sp3C);
    // Print "
    func_80093324(arg0 + 0x62, arg1, &D_800F0C30, 0, temp_f20, temp_f20);
    // Print centiseconds
    func_800939C8(arg0 + 0x6A, arg1, &sp3C, 0, temp_f20, temp_f20);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A32B4.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
? draw_text(s32, s32, s32, ?, f32, f32);            /* extern */
s32 get_string_width(s32);                             /* extern */
? func_80093324(s32, s32, ? *, ?, f32, f32);        /* extern */
? func_800A3A10(s8 *);                              /* extern */
? func_800A3ADC(void *, s32, s32, s8, s32, s8 *);   /* extern */
? convert_number_to_ascii(s32, ? *);                          /* extern */
? set_text_color(s32);                              /* extern */
extern s32 D_800DC540;
extern ? D_80164360;
extern ? D_80164370;
extern ? D_80164478;
extern s8 D_8018EDF3;
static ? D_800E7500;                                /* unable to generate initializer; const */
static ? D_800E76CC;                                /* unable to generate initializer; const */
static ? D_800E86AB;                                /* unable to generate initializer; const */
static ? D_800E86AD;                                /* unable to generate initializer; const */

void func_800A34A8(void *arg0) {
    s8 sp80;
    ? sp79;
    ? sp78;
    s32 sp68;
    ? *temp_a0;
    s32 temp_s0_2;
    s32 temp_s1;
    s32 temp_s1_2;
    s32 temp_v1;
    s32 temp_v1_2;
    s32 temp_v1_3;
    s8 *temp_s0;
    s8 temp_v0;
    ? *phi_a0;
    s8 *phi_s0;
    s32 phi_s1;
    s32 phi_v0;
    s32 phi_v0_2;
    s32 phi_v1;
    s32 phi_a0_2;
    s32 phi_s1_2;
    s32 phi_v0_3;
    s32 phi_v0_4;
    s32 phi_a0_3;

    temp_v1 = arg0->unk4;
    if (temp_v1 != 0) {
        if (temp_v1 < 9) {
            phi_a0 = &D_80164360;
            phi_s0 = &sp80;
            do {
                temp_a0 = phi_a0 + 8;
                temp_s0 = phi_s0 + 4;
                temp_s0->unk-4 = gPlayers[phi_a0->unk0].characterId;
                temp_s0->unk-3 = gPlayers[phi_a0->unk2].characterId;
                temp_s0->unk-2 = gPlayers[phi_a0->unk4].characterId;
                temp_s0->unk-1 = gPlayers[temp_a0->unk-2].characterId;
                phi_a0 = temp_a0;
                phi_s0 = temp_s0;
            } while (temp_a0 != &D_80164370);
        } else {
            func_800A3A10(&sp80);
            func_800A3A10(gCharacterIdByGPOverallRank);
        }
        // "Driver's Points"
        set_text_color(TEXT_BLUE_GREEN_RED_CYCLE_1);
        func_80093324(arg0->unkC + 0x19, 0x19 - arg0->unk10, "driver's points", 0, 0.8f, 0.8f);
        // "Round"
        set_text_color(TEXT_BLUE_GREEN_RED_CYCLE_2);
        func_80093324(arg0->unkC + 0x36, 0x28 - arg0->unk10, "round", 0, 0.7f, 0.7f);
        // Convert course index to a round number
        convert_number_to_ascii(gCupCourseSelection + 1, &sp78);
        // Print round number
        func_80093324(arg0->unkC + 0x61, 0x28 - arg0->unk10, &sp79, 0, 0.7f, 0.7f);
        phi_s1 = 0;
        // Print rank 1, 2, 3 and 4 lines
        do {
            temp_v1_2 = arg0->unk4;
            if ((temp_v1_2 != 8) && (temp_v1_2 != 9)) {
                phi_v0 = 0;
            } else {
                phi_v0 = 0;
                if ((phi_s1 * 5) < arg0->unk1C) {
                    phi_v0 = 1;
                }
            }
            if (phi_v0 == 0) {
                if (temp_v1_2 < 9) {
                    phi_v0_2 = *(&D_80164360 + (phi_s1 * 2));
                    phi_v1 = 0;
                } else {
                    phi_v0_2 = *(&D_80164478 + ((&sp80)[phi_s1] * 2));
                    phi_v1 = 0xD;
                }
                if (phi_v0_2 < D_8018EDF3) {
                    phi_a0_2 = gGlobalTimer % 3;
                } else {
                    phi_a0_2 = TEXT_YELLOW;
                }
                sp68 = phi_v1;
                set_text_color(phi_a0_2);
                func_800A3ADC(arg0, arg0->unkC + phi_v1 + 0x1C, ((phi_s1 * 0x10) - arg0->unk10) + 0x38, (&sp80)[phi_s1], phi_s1, &sp80);
            }
            temp_s1 = phi_s1 + 1;
            phi_s1 = temp_s1;
        } while (temp_s1 < 4);
        phi_s1_2 = 4;
        // Print rank 5, 6, 7 and 8 lines
        do {
            temp_v1_3 = arg0->unk4;
            if ((temp_v1_3 != 8) && (temp_v1_3 != 9)) {
                phi_v0_3 = 0;
            } else {
                phi_v0_3 = 0;
                if ((phi_s1_2 * 5) < arg0->unk1C) {
                    phi_v0_3 = 1;
                }
            }
            if (phi_v0_3 == 0) {
                if (temp_v1_3 < 9) {
                    phi_v0_4 = *(&D_80164360 + (phi_s1_2 * 2));
                } else {
                    phi_v0_4 = *(&D_80164478 + ((&sp80)[phi_s1_2] * 2));
                }
                if (phi_v0_4 < D_8018EDF3) {
                    phi_a0_3 = gGlobalTimer % 3;
                } else {
                    phi_a0_3 = TEXT_YELLOW;
                }
                set_text_color(phi_a0_3);
                func_800A3ADC(arg0, 0xBE - arg0->unkC, arg0->unk10 + (phi_s1_2 * 0x10) + 0x5A, (&sp80)[phi_s1_2], phi_s1_2, &sp80);
            }
            temp_s1_2 = phi_s1_2 + 1;
            phi_s1_2 = temp_s1_2;
        } while (temp_s1_2 != 8);
        set_text_color(TEXT_BLUE_GREEN_RED_CYCLE_2);
        temp_s0_2 = ((get_string_width(*(&D_800E7500 + (gCupSelection * 4))) + 8) * 0.6f) / 2.0f;
        draw_text((-(((get_string_width(*(&D_800E76CC + (gCCSelection * 4))) + 8) * 0.6f) / 2.0f) - arg0->unkC) + 0xE6, arg0->unk10 + 0xE1, *(&D_800E7500 + (D_800DC540 * 4)), 0, 0.6f, 0.6f);
        temp_v0 = D_8018EDF3;
        draw_text((temp_s0_2 - arg0->unkC) + 0xE6, arg0->unk10 + 0xE1, *(&D_800E76CC + (*(&D_800E86AD + ((temp_v0 * 3) + *(&D_800E86AB + temp_v0))) * 4)), 0, 0.6f, 0.6f);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A34A8.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
extern ? D_80164478;
extern s8 D_8018EDF3;

void func_800A3A10(s8 *arg0) {
    s16 temp_t0_2;
    s8 temp_a1;
    s8 temp_a3;
    s8 temp_t0;
    s8 temp_t1;
    s8 temp_t2;
    s8 temp_v0;
    s8 phi_v0;
    s8 *phi_v1;
    s8 *phi_a2;
    s8 phi_a1;

    phi_v0 = 0;
    phi_v1 = arg0;
    do {
        *phi_v1 = phi_v0;
        phi_a1 = phi_v0;
        if (phi_v0 > 0) {
            phi_a2 = &arg0[phi_v0];
loop_3:
            temp_a3 = phi_a2->unk-1;
            temp_t1 = phi_a2->unk0;
            temp_a1 = phi_a1 - 1;
            temp_t2 = gGPPointsByCharacterId[temp_t1];
            temp_t0 = gGPPointsByCharacterId[temp_a3];
            phi_a1 = temp_a1;
            if (temp_t0 < temp_t2) {
                phi_a2->unk0 = temp_a3;
                goto block_9;
            }
            if (temp_t2 == temp_t0) {
                temp_t0_2 = *(&D_80164478 + (temp_t1 * 2));
                if ((temp_t0_2 < D_8018EDF3) && (temp_t0_2 < *(&D_80164478 + (temp_a3 * 2)))) {
                    phi_a2->unk0 = temp_a3;
block_9:
                    phi_a2->unk-1 = temp_t1;
                    phi_a2 += -1;
                    if (temp_a1 != 0) {
                        goto loop_3;
                    }
                }
            }
        }
        temp_v0 = phi_v0 + 1;
        phi_v0 = temp_v0;
        phi_v1 += 1;
    } while (temp_v0 != 8);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A3A10.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
? func_80093324(s32, s32, s8 *, ?, f32, f32);       /* extern */
? func_800939C8(s32, s32, s8 *, ?, f32, f32);       /* extern */
? convert_number_to_ascii(s8, s8 *);                          /* extern */
extern s32 D_8018D9BC;
static ? D_800E76A8;                                /* unable to generate initializer; const */

void func_800A3ADC(void *arg0, s32 arg1, s32 arg2, s32 arg3, s32 arg4, s32 arg5) {
    s8 sp37;
    s8 sp36;
    s8 sp35;
    s8 sp34;
    s32 temp_v1;
    void *phi_v0;
    s32 phi_v1;
    s32 phi_v1_2;

    if (arg0->unk4 < 9) {
        convert_number_to_ascii(arg4 + 1, &sp34);
    } else {
        phi_v1 = arg4;
        phi_v1_2 = arg4;
        if (arg4 > 0) {
            phi_v0 = arg5 + arg4;
loop_4:
            phi_v1_2 = phi_v1;
            if (gGPPointsByCharacterId[phi_v0->unk0] == gGPPointsByCharacterId[phi_v0->unk-1]) {
                temp_v1 = phi_v1 - 1;
                phi_v0 += -1;
                phi_v1 = temp_v1;
                phi_v1_2 = temp_v1;
                if (temp_v1 != 0) {
                    goto loop_4;
                }
            }
        }
        convert_number_to_ascii(phi_v1_2 + 1, &sp34);
    }
    sp36 = 0x2E;
    sp37 = 0;
    // Print rank # + "."
    func_800939C8(arg1, arg2, &sp35, -4, 0.7f, 0.7f);
    // Print character name
    func_80093324(arg1 + 0xA, arg2, *(&D_800E76A8 + (arg3 * 4)), 0, 0.7f, 0.7f);
    // Print character's current point count
    convert_number_to_ascii(gGPPointsByCharacterId[arg3], &sp34);
    func_800939C8(arg1 + 0x47, arg2, &sp34, 0, 0.7f, 0.7f);
    // Print "+" + points left to be allocated
    // Only done for rank 1, 2, 3 and 4
    // arg4 is almost certainly rank
    if ((arg4 < 4) && (arg0->unk4 < 9)) {
        convert_number_to_ascii(*(D_8018D9BC + arg4), &sp34);
        sp34 = 0x2B;
        func_80093324(arg1 + 0x5A, arg2, &sp34, 0, 0.7f, 0.7f);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A3ADC.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? draw_text(s32, s32, s32, ?, f32, f32); // extern
? func_80093324(s32, s32, s32, ?, f32, f32); // extern
? func_800A4550(s32, s32, s32); // extern
? func_800A474C(s32, s32, s32); // extern
? set_text_color(?); // extern
extern ? D_800E7574;
extern s32 D_800E7728;
extern s32 D_800E772C;
extern s32 D_800E7730;
extern f32 D_800F1CC8;
extern s8 gCupSelection;
extern ? gCupCourseOrder;

void func_800A3C84(void *arg0) {
    f32 temp_f0;
    s32 temp_s0;
    s32 temp_s0_2;
    s32 phi_s0;
    s32 phi_s1;
    s32 phi_s0_2;
    s32 phi_s1_2;

    set_text_color(TEXT_BLUE_GREEN_RED_CYCLE_1);
    temp_f0 = D_800F1CC8;
    draw_text(arg0->unkC + 0x43, arg0->unk10 + 0x19, *(&D_800E7574 + (*(&gCupCourseOrder + ((gCupSelection * 8) + (gCupCourseSelection * 2))) * 4)), 0, temp_f0, temp_f0);
    set_text_color(TEXT_YELLOW);
    draw_text(arg0->unkC + 0x46, arg0->unk10 + 0x28, D_800E7730, 0, 0.75f, 0.75f);
    phi_s0 = 0;
    phi_s1 = 0;
    phi_s0_2 = 0;
    phi_s1_2 = 0;
    do {
        func_800A4550(phi_s0, arg0->unkC + 0x17, arg0->unk10 + phi_s1 + 0x37);
        temp_s0 = phi_s0 + 1;
        phi_s0 = temp_s0;
        phi_s1 += 0xF;
    } while (temp_s0 < 4);
    set_text_color(TEXT_YELLOW);
    func_80093324(0xB4 - arg0->unkC, arg0->unk10 + 0x86, D_800E7728, 0, 0.75f, 0.75f);
    do {
        set_text_color(TEXT_RED);
        func_800A474C(phi_s0_2, 0xAA - arg0->unkC, arg0->unk10 + phi_s1_2 + 0x92);
        temp_s0_2 = phi_s0_2 + 1;
        phi_s0_2 = temp_s0_2;
        phi_s1_2 += 0xD;
    } while (temp_s0_2 != 5);
    set_text_color(TEXT_YELLOW);
    func_80093324(0xB4 - arg0->unkC, arg0->unk10 + 0xD5, D_800E772C, 0, 0.75f, 0.75f);
    func_800A474C(5, 0xAA - arg0->unkC, arg0->unk10 + 0xE1);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A3C84.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
? draw_text(s32, s32, ? *, ?, f32, f32);            /* extern */
? func_800921C0(s32, s32, ?);                       /* extern */
? func_80093324(s32, s32, ? *, ?, f32, f32);        /* extern */
? func_80093358(s32, s32, ? *, ?, f32, f32);        /* extern */
? func_800A4550(s32, s32, s32);                     /* extern */
? func_800A66A8(void *, s16 *);                     /* extern */
? convert_number_to_ascii(s32, ? *);                          /* extern */
? set_text_color(?);                                /* extern */
extern ? D_8018EE10;
static ? D_800E7390;                                /* unable to generate initializer; const */
static ? D_800E73C0;                                /* unable to generate initializer; const */
static ? D_800E73D0;                                /* unable to generate initializer; const */
static ? D_800E7574;                                /* unable to generate initializer; const */
static ? D_800E75C4;                                /* unable to generate initializer; const */
static ? *D_800E7730 = "LAP TIME";                  /* const */
static ? D_800E775C;                                /* unable to generate initializer; const */
static ? D_800E798C;                                /* unable to generate initializer; const */
static ? *D_800E7A3C[2] = { "SELECT THE FILE ", "YOU WANT TO SAVE" }; /* const */
static ? *D_800E7A44 = "NO DATA";                   /* const */
static ? *D_800E7A48[3] = { "CREATING ", "MARIO KART 64 ", "GAME DATA" }; /* const */
static ? D_800E7A54;                                /* unable to generate initializer; const */
static ? *D_800E7A60[3] = { "THE PREVIOUS DATA ", "WILL BE ERASED, ", "IS THIS OK?" }; /* const */
static ? *D_800E7A6C[2] = { "QUIT", "SAVE" };       /* const */
static ? *D_800E7A74[3] = { "SAVING GHOST DATA", "", "PLEASE WAIT" }; /* const */
static ? *D_800E7A80[2] = { "UNABLE TO SAVE ", "THE GHOST" }; /* const */
static ? D_800E7A88;                                /* unable to generate initializer; const */
static ? gCupCourseOrder;                            /* unable to generate initializer; const */

void func_800A3E60(void *arg0) {
    s16 sp86;
    s16 sp84;
    s32 sp6C;
    ? sp61;
    ? sp60;
    s32 sp54;
    ? **sp50;
    ? **temp_s0_2;
    ? **temp_s0_3;
    ? **temp_v0_3;
    ? **temp_v0_4;
    ? **temp_v0_5;
    Gfx *temp_v1_2;
    s16 *temp_a1;
    s32 temp_a0;
    s32 temp_s0;
    s32 temp_s1;
    s32 temp_s1_2;
    s32 temp_s1_3;
    s32 temp_v0;
    s32 temp_v1;
    s8 temp_v0_2;
    s32 phi_s1;
    s32 phi_s0;
    s32 phi_s1_2;
    s32 phi_v1;
    s32 phi_s2;
    ? *phi_s0_2;
    ? **phi_v0;
    s32 phi_s0_3;
    s32 phi_s2_2;
    ? **phi_s0_4;
    s32 phi_s1_3;
    s32 phi_s0_5;
    ? *phi_s2_3;
    ? **phi_v0_2;
    s32 phi_s0_6;
    s32 phi_s2_4;
    ? **phi_s0_7;
    s32 phi_s1_4;
    s32 phi_s0_8;
    ? **phi_s2_5;
    ? **phi_v0_3;
    s32 phi_s0_9;
    ? **phi_v0_4;
    s32 phi_s0_10;
    void *phi_v0_5;

    temp_v0 = arg0->unk4;
    if ((temp_v0 != 0) && (temp_v0 != 0x1F)) {
        set_text_color(TEXT_BLUE_GREEN_RED_CYCLE_1);
        draw_text(arg0->unkC + 0x55, 0x19 - arg0->unk10, *(&D_800E7574 + (*(&gCupCourseOrder + ((gCupSelection * 8) + (gCupCourseSelection * 2))) * 4)), 0, 0.6f, 0.6f);
        set_text_color(TEXT_YELLOW);
        draw_text(arg0->unkC + 0x55, 0x28 - arg0->unk10, D_800E7730, 0, 0.75f, 0.75f);
        phi_s1 = 0;
        phi_s0 = 0;
        phi_s1_2 = 0;
        phi_s1_3 = 0;
        phi_s1_4 = 0;
        do {
            func_800A4550(phi_s1, arg0->unkC + 0x26, (phi_s0 - arg0->unk10) + 0x37);
            temp_s1 = phi_s1 + 1;
            phi_s1 = temp_s1;
            phi_s0 += 0xF;
        } while (temp_s1 < 4);
        temp_v1 = arg0->unk4;
        switch (temp_v1) {                          /* switch 1 */
        case 1:                                     /* switch 1 */
        case 5:                                     /* switch 1 */
        case 6:                                     /* switch 1 */
        case 7:                                     /* switch 1 */
        case 8:                                     /* switch 1 */
        case 9:                                     /* switch 1 */
        case 10:                                    /* switch 1 */
        case 30:                                    /* switch 1 */
            phi_s2 = 0;
            phi_s0_2 = &D_800E775C;
            do {
                sp6C = 0;
                func_800921C0(arg0->unk4 - 5, phi_s1_2, TEXT_GREEN);
                phi_v1 = sp6C;
                if (phi_s1_2 != 4) {
                    if (phi_s1_2 != 5) {

                    } else if (D_80162DD4 != 0) {
                        phi_v1 = 2;
                    }
                } else if (D_80162DF8 == 1) {
                    phi_v1 = 1;
                }
                if (phi_v1 != 0) {
                    set_text_color(TEXT_BLUE);
                    temp_v1_2 = gDisplayListHead;
                    gDisplayListHead = temp_v1_2 + 8;
                    temp_v1_2->words.w1 = 0x96;
                    temp_v1_2->words.w0 = 0xFA000000;
                    func_80093358(0xB2 - arg0->unkC, arg0->unk10 + phi_s2 + 0x93, phi_s0_2->unk4, 0, 0.75f, 0.75f);
                } else {
                    func_80093324(0xB2 - arg0->unkC, arg0->unk10 + phi_s2 + 0x93, phi_s0_2->unk4, 0, 0.75f, 0.75f);
                }
                temp_s1_2 = phi_s1_2 + 1;
                phi_s1_2 = temp_s1_2;
                phi_s2 += 0xD;
                phi_s0_2 += 4;
            } while (temp_s1_2 != 6);
block_43:
            break;
        case 11:                                    /* switch 1 */
        case 12:                                    /* switch 1 */
        case 13:                                    /* switch 1 */
        case 14:                                    /* switch 1 */
        case 15:                                    /* switch 1 */
        case 16:                                    /* switch 1 */
            set_text_color(TEXT_YELLOW);
            phi_v0 = ((arg0->unk4 - 0xB) * 0x1C) + &D_800E798C;
            phi_s0_3 = 0x8C;
            do {
                sp50 = phi_v0;
                func_80093324(0xA2, phi_s0_3, *phi_v0, 0, 0.6f, 0.6f);
                temp_s0 = phi_s0_3 + 0xD;
                phi_v0 += 4;
                phi_s0_3 = temp_s0;
            } while (temp_s0 != 0xE7);
            goto block_43;
        case 17:                                    /* switch 1 */
        case 18:                                    /* switch 1 */
            set_text_color(TEXT_GREEN);
            phi_s2_2 = 0;
            phi_s0_4 = D_800E7A3C;
            do {
                func_80093324(0xA5, arg0->unk10 + phi_s2_2 + 0x8C, *phi_s0_4, 0, 0.7f, 0.7f);
                temp_s0_2 = phi_s0_4 + 4;
                phi_s2_2 += 0xD;
                phi_s0_4 = temp_s0_2;
            } while (temp_s0_2 < &D_800E7A44);
            phi_s0_5 = 0xAA;
            phi_s2_3 = &D_8018EE10;
            do {
                func_800921C0(arg0->unk4 - 0x11, phi_s1_3, TEXT_GREEN);
                temp_a0 = phi_s1_3 + 1;
                sp54 = temp_a0;
                convert_number_to_ascii(temp_a0, &sp60);
                func_80093324(0xB1 - arg0->unkC, phi_s0_5, &sp61, 0, 0.6f, 0.6f);
                if (phi_s2_3->unk4 == 0) {
                    func_80093324(0xBB - arg0->unkC, phi_s0_5, D_800E7A44, 0, 0.45f, 0.45f);
                } else {
                    temp_v0_2 = phi_s2_3->unk5;
                    func_80093324(0xBB - arg0->unkC, phi_s0_5, *(&D_800E75C4 + (*(&gCupCourseOrder + (((temp_v0_2 / 4) * 8) + ((temp_v0_2 % 4) * 2))) * 4)), 0, 0.45f, 0.45f);
                }
                phi_s1_3 = sp54;
                phi_s0_5 += 0x1E;
                phi_s2_3 += 0x80;
            } while (sp54 != 2);
            goto block_43;
        case 19:                                    /* switch 1 */
            set_text_color(TEXT_YELLOW);
            phi_v0_2 = D_800E7A48;
            phi_s0_6 = 0x93;
            do {
                sp50 = phi_v0_2;
                func_80093324(0xAA, phi_s0_6, *phi_v0_2, 0, 0.8f, 0.8f);
                temp_v0_3 = phi_v0_2 + 4;
                phi_v0_2 = temp_v0_3;
                phi_s0_6 += 0xD;
            } while (temp_v0_3 != &D_800E7A54);
            goto block_43;
        case 20:                                    /* switch 1 */
        case 21:                                    /* switch 1 */
            set_text_color(TEXT_YELLOW);
            phi_s2_4 = 0;
            phi_s0_7 = D_800E7A60;
            do {
                func_80093324(0xA3, arg0->unk10 + phi_s2_4 + 0x8C, *phi_s0_7, 0, 0.67f, 0.67f);
                temp_s0_3 = phi_s0_7 + 4;
                phi_s2_4 += 0xD;
                phi_s0_7 = temp_s0_3;
            } while (temp_s0_3 < D_800E7A6C);
            phi_s0_8 = 0xB9;
            phi_s2_5 = D_800E7A6C;
            do {
                func_800921C0(arg0->unk4 - 0x14, phi_s1_4, TEXT_GREEN);
                func_80093324(0xC8 - arg0->unkC, phi_s0_8, *phi_s2_5, 0, 0.75f, 0.75f);
                temp_s1_3 = phi_s1_4 + 1;
                phi_s1_4 = temp_s1_3;
                phi_s0_8 += 0xF;
                phi_s2_5 += 4;
            } while (temp_s1_3 != 2);
            goto block_43;
        case 25:                                    /* switch 1 */
            set_text_color(TEXT_YELLOW);
            phi_v0_3 = D_800E7A74;
            phi_s0_9 = 0x93;
            do {
                sp50 = phi_v0_3;
                func_80093324(0xA3, phi_s0_9, *phi_v0_3, 0, 0.67f, 0.67f);
                temp_v0_4 = phi_v0_3 + 4;
                phi_v0_3 = temp_v0_4;
                phi_s0_9 += 0xD;
            } while (temp_v0_4 != D_800E7A80);
            goto block_43;
        case 26:                                    /* switch 1 */
            set_text_color(TEXT_YELLOW);
            phi_v0_4 = D_800E7A80;
            phi_s0_10 = 0x93;
            do {
                sp50 = phi_v0_4;
                func_80093324(0xAA, phi_s0_10, *phi_v0_4, 0, 0.75f, 0.75f);
                temp_v0_5 = phi_v0_4 + 4;
                phi_v0_4 = temp_v0_5;
                phi_s0_10 += 0xD;
            } while (temp_v0_5 != &D_800E7A88);
            goto block_43;
        }
        switch (arg0->unk4) {                       /* switch 2 */
        case 5:                                     /* switch 2 */
        case 6:                                     /* switch 2 */
        case 7:                                     /* switch 2 */
        case 8:                                     /* switch 2 */
        case 9:                                     /* switch 2 */
        case 10:                                    /* switch 2 */
            phi_v0_5 = (arg0->unk4 * 8) - 0x28 + &D_800E7390;
block_50:
            temp_a1 = &sp84;
            sp84 = phi_v0_5->unk0 - arg0->unkC;
            sp86 = phi_v0_5->unk2 + arg0->unk10;
            func_800A66A8(arg0, temp_a1);
            break;
        case 17:                                    /* switch 2 */
        case 18:                                    /* switch 2 */
            phi_v0_5 = (arg0->unk4 * 8) - 0x88 + &D_800E73C0;
            goto block_50;
        case 20:                                    /* switch 2 */
        case 21:                                    /* switch 2 */
            phi_v0_5 = (arg0->unk4 * 8) - 0xA0 + &D_800E73D0;
            goto block_50;
        case 30:                                    /* switch 2 */
            phi_v0_5 = (arg0->unk1C * 8) - 0x28 + &D_800E7390;
            goto block_50;
        }
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A3E60.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80093324(s32, s32, ? *, ?, f32, f32); // extern
? func_800936B8(s32, s32, s32, ?, f32, f32); // extern
? func_800939C8(s32, s32, ? *, ?, f32, f32); // extern
? get_time_record_minutes(s32, ? *); // extern
? get_time_record_seconds(s32, ? *); // extern
? get_time_record_centiseconds(s32, ? *); // extern
void *func_800AAEF4(?); // extern
? set_text_color(s32); // extern
extern ? D_800E7734;
extern ? D_800F0C4C;
extern ? D_800F0C50;
extern f32 D_800F1DC4;
extern s32 D_8018CA78;
extern ? D_8018CA90;
extern s32 gGlobalTimer;

void func_800A4550(s32 arg0, s32 arg1, s32 arg2) {
    s32 sp40;
    ? sp34;
    s32 sp2C;
    f32 temp_f20;
    s32 temp_v0;
    void *temp_v0_2;
    s32 phi_v0;
    s32 phi_a0;

    if (arg0 < 3) {
        temp_v0 = arg0 * 4;
        sp2C = temp_v0;
        sp40 = *(&D_8018CA90 + temp_v0);
        set_text_color(TEXT_RED);
        phi_v0 = temp_v0;
    } else {
        sp40 = D_8018CA78;
        set_text_color(TEXT_GREEN);
        phi_v0 = arg0 * 4;
    }
    temp_f20 = D_800F1DC4;
    func_800936B8(arg1 + 0x21, arg2, *(&D_800E7734 + phi_v0), 0, temp_f20, temp_f20);
    temp_v0_2 = func_800AAEF4(0xBB);
    if (arg0 < 3) {
        if ((temp_v0_2->unk20 & (1 << arg0)) != 0) {
            phi_a0 = gGlobalTimer % 3;
        } else {
            phi_a0 = TEXT_YELLOW;
        }
    } else {
        phi_a0 = TEXT_YELLOW;
        // If 3 lap time is in top 5 times
        if (temp_v0_2->unk1C >= 0) {
            phi_a0 = gGlobalTimer % 3;
        }
    }
    set_text_color(phi_a0);
    // Get minutes
    get_time_record_minutes(sp40, &sp34);
    // Print minute
    func_800939C8(arg1 + 0x2C, arg2, &sp34, 0, temp_f20, temp_f20);
    // '
    func_80093324(arg1 + 0x37, arg2, &D_800F0C4C, 0, temp_f20, temp_f20);
    // Get seconds
    get_time_record_seconds(sp40, &sp34);
    // Print seconds
    func_800939C8(arg1 + 0x40, arg2, &sp34, 0, temp_f20, temp_f20);
    // "
    func_80093324(arg1 + 0x4B, arg2, &D_800F0C50, 0, temp_f20, temp_f20);
    // Get milliseconds
    get_time_record_centiseconds(sp40, &sp34);
    // Print millisecond
    func_800939C8(arg1 + 0x55, arg2, &sp34, 0, temp_f20, temp_f20);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A4550.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? draw_text(s32, s32, s32, ?, f32, f32); // extern
? func_80093324(s32, s32, ? *, ?, f32, f32); // extern
? func_800939C8(s32, s32, ? *, ?, f32, f32); // extern
? get_time_record_minutes(u32, ? *); // extern
? get_time_record_seconds(u32, ? *); // extern
? get_time_record_centiseconds(u32, ? *); // extern
void *func_800AAEF4(?); // extern
u32 func_800B4E24(s32, s8 *); // extern
u32 func_800B4EB4(s32, s8); // extern
u32 func_800B4F2C(s8 *); // extern
u32 func_800B4FB0(s8); // extern
? set_text_color(s32); // extern
extern ? D_800E76A8;
extern ? D_800E7744;
extern ? D_800F0C54;
extern ? D_800F0C58;
extern f32 D_800F1DC8;
extern s8 D_8018EDF7;
extern s32 gGlobalTimer;

void func_800A474C(s32 arg0, s32 arg1, s32 arg2) {
    u32 sp48;
    s32 sp40;
    ? sp38;
    s32 sp30;
    u32 sp2C;
    f32 temp_f20;
    u32 temp_t0;
    void *temp_v0;
    u32 phi_v0;
    u32 phi_v0_2;
    u32 phi_v0_3;

    if (D_800DC50C == 4) {
        sp30 = 0;
    } else {
        sp30 = 1;
    }
    if (arg0 < 5) {
        if (sp30 == 0) {
            phi_v0 = func_800B4E24(arg0, &D_8018EDF7);
        } else {
            phi_v0 = func_800B4EB4(arg0, D_8018EDF7);
        }
        sp48 = phi_v0;
        set_text_color(TEXT_GREEN);
    } else {
        if (sp30 == 0) {
            phi_v0_2 = func_800B4F2C(&D_8018EDF7);
        } else {
            phi_v0_2 = func_800B4FB0(D_8018EDF7);
        }
        sp48 = phi_v0_2;
    }
    temp_f20 = D_800F1DC8;
    func_800939C8(arg1 + 0x14, arg2, *(&D_800E7744 + (arg0 * 4)), 2, temp_f20, temp_f20);
    if (sp30 == 0) {
        temp_v0 = func_800AAEF4(0xBB);
        if (arg0 < 5) {
            if (arg0 == temp_v0->unk1C) {
                sp40 = gGlobalTimer % 3;
            } else {
                goto block_21;
            }
        } else if (temp_v0->unk20 != 0) {
            sp40 = gGlobalTimer % 3;
        } else {
            goto block_21;
        }
    } else {
block_21:
        sp40 = 3;
    }
    set_text_color(sp40);
    temp_t0 = sp48 & 0xFFFFF;
    sp2C = temp_t0;
    get_time_record_minutes(temp_t0, &sp38);
    // Print minute
    func_800939C8(arg1 + 0x27, arg2, &sp38, 0, temp_f20, temp_f20);
    // '
    func_80093324(arg1 + 0x32, arg2, &D_800F0C54, 0, temp_f20, temp_f20);
    get_time_record_seconds(sp2C, &sp38);
    // Print second
    func_800939C8(arg1 + 0x3B, arg2, &sp38, 0, temp_f20, temp_f20);
    // "
    func_80093324(arg1 + 0x46, arg2, &D_800F0C58, 0, temp_f20, temp_f20);
    get_time_record_centiseconds(sp2C, &sp38);
    // Print millisecond
    func_800939C8(arg1 + 0x50, arg2, &sp38, 0, temp_f20, temp_f20);
    if (sp2C < 0x927C0) {
        phi_v0_3 = sp48 >> 0x14;
    } else {
        phi_v0_3 = 8;
    }
    draw_text(arg1 + 0x78, arg2, *(&D_800E76A8 + (phi_v0_3 * 4)), 0, temp_f20, temp_f20);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A474C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 draw_box(s32, s32, s32, s32, s32, s32, s32, s32, s32); // extern
? draw_text(s32, s32, ? *, ?, f32, f32); // extern
s32 get_string_width(? *, void *); // extern
? set_text_color(?); // extern
extern ? D_800E7780;
extern f32 D_800F1DCC;
extern f32 D_800F1DD0;
extern s32 gDisplayListHead;

void func_800A4A24(void *arg0) {
    s32 sp38;
    s32 sp34;
    f32 temp_f0;
    f32 temp_f0_2;
    s32 temp_t0;
    s32 temp_t1;
    s32 temp_t2;
    void *temp_a1;

    temp_t1 = arg0->unk10;
    temp_a1 = arg0;
    temp_t0 = 0x140 - arg0->unkC;
    sp38 = temp_t0;
    arg0 = temp_a1;
    sp34 = temp_t1;
    temp_f0 = D_800F1DCC;
    temp_t2 = ((get_string_width(&D_800E7780, temp_a1) + 8) * temp_f0) / 2;
    gDisplayListHead = draw_box(gDisplayListHead, temp_t0 - temp_t2, (temp_t1 - (24.0f * temp_f0)) + 4, temp_t2 + temp_t0, temp_t1 + 4, 0, 0, 0, 0x64);
    set_text_color(TEXT_BLUE_GREEN_RED_CYCLE_1);
    temp_f0_2 = D_800F1DD0;
    draw_text(arg0->unkC - 3, arg0->unk10, &D_800E7780, 0, temp_f0_2, temp_f0_2);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A4A24.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800A4BC8(); // extern
? func_800A4EF8(); // extern
? func_800A5084(); // extern
? func_800A5360(); // extern
extern u16 D_800DC5FC;

void func_800A4B38(void) {
    s32 temp_v0;

    if (D_800DC5FC != 0) {
        temp_v0 = gModeSelection;
        if (temp_v0 != GRAND_PRIX) {
            if (temp_v0 != TIME_TRIALS) {
                if (temp_v0 != VERSUS) {
                    if (temp_v0 != BATTLE) {
                        return;
                    }
                    func_800A5360();
                    // Duplicate return node #10. Try simplifying control flow for better match
                    return;
                }
                func_800A4EF8();
                return;
            }
            func_800A4BC8();
            return;
        }
        func_800A5084();
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A4B38.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 draw_box(s32, ?, ?, ?, s32, s32, s32, s32, s32); // extern
? draw_text(?, ?, s32, ?, f32, f32); // extern
? func_800921C0(s32, s32, ?); // extern
? func_80093324(s16, s32, ? *, ?, f32, f32); // extern
? func_800939C8(?, ?, ? *, ?, f32, f32); // extern
? get_time_record_minutes(s32, ? *); // extern
? get_time_record_seconds(s32, ? *); // extern
? get_time_record_centiseconds(s32, ? *); // extern
s32 func_800B4E24(?); // extern
s32 func_800B4F2C(); // extern
? set_text_color(?); // extern
extern ? D_800E7574;
extern ? D_800E7728;
extern ? *D_800E775C;
extern s16 D_800E8538;
extern s16 D_800E853A;
extern ? D_800F0C5C;
extern ? D_800F0C60;
extern ? D_800F0C64;
extern ? D_800F0C68;
extern f32 D_800F1DD4;
extern s8 gCupSelection;
extern ? gCupCourseOrder;
extern s32 gDisplayListHead;

void func_800A4BC8(void *arg0) {
    ? sp68;
    f32 temp_f20;
    s32 temp_a0;
    s32 temp_a0_2;
    s32 temp_s0;
    s32 temp_s1;
    s32 temp_s1_2;
    s32 phi_s0;
    s32 phi_s1;
    ? **phi_s2;

    gDisplayListHead = draw_box(gDisplayListHead, 0, 0, 0x13F, 0xEF, 0, 0, 0, 0x8C);
    set_text_color(TEXT_YELLOW);
    draw_text(0xA0, 0x50, *(&D_800E7574 + (*(&gCupCourseOrder + ((gCupSelection * 8) + (gCupCourseSelection * 2))) * 4)), 0, 1.0f, 1.0f);
    set_text_color(TEXT_RED);
    temp_f20 = D_800F1DD4;
    // "Best Records"
    draw_text(0x9D, 0x60, D_800E7728.unk0, 0, temp_f20, temp_f20);
    temp_a0 = func_800B4E24(0) & 0xFFFFF;
    temp_s1 = temp_a0;
    // Print minutes
    get_time_record_minutes(temp_a0, &sp68);
    func_800939C8(0x7F, 0x6D, &sp68, 0, temp_f20, temp_f20);
    // '
    func_80093324(0x8E, 0x6D, &D_800F0C5C, 0, temp_f20, temp_f20);
    // Print seconds
    get_time_record_seconds(temp_s1, &sp68);
    func_800939C8(0x98, 0x6D, &sp68, 0, temp_f20, temp_f20);
    // "
    func_80093324(0xA7, 0x6D, &D_800F0C60, 0, temp_f20, temp_f20);
    // Print centiseconds
    get_time_record_centiseconds(temp_s1, &sp68);
    func_800939C8(0xB3, 0x6D, &sp68, 0, temp_f20, temp_f20);
    // "Best Lap"
    draw_text(0x9D, 0x7C, D_800E7728.unk4, 0, temp_f20, temp_f20);
    temp_a0_2 = func_800B4F2C() & 0xFFFFF;
    temp_s1_2 = temp_a0_2;
    // Print minutes
    get_time_record_minutes(temp_a0_2, &sp68);
    func_800939C8(0x7F, 0x89, &sp68, 0, temp_f20, temp_f20);
    // '
    func_80093324(0x8E, 0x89, &D_800F0C64, 0, temp_f20, temp_f20);
    // Print seconds
    get_time_record_seconds(temp_s1_2, &sp68);
    func_800939C8(0x98, 0x89, &sp68, 0, temp_f20, temp_f20);
    // "
    func_80093324(0xA7, 0x89, &D_800F0C68, 0, temp_f20, temp_f20);
    // Print centiseconds
    get_time_record_centiseconds(temp_s1_2, &sp68);
    func_800939C8(0xB3, 0x89, &sp68, 0, temp_f20, temp_f20);
    phi_s0 = 0;
    phi_s1 = 0;
    phi_s2 = &D_800E775C;
    do {
        func_800921C0(arg0->unk4 - 0xB, phi_s0, TEXT_GREEN);
        func_80093324(D_800E8538, D_800E853A + phi_s1, *phi_s2, 0, 0.75f, 0.75f);
        temp_s0 = phi_s0 + 1;
        phi_s0 = temp_s0;
        phi_s1 += 0xD;
        phi_s2 += 4;
    } while (temp_s0 != 5);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A4BC8.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 draw_box(s32, s32, s32, s32, s32, s32, s32, s32, s32); // extern
? func_800921C0(s32, s32, ?); // extern
? func_80093324(s32, s32, s32, ?, f32, f32); // extern
extern u16 D_800DC5FC;
extern ? D_800E775C;
extern ? D_800E8540;
extern ? D_8015F480;
extern s32 gDisplayListHead;

void func_800A4EF8(void *arg0) {
    s16 temp_t0;
    s16 temp_v1;
    s32 temp_s0;
    s32 temp_t3;
    s32 temp_t4;
    void *temp_s3;
    void *temp_v0;
    s32 phi_a1;
    s32 phi_s2;
    s32 phi_s1;
    s32 phi_s0;

    temp_v0 = (D_800DC5FC << 6) - 0x40 + &D_8015F480;
    temp_v1 = temp_v0->unk30;
    temp_t0 = temp_v0->unk32;
    temp_t3 = temp_v0->unk2C / 2;
    temp_t4 = temp_v0->unk2E / 2;
    gDisplayListHead = draw_box(gDisplayListHead, temp_v1 - temp_t3, temp_t0 - temp_t4, temp_v1 + temp_t3, temp_t0 + temp_t4, 0, 0, 0, 0x8C);
    temp_s3 = ((D_800DC530 << 5) + (D_800DC5FC * 8)) - 8 + &D_800E8540;
    phi_a1 = 0;
    phi_s2 = 0;
    do {
        phi_s1 = phi_a1;
        if (phi_a1 > 0) {
            temp_s0 = phi_a1 + 1;
            phi_s1 = temp_s0;
            phi_s0 = temp_s0;
        } else {
            phi_s0 = phi_a1 + 1;
        }
        func_800921C0(arg0->unk4 - 0x15, phi_a1, TEXT_YELLOW);
        func_80093324(temp_s3->unk0 - 2, temp_s3->unk2 + phi_s2, *(&D_800E775C + (phi_s1 * 4)), 0, 0.75f, 0.75f);
        phi_a1 = phi_s0;
        phi_s2 += 0xD;
    } while (phi_s0 != 4);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A4EF8.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 draw_box(s32, s32, s32, s32, s32, s32, s32, s32, s32); // extern
? draw_text(s32, s32, s32, ?, f32, f32); // extern
? func_800921C0(s32, s32, ?); // extern
s32 get_string_width(s32); // extern
? func_80093324(s16, s32, s32, ?, f32, f32); // extern
? set_text_color(?); // extern
extern u16 D_800DC5FC;
extern ? D_800E7500;
extern ? D_800E7574;
extern ? D_800E76CC;
extern s32 D_800E775C;
extern ? D_800E85C0;
extern ? D_8015F480;
extern s8 gCupSelection;
extern ? gCupCourseOrder;
extern s32 gDisplayListHead;

void func_800A5084(void *arg0) {
    s16 temp_t0;
    s16 temp_v1;
    s32 temp_s0;
    s32 temp_s0_2;
    s32 temp_s1;
    s32 temp_t3;
    s32 temp_t4;
    void *temp_s3;
    void *temp_v0;
    s32 phi_s0;
    s32 phi_s1;
    s32 *phi_s2;

    temp_v0 = (D_800DC5FC << 6) - 0x40 + &D_8015F480;
    temp_v1 = temp_v0->unk30;
    temp_t0 = temp_v0->unk32;
    temp_t3 = temp_v0->unk2C / 2;
    temp_t4 = temp_v0->unk2E / 2;
    gDisplayListHead = draw_box(gDisplayListHead, temp_v1 - temp_t3, temp_t0 - temp_t4, temp_v1 + temp_t3, temp_t0 + temp_t4, 0, 0, 0, 0x8C);
    temp_s3 = ((D_800DC530 << 5) + (D_800DC5FC * 8)) - 8 + &D_800E85C0;
    temp_s0 = ((get_string_width(*(&D_800E7500 + (gCupSelection * 4))) * 1.0f) + 10.0f) / 2.0f;
    temp_s1 = ((get_string_width(*(&D_800E76CC + (gCCSelection * 4))) * 1.0f) + 10.0f) / 2.0f;
    set_text_color(TEXT_YELLOW);
    draw_text(0xA0 - temp_s1, temp_s3->unk2 - 0x32, *(&D_800E7500 + (gCupSelection * 4)), 0, 1.0f, 1.0f);
    set_text_color(TEXT_YELLOW);
    draw_text(temp_s0 + 0xA0, temp_s3->unk2 - 0x32, *(&D_800E76CC + (gCCSelection * 4)), 0, 1.0f, 1.0f);
    set_text_color(TEXT_YELLOW);
    draw_text(0xA0, temp_s3->unk2 - 0x1E, *(&D_800E7574 + (*(&gCupCourseOrder + ((gCupSelection * 8) + (gCupCourseSelection * 2))) * 4)), 0, 1.0f, 1.0f);
    phi_s0 = 0;
    phi_s1 = 0;
    phi_s2 = &D_800E775C;
    do {
        func_800921C0(arg0->unk4 - 0x1F, phi_s0, TEXT_YELLOW);
        func_80093324(temp_s3->unk0, temp_s3->unk2 + phi_s1, *phi_s2, 0, 0.75f, 0.75f);
        temp_s0_2 = phi_s0 + 1;
        phi_s0 = temp_s0_2;
        phi_s1 += 0xD;
        phi_s2 += 0x10;
    } while (temp_s0_2 != 2);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A5084.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 draw_box(s32, s32, s32, s32, s32, s32, s32, s32, s32); // extern
? func_800921C0(s32, s32, ?); // extern
? func_80093324(s32, s32, s32, ?, f32, f32); // extern
extern u16 D_800DC5FC;
extern ? D_800E775C;
extern ? D_800E8600;
extern ? D_8015F480;
extern s32 gDisplayListHead;

void func_800A5360(void *arg0) {
    s16 temp_t0;
    s16 temp_v1;
    s32 temp_s0;
    s32 temp_t3;
    s32 temp_t4;
    void *temp_s3;
    void *temp_v0;
    s32 phi_a1;
    s32 phi_s2;
    s32 phi_s1;
    s32 phi_s0;

    temp_v0 = (D_800DC5FC << 6) - 0x40 + &D_8015F480;
    temp_v1 = temp_v0->unk30;
    temp_t0 = temp_v0->unk32;
    temp_t3 = temp_v0->unk2C / 2;
    temp_t4 = temp_v0->unk2E / 2;
    gDisplayListHead = draw_box(gDisplayListHead, temp_v1 - temp_t3, temp_t0 - temp_t4, temp_v1 + temp_t3, temp_t0 + temp_t4, 0, 0, 0, 0x8C);
    temp_s3 = ((D_800DC530 << 5) + (D_800DC5FC * 8)) - 8 + &D_800E8600;
    phi_a1 = 0;
    phi_s2 = 0;
    do {
        phi_s1 = phi_a1;
        if (phi_a1 > 0) {
            temp_s0 = phi_a1 + 1;
            phi_s1 = temp_s0;
            phi_s0 = temp_s0;
        } else {
            phi_s0 = phi_a1 + 1;
        }
        func_800921C0(arg0->unk4 - 0x29, phi_a1, TEXT_YELLOW);
        func_80093324(temp_s3->unk0 - 2, temp_s3->unk2 + phi_s2, *(&D_800E775C + (phi_s1 * 4)), 0, 0.75f, 0.75f);
        phi_a1 = phi_s0;
        phi_s2 += 0xD;
    } while (phi_s0 != 4);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A5360.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800A66A8(void *, s16 *); // extern
void *func_800AAF30(?); // extern
extern u16 D_800DC5FC;
extern ? D_800E8538;
extern ? D_800E8540;
extern ? D_800E85C0;
extern ? D_800E8600;
extern ? D_800F0B50;
extern s16 D_80164AF0;
extern ? D_802B8880;
extern void *gDisplayListHead;

void func_800A54EC(void) {
    s16 sp52;
    s16 sp50;
    void *sp48;
    s32 sp40;
    s32 temp_t2;
    void *temp_v1;
    void *temp_v1_2;
    ? *phi_v1;

    if (D_800DC5FC != 0) {
        temp_t2 = gModeSelection;
        sp40 = temp_t2;
        temp_v1 = gDisplayListHead;
        sp48 = func_800AAF30(0xC7);
        gDisplayListHead = temp_v1 + 8;
        temp_v1->unk4 = &D_802B8880 & 0x1FFFFFFF;
        temp_v1->unk0 = 0x3800010;
        sp40 = temp_t2;
        guOrtho(gGfxPool + (D_80164AF0 << 6) + 0xFAC0, 0.0f, 319.0f, 239.0f, 0.0f, -100.0f, 100.0f, 1.0f);
        temp_v1_2 = gDisplayListHead;
        gDisplayListHead = temp_v1_2 + 8;
        temp_v1_2->unk0 = 0x1030040;
        temp_v1_2->unk4 = (gGfxPool + (D_80164AF0 << 6) + 0xFAC0) & 0x1FFFFFFF;
        D_80164AF0 = D_80164AF0 + 1;
        if (temp_t2 != GRAND_PRIX) {
            if (temp_t2 != TIME_TRIALS) {
                if (temp_t2 != VERSUS) {
                    if (temp_t2 != BATTLE) {
                        phi_v1 = sp4C;
                    } else {
                        phi_v1 = ((D_800DC530 << 5) + (D_800DC5FC * 8)) - 8 + &D_800E8600;
                    }
                } else {
                    phi_v1 = ((D_800DC530 << 5) + (D_800DC5FC * 8)) - 8 + &D_800E8540;
                }
            } else {
                phi_v1 = &D_800E8538;
            }
        } else {
            phi_v1 = ((D_800DC530 << 5) + (D_800DC5FC * 8)) - 8 + &D_800E85C0;
        }
        sp50 = phi_v1->unk0 - 8;
        sp52 = (phi_v1->unk2 + ((sp48->unk4 - *(&D_800F0B50 + temp_t2)) * 0xD)) - 8;
        func_800A66A8(sp48, &sp50);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A54EC.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
Gfx *draw_box(Gfx *, ?, ?, s32, s32, s32, s32, s32, s32); /* extern */
? func_800921C0(s32, s32, ?);                       /* extern */
s32 get_string_width(? *);                             /* extern */
? func_80093324(s32, s32, ? *, ?, f32, f32);        /* extern */
? func_80093358(s16, s32, ? *, ?, f32, f32);        /* extern */
? func_80093754(?, ?, s32, ?, f32, f32);            /* extern */
? func_800A66A8(void *, s16 *);                     /* extern */
? convert_number_to_ascii(s32, ? *);                          /* extern */
? get_time_record_minutes(s32, ? *);                          /* extern */
? get_time_record_seconds(s32, ? *);                          /* extern */
? get_time_record_centiseconds(s32, ? *);                          /* extern */
s32 func_800B4E24(?);                               /* extern */
? set_text_color(?);                                /* extern */
? text_draw(?, ?, ? *, ?, f32, f32);                /* extern */
extern ? D_8018EE10;
static ? D_800E73E0;                                /* unable to generate initializer; const */
static ? D_800E7410;                                /* unable to generate initializer; const */
static ? D_800E7420;                                /* unable to generate initializer; const */
static ? D_800E7574;                                /* unable to generate initializer; const */
static ? D_800E75C4;                                /* unable to generate initializer; const */
static ? D_800E7728;                                /* unable to generate initializer; const */
static ? *D_800E775C[7] = {
    "CONTINUE GAME",
    "RETRY",
    "COURSE CHANGE",
    "DRIVER CHANGE",
    "QUIT",
    "REPLAY",
    "SAVE GHOST",
}; /* const */
static ? D_800E798C;                                /* unable to generate initializer; const */
static ? *D_800E7A3C[2] = { "SELECT THE FILE ", "YOU WANT TO SAVE" }; /* const */
static ? *D_800E7A44 = "NO DATA";                   /* const */
static ? *D_800E7A48[3] = { "CREATING ", "MARIO KART 64 ", "GAME DATA" }; /* const */
static ? D_800E7A54;                                /* unable to generate initializer; const */
static ? *D_800E7A60[3] = { "THE PREVIOUS DATA ", "WILL BE ERASED, ", "IS THIS OK?" }; /* const */
static ? *D_800E7A6C[2] = { "QUIT", "SAVE" };       /* const */
static ? *D_800E7A74[3] = { "SAVING GHOST DATA", "", "PLEASE WAIT" }; /* const */
static ? *D_800E7A80[2] = { "UNABLE TO SAVE ", "THE GHOST" }; /* const */
static ? D_800E7A88;                                /* unable to generate initializer; const */
static s16 D_800E8538;                              /* type too large by 2; unable to generate initializer; const */
static s16 D_800E853A;                              /* type too large by 2; unable to generate initializer; const */
static ? gCupCourseOrder;                            /* unable to generate initializer; const */

void func_800A5738(void *arg0) {
    s16 sp9A;
    s16 sp98;
    ? sp84;
    ? sp5D;
    ? sp5C;
    s32 sp54;
    ? **sp50;
    ? **temp_v0_2;
    ? **temp_v0_4;
    ? **temp_v0_5;
    ? **temp_v0_6;
    ? **temp_v0_7;
    Gfx *temp_v0;
    s16 *temp_a1;
    s32 temp_a0;
    s32 temp_a0_2;
    s32 temp_a0_3;
    s32 temp_s0;
    s32 temp_s1;
    s32 temp_s1_2;
    s32 temp_s1_3;
    s32 temp_s1_4;
    s32 temp_s1_5;
    s32 temp_v1;
    s32 temp_v1_2;
    s8 temp_v0_3;
    s32 phi_s1;
    s32 phi_s2;
    ? **phi_v0;
    s32 phi_s1_2;
    s32 phi_s0;
    ? **phi_v0_2;
    s32 phi_s0_2;
    ? **phi_v0_3;
    s32 phi_s0_3;
    s32 phi_s1_3;
    s32 phi_s0_4;
    ? *phi_s2_2;
    ? **phi_v0_4;
    s32 phi_s0_5;
    ? **phi_v0_5;
    s32 phi_s0_6;
    ? **phi_v0_6;
    s32 phi_s1_4;
    s32 phi_s0_7;
    ? **phi_v0_7;
    s32 phi_s0_8;
    ? **phi_v0_8;
    s32 phi_s0_9;
    void *phi_v0_9;

    temp_v1 = arg0->unk4;
    if (temp_v1 == 0) {
        if ((arg0->unk1C >= 0x1E) && (((gGlobalTimer / 16) % 2) != 0)) {
            gDisplayListHead = draw_box(gDisplayListHead, 0xC0, 0x21, (get_string_width(D_800E775C->unk14) * 0.8f) + 0xC6, 0x32, 0, 0, 0, 0x96);
            set_text_color(TEXT_GREEN);
            func_80093324(0xBF, 0x30, D_800E775C->unk14, 0, 0.8f, 0.8f);
            return;
        }
        /* Duplicate return node #43. Try simplifying control flow for better match */
        return;
    }
    if (temp_v1 == 1) {
        temp_s1 = arg0->unk1C;
        phi_s1 = temp_s1;
        phi_s2 = (temp_s1 * 0xFF) / 140;
    } else {
        phi_s1 = 0x8C;
        phi_s2 = 0xFF;
    }
    temp_v0 = draw_box(gDisplayListHead, 0, 0, 0x13F, 0xEF, 0, 0, 0, phi_s1);
    gDisplayListHead = temp_v0;
    gDisplayListHead = temp_v0 + 8;
    temp_v0->words.w1 = phi_s2 & 0xFF;
    temp_v0->words.w0 = 0xFA000000;
    set_text_color(TEXT_YELLOW);
    func_80093754(0xA0, 0x50, *(&D_800E7574 + (*(&gCupCourseOrder + ((gCupSelection * 8) + (gCupCourseSelection * 2))) * 4)), 0, 1.0f, 1.0f);
    temp_v1_2 = arg0->unk4;
    switch (temp_v1_2) {                            /* switch 1 */
    case 1:                                         /* switch 1 */
    case 11:                                        /* switch 1 */
    case 12:                                        /* switch 1 */
    case 13:                                        /* switch 1 */
    case 14:                                        /* switch 1 */
    case 15:                                        /* switch 1 */
    case 16:                                        /* switch 1 */
        set_text_color(TEXT_RED);
        func_80093754(0x9D, 0x60, D_800E7728.unk0, 0, 0.8f, 0.8f);
        temp_a0 = func_800B4E24(0) & 0xFFFFF;
        temp_s1_2 = temp_a0;
        get_time_record_minutes(temp_a0, &sp84);
        text_draw(0x7F, 0x6D, &sp84, 0, 0.8f, 0.8f);
        func_80093358(0x8E, 0x6D, "'", 0, 0.8f, 0.8f);
        get_time_record_seconds(temp_s1_2, &sp84);
        text_draw(0x98, 0x6D, &sp84, 0, 0.8f, 0.8f);
        func_80093358(0xA7, 0x6D, "\"", 0, 0.8f, 0.8f);
        get_time_record_centiseconds(temp_s1_2, &sp84);
        text_draw(0xB3, 0x6D, &sp84, 0, 0.8f, 0.8f);
        func_80093754(0x9D, 0x7C, D_800E7728.unk4, 0, 0.8f, 0.8f);
        temp_a0_2 = func_800B4F2C() & 0xFFFFF;
        temp_s1_3 = temp_a0_2;
        get_time_record_minutes(temp_a0_2, &sp84);
        text_draw(0x7F, 0x89, &sp84, 0, 0.8f, 0.8f);
        func_80093358(0x8E, 0x89, "'", 0, 0.8f, 0.8f);
        get_time_record_seconds(temp_s1_3, &sp84);
        text_draw(0x98, 0x89, &sp84, 0, 0.8f, 0.8f);
        func_80093358(0xA7, 0x89, "\"", 0, 0.8f, 0.8f);
        get_time_record_centiseconds(temp_s1_3, &sp84);
        text_draw(0xB3, 0x89, &sp84, 0, 0.8f, 0.8f);
        phi_v0 = D_800E775C;
        phi_s1_2 = 0;
        phi_s0 = 0;
        do {
            sp50 = phi_v0;
            func_800921C0(arg0->unk4 - 0xB, phi_s1_2, TEXT_GREEN);
            func_80093358(D_800E8538, D_800E853A + phi_s0, phi_v0->unk4, 0, 0.75f, 0.75f);
            temp_s1_4 = phi_s1_2 + 1;
            phi_v0 += 4;
            phi_s1_2 = temp_s1_4;
            phi_s0 += 0xD;
        } while (temp_s1_4 != 6);
block_36:
        break;
    case 21:                                        /* switch 1 */
    case 22:                                        /* switch 1 */
    case 23:                                        /* switch 1 */
    case 24:                                        /* switch 1 */
    case 25:                                        /* switch 1 */
    case 26:                                        /* switch 1 */
        set_text_color(TEXT_YELLOW);
        phi_v0_2 = ((arg0->unk4 - 0x15) * 0x1C) + &D_800E798C;
        phi_s0_2 = 0x6E;
        do {
            sp50 = phi_v0_2;
            func_80093324(0x4D, phi_s0_2, *phi_v0_2, 0, 0.8f, 0.8f);
            temp_s0 = phi_s0_2 + 0xD;
            phi_v0_2 += 4;
            phi_s0_2 = temp_s0;
        } while (temp_s0 != 0xC9);
        goto block_36;
    case 30:                                        /* switch 1 */
    case 31:                                        /* switch 1 */
        set_text_color(TEXT_GREEN);
        phi_v0_3 = D_800E7A3C;
        phi_s0_3 = 0;
        do {
            sp50 = phi_v0_3;
            func_80093324(0x5A, arg0->unk10 + phi_s0_3 + 0x6E, *phi_v0_3, 0, 0.8f, 0.8f);
            temp_v0_2 = phi_v0_3 + 4;
            phi_v0_3 = temp_v0_2;
            phi_s0_3 += 0xD;
        } while (temp_v0_2 < &D_800E7A44);
        phi_s1_3 = 0;
        phi_s0_4 = 0x96;
        phi_s2_2 = &D_8018EE10;
        do {
            func_800921C0(arg0->unk4 - 0x1E, phi_s1_3, TEXT_GREEN);
            temp_a0_3 = phi_s1_3 + 1;
            sp54 = temp_a0_3;
            convert_number_to_ascii(temp_a0_3, &sp5C);
            func_80093324(0x5A - arg0->unkC, phi_s0_4, &sp5D, 0, 0.75f, 0.75f);
            if (phi_s2_2->unk4 == 0) {
                func_80093324(0x69 - arg0->unkC, phi_s0_4, D_800E7A44, 0, 0.75f, 0.75f);
            } else {
                temp_v0_3 = phi_s2_2->unk5;
                func_80093324(0x69 - arg0->unkC, phi_s0_4, *(&D_800E75C4 + (*(&gCupCourseOrder + (((temp_v0_3 / 4) * 8) + ((temp_v0_3 % 4) * 2))) * 4)), 0, 0.75f, 0.75f);
            }
            phi_s1_3 = sp54;
            phi_s0_4 += 0x14;
            phi_s2_2 += 0x80;
        } while (sp54 != 2);
        goto block_36;
    case 32:                                        /* switch 1 */
        set_text_color(TEXT_YELLOW);
        phi_v0_4 = D_800E7A48;
        phi_s0_5 = 0x6E;
        do {
            sp50 = phi_v0_4;
            func_80093324(0x64, phi_s0_5, *phi_v0_4, 0, 0.8f, 0.8f);
            temp_v0_4 = phi_v0_4 + 4;
            phi_v0_4 = temp_v0_4;
            phi_s0_5 += 0xD;
        } while (temp_v0_4 != &D_800E7A54);
        goto block_36;
    case 35:                                        /* switch 1 */
    case 36:                                        /* switch 1 */
        set_text_color(TEXT_YELLOW);
        phi_v0_5 = D_800E7A60;
        phi_s0_6 = 0;
        do {
            sp50 = phi_v0_5;
            func_80093324(0x55, arg0->unk10 + phi_s0_6 + 0x6E, *phi_v0_5, 0, 0.8f, 0.8f);
            temp_v0_5 = phi_v0_5 + 4;
            phi_v0_5 = temp_v0_5;
            phi_s0_6 += 0xD;
        } while (temp_v0_5 < D_800E7A6C);
        phi_v0_6 = D_800E7A6C;
        phi_s1_4 = 0;
        phi_s0_7 = 0x9B;
        do {
            sp50 = phi_v0_6;
            func_800921C0(arg0->unk4 - 0x23, phi_s1_4, TEXT_GREEN);
            func_80093324(0x7D - arg0->unkC, phi_s0_7, *phi_v0_6, 0, 0.8f, 0.8f);
            temp_s1_5 = phi_s1_4 + 1;
            phi_v0_6 += 4;
            phi_s1_4 = temp_s1_5;
            phi_s0_7 += 0xF;
        } while (temp_s1_5 != 2);
        goto block_36;
    case 40:                                        /* switch 1 */
        set_text_color(TEXT_YELLOW);
        phi_v0_7 = D_800E7A74;
        phi_s0_8 = 0x6E;
        do {
            sp50 = phi_v0_7;
            func_80093324(0x55, phi_s0_8, *phi_v0_7, 0, 0.8f, 0.8f);
            temp_v0_6 = phi_v0_7 + 4;
            phi_v0_7 = temp_v0_6;
            phi_s0_8 += 0xD;
        } while (temp_v0_6 != D_800E7A80);
        goto block_36;
    case 41:                                        /* switch 1 */
        set_text_color(TEXT_YELLOW);
        phi_v0_8 = D_800E7A80;
        phi_s0_9 = 0x6E;
        do {
            sp50 = phi_v0_8;
            func_80093324(0x5D, phi_s0_9, *phi_v0_8, 0, 0.8f, 0.8f);
            temp_v0_7 = phi_v0_8 + 4;
            phi_v0_8 = temp_v0_7;
            phi_s0_9 += 0xD;
        } while (temp_v0_7 != &D_800E7A88);
        goto block_36;
    }
    switch (arg0->unk4) {                           /* switch 2 */
    case 11:                                        /* switch 2 */
    case 12:                                        /* switch 2 */
    case 13:                                        /* switch 2 */
    case 14:                                        /* switch 2 */
    case 15:                                        /* switch 2 */
    case 16:                                        /* switch 2 */
        phi_v0_9 = (arg0->unk4 * 8) - 0x58 + &D_800E73E0;
block_42:
        temp_a1 = &sp98;
        sp98 = phi_v0_9->unk0;
        sp9A = phi_v0_9->unk2;
        func_800A66A8(arg0, temp_a1);
        break;
    case 30:                                        /* switch 2 */
    case 31:                                        /* switch 2 */
        phi_v0_9 = (arg0->unk4 * 8) - 0xF0 + &D_800E7410;
        goto block_42;
    case 35:                                        /* switch 2 */
    case 36:                                        /* switch 2 */
        phi_v0_9 = (arg0->unk4 * 8) - 0x118 + &D_800E7420;
        goto block_42;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A5738.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80093754(s32, s32, s32, ?, f32, f32); // extern
? set_text_color(s32, void **); // extern
extern s32 D_800DC540;
extern ? D_800E7500;
extern ? D_800E7524;
extern f32 D_800F1F04;
extern f32 D_800F1F08;
extern f32 D_800F1F0C;
extern s8 D_801657E8;
extern void *gDisplayListHead;

void func_800A6034(void *arg0) {
    s32 sp2C;
    s16 temp_v0;
    void *temp_v1;

    if (D_801657E8 != 1) {
        temp_v1 = gDisplayListHead;
        gDisplayListHead = temp_v1 + 8;
        temp_v1->unk0 = 0xFA000000;
        temp_v1->unk4 = arg0->unk1C & 0xFF;
        sp2C = *(&D_800E7500 + (D_800DC540 * 4));
        set_text_color(TEXT_BLUE_GREEN_RED_CYCLE_2);
        func_80093754(arg0->unkC + 0x41, arg0->unk10 + 0xA0, sp2C, 0, D_800F1F04, 1.0f);
        temp_v0 = gCurrentCourseId;
        sp2C = *(&D_800E7524 + (temp_v0 * 4));
        set_text_color(temp_v0 % 4);
        func_80093754(arg0->unkC + 0x41, arg0->unk10 + 0xC3, sp2C, 0, D_800F1F08, D_800F1F0C);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A6034.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void *draw_box(void *, ?, ?, ?, s32, s32, s32, s32, s32); // extern
? func_800921C0(s32, s32, ?); // extern
? func_80093324(?, s32, s32, ?, f32, f32); // extern
? func_80093358(?, s32, s32, ?, f32, f32); // extern
void *func_80098FC8(void *, ?, s32, ?, s32); // extern
? func_800A66A8(void *, s16 *); // extern
? set_text_color(?); // extern
extern ? D_800E775C;
extern void *gDisplayListHead;

void func_800A6154(void *arg0) {
    s16 sp6E;
    s16 sp6C;
    s32 temp_s0;
    s32 temp_s1;
    s32 temp_v0_2;
    void *temp_v0;
    void *temp_v0_3;
    s32 phi_s0;
    ? *phi_s2;
    s32 phi_s1;
    s32 phi_s0_2;
    ? *phi_s2_2;

    if (arg0->unk4 == 0) {
        gDisplayListHead = draw_box(gDisplayListHead, 0, 0, 0x13F, 0xEF, 0, 0, 0, arg0->unk1C);
        set_text_color(TEXT_YELLOW);
        temp_v0 = gDisplayListHead;
        gDisplayListHead = temp_v0 + 8;
        temp_v0->unk0 = 0xFA000000;
        temp_v0->unk4 = ((arg0->unk1C * 0xFF) / 0x64) & 0xFF;
        phi_s0 = 0x96;
        phi_s2 = &D_800E775C;
        do {
            func_80093358(0x8C, phi_s0, phi_s2->unk4, 0, 1.0f, 1.0f);
            temp_s0 = phi_s0 + 0x14;
            phi_s0 = temp_s0;
            phi_s2 += 0xC;
        } while (temp_s0 != 0xBE);
    } else {
        gDisplayListHead = draw_box(gDisplayListHead, 0, 0, 0x13F, 0xEF, 0, 0, 0, 0x64);
        phi_s1 = 0;
        phi_s0_2 = 0x96;
        phi_s2_2 = &D_800E775C;
        do {
            func_800921C0(arg0->unk4 - 0xB, phi_s1, TEXT_YELLOW);
            func_80093324(0x8C, phi_s0_2, phi_s2_2->unk4, 0, 1.0f, 1.0f);
            temp_s1 = phi_s1 + 1;
            phi_s1 = temp_s1;
            phi_s0_2 += 0x14;
            phi_s2_2 += 0xC;
        } while (temp_s1 != 2);
    }
    if (arg0->unk4 >= 0xB) {
        sp6C = 0x84;
        sp6E = (arg0->unk4 * 0x14) - 0x4E;
        func_800A66A8(arg0, &sp6C);
    }
    temp_v0_2 = arg0->unk20;
    if (temp_v0_2 > 0) {
        temp_v0_3 = func_80098FC8(gDisplayListHead, 0, 0, 0x13F, temp_v0_2);
        gDisplayListHead = temp_v0_3;
        gDisplayListHead = func_80098FC8(temp_v0_3, 0, 0xEF - arg0->unk20, 0x13F, 0xEF);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A6154.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void *draw_box(void *, ?, ?, ?, s32, s32, s32, s32, s32); // extern
? draw_text(?, s32, s32, ?, f32, f32); // extern
? func_800921C0(s32, s32, ?); // extern
? func_80093324(?, s32, s32, ?, f32, f32); // extern
? func_80093754(?, s32, s32, ?, f32, f32); // extern
? func_800A66A8(void *, void *); // extern
? func_800A69C8(void *, s32); // extern
? func_800A6BEC(void *, s32); // extern
? func_800A6CC0(void *, s32); // extern
? set_text_color(?); // extern
extern ? D_800E7360;
extern ? D_800E775C;
extern ? D_800E7778;
extern f32 D_800F1F10;
extern void *gDisplayListHead;

void func_800A638C(void *arg0) {
    f32 temp_f20;
    s32 temp_a0;
    s32 temp_s0;
    s8 temp_a0_2;
    void *temp_v0;
    void *temp_v0_2;
    s32 phi_a1;
    s32 phi_s0;
    s32 phi_s1;
    ? *phi_s2;

    if (arg0->unk4 == 0) {
        gDisplayListHead = draw_box(gDisplayListHead, 0, 0, 0x13F, 0xEF, 0, 0, 0, arg0->unk1C);
        set_text_color(TEXT_BLUE_GREEN_RED_CYCLE_2);
        temp_v0 = gDisplayListHead;
        gDisplayListHead = temp_v0 + 8;
        temp_v0->unk0 = 0xFA000000;
        temp_v0->unk4 = ((arg0->unk1C * 0xFF) / 0x64) & 0xFF;
        func_80093754(0xA0, arg0->unk10 + 0x1E, *(&D_800E7778 + ((gModeSelection / 3) * 4)), 0, 1.0f, 1.0f);
    } else {
        gDisplayListHead = draw_box(gDisplayListHead, 0, 0, 0x13F, 0xEF, 0, 0, 0, 0x64);
        set_text_color(TEXT_BLUE_GREEN_RED_CYCLE_2);
        draw_text(0xA0, arg0->unk10 + 0x1E, *(&D_800E7778 + ((gModeSelection / 3) * 4)), 0, 1.0f, 1.0f);
    }
    temp_a0 = arg0->unk4;
    if ((temp_a0 != 0) && (temp_a0 != 1)) {
        if (temp_a0 != 2) {
            phi_a1 = 0xFF;
        } else {
            phi_a1 = arg0->unk1C;
        }
    } else {
        phi_a1 = 0;
    }
    temp_v0_2 = gDisplayListHead;
    gDisplayListHead = temp_v0_2 + 8;
    temp_v0_2->unk4 = phi_a1 & 0xFF;
    temp_v0_2->unk0 = 0xFA000000;
    temp_a0_2 = D_8018EDF3;
    if (temp_a0_2 != 2) {
        if (temp_a0_2 != 3) {
            if (temp_a0_2 != 4) {

            } else {
                func_800A6CC0(arg0, phi_a1);
            }
        } else {
            func_800A6BEC(arg0, phi_a1);
        }
    } else {
        func_800A69C8(arg0, phi_a1);
    }
    phi_s0 = 0;
    phi_s1 = 0xAE;
    if (arg0->unk4 >= 0xA) {
        temp_f20 = D_800F1F10;
        phi_s2 = &D_800E775C;
        do {
            func_800921C0(arg0->unk4 - 0xA, phi_s0, TEXT_GREEN);
            func_80093324(0x69, phi_s1, phi_s2->unk4, 0, temp_f20, temp_f20);
            temp_s0 = phi_s0 + 1;
            phi_s0 = temp_s0;
            phi_s1 += 0xF;
            phi_s2 += 4;
        } while (temp_s0 != 4);
        func_800A66A8(arg0, (arg0->unk4 * 8) - 0x50 + &D_800E7360);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A638C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? guMtxCatL(Mtx *, Mtx *, Mtx *); // extern
extern ? D_0D003090;
extern f64 D_800F1F18;
extern f32 D_800F1F20;
extern s16 D_80164AF0;
extern f32 D_8018ED98;
extern f32 D_8018ED9C;
extern f32 D_8018EDA0;
extern f32 D_8018EDA4;
extern f32 D_8018EDA8;
extern f32 D_8018EDAC;
extern void *gDisplayListHead;

void func_800A66A8(void *arg0, void *arg1) {
    Mtx *temp_s0;
    Mtx *temp_s1;
    f32 temp_f0_2;
    f32 temp_f0_3;
    f32 temp_f12;
    f32 temp_f14;
    f32 temp_f2;
    f64 temp_f0;
    void *temp_v0;
    void *temp_v0_2;
    void *temp_v0_3;
    void *temp_v0_4;
    void *temp_v0_5;
    void *temp_v0_6;

    temp_s1 = gGfxPool + (D_80164AF0 << 6) + 0xFAC0;
    temp_f0 = arg0->unk24;
    if (temp_f0 > 1.5) {
        arg0->unk24 = temp_f0 * D_800F1F18;
    } else {
        arg0->unk24 = 1.5f;
    }
    temp_f0_2 = arg0->unk24;
    temp_f2 = temp_f0_2 * 3.0f * arg0->unk8;
    temp_f12 = temp_f0_2 * 4.0f;
    temp_f14 = temp_f0_2 * 2.0f;
    D_8018EDA0 = D_8018EDA0 + temp_f14;
    D_8018EDA4 = temp_f2;
    D_8018EDA8 = temp_f12;
    D_8018EDAC = temp_f14;
    D_8018ED98 = D_8018ED98 + temp_f2;
    D_8018ED9C = D_8018ED9C + temp_f12;
    temp_f0_3 = D_800F1F20;
    guScale(temp_s1, temp_f0_3, temp_f0_3, temp_f0_3);
    temp_s0 = temp_s1 + 0x40;
    guRotate(temp_s0, D_8018ED9C, 0.0f, 1.0f, 0.0f);
    guMtxCatL(temp_s1, temp_s0, temp_s1);
    guRotate(temp_s0, D_8018EDA0, 0.0f, 0.0f, 1.0f);
    guMtxCatL(temp_s1, temp_s0, temp_s1);
    guRotate(temp_s0, D_8018ED98, 1.0f, 0.0f, 0.0f);
    guMtxCatL(temp_s1, temp_s0, temp_s1);
    guTranslate(temp_s0, arg1->unk0, arg1->unk2, 0.0f);
    guMtxCatL(temp_s1, temp_s0, temp_s1);
    temp_v0 = gDisplayListHead;
    gDisplayListHead = temp_v0 + 8;
    temp_v0->unk0 = 0x1020040;
    temp_v0->unk4 = (gGfxPool + (D_80164AF0 << 6) + 0xFAC0) & 0x1FFFFFFF;
    temp_v0_2 = gDisplayListHead;
    D_80164AF0 = D_80164AF0 + 1;
    gDisplayListHead = temp_v0_2 + 8;
    temp_v0_2->unk0 = 0xB6000000;
    temp_v0_2->unk4 = 0x20000;
    temp_v0_3 = gDisplayListHead;
    gDisplayListHead = temp_v0_3 + 8;
    temp_v0_3->unk4 = 0xFF33FFFF;
    temp_v0_3->unk0 = 0xFC121824;
    temp_v0_4 = gDisplayListHead;
    gDisplayListHead = temp_v0_4 + 8;
    temp_v0_4->unk4 = 0;
    temp_v0_4->unk0 = 0xC0000000;
    temp_v0_5 = gDisplayListHead;
    gDisplayListHead = temp_v0_5 + 8;
    temp_v0_5->unk4 = 0x504340;
    temp_v0_5->unk0 = 0xB900031D;
    temp_v0_6 = gDisplayListHead;
    gDisplayListHead = temp_v0_6 + 8;
    temp_v0_6->unk0 = 0x6000000;
    temp_v0_6->unk4 = &D_0D003090;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A66A8.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80093754(s16, s16, s32, ?, f32, f32); // extern
? func_800A79F4(u8, ? *); // extern
? set_text_color(s32); // extern
? text_draw(s32, s32, ? *, ?, f32, f32); // extern
extern s32 D_800DC5E8;
extern ? D_800E7300;
extern s16 D_800E7302;
extern ? D_800E7380;
extern ? D_800E7720;
extern ? D_800F0C7C;
extern f32 D_800F1F24;
extern s32 D_8015F8B8;
extern s32 D_8015F8C4;
extern s32 gGlobalTimer;

void func_800A69C8(s32 arg0) {
    ? sp74;
    u8 *sp68;
    f32 temp_f22;
    s32 temp_s0;
    s32 temp_s3;
    s32 temp_v0;
    s32 phi_s0;
    s32 phi_v1;
    u8 *phi_s4;
    ? *phi_s1;
    ? *phi_s2;

    phi_s0 = 0;
    if (D_8018EDF3 > 0) {
        temp_f22 = D_800F1F24;
        phi_s1 = &D_800E7300;
        phi_s2 = &D_800E7380;
        phi_s4 = sp68;
        do {
            temp_v0 = gModeSelection;
            phi_v1 = 0;
            phi_v1 = 0;
            phi_v1 = 0;
            if (temp_v0 != VERSUS) {
                if (temp_v0 != BATTLE) {

                } else {
                    if (phi_s0 != D_800DC5E8) {
                        phi_v1 = 1;
                    }
                    phi_s4 = D_8015F8C4 + phi_s0;
                }
            } else {
                if (D_801643B8[phi_s0] != 0) {
                    phi_v1 = 1;
                }
                phi_s4 = D_8015F8B8 + phi_s0;
            }
            temp_s3 = *(&D_800E7720 + (phi_v1 * 4));
            if (phi_v1 != 0) {
                set_text_color(TEXT_BLUE);
            } else {
                set_text_color(gGlobalTimer % 3);
            }
            func_800A79F4(*phi_s4, &sp74);
            text_draw(phi_s1->unk0 + 0x10, phi_s1->unk2 + 0x75, &sp74, 0, 1.0f, 1.0f);
            func_80093754(phi_s2->unk0, phi_s2->unk2, temp_s3, 0, temp_f22, 1.0f);
            temp_s0 = phi_s0 + 1;
            phi_s0 = temp_s0;
            phi_s1 += 8;
            phi_s2 += 8;
        } while (temp_s0 < D_8018EDF3);
        sp68 = phi_s4;
    }
    set_text_color(TEXT_BLUE);
    text_draw(0x9E, D_800E7302 + 0x6D, &D_800F0C7C, 0, 1.0f, 1.0f);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A69C8.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800A6D94(s32, s32, s32); // extern
? func_800A6E94(s32, s32, s32); // extern
extern s32 D_8015F8BC;
extern s32 D_8015F8C8;

void func_800A6BEC(s32 arg0) {
    s32 temp_s0;
    s32 temp_v0;
    s8 temp_v1;
    s32 phi_s0;
    s32 phi_v1;

    temp_v1 = D_8018EDF3;
    phi_s0 = 0;
    phi_v1 = temp_v1;
    if (temp_v1 > 0) {
        do {
            temp_v0 = gModeSelection;
            if (temp_v0 != VERSUS) {
                if (temp_v0 != BATTLE) {

                } else {
                    func_800A6D94(3, phi_s0, D_8015F8C8);
                    goto block_7;
                }
            } else {
                func_800A6E94(3, phi_s0, D_8015F8BC);
block_7:
                phi_v1 = D_8018EDF3;
            }
            temp_s0 = phi_s0 + 1;
            phi_s0 = temp_s0;
        } while (temp_s0 < phi_v1);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A6BEC.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800A6D94(?, s32, s32); // extern
? func_800A6E94(?, s32, s32); // extern
extern s32 D_8015F8C0;
extern s32 D_8015F8CC;

void func_800A6CC0(s32 arg0) {
    s32 temp_s0;
    s32 temp_v0;
    s8 temp_v1;
    s32 phi_s0;
    s32 phi_v1;

    temp_v1 = D_8018EDF3;
    phi_s0 = 0;
    phi_v1 = temp_v1;
    if (temp_v1 > 0) {
        do {
            temp_v0 = gModeSelection;
            if (temp_v0 != VERSUS) {
                if (temp_v0 != BATTLE) {

                } else {
                    func_800A6D94(4, phi_s0, D_8015F8CC);
                    goto block_7;
                }
            } else {
                func_800A6E94(4, phi_s0, D_8015F8C0);
block_7:
                phi_v1 = D_8018EDF3;
            }
            temp_s0 = phi_s0 + 1;
            phi_s0 = temp_s0;
        } while (temp_s0 < phi_v1);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A6CC0.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800A79F4(s32, ? *); // extern
? set_text_color(s32); // extern
? text_draw(s32, s32, ? *, ?, f32, f32); // extern
extern s32 D_800DC5E8;
extern ? D_800E7300;

void func_800A6D94(s32 arg0, s32 arg1, s32 arg2) {
    ? sp30;
    s32 sp24;
    void *temp_v0;
    s32 phi_v0;

    phi_v0 = 0;
    if (arg1 != D_800DC5E8) {
        phi_v0 = 1;
    }
    sp24 = *(arg2 + arg1);
    if (phi_v0 != 0) {
        set_text_color(TEXT_BLUE);
    } else {
        set_text_color(gModeSelection % 3);
    }
    func_800A79F4(sp24, &sp30);
    temp_v0 = ((arg0 << 5) + (arg1 * 8)) - 0x40 + &D_800E7300;
    text_draw((temp_v0->unk0 + 0x20) - ((32.0f * 0.75f) / 2.0f), temp_v0->unk2 + 0x75, &sp30, 0, 0.75f, 0.75f);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A6D94.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? convert_number_to_ascii(u8, ? *); // extern
? set_text_color(s32); // extern
? text_draw(s32, s32, ? *, ?, f32, f32); // extern
extern ? D_800E7300;
extern ? D_800F0C80;
extern ? D_800F0C88;
extern ? D_800F0C90;
extern f32 D_800F1F28;
extern s32 gGlobalTimer;

void func_800A6E94(s32 arg0, s32 arg1, s32 arg2) {
    ? sp40;
    s32 sp3C;
    s32 sp38;
    u8 *sp30;
    f32 temp_f20;
    s32 temp_t8;
    u8 *temp_v0;
    void *temp_s0;

    temp_t8 = D_801643B8[arg1];
    sp3C = temp_t8;
    if (temp_t8 == 0) {
        set_text_color(gGlobalTimer % 3);
    } else {
        set_text_color(TEXT_YELLOW);
    }
    temp_s0 = ((arg0 << 5) + (arg1 * 8)) - 0x40 + &D_800E7300;
    temp_f20 = D_800F1F28;
    text_draw(temp_s0->unk0 + 4, temp_s0->unk2 + 0x5A, &D_800F0C80, 0, temp_f20, temp_f20);
    temp_v0 = (arg1 * 3) + arg2;
    sp30 = temp_v0;
    convert_number_to_ascii(*temp_v0, &sp40);
    text_draw(temp_s0->unk0 + 0x2D, temp_s0->unk2 + 0x5A, &sp40, 0, temp_f20, temp_f20);
    if (sp3C == 1) {
        sp38 = 1;
        set_text_color(gGlobalTimer % 3);
    } else {
        sp38 = 1;
        set_text_color(TEXT_BLUE);
    }
    sp38 = sp38;
    text_draw(temp_s0->unk0 + 4, temp_s0->unk2 + 0x69, &D_800F0C88, 0, temp_f20, temp_f20);
    convert_number_to_ascii(sp30->unk1, &sp40);
    text_draw(temp_s0->unk0 + 0x2D, temp_s0->unk2 + 0x69, &sp40, 0, temp_f20, temp_f20);
    if ((sp38 + 1) == sp3C) {
        set_text_color(gGlobalTimer % 3);
    } else {
        set_text_color(TEXT_RED);
    }
    text_draw(temp_s0->unk0 + 4, temp_s0->unk2 + 0x78, &D_800F0C90, 0, temp_f20, temp_f20);
    convert_number_to_ascii(sp30->unk2, &sp40);
    text_draw(temp_s0->unk0 + 0x2D, temp_s0->unk2 + 0x78, &sp40, 0, temp_f20, temp_f20);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A6E94.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void *draw_box(void *, ?, ?, s32, s32, s32, s32, s32, s32); // extern
s32 get_string_width(s32); // extern
? func_80093358(?, s32, s32, ?, f32, f32); // extern
? set_text_color(?, s32); // extern
extern s32 D_800E7A34;
extern f32 D_800F1F2C;
extern void *gDisplayListHead;

void func_800A70E8(void *arg0) {
    f32 temp_f20;
    s32 temp_a1;
    s32 temp_f6;
    s32 temp_s0;
    s32 temp_s0_2;
    void *temp_v0;
    s32 phi_s0;
    s32 phi_a1;
    s32 phi_s0_2;
    s32 *phi_s1;

    if (arg0->unk4 == 1) {
        temp_f20 = D_800F1F2C;
        temp_s0 = get_string_width(D_800E7A34.unk0) * temp_f20;
        temp_f6 = get_string_width(D_800E7A34.unk4) * temp_f20;
        phi_s0 = temp_s0;
        if (temp_s0 < temp_f6) {
            phi_s0 = temp_f6;
        }
        gDisplayListHead = draw_box(gDisplayListHead, 0xC0, 0x22, phi_s0 + 0xC6, 0x39, 0, 0, 0, 0x96);
        temp_a1 = 0x180 - ((arg0->unk1C % 0x20) * 8);
        phi_a1 = temp_a1;
        if (temp_a1 >= 0x100) {
            phi_a1 = 0xFF;
        }
        temp_v0 = gDisplayListHead;
        gDisplayListHead = temp_v0 + 8;
        temp_v0->unk4 = phi_a1 & 0xFF;
        temp_v0->unk0 = 0xFA000000;
        set_text_color(TEXT_RED);
        phi_s0_2 = 0x2C;
        phi_s1 = &D_800E7A34;
        do {
            func_80093358(0xC0, phi_s0_2, *phi_s1, 0, temp_f20, temp_f20);
            temp_s0_2 = phi_s0_2 + 0xA;
            phi_s0_2 = temp_s0_2;
            phi_s1 += 4;
        } while (temp_s0_2 != 0x40);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A70E8.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 draw_box(s32, ?, ?, ?, s32, s32, s32, s32, s32); // extern
extern s32 gDisplayListHead;

void func_800A7258(void *arg0) {
    s32 phi_v0;

    if (arg0->unk4 == 0) {
        phi_v0 = draw_box(gDisplayListHead, 0, 0, 0x13F, 0xEF, 0, 0, 0, arg0->unk1C);
    } else {
        phi_v0 = draw_box(gDisplayListHead, 0, 0, 0x13F, 0xEF, 0, 0, 0, 0x64);
    }
    gDisplayListHead = phi_v0;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A7258.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? draw_text(s32, s32, s32, ?, f32, f32); // extern
s32 get_string_width(s32); // extern
? set_text_color(?); // extern
extern ? D_800E7500;
extern ? D_800E76CC;
extern ? D_800E76DC;
extern s8 gCupSelection;

void func_800A72FC(void *arg0) {
    s32 sp30;
    s32 sp2C;

    sp30 = ((get_string_width(*(&D_800E7500 + (gCupSelection * 4))) * 1.0f) + 10.0f) / 2.0f;
    sp2C = ((get_string_width(*(&D_800E76CC + (gCCSelection * 4))) * 1.0f) + 10.0f) / 2.0f;
    set_text_color(TEXT_YELLOW);
    draw_text(arg0->unkC - sp2C, arg0->unk10, *(&D_800E7500 + (gCupSelection * 4)), 0, 1.0f, 1.0f);
    set_text_color(TEXT_YELLOW);
    draw_text(arg0->unkC + sp30, arg0->unk10, *(&D_800E76DC + (gCCSelection * 4)), 0, 1.0f, 1.0f);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A72FC.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? draw_text(s32, s32, s32, ?, f32, f32); // extern
s32 get_string_width(s32, void *); // extern
? set_text_color(?); // extern
extern s32 D_800E7A88;
extern s32 D_800E7A98;
extern s8 D_802874F5;

void func_800A7448(void *arg0) {
    s32 sp40;
    s32 sp3C;
    s32 sp38;
    void *sp34;
    f32 temp_f8;
    s8 temp_v1;
    void *temp_a1;

    temp_v1 = D_802874F5;
    if (temp_v1 >= 3) {
        set_text_color(TEXT_YELLOW);
        draw_text(arg0->unkC, arg0->unk10, D_800E7A98, 0, 0.75f, 0.75f);
        return;
    }
    sp38 = temp_v1;
    temp_f8 = (get_string_width(D_800E7A88) + 5) * 0.75f;
    temp_a1 = (temp_v1 * 4) + &D_800E7A88;
    sp34 = temp_a1;
    sp40 = temp_f8 / 2.0f;
    sp3C = ((get_string_width(temp_a1->unk4, temp_a1) + 5) * 0.75f) / 2.0f;
    set_text_color(TEXT_YELLOW);
    draw_text(arg0->unkC - sp3C, arg0->unk10, D_800E7A88, 0, 0.75f, 0.75f);
    set_text_color(TEXT_YELLOW);
    draw_text(arg0->unkC + sp40, arg0->unk10, sp34->unk4, 0, 0.75f, 0.75f);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A7448.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? draw_text(s32, s32, s32, ?, f32, f32); // extern
? set_text_color(?); // extern
extern ? D_800E7A9C;
extern f32 D_800F1F30;
extern s8 D_802874F5;

void func_800A75A0(void *arg0) {
    s32 sp20;
    f32 temp_f0;
    s32 phi_v0;

    if (D_802874F5 < 3) {
        phi_v0 = 0;
    } else {
        phi_v0 = 1;
    }
    sp20 = phi_v0;
    set_text_color(TEXT_BLUE_GREEN_RED_CYCLE_1);
    temp_f0 = D_800F1F30;
    draw_text(arg0->unkC, arg0->unk10, *(&D_800E7A9C + (phi_v0 * 4)), 0, temp_f0, temp_f0);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A75A0.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? draw_text(s32, s32, s32, ?, f32, f32); // extern
s32 get_string_width(s32); // extern
? func_800939C8(s32, s32, ? *, ?, f32, f32); // extern
? convert_number_to_ascii(s32, ? *); // extern
? func_800A79F4(s32, ? *); // extern
? set_text_color(s32); // extern
extern s32 D_800E7AA4;
extern f32 D_800F1F34;
extern s8 D_802874F5;
extern s32 gGlobalTimer;

void func_800A761C(void *arg0) {
    s32 sp48;
    s32 sp44;
    ? sp3D;
    ? sp3C;
    s32 sp38;
    s32 *sp34;
    f32 temp_f20;
    f32 temp_f8;
    s32 *temp_v1;
    s32 temp_a0;

    temp_a0 = D_802874F5 + 1;
    sp38 = temp_a0;
    func_800A79F4(temp_a0, &sp3C);
    temp_f20 = D_800F1F34;
    temp_f8 = (get_string_width(D_800E7AA4) + 5) * temp_f20;
    temp_v1 = (sp38 * 4) + &D_800E7AA4;
    sp34 = temp_v1;
    sp48 = temp_f8 / 2.0f;
    sp44 = ((get_string_width(*temp_v1) + 5) * temp_f20) / 2.0f;
    set_text_color(TEXT_BLUE_GREEN_RED_CYCLE_2);
    draw_text(arg0->unkC - sp44, arg0->unk10, D_800E7AA4, 0, temp_f20, temp_f20);
    set_text_color(gGlobalTimer % 3);
    draw_text(arg0->unkC + sp48, arg0->unk10, *sp34, 0, temp_f20, temp_f20);
    convert_number_to_ascii(temp_a0, &sp3C);
    func_800939C8((arg0->unkC + sp48) - 0x18, arg0->unk10, &sp3D, 0, 2.0f, 2.0f);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A761C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80093324(s32, s32, s32, s32, f32, f32); // extern
? func_800936B8(s32, s32, s32, s32, f32, f32); // extern
? set_text_color(s8); // extern
extern ? D_802850C0;
extern ? D_802854B0;

void func_800A7790(void *arg0) {
    s32 sp38;
    void *sp2C;
    f32 temp_f0;
    f32 temp_f0_2;
    s32 temp_t0;
    s8 temp_v1;
    void *temp_v0;

    temp_t0 = arg0->unk0 - 0x190;
    temp_v0 = (temp_t0 * 0x10) + &D_802850C0;
    sp2C = temp_v0;
    sp38 = temp_t0;
    set_text_color(temp_v0->unkD);
    temp_v1 = temp_v0->unkC;
    if ((temp_v1 == 0) || (temp_v1 != 1)) {
        temp_f0_2 = temp_v0->unk0;
        func_800936B8(arg0->unkC, arg0->unk10, *(&D_802854B0 + (temp_t0 * 4)), arg0->unk1C * temp_f0_2, arg0->unk24 * temp_f0_2, temp_f0_2);
        return;
    }
    temp_f0 = temp_v0->unk0;
    func_80093324(arg0->unkC, arg0->unk10, *(&D_802854B0 + (temp_t0 * 4)), arg0->unk1C * temp_f0, arg0->unk24 * temp_f0, temp_f0);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A7790.s")
#endif

// Originally func_800A7894
// Presumes that "number" is a 2 digit number. Convert it to a string
void convert_number_to_ascii(s32 number, char *buffer) {
    buffer[0] = (number / 0xA) + 0x30;
    buffer[1] = (number % 0xA) + 0x30;
    // Terminator
    buffer[2] = 0;
}

// Originally func_800A78E0
// MK 64 doesn't show more then 2 digits for any given time
// (minute, second, centisecond)
// So, if timeRecord is greater than 10 minutes, just use '-'s
void write_dashes(char *buffer) {
    buffer[0] = 0x2D;
    buffer[1] = 0x2D;
    // Terminator
    buffer[2] = 0;
}

// Originally func_800A78F4
// timeRecord is assumed to be measured in centiseconds
void get_time_record_minutes(s32 timeRecord, char *buffer) {
    // If timeRecord is greater than 100 minutes, put '-'
    // in buffer
    if (timeRecord >= 0x927C0) {
        write_dashes(buffer);
        return;
    }
    convert_number_to_ascii(timeRecord / 0x1770, buffer);
}

// Originally func_800A7944
// timeRecord is assumed to be measured in centiseconds
void get_time_record_seconds(s32 timeRecord, char *buffer) {
    // If timeRecord is greater than 100 minutes, put '-'
    // in buffer
    if (timeRecord >= 0x927C0) {
        write_dashes(buffer);
        return;
    }
    convert_number_to_ascii((timeRecord / 0x64) % 0x3C, buffer);
}

// Originally func_800A79A4
// timeRecord is assumed to be measured in centiseconds
void get_time_record_centiseconds(s32 timeRecord, char *buffer) {
    // If timeRecord is greater than 100 minutes, put '-'
    // in buffer
    if (timeRecord >= 0x927C0) {
        write_dashes(buffer);
        return;
    }
    convert_number_to_ascii(timeRecord % 0x64, buffer);
}

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void func_800A79F4(s32 arg0, void *arg1) {
    arg1->unk0 = -0x5D;
    arg1->unk1 = (arg0 / 0xA) - 0x50;
    arg1->unk2 = -0x5D;
    arg1->unk3 = (arg0 % 0xA) - 0x50;
    arg1->unk4 = 0;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A79F4.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
? func_8009E000(?);                                 /* extern */
? func_8009F5E0(? *);                               /* extern */
? func_800A954C(? *);                               /* extern */
? func_800A9710(? *);                               /* extern */
? func_800A97BC(? *);                               /* extern */
? func_800A9A98(? *);                               /* extern */
? func_800A9B9C(? *);                               /* extern */
? func_800A9C40(? *);                               /* extern */
? func_800A9D5C(? *);                               /* extern */
? func_800A9E58(? *);                               /* extern */
? func_800AA280(? *);                               /* extern */
? func_800AA2EC(? *);                               /* extern */
? func_800AA69C(? *);                               /* extern */
? func_800AAA9C(? *);                               /* extern */
? func_800AAB90(? *);                               /* extern */
? func_800AAC18(? *);                               /* extern */
? func_800AADD4(? *);                               /* extern */
? func_800AAE18(? *);                               /* extern */
? func_800AB020(? *);                               /* extern */
? func_800AB098(? *);                               /* extern */
? func_800AB164(? *);                               /* extern */
? func_800AB260(? *);                               /* extern */
? func_800AB290(? *);                               /* extern */
? func_800AB314(? *);                               /* extern */
? func_800AB904(? *);                               /* extern */
? func_800AB9B0(? *);                               /* extern */
? func_800ABAE8(? *);                               /* extern */
? func_800ABB24(? *);                               /* extern */
? func_800ABBCC(? *);                               /* extern */
? func_800ABC38(? *);                               /* extern */
? func_800ABEAC(? *);                               /* extern */
? func_800AC300(? *);                               /* extern */
? func_800AC324(? *);                               /* extern */
? func_800AC458(? *);                               /* extern */
? func_800AC978(? *);                               /* extern */
? func_800ACA14(? *);                               /* extern */
? func_800ACC50(? *);                               /* extern */
? func_800ACF40(? *);                               /* extern */
? func_800AD1A4(? *);                               /* extern */
? func_800AD2E8(? *);                               /* extern */
? func_800ADF48(? *);                               /* extern */
? func_800AE218(? *);                               /* extern */
? func_800AEC54(? *);                               /* extern */
? func_800AEDBC(? *);                               /* extern */
? func_800AEE90(? *);                               /* extern */
? func_800AEEBC(? *);                               /* extern */
? func_800AEEE8(? *);                               /* extern */
? func_800AEF14(? *);                               /* extern */
? func_800AEF74(? *);                               /* extern */
? func_800AF004(? *);                               /* extern */
? func_800AF1AC(? *);                               /* extern */
? func_800AF270(? *);                               /* extern */
? func_800AF480(? *);                               /* extern */
? func_800CA388(?);                                 /* extern */
? play_sound2(?);                                   /* extern */
extern ? D_8018D9E0;
extern ? D_8018DEE0;

void func_800A7A4C(s32 arg0) {
    ? *temp_s1;
    ? *temp_s1_2;
    f32 temp_f18;
    f64 temp_f0;
    s32 temp_s0;
    s32 temp_t2;
    s32 temp_t3;
    s32 temp_v0;
    s32 temp_v0_2;
    s32 temp_v0_4;
    s32 temp_v0_6;
    s8 temp_t1;
    s8 temp_t9;
    s8 temp_v0_3;
    s8 temp_v0_5;
    ? *phi_s1;
    s8 phi_v1;
    ? *phi_s1_2;
    s8 phi_v1_2;
    s32 phi_s0;

    phi_s1 = &D_8018D9E0;
    do {
        temp_v0 = phi_s1->unk0;
        phi_v1 = 0;
        phi_v1_2 = 0;
        if ((temp_v0 == 4) || (temp_v0 == 5) || (temp_v0 == 0xC7)) {
            if (arg0 != 0) {
                goto block_7;
            }
        } else if (arg0 == 0) {
block_7:
            phi_v1 = 1;
        }
        if (phi_v1 != 0) {
            if (temp_v0 >= 0x10F) {
                if (temp_v0 >= 0x131) {
                    switch (temp_v0) {              /* switch 1 */
                        func_800AF480(phi_s1);
                        break;
                    }
                } else {
                    switch (temp_v0) {              /* switch 2 */
                    case 0x12B:                     /* switch 2 */
                        func_800AF004(phi_s1);
                        break;
                    case 0x12C:                     /* switch 2 */
                    case 0x12D:                     /* switch 2 */
                    case 0x12E:                     /* switch 2 */
                    case 0x12F:                     /* switch 2 */
                        func_800AF1AC(phi_s1);
                        break;
                    case 0x130:                     /* switch 2 */
                        func_800AF270(phi_s1);
                        break;
                    }
                }
            } else if (temp_v0 >= 0x38) {
                switch (temp_v0) {                  /* switch 3 */
                case 0xFA:                          /* switch 3 */
                    temp_v0_2 = D_8018ED94;
                    if (temp_v0_2 < 0x50) {
                        D_800E8534 = 3.0f;
                    } else if (temp_v0_2 < 0x5A) {
                        temp_f0 = 0.0f;
                        if (temp_f0 < 1.0) {
                            D_800E8530 = temp_f0 + 0.1;
                        }
                        D_800E8534 = 3.0f + 0.1;
                    } else if (temp_v0_2 < 0xA0) {
                        D_800E8534 = 3.0f + 0.1;
                    } else if (temp_v0_2 < 0x190) {
                        D_800E8534 = 3.0f + 0.3;
                    }
                    temp_f18 = D_8018EDCC - 3.0f;
                    D_8018EDCC = temp_f18;
                    D_8018ED94 = temp_v0_2 + 1;
                    if (temp_f18 < -360.0f) {
                        D_8018EDCC = temp_f18 + 360.0f;
                    }
                    temp_t2 = phi_s1->unk1C + 1;
                    phi_s1->unk1C = temp_t2;
                    if (temp_t2 == 0xB4) {
                        func_8009E000(0x28);
                        func_800CA388(0x64);
                        D_8018EDE0 = 0;
                    }
                    if ((phi_s1->unk20 != 0) && (phi_s1->unk1C >= 3)) {
                        phi_s1->unk20 = 0;
                        play_sound2(0x49018008);
                    }
                    break;
                case 0xDA:                          /* switch 3 */
                    func_800A954C(phi_s1);
                    break;
                case 0xD6:                          /* switch 3 */
                    func_800A9710(phi_s1);
                    break;
                case 0xD4:                          /* switch 3 */
                    func_800A97BC(phi_s1);
                    break;
                case 0x53:                          /* switch 3 */
                case 0x54:                          /* switch 3 */
                case 0x55:                          /* switch 3 */
                case 0x56:                          /* switch 3 */
                    func_800AB164(phi_s1);
                    temp_v0_3 = D_8018EDEC;
                    if (temp_v0_3 != 1) {
                        if ((temp_v0_3 != 2) && (temp_v0_3 != 3)) {

                        } else {
                            func_800AB098(phi_s1);
                        }
                    } else {
                        func_800AB020(phi_s1);
                    }
                    break;
                case 0x58:                          /* switch 3 */
                case 0x59:                          /* switch 3 */
                case 0x5A:                          /* switch 3 */
                case 0x5B:                          /* switch 3 */
                    func_800AB260(phi_s1);
                    break;
                case 0x64:                          /* switch 3 */
                    func_800AB314(phi_s1);
                    break;
                case 0x5F:                          /* switch 3 */
                case 0x60:                          /* switch 3 */
                case 0x61:                          /* switch 3 */
                case 0x62:                          /* switch 3 */
                    func_800AB290(phi_s1);
                    break;
                case 0x65:                          /* switch 3 */
                case 0x66:                          /* switch 3 */
                    func_800AB904(phi_s1);
                    break;
                case 0x67:                          /* switch 3 */
                    func_800AB9B0(phi_s1);
                    break;
                case 0x78:                          /* switch 3 */
                case 0x79:                          /* switch 3 */
                case 0x7A:                          /* switch 3 */
                case 0x7B:                          /* switch 3 */
                case 0x8C:                          /* switch 3 */
                    func_800ABAE8(phi_s1);
                    break;
                case 0x8D:                          /* switch 3 */
                    func_800ABB24(phi_s1);
                    break;
                case 0x7C:                          /* switch 3 */
                case 0x7D:                          /* switch 3 */
                case 0x7E:                          /* switch 3 */
                case 0x7F:                          /* switch 3 */
                case 0x80:                          /* switch 3 */
                case 0x81:                          /* switch 3 */
                case 0x82:                          /* switch 3 */
                case 0x83:                          /* switch 3 */
                case 0x84:                          /* switch 3 */
                case 0x85:                          /* switch 3 */
                case 0x86:                          /* switch 3 */
                case 0x87:                          /* switch 3 */
                case 0x88:                          /* switch 3 */
                case 0x89:                          /* switch 3 */
                case 0x8A:                          /* switch 3 */
                case 0x8B:                          /* switch 3 */
                    func_800ABBCC(phi_s1);
                    break;
                case 0x96:                          /* switch 3 */
                    func_800ABC38(phi_s1);
                    break;
                case 0x97:                          /* switch 3 */
                    func_800ABEAC(phi_s1);
                    break;
                case 0x5E:                          /* switch 3 */
                    func_800AC300(phi_s1);
                    break;
                case 0xAA:                          /* switch 3 */
                    func_800AC324(phi_s1);
                    break;
                case 0xAB:                          /* switch 3 */
                    func_800AC458(phi_s1);
                    break;
                case 0xAC:                          /* switch 3 */
                    func_800ACA14(phi_s1);
                    break;
                case 0xAF:                          /* switch 3 */
                    func_800AC978(phi_s1);
                    break;
                case 0xB0:                          /* switch 3 */
                    func_800ACC50(phi_s1);
                    break;
                case 0xB1:                          /* switch 3 */
                case 0xB2:                          /* switch 3 */
                case 0xB3:                          /* switch 3 */
                case 0xB4:                          /* switch 3 */
                    func_800ACF40(phi_s1);
                    break;
                case 0xB9:                          /* switch 3 */
                    func_800AD1A4(phi_s1);
                    break;
                case 0xBA:                          /* switch 3 */
                    func_800AD2E8(phi_s1);
                    break;
                case 0xBC:                          /* switch 3 */
                    func_800AEC54(phi_s1);
                    break;
                case 0xC7:                          /* switch 3 */
                    func_800ADF48(phi_s1);
                    break;
                case 0xBD:                          /* switch 3 */
                    func_800AE218(phi_s1);
                    break;
                case 0xE6:                          /* switch 3 */
                    func_800AEDBC(phi_s1);
                    break;
                case 0xE8:                          /* switch 3 */
                    func_800AEE90(phi_s1);
                    break;
                case 0xE9:                          /* switch 3 */
                    func_800AEEBC(phi_s1);
                    break;
                case 0xEA:                          /* switch 3 */
                    func_800AEEE8(phi_s1);
                    break;
                case 0xBE:                          /* switch 3 */
                    func_800AEF14(phi_s1);
                    break;
                case 0x10E:                         /* switch 3 */
                    func_800AEF74(phi_s1);
                    break;
                }
            } else {
                switch (temp_v0) {                  /* switch 4 */
                case 0x5:                           /* switch 4 */
                    temp_v0_4 = phi_s1->unk4;
                    if (temp_v0_4 != 0) {
                        if (temp_v0_4 != 1) {

                        }
                        phi_s1->unk15 = 1;
                    } else if ((D_800DC4CC->button & 0x10) != 0) {
                        phi_s1->unk4 = 1;
                        play_sound2(0x4900801C);
                    } else {
                        phi_s1->unk15 = 0;
                    }
                    break;
                case 0xA:                           /* switch 4 */
                    func_800AA280(phi_s1);
                    break;
                case 0x10:                          /* switch 4 */
                case 0x11:                          /* switch 4 */
                    temp_t9 = D_8018EDED;
                    switch (temp_t9) {              /* switch 5 */
                    case 1:                         /* switch 5 */
                    case 2:                         /* switch 5 */
                    case 3:                         /* switch 5 */
                        func_800A9B9C(phi_s1);
                        break;
                    case 4:                         /* switch 5 */
                    case 5:                         /* switch 5 */
                    case 6:                         /* switch 5 */
                    case 7:                         /* switch 5 */
                    case 8:                         /* switch 5 */
                        func_800A9C40(phi_s1);
                        break;
                    }
                    break;
                case 0xF:                           /* switch 4 */
                    func_800AA280(phi_s1);
                    func_800A9A98(phi_s1);
                    break;
                case 0xB:                           /* switch 4 */
                case 0xC:                           /* switch 4 */
                case 0xD:                           /* switch 4 */
                case 0xE:                           /* switch 4 */
                    temp_t1 = D_8018EDED;
                    switch (temp_t1) {              /* switch 6 */
                    case 1:                         /* switch 6 */
                    case 2:                         /* switch 6 */
                    case 3:                         /* switch 6 */
                        func_800A9B9C(phi_s1);
                        break;
                    case 4:                         /* switch 6 */
                    case 5:                         /* switch 6 */
                    case 6:                         /* switch 6 */
                    case 7:                         /* switch 6 */
                    case 8:                         /* switch 6 */
                        func_800A9C40(phi_s1);
                        break;
                    }
                    func_800A9D5C(phi_s1);
                    break;
                case 0x12:                          /* switch 4 */
                case 0x13:                          /* switch 4 */
                case 0x14:                          /* switch 4 */
                case 0x15:                          /* switch 4 */
                case 0x16:                          /* switch 4 */
                case 0x17:                          /* switch 4 */
                case 0x18:                          /* switch 4 */
                case 0x19:                          /* switch 4 */
                    func_800A9E58(phi_s1);
                    break;
                case 0x1B:                          /* switch 4 */
                    func_800AA2EC(phi_s1);
                    break;
                case 0x34:                          /* switch 4 */
                case 0x35:                          /* switch 4 */
                case 0x36:                          /* switch 4 */
                case 0x37:                          /* switch 4 */
                    func_800AADD4(phi_s1);
                    break;
                case 0x2B:                          /* switch 4 */
                case 0x2C:                          /* switch 4 */
                case 0x2D:                          /* switch 4 */
                case 0x2E:                          /* switch 4 */
                case 0x2F:                          /* switch 4 */
                case 0x30:                          /* switch 4 */
                case 0x31:                          /* switch 4 */
                case 0x32:                          /* switch 4 */
                    func_800AAC18(phi_s1);
                    temp_t3 = phi_s1->unk0;
                    switch (temp_t3) {              /* switch 7 */
                        func_800AA69C(phi_s1);
                        break;
                    }
                    temp_v0_5 = D_8018EDEE;
                    if (temp_v0_5 != 1) {
                        if ((temp_v0_5 != 2) && (temp_v0_5 != 3)) {

                        } else {
                            func_800AAA9C(phi_s1);
                        }
                    } else {
                        func_800AAB90(phi_s1);
                    }
                    func_800AAE18(phi_s1);
                    break;
                case 0x33:                          /* switch 4 */
                case 0x5D:                          /* switch 3 */
                    func_800A9A98(phi_s1);
                    break;
                }
            }
        }
        temp_s1 = phi_s1 + 0x28;
        phi_s1 = temp_s1;
    } while (temp_s1 != &D_8018DEE0);
    phi_s0 = 0;
    do {
        phi_s1_2 = &D_8018D9E0;
loop_113:
        temp_v0_6 = phi_s1_2->unk0;
        if ((temp_v0_6 == 4) || (temp_v0_6 == 5) || (temp_v0_6 == 0xC7)) {
            if (arg0 != 0) {
                goto block_119;
            }
        } else if (arg0 == 0) {
block_119:
            phi_v1_2 = 1;
        }
        if ((phi_v1_2 != 0) && (phi_s0 == phi_s1_2->unk14)) {
            func_8009F5E0(phi_s1_2);
        }
        temp_s1_2 = phi_s1_2 + 0x28;
        phi_s1_2 = temp_s1_2;
        if (temp_s1_2 != &D_8018DEE0) {
            goto loop_113;
        }
        temp_s0 = phi_s0 + 1;
        phi_s0 = temp_s0;
    } while (temp_s0 != 0x10);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A7A4C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800A7A4C(?); // extern

void func_800A8230(void) {
    func_800A7A4C(0);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A8230.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800A7A4C(?); // extern

void func_800A8250(void) {
    func_800A7A4C(1);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A8250.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void *func_800959A0(void *, s32, s32, s32, s32); // extern
void *func_80098C18(void *, s32, s32, s32, s32, s32, s32, s32, s32); // extern
void *func_80098FC8(void *, s32, s32, s32, s32); // extern
extern ? D_800E86AC;
extern ? D_800F2B60;
extern s8 D_8018EDED;
extern void *gDisplayListHead;

void func_800A8270(s32 arg0, void *arg1) {
    s32 temp_a3;
    s32 temp_s0;
    s32 temp_s2;
    s32 temp_s3;
    s32 temp_s3_2;
    s32 temp_s3_3;
    s32 temp_s4;
    s32 temp_s4_2;
    s32 temp_s4_3;
    s32 temp_t1;
    s32 temp_t6;
    s8 *temp_s7;
    s8 temp_v0_4;
    s8 temp_v0_5;
    void *temp_v0;
    void *temp_v0_2;
    void *temp_v0_3;
    void *phi_v0;
    s32 phi_s2;
    s32 phi_s3;
    s32 phi_s0;
    s32 phi_s4;
    void *phi_v0_2;

    temp_a3 = arg1->unk1C;
    if (temp_a3 < 0x20) {
        temp_v0 = gDisplayListHead;
        temp_t1 = arg1->unkC;
        temp_s0 = arg1->unk10;
        gDisplayListHead = temp_v0 + 8;
        temp_v0->unk0 = 0xE7000000;
        temp_v0->unk4 = 0;
        temp_v0_2 = gDisplayListHead;
        gDisplayListHead = temp_v0_2 + 8;
        temp_v0_2->unk0 = 0xB900031D;
        temp_v0_2->unk4 = 0xF0A4000;
        temp_v0_3 = gDisplayListHead;
        temp_t6 = (temp_a3 << 6) / 0x40;
        gDisplayListHead = temp_v0_3 + 8;
        temp_v0_3->unk4 = 0xFFFCF279;
        temp_v0_3->unk0 = 0xFCFFFFFF;
        temp_s3 = temp_t1 + temp_t6;
        phi_s3 = temp_s3;
        if ((arg0 + 1) == D_8018EDF3) {
            temp_v0_4 = D_8018EDED;
            temp_s3_2 = temp_t1 + temp_t6;
            phi_s3 = temp_s3_2;
            if ((temp_v0_4 == 1) || (temp_v0_4 == 2) || (temp_v0_4 == 3)) {
                temp_s4_2 = (temp_t1 - temp_t6) + 0x3F;
                phi_v0 = func_800959A0(gDisplayListHead, temp_s3_2, temp_s0, temp_s4_2, temp_s0 + 0x35);
                phi_s4 = temp_s4_2;
            } else {
                temp_s4 = (temp_t1 - temp_t6) + 0x3F;
                temp_s3_3 = temp_t1 + temp_t6;
                phi_v0 = func_80098C18(gDisplayListHead, temp_s3_3, temp_s0, temp_s4, temp_s0 + 0x35, 0xFF, 0xF9, 0xDC, 0xFF);
                phi_s3 = temp_s3_3;
                phi_s4 = temp_s4;
            }
        } else {
            temp_s4_3 = (temp_t1 - temp_t6) + 0x3F;
            phi_v0 = func_80098FC8(gDisplayListHead, temp_s3, temp_s0, temp_s4_3, temp_s0 + 0x35);
            phi_s4 = temp_s4_3;
        }
        gDisplayListHead = phi_v0;
        temp_s7 = arg0 + &D_800F2B60;
        phi_s2 = 0;
        phi_s0 = temp_s0 + 0x41;
        if (*temp_s7 >= 0) {
            do {
                if ((phi_s2 == *(arg0 + &D_800E86AC)) && ((arg0 + 1) == D_8018EDF3) && (temp_v0_5 = D_8018EDED, ((temp_v0_5 < 4) == 0))) {
                    if (temp_v0_5 == 4) {
                        phi_v0_2 = func_800959A0(gDisplayListHead, phi_s3, phi_s0, phi_s4, phi_s0 + 0x11);
                    } else {
                        phi_v0_2 = func_80098C18(gDisplayListHead, phi_s3, phi_s0, phi_s4, phi_s0 + 0x11, 0xFF, 0xF9, 0xDC, 0xFF);
                    }
                } else {
                    phi_v0_2 = func_80098C18(gDisplayListHead, phi_s3, phi_s0, phi_s4, phi_s0 + 0x11, 1, 1, 1, 0xFF);
                }
                gDisplayListHead = phi_v0_2;
                temp_s2 = phi_s2 + 1;
                phi_s2 = temp_s2;
                phi_s0 += 0x12;
            } while (*temp_s7 >= temp_s2);
        }
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A8270.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 func_800959A0(s32, s32, s32, s32, s32); // extern
s32 func_80098C18(s32, s32, s32, s32, s32, s32, s32, s32, s32); // extern
void *segmented_to_virtual(? *, s32, void *); // extern
extern ? D_0200487C;
extern ? D_02004B74;
extern ? D_02004E80;
extern s8 D_8018EDEC;
extern s8 D_8018EDED;
extern s8 D_8018EDEE;
extern s32 gDisplayListHead;

void func_800A8564(void *arg0) {
    s32 sp34;
    s32 sp30;
    s32 temp_a2;
    s32 temp_t0;
    s32 temp_v0;
    s32 temp_v0_4;
    s8 temp_v0_2;
    s8 temp_v0_3;
    void *temp_a3;
    void *temp_v0_5;
    s32 phi_a1;
    ? *phi_a0;
    s32 phi_v0;

    temp_v0 = arg0->unk0;
    temp_a3 = arg0;
    phi_a1 = 0;
    if (temp_v0 != 0xF) {
        if (temp_v0 != 0x33) {
            if (temp_v0 != 0x5D) {
                return;
            }
            phi_a0 = &D_02004E80;
            phi_a0 = &D_02004E80;
            if (D_8018EDEC == 3) {
                goto block_11;
            }
            goto block_12;
        }
        temp_v0_2 = D_8018EDEE;
        phi_a0 = &D_02004B74;
        phi_a0 = &D_02004B74;
        if ((temp_v0_2 == 2) || (temp_v0_2 == 3)) {
            goto block_11;
        }
        goto block_12;
    }
    temp_v0_3 = D_8018EDED;
    phi_a0 = &D_0200487C;
    phi_a0 = &D_0200487C;
    if ((temp_v0_3 == 6) || (temp_v0_3 == 7)) {
block_11:
        phi_a1 = 1;
    }
block_12:
    temp_v0_4 = temp_a3->unk1C;
    if (temp_v0_4 < 0x20) {
        sp34 = (temp_v0_4 << 5) / 0x40;
        sp30 = phi_a1;
        arg0 = temp_a3;
        temp_v0_5 = segmented_to_virtual(phi_a0, phi_a1, temp_a3);
        temp_t0 = arg0->unkC + temp_v0_5->unkC;
        temp_a2 = arg0->unk10 + temp_v0_5->unkE;
        if (phi_a1 != 0) {
            phi_v0 = func_800959A0(gDisplayListHead, temp_t0 + sp34, temp_a2, (temp_t0 - sp34) + 0x1E, temp_a2 + 0x12);
        } else {
            phi_v0 = func_80098C18(gDisplayListHead, temp_t0 + sp34, temp_a2, (temp_t0 - sp34) + 0x1E, temp_a2 + 0x12, 1, 1, 1, 0xFF);
        }
        gDisplayListHead = phi_v0;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A8564.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 func_80098C18(s32, s32, s32, s32, s32, s32, s32, s32, s32); // extern
extern s32 gDisplayListHead;

void func_800A86E8(void *arg0) {
    s32 temp_a1;
    s32 temp_a2;

    temp_a2 = arg0->unk10;
    temp_a1 = arg0->unkC;
    gDisplayListHead = func_80098C18(gDisplayListHead, temp_a1, temp_a2, temp_a1 + 0x64, temp_a2 + 0x27, 1, 1, 1, 0xFF);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A86E8.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80093324(s32, s32, ? *, ?, f32, f32); // extern
? func_800936B8(s32, s32, s32, ?, f32, f32); // extern
? get_time_record_minutes(u32, ? *); // extern
? get_time_record_seconds(u32, ? *); // extern
? get_time_record_centiseconds(u32, ? *); // extern
u32 func_800B4E24(?); // extern
u32 func_800B4F2C(); // extern
? set_text_color(?); // extern
? text_draw(s32, s32, ? *, ?, f32, f32); // extern
extern ? D_800E76A8;
extern ? D_800F0C98;
extern ? D_800F0C9C;
extern f32 D_800F24A0;
extern f32 D_800F24A4;

void func_800A874C(void *arg0) {
    ? sp58;
    f32 temp_f20;
    f32 temp_f22;
    u32 temp_s1;
    u32 phi_v0;
    u32 phi_s2;

    set_text_color(TEXT_GREEN);
    if (arg0->unk0 == 0x65) {
        phi_v0 = func_800B4E24(0);
    } else {
        phi_v0 = func_800B4F2C();
    }
    temp_s1 = phi_v0 & 0xFFFFF;
    get_time_record_minutes(temp_s1, &sp58);
    temp_f20 = D_800F24A0;
    temp_f22 = D_800F24A4;
    text_draw(arg0->unkC + 5, arg0->unk10 + 0x21, &sp58, 0, temp_f20, temp_f22);
    func_80093324(arg0->unkC + 0xE, arg0->unk10 + 0x21, &D_800F0C98, 0, temp_f20, temp_f22);
    get_time_record_seconds(temp_s1, &sp58);
    text_draw(arg0->unkC + 0x16, arg0->unk10 + 0x21, &sp58, 0, temp_f20, temp_f22);
    func_80093324(arg0->unkC + 0x20, arg0->unk10 + 0x21, &D_800F0C9C, 0, temp_f20, temp_f22);
    get_time_record_centiseconds(temp_s1, &sp58);
    text_draw(arg0->unkC + 0x29, arg0->unk10 + 0x21, &sp58, 0, temp_f20, temp_f22);
    if (temp_s1 < 0x927C0) {
        phi_s2 = phi_v0 >> 0x14;
    } else {
        phi_s2 = 8;
    }
    func_800936B8(arg0->unkC + 0x60, arg0->unk10 + 0x21, *(&D_800E76A8 + (phi_s2 * 4)), 0, temp_f20, temp_f22);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A874C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void *func_800959A0(void *, s32, s32, s32, s32); // extern
void *func_80098C18(void *, s32, s32, s32, s32, s32, s32, s32, s32); // extern
extern s8 D_8018EDEC;
extern s8 gCupSelection;
extern void *gDisplayListHead;

void func_800A890C(s32 arg0, void *arg1) {
    s32 temp_a2;
    s32 temp_t0;
    s32 temp_t1;
    s32 temp_t7;
    void *temp_v0;
    void *temp_v0_2;
    void *temp_v0_3;
    void *phi_v0;

    temp_t1 = arg1->unk1C;
    if (temp_t1 < 0x20) {
        temp_v0 = gDisplayListHead;
        temp_t0 = arg1->unkC;
        temp_a2 = arg1->unk10;
        gDisplayListHead = temp_v0 + 8;
        temp_v0->unk4 = 0;
        temp_v0->unk0 = 0xE7000000;
        temp_v0_2 = gDisplayListHead;
        gDisplayListHead = temp_v0_2 + 8;
        temp_v0_2->unk0 = 0xB900031D;
        temp_v0_2->unk4 = 0xF0A4000;
        temp_v0_3 = gDisplayListHead;
        temp_t7 = (temp_t1 * 0x41) / 0x40;
        gDisplayListHead = temp_v0_3 + 8;
        temp_v0_3->unk0 = 0xFCFFFFFF;
        temp_v0_3->unk4 = 0xFFFCF279;
        if (arg0 == gCupSelection) {
            if (D_8018EDEC == 1) {
                phi_v0 = func_800959A0(gDisplayListHead, temp_t0 + temp_t7, temp_a2, (temp_t0 - temp_t7) + 0x40, temp_a2 + 0x27);
            } else {
                phi_v0 = func_80098C18(gDisplayListHead, temp_t0 + temp_t7, temp_a2, (temp_t0 - temp_t7) + 0x40, temp_a2 + 0x27, 0xFF, 0xF9, 0xDC, 0xFF);
            }
        } else {
            phi_v0 = func_80098C18(gDisplayListHead, temp_t0 + temp_t7, temp_a2, (temp_t0 - temp_t7) + 0x40, temp_a2 + 0x27, 1, 1, 1, 0xFF);
        }
        gDisplayListHead = phi_v0;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A890C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void *func_800959A0(void *, s32, s32, s32, s32); // extern
void *func_80098C18(void *, s32, s32, s32, s32, s32, s32, s32, s32); // extern
extern ? D_800E7208;
extern s8 D_8018EDEC;
extern void *gDisplayListHead;

void func_800A8A98(void *arg0) {
    s32 temp_s2;
    s32 temp_s3;
    s32 temp_s4;
    s8 temp_v0_4;
    void *temp_v0;
    void *temp_v0_2;
    void *temp_v0_3;
    s32 phi_s4;
    ? *phi_s0;
    void *phi_v0;

    temp_v0 = gDisplayListHead;
    temp_s2 = arg0->unkC;
    temp_s3 = arg0->unk10;
    gDisplayListHead = temp_v0 + 8;
    temp_v0->unk0 = 0xE7000000;
    temp_v0->unk4 = 0;
    temp_v0_2 = gDisplayListHead;
    gDisplayListHead = temp_v0_2 + 8;
    temp_v0_2->unk0 = 0xB900031D;
    temp_v0_2->unk4 = 0xF0A4000;
    temp_v0_3 = gDisplayListHead;
    gDisplayListHead = temp_v0_3 + 8;
    temp_v0_3->unk0 = 0xFCFFFFFF;
    temp_v0_3->unk4 = 0xFFFCF279;
    phi_s4 = 0;
    phi_s0 = &D_800E7208;
    do {
        if ((phi_s4 == gCupCourseSelection) && (temp_v0_4 = D_8018EDEC, ((temp_v0_4 < 2) == 0)) && (gModeSelection != GRAND_PRIX)) {
            if ((temp_v0_4 == 2) || (temp_v0_4 == 4)) {
                phi_v0 = func_800959A0(gDisplayListHead, phi_s0->unk0 + temp_s2, phi_s0->unk2 + temp_s3, phi_s0->unk8 + temp_s2, phi_s0->unkA + temp_s3);
            } else {
                phi_v0 = func_80098C18(gDisplayListHead, phi_s0->unk0 + temp_s2, phi_s0->unk2 + temp_s3, phi_s0->unk8 + temp_s2, phi_s0->unkA + temp_s3, 0xFF, 0xF9, 0xDC, 0xFF);
            }
        } else {
            phi_v0 = func_80098C18(gDisplayListHead, phi_s0->unk0 + temp_s2, phi_s0->unk2 + temp_s3, phi_s0->unk8 + temp_s2, phi_s0->unkA + temp_s3, 1, 1, 1, 0xFF);
        }
        gDisplayListHead = phi_v0;
        temp_s4 = phi_s4 + 1;
        phi_s4 = temp_s4;
        phi_s0 += 0x10;
    } while (temp_s4 != 4);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A8A98.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void *draw_box(void *, s32, s32, s32, s32, s32, s32, s32, s32); // extern
void *func_800AAEF4(?); // extern
extern ? D_800E7208;
extern s8 D_8018EDEC;
extern ? D_E6FFFFFC;
extern void *gDisplayListHead;

void func_800A8CA4(void *arg0) {
    s32 temp_s0;
    s32 temp_s2;
    s32 temp_s3;
    s32 temp_t6;
    void *temp_v0;
    void *temp_v0_2;
    void *temp_v1;
    void *temp_v1_2;
    void *temp_v1_3;
    s32 phi_s0;

    temp_v0 = func_800AAEF4(0x64);
    temp_v1 = gDisplayListHead;
    temp_s2 = arg0->unkC;
    temp_s3 = arg0->unk10;
    gDisplayListHead = temp_v1 + 8;
    temp_v1->unk0 = &D_E6FFFFFC;
    temp_v1->unk4 = 0;
    temp_v1_2 = gDisplayListHead;
    gDisplayListHead = temp_v1_2 + 8;
    temp_v1_2->unk0 = 0xB900031D;
    temp_v1_2->unk4 = 0xF0A4000;
    temp_v1_3 = gDisplayListHead;
    gDisplayListHead = temp_v1_3 + 8;
    temp_v1_3->unk0 = 0xFCFFFFFF;
    temp_v1_3->unk4 = 0xFFFCF279;
    if (gModeSelection == GRAND_PRIX) {
        phi_s0 = 0;
        if (D_8018EDEC != 3) {
            do {
                temp_t6 = temp_v0->unk1C;
                temp_v0_2 = &D_800E7208 + (phi_s0 * 0x10);
                if ((temp_t6 < 0) && ((temp_t6 & 3) != 0)) {

                }
                if (phi_s0 != (temp_t6 & 3)) {
                    gDisplayListHead = draw_box(gDisplayListHead, temp_v0_2->unk0 + temp_s2, temp_v0_2->unk2 + temp_s3, temp_v0_2->unk8 + temp_s2, temp_v0_2->unkA + temp_s3, 0, 0, 0, 0x64);
                }
                temp_s0 = phi_s0 + 1;
                phi_s0 = temp_s0;
            } while (temp_s0 != 4);
        }
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A8CA4.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? draw_text(?, ?, s32, ?, f32, f32); // extern
? func_80093324(?, ?, s32, ?, f32, f32); // extern
? set_text_color(?); // extern
extern s32 D_800E77A8;
extern s32 D_800E77AC;
extern s32 D_800E77B0;
extern f32 D_800F24A8;
extern f32 D_800F24AC;
extern f32 D_800F24B0;
extern f32 D_800F24B4;

void func_800A8E14(s32 arg0) {
    set_text_color(TEXT_YELLOW);
    draw_text(0x98, 0x44, D_800E77A8, 0, 1.0f, 1.0f);
    func_80093324(0x17, 0x58, D_800E77AC, 0, D_800F24A8, D_800F24AC);
    func_80093324(0x17, 0x6A, D_800E77B0, 0, D_800F24B0, D_800F24B4);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A8E14.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80093324(s32, s32, s32, ?, f32, f32); // extern
? func_8009A76C(s32, s32, s32, ?); // extern
? set_text_color(?); // extern
extern ? D_800E7678;
extern f32 D_800F24B8;

void func_800A8EC0(void *arg0) {
    f32 temp_f0;

    if (arg0->unk20 != 0) {
        func_8009A76C(arg0->unk18, arg0->unkC, arg0->unk10, -1);
        set_text_color(TEXT_YELLOW);
        temp_f0 = D_800F24B8;
        func_80093324(arg0->unkC + 0x20, arg0->unk10 + 0x28, *(&D_800E7678 + (arg0->unk20 * 4)), 0, temp_f0, temp_f0);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A8EC0.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 func_80098FC8(s32, s32, s16, s32, s32); // extern
s32 func_8009BA74(s32, ?, ?, ?); // extern
s32 func_8009C204(s32, s32, s32, s16, s32); // extern
s32 func_800B639C(s32); // extern
s32 segmented_to_virtual(? *); // extern
extern ? D_02004A0C;
extern ? D_800E7168;
extern s8 D_8018EDEC;
extern s8 gCupSelection;
extern s32 gDisplayListHead;

void func_800A8F48(s32 arg0) {
    s16 temp_s0;
    s16 temp_v1;
    s32 temp_s1;
    s32 temp_s2;
    s32 temp_v0_2;
    s8 temp_v0;
    void *temp_v0_3;
    s32 phi_s1;

    temp_v0 = D_8018EDEC;
    if (temp_v0 != 1) {
        if (temp_v0 != 2) {

        }
        if (func_800B639C((gCupSelection * 4) + gCupCourseSelection) >= 0) {
            temp_v0_2 = func_80098FC8(gDisplayListHead, 0x57, 0x70, 0x96, 0x81);
            gDisplayListHead = temp_v0_2;
            gDisplayListHead = func_8009BA74(temp_v0_2, 0x2004A0C, 0x57, 0x70);
        }
        return;
    }
    phi_s1 = 0;
    do {
        if (func_800B639C((gCupSelection * 4) + phi_s1) >= 0) {
            temp_v0_3 = &D_800E7168 + (phi_s1 * 8);
            temp_v1 = temp_v0_3->unk0;
            temp_s0 = temp_v0_3->unk2;
            temp_s2 = temp_v1 + 0x20;
            gDisplayListHead = func_80098FC8(gDisplayListHead, temp_s2, temp_s0, temp_v1 + 0x3F, temp_s0 + 9);
            gDisplayListHead = func_8009C204(gDisplayListHead, segmented_to_virtual(&D_02004A0C), temp_s2, temp_s0, 2);
        }
        temp_s1 = phi_s1 + 1;
        phi_s1 = temp_s1;
    } while (temp_s1 != 4);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A8F48.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void *func_80098C18(void *, s32, s32, s32, s32, s32, s32, s32, s32); // extern
extern void *gDisplayListHead;

void func_800A90D4(s32 arg0, void *arg1) {
    s32 temp_a2;
    s32 temp_t1;
    s32 temp_t5;
    s32 temp_t7;
    void *temp_v0;
    void *temp_v0_2;
    void *temp_v0_3;

    temp_t5 = arg1->unk1C;
    if (temp_t5 < 0x20) {
        temp_v0 = gDisplayListHead;
        temp_t1 = arg1->unkC;
        temp_a2 = arg1->unk10;
        gDisplayListHead = temp_v0 + 8;
        temp_v0->unk0 = 0xE7000000;
        temp_v0->unk4 = 0;
        temp_v0_2 = gDisplayListHead;
        temp_t7 = (temp_t5 * 0x41) / 0x40;
        gDisplayListHead = temp_v0_2 + 8;
        temp_v0_2->unk4 = 0xF0A4000;
        temp_v0_2->unk0 = 0xB900031D;
        temp_v0_3 = gDisplayListHead;
        gDisplayListHead = temp_v0_3 + 8;
        temp_v0_3->unk4 = 0xFFFCF279;
        temp_v0_3->unk0 = 0xFCFFFFFF;
        gDisplayListHead = func_80098C18(gDisplayListHead, temp_t1 + temp_t7, temp_a2, (temp_t1 - temp_t7) + 0x40, temp_a2 + 0x27, 1, 1, 1, 0xFF);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A90D4.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800A9208(); // extern
? func_800A9278(s32, s32); // extern

void func_800A91D8(s32 arg0, s32 arg2) {
    func_800A9208();
    func_800A9278(arg0, arg2);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A91D8.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void func_800A9208(void *arg0, s32 arg1) {
    s32 temp_v0;
    s32 temp_v0_2;
    s32 temp_v0_3;
    s32 temp_v1;
    s32 phi_v0;

    temp_v1 = arg0->unkC;
    temp_v0 = arg1 - temp_v1;
    phi_v0 = temp_v0;
    if (temp_v0 != 0) {
        if (temp_v0 > 0) {
            temp_v0_2 = (temp_v0 / 4) + 1;
            phi_v0 = temp_v0_2;
            if (temp_v0_2 >= 0x11) {
                phi_v0 = 0x10;
            }
        } else {
            temp_v0_3 = (temp_v0 / 4) - 1;
            phi_v0 = temp_v0_3;
            if (temp_v0_3 < -0x10) {
                phi_v0 = -0x10;
            }
        }
    }
    arg0->unkC = temp_v1 + phi_v0;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A9208.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void func_800A9278(void *arg0, s32 arg1) {
    s32 temp_v0;
    s32 temp_v0_2;
    s32 temp_v0_3;
    s32 temp_v1;
    s32 phi_v0;

    temp_v1 = arg0->unk10;
    temp_v0 = arg1 - temp_v1;
    phi_v0 = temp_v0;
    if (temp_v0 != 0) {
        if (temp_v0 > 0) {
            temp_v0_2 = (temp_v0 / 4) + 1;
            phi_v0 = temp_v0_2;
            if (temp_v0_2 >= 0x11) {
                phi_v0 = 0x10;
            }
        } else {
            temp_v0_3 = (temp_v0 / 4) - 1;
            phi_v0 = temp_v0_3;
            if (temp_v0_3 < -0x10) {
                phi_v0 = -0x10;
            }
        }
    }
    arg0->unk10 = temp_v1 + phi_v0;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A9278.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void func_800A92E8(void *arg0, s32 arg1) {
    s32 temp_t0;
    s32 temp_t7;
    s32 temp_v0;
    s32 temp_v0_2;
    s32 temp_v0_3;
    s32 temp_v1;
    s32 phi_v0;
    s32 phi_v0_2;
    s32 phi_v0_3;
    s32 phi_v0_4;

    temp_v1 = arg0->unkC;
    temp_v0 = arg1 - temp_v1;
    if (temp_v0 != 0) {
        if (temp_v0 > 0) {
            temp_v0_2 = (temp_v0 / 4) + 1;
            phi_v0 = temp_v0_2;
            if (temp_v0_2 >= 0x11) {
                phi_v0 = 0x10;
            }
            phi_v0_2 = phi_v0;
            if (phi_v0 < 8) {
                phi_v0_2 = 8;
            }
            temp_t7 = temp_v1 + phi_v0_2;
            arg0->unkC = temp_t7;
            if (arg1 < temp_t7) {
                arg0->unkC = arg1;
                return;
            }
            // Duplicate return node #14. Try simplifying control flow for better match
            return;
        }
        temp_v0_3 = (temp_v0 / 4) - 1;
        phi_v0_3 = temp_v0_3;
        if (temp_v0_3 < -0x10) {
            phi_v0_3 = -0x10;
        }
        phi_v0_4 = phi_v0_3;
        if (phi_v0_3 < -8) {
            phi_v0_4 = -8;
        }
        temp_t0 = temp_v1 + phi_v0_4;
        arg0->unkC = temp_t0;
        if (temp_t0 < arg1) {
            arg0->unkC = arg1;
        }
        // Duplicate return node #14. Try simplifying control flow for better match
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A92E8.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void func_800A940C(void *arg0, s32 arg1) {
    s32 temp_lo;
    s32 temp_t7;
    s32 temp_t9;
    s32 temp_v0;
    s32 temp_v1;
    s32 phi_v0;
    s32 phi_v0_2;
    s32 phi_v0_3;
    s32 phi_v0_4;

    temp_v1 = arg0->unkC;
    temp_v0 = arg1 - temp_v1;
    if (temp_v0 != 0) {
        temp_lo = 0xC8 / temp_v0;
        phi_v0 = temp_lo;
        phi_v0_3 = temp_lo;
        if (temp_lo > 0) {
            if (temp_lo >= 0x19) {
                phi_v0 = 0x18;
            }
            phi_v0_2 = phi_v0;
            if (phi_v0 < 0x10) {
                phi_v0_2 = 0x10;
            }
            temp_t7 = temp_v1 + phi_v0_2;
            arg0->unkC = temp_t7;
            if (arg1 < temp_t7) {
                arg0->unkC = arg1;
                return;
            }
            // Duplicate return node #14. Try simplifying control flow for better match
            return;
        }
        if (temp_lo < -0x18) {
            phi_v0_3 = -0x18;
        }
        phi_v0_4 = phi_v0_3;
        if (phi_v0_3 >= -0xF) {
            phi_v0_4 = -0x10;
        }
        temp_t9 = temp_v1 + phi_v0_4;
        arg0->unkC = temp_t9;
        if (temp_t9 < arg1) {
            arg0->unkC = arg1;
        }
        // Duplicate return node #14. Try simplifying control flow for better match
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A940C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void func_800A94C8(void *arg0, s32 arg1, s32 arg2) {
    s32 temp_v0;
    s32 temp_v1;
    s32 temp_v1_2;
    s32 temp_v1_3;
    s32 phi_v1;

    temp_v0 = arg0->unkC;
    temp_v1 = arg1 - temp_v0;
    phi_v1 = temp_v1;
    if (arg1 == temp_v0) {
        arg0->unkC = temp_v0 + arg2;
        return;
    }
    if (temp_v1 != 0) {
        if (temp_v1 > 0) {
            temp_v1_2 = (temp_v1 / 4) + 1;
            phi_v1 = temp_v1_2;
            if (temp_v1_2 >= 0x11) {
                phi_v1 = 0x10;
            }
        } else {
            temp_v1_3 = (temp_v1 / 4) - 1;
            phi_v1 = temp_v1_3;
            if (temp_v1_3 < -0x10) {
                phi_v1 = -0x10;
            }
        }
    }
    arg0->unkC = temp_v0 - phi_v1;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A94C8.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern f64 D_800F24C0;

void func_800A954C(void *arg0) {
    s32 temp_t3;

    if (arg0->unk4 == 0) {
        arg0->unk20 = (((0xC - arg0->unk1C) * 127.0f) / 12.0f) + 128.0f;
    } else {
        arg0->unk20 = ((arg0->unk1C * D_800F24C0) / 12.0) + 128.0;
    }
    temp_t3 = arg0->unk1C + 1;
    arg0->unk1C = temp_t3;
    if (temp_t3 >= 0xC) {
        arg0->unk1C = 0;
        arg0->unk4 = arg0->unk4 ^ 1;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A954C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
? func_8009A594(s32, ?, s32, void *);               /* extern */
static ? D_800E7D34;                                /* unable to generate initializer; const */

void func_800A9710(void *arg0) {
    s8 temp_t6;
    s32 phi_v0;

    temp_t6 = gPlayerCountSelection2;
    switch (temp_t6) {
    case 3:
    case 4:
        phi_v0 = 1;
        break;
    case 6:
    case 7:
        phi_v0 = 5;
        break;
    case 8:
        phi_v0 = 2;
        break;
    case 9:
        phi_v0 = 3;
        break;
    case 10:
        phi_v0 = 4;
        break;
    default:
        phi_v0 = 0;
        break;
    }
    if (phi_v0 != arg0->unk4) {
        arg0->unk4 = phi_v0;
        arg0 = arg0;
        func_8009A594(arg0->unk18, 0, segmented_to_virtual_dupe(*(&D_800E7D34 + (phi_v0 * 4)), MIPS2C_ERROR(Read from unset register $a1)), arg0);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A9710.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern ? D_800E86C4;
extern ? D_800E86C6;
extern ? D_800E86C7;
extern ? D_800E86C8;
extern ? D_800E86C9;
extern ? D_800E86CA;
extern ? D_800E86CB;
extern ? D_800E86CC;
extern s8 D_800E86D0;

void func_800A97BC(void *arg0) {
    s32 temp_t4;
    s32 temp_t7;
    s8 temp_v0;
    s8 temp_v0_2;
    s8 temp_v0_3;
    s8 temp_v0_4;
    s8 temp_v0_5;
    s8 temp_v0_6;
    s8 temp_v0_7;
    s8 temp_v0_8;
    s8 temp_v0_9;
    u32 temp_v1;
    u32 temp_v1_2;
    u32 phi_v1;
    u32 phi_v1_2;

    temp_v0 = D_800E86D0;
    if (temp_v0 != 1) {
        if (temp_v0 != 2) {
            D_800E86D0 = 0;
            return;
        }
        temp_t4 = arg0->unk10 + 2;
        arg0->unk10 = temp_t4;
        if (temp_t4 >= 0x73) {
            arg0->unk10 = 0x69;
            D_800E86D0 = 0;
            phi_v1 = &D_800E86CC;
            do {
                if (phi_v1 >= &D_800E86C6) {
                    phi_v1->unk0 = phi_v1->unk-1;
                } else {
                    temp_v0_2 = phi_v1->unk1;
                    if ((temp_v0_2 == 1) || (temp_v0_2 == 0)) {
                        phi_v1->unk0 = 0;
                    } else {
                        phi_v1->unk0 = temp_v0_2 - 1;
                    }
                }
                if (phi_v1 >= &D_800E86C7) {
                    phi_v1->unk-1 = phi_v1->unk-2;
                } else {
                    temp_v0_3 = phi_v1->unk0;
                    if ((temp_v0_3 == 1) || (temp_v0_3 == 0)) {
                        phi_v1->unk-1 = 0;
                    } else {
                        phi_v1->unk-1 = temp_v0_3 - 1;
                    }
                }
                if (phi_v1 >= &D_800E86C8) {
                    phi_v1->unk-2 = phi_v1->unk-3;
                } else {
                    temp_v0_4 = phi_v1->unk-1;
                    if ((temp_v0_4 == 1) || (temp_v0_4 == 0)) {
                        phi_v1->unk-2 = 0;
                    } else {
                        phi_v1->unk-2 = temp_v0_4 - 1;
                    }
                }
                if (phi_v1 >= &D_800E86C9) {
                    phi_v1->unk-3 = phi_v1->unk-4;
                } else {
                    temp_v0_5 = phi_v1->unk-2;
                    if ((temp_v0_5 == 1) || (temp_v0_5 == 0)) {
                        phi_v1->unk-3 = 0;
                    } else {
                        phi_v1->unk-3 = temp_v0_5 - 1;
                    }
                }
                temp_v1 = phi_v1 - 4;
                phi_v1 = temp_v1;
            } while (temp_v1 != &D_800E86C4);
            D_800E86C4.unk8 = 0;
            D_800E86C4.unk0 = D_800E86C4.unk8;
        }
        // Duplicate return node #59. Try simplifying control flow for better match
        return;
    }
    temp_t7 = arg0->unk10 - 2;
    arg0->unk10 = temp_t7;
    if (temp_t7 < 0x60) {
        arg0->unk10 = 0x69;
        D_800E86D0 = 0;
        phi_v1_2 = &D_800E86C4;
        do {
            if (phi_v1_2 < &D_800E86CB) {
                phi_v1_2->unk0 = phi_v1_2->unk1;
            } else {
                temp_v0_6 = phi_v1_2->unk-1;
                if ((temp_v0_6 == 0x10) || (temp_v0_6 == 0)) {
                    phi_v1_2->unk0 = 0;
                } else {
                    phi_v1_2->unk0 = temp_v0_6 + 1;
                }
            }
            if (phi_v1_2 < &D_800E86CA) {
                phi_v1_2->unk1 = phi_v1_2->unk2;
            } else {
                temp_v0_7 = phi_v1_2->unk0;
                if ((temp_v0_7 == 0x10) || (temp_v0_7 == 0)) {
                    phi_v1_2->unk1 = 0;
                } else {
                    phi_v1_2->unk1 = temp_v0_7 + 1;
                }
            }
            if (phi_v1_2 < &D_800E86C9) {
                phi_v1_2->unk2 = phi_v1_2->unk3;
            } else {
                temp_v0_8 = phi_v1_2->unk1;
                if ((temp_v0_8 == 0x10) || (temp_v0_8 == 0)) {
                    phi_v1_2->unk2 = 0;
                } else {
                    phi_v1_2->unk2 = temp_v0_8 + 1;
                }
            }
            if (phi_v1_2 < &D_800E86C8) {
                phi_v1_2->unk3 = phi_v1_2->unk4;
            } else {
                temp_v0_9 = phi_v1_2->unk2;
                if ((temp_v0_9 == 0x10) || (temp_v0_9 == 0)) {
                    phi_v1_2->unk3 = 0;
                } else {
                    phi_v1_2->unk3 = temp_v0_9 + 1;
                }
            }
            temp_v1_2 = phi_v1_2 + 4;
            phi_v1_2 = temp_v1_2;
        } while (temp_v1_2 != &D_800E86CC);
        D_800E86C4.unk8 = 0;
        D_800E86C4.unk0 = D_800E86C4.unk8;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A97BC.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern ? D_800F0C9C;
extern ? D_800F0CA7;
extern ? D_800F0CAB;
extern s8 D_8018EDEC;
extern s8 D_8018EDED;
extern s8 D_8018EDEE;

void func_800A9A98(void *arg0) {
    s32 temp_t2;
    s32 temp_t4;
    s32 temp_v0;
    s32 temp_v0_2;
    s32 temp_v0_3;
    s32 phi_v0;

    temp_v0 = arg0->unk0;
    if (temp_v0 != 0xF) {
        if (temp_v0 != 0x33) {
            if (temp_v0 != 0x5D) {
                phi_v0 = sp4;
            } else {
                phi_v0 = *(&D_800F0CAB + D_8018EDEC);
            }
        } else {
            phi_v0 = *(&D_800F0CA7 + D_8018EDEE);
        }
    } else {
        phi_v0 = *(&D_800F0C9C + 3 + D_8018EDED);
    }
    if (phi_v0 != 0) {
        if (phi_v0 != 1) {
            if (phi_v0 != 2) {
                if (phi_v0 != 3) {
                    return;
                }
                temp_v0_2 = arg0->unk1C;
                temp_t4 = temp_v0_2 + 2;
                if (temp_v0_2 < 0x20) {
                    arg0->unk1C = temp_t4;
                    if (temp_t4 >= 0x20) {
                        arg0->unk1C = 0x20;
                    }
                }
                // Duplicate return node #20. Try simplifying control flow for better match
                return;
            }
            temp_v0_3 = arg0->unk1C;
            if ((temp_v0_3 > 0) && (temp_t2 = (temp_v0_3 - (temp_v0_3 / 0xC)) - 2, arg0->unk1C = temp_t2, (temp_t2 < 0))) {
                arg0->unk1C = 0;
                return;
            }
            return;
        }
        arg0->unk1C = 0x20;
        return;
    }
    arg0->unk1C = 0;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A9A98.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
? func_800AA280();                                  /* extern */

void func_800A9B9C(void *arg0) {
    s32 temp_t0;
    s32 temp_v0;
    u32 temp_t6;

    temp_t6 = arg0->unk4;
    switch (temp_t6) {
    case 0:
        func_800AA280();
        return;
    case 1:
        func_800AA280();
        arg0->unk4 = 4;
        /* fallthrough */
    case 4:
        temp_v0 = arg0->unk1C;
        if (temp_v0 > 0) {
            temp_t0 = (temp_v0 - (temp_v0 / 12)) - 2;
            arg0->unk1C = temp_t0;
            if (temp_t0 < 0) {
                arg0->unk1C = 0;
                return;
            }
        default:
            return;
        }
        arg0->unk1C = 0;
        arg0->unk4 = 0;
        return;
    case 2:
        arg0->unk4 = 3;
        /* Duplicate return node #9. Try simplifying control flow for better match */
        return;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A9B9C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
? func_800AA280();                                  /* extern */

void func_800A9C40(void *arg0) {
    s32 temp_t7;
    s32 temp_v0_2;
    s8 temp_v0;
    u32 temp_t6;

    temp_t6 = arg0->unk4;
    switch (temp_t6) {
    case 0:
        func_800AA280();
        if (arg0->unk0 == (D_8018EDF3 + 0xA)) {
            arg0->unk4 = 2;
            return;
        }
        arg0->unk4 = 1;
        return;
    case 4:
        if (arg0->unk0 == (D_8018EDF3 + 0xA)) {
            arg0->unk4 = 2;
            arg0->unk1C = 0;
            return;
        }
        arg0->unk4 = 1;
    case 1:
        func_800AA280();
        temp_v0 = D_8018EDED;
        if ((temp_v0 == 7) || (temp_v0 == 8)) {
            arg0->unk1C = 0x20;
            return;
        }
        temp_v0_2 = arg0->unk1C;
        temp_t7 = temp_v0_2 + 2;
        if ((temp_v0_2 < 0x20) && (arg0->unk1C = temp_t7, ((temp_t7 < 0x20) == 0))) {
            arg0->unk1C = 0x20;
            return;
        }
    default:
        return;
    case 3:
        if (arg0->unk0 == (D_8018EDF3 + 0xA)) {
            arg0->unk4 = 2;
        }
        /* Duplicate return node #16. Try simplifying control flow for better match */
        return;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A9C40.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
? func_800A91D8(s16, s16);                          /* extern */
static ? D_800E70A0;                                /* unable to generate initializer; const */

void func_800A9D5C(void *arg0) {
    void *sp1C;
    s8 temp_v0;
    u32 temp_t1;
    void *temp_v0_2;

    if (arg0->unk0 == (D_8018EDF3 + 0xA)) {
        arg0->unk14 = 0xA;
    } else {
        arg0->unk14 = 6;
    }
    temp_t1 = arg0->unk4;
    switch (temp_t1) {
    case 2:
        temp_v0 = D_8018EDED;
        if ((temp_v0 == 7) || (temp_v0 == 8)) {
            arg0->unkC = 0x80;
            arg0->unk10 = 0x3E;
            return;
        }
        func_800A91D8(0x80, 0x3E);
        return;
    case 3:
        temp_v0_2 = (arg0->unk0 * 8) - 0x50 + &D_800E70A0;
        sp1C = temp_v0_2;
        func_800A91D8(temp_v0_2->unk0, temp_v0_2->unk2);
        if ((temp_v0_2->unk0 == arg0->unkC) && (temp_v0_2->unk2 == arg0->unk10)) {
            arg0->unk4 = 0;
        }
        /* fallthrough */
    default:
        return;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A9D5C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
? func_800A91D8(void *, s32, s32);                  /* extern */
? func_800A92E8(void *, s32);                       /* extern */
static ? D_800E70E8;                                /* unable to generate initializer; const */
static ? D_800E86AB;                                /* unable to generate initializer; const */
static ? D_800F2B70;                                /* unable to generate initializer; const */

void func_800A9E58(void *arg0) {
    void *sp2C;
    s16 *sp28;
    s32 sp24;
    s32 sp20;
    s32 sp1C;
    s16 *temp_v1_3;
    s32 temp_a1;
    s32 temp_a1_2;
    s32 temp_t2_2;
    s32 temp_t5_2;
    s32 temp_t6;
    s32 temp_v1;
    s8 temp_a2;
    s8 temp_t2;
    s8 temp_t5;
    s8 temp_t9;
    s8 temp_v0;
    void *temp_v0_2;
    void *temp_v0_3;
    void *temp_v0_4;
    void *temp_v0_5;
    void *temp_v1_2;
    void *temp_v1_4;
    s32 phi_a3;

    temp_t6 = arg0->unk0;
    switch (temp_t6) {                              /* switch 1 */
    case 18:                                        /* switch 1 */
    case 19:                                        /* switch 1 */
    case 20:                                        /* switch 1 */
    case 21:                                        /* switch 1 */
        sp24 = 0x12;
        sp1C = 2;
        sp20 = 0;
        break;
    case 22:                                        /* switch 1 */
    case 23:                                        /* switch 1 */
        sp24 = 0x16;
        sp1C = 2;
        phi_a3 = 2;
block_5:
        sp20 = phi_a3;
        break;
    case 24:                                        /* switch 1 */
    case 25:                                        /* switch 1 */
        sp24 = 0x18;
        sp1C = 1;
        phi_a3 = 1;
        goto block_5;
    }
    temp_v0 = D_8018EDF3;
    temp_v1 = arg0->unk4;
    temp_a2 = *(&D_800E86AB + temp_v0);
    temp_a1 = *(&D_800F2B70 + ((temp_v0 * 0xC) + (temp_a2 * 4)));
    if (temp_v1 != 0) {
        if (temp_v1 != 1) {
            if (temp_v1 != 2) {
                return;
            }
            temp_t9 = D_8018EDED;
            switch (temp_t9) {                      /* switch 4 */
                if ((temp_a1 != sp20) && (temp_a1 != sp1C)) {
                    arg0->unk15 = 0;
                    goto block_37;
                }
                if (arg0->unk20 != temp_a2) {
                    arg0->unk4 = 0;
                }
                temp_v0_2 = func_800AAE68(arg0, temp_a1, temp_a2);
                temp_v1_2 = (arg0->unk0 * 8) + -(sp24 * 8) + &D_800E70E8;
                temp_a1_2 = temp_v0_2->unkC + temp_v1_2->unk0;
                arg0->unkC = temp_a1_2;
                arg0->unk10 = temp_v0_2->unk10 + arg0->unk1C;
                sp2C = temp_v0_2;
                func_800A91D8(arg0, temp_a1_2, (*(&D_800E86AB + D_8018EDF3) * 0x12) + temp_v0_2->unk10 + temp_v1_2->unk2);
                arg0->unk1C = arg0->unk10 - sp2C->unk10;
                return;
            default:                                /* switch 4 */
                arg0->unk15 = 0;
                goto block_37;
            }
        } else {
            temp_t2 = D_8018EDED;
            switch (temp_t2) {                      /* switch 3 */
                if ((temp_a1 != sp20) && (temp_a1 != sp1C)) {
                    arg0->unk15 = 0;
block_37:
                    arg0->unk4 = 0;
                    /* Duplicate return node #38. Try simplifying control flow for better match */
                    return;
                }
                if (arg0->unk20 != temp_a2) {
                    arg0->unk4 = 0;
                }
                temp_v0_3 = func_800AAE68(arg0, temp_a1, temp_a2);
                arg0->unkC = temp_v0_3->unkC + arg0->unk1C;
                temp_v1_3 = (arg0->unk0 * 8) + -(sp24 * 8) + &D_800E70E8;
                sp2C = temp_v0_3;
                sp28 = temp_v1_3;
                func_800A92E8(arg0, temp_v0_3->unkC + *temp_v1_3);
                temp_t2_2 = arg0->unkC - sp2C->unkC;
                arg0->unk1C = temp_t2_2;
                if (*temp_v1_3 == temp_t2_2) {
                    arg0->unk4 = 2;
                    arg0->unk1C = arg0->unk10 - sp2C->unk10;
                    return;
                }
                return;
            default:                                /* switch 3 */
                arg0->unk15 = 0;
                goto block_37;
            }
        }
    } else {
        if ((temp_a1 != sp20) && (temp_a1 != sp1C)) {
            arg0->unk15 = 0;
            return;
        }
        arg0->unk20 = temp_a2;
        temp_t5 = D_8018EDED;
        switch (temp_t5) {                          /* switch 2 */
        case 4:                                     /* switch 2 */
        case 5:                                     /* switch 2 */
        case 6:                                     /* switch 2 */
            arg0->unk15 = 1;
            temp_v0_4 = func_800AAE68(arg0, temp_a1, temp_a2);
            arg0->unkC = temp_v0_4->unkC;
            arg0->unk1C = 0;
            arg0->unk4 = 1;
            arg0->unk10 = (*(&D_800E86AB + D_8018EDF3) * 0x12) + temp_v0_4->unk10 + 0x41;
            return;
        case 7:                                     /* switch 2 */
        case 8:                                     /* switch 2 */
            temp_v0_5 = func_800AAE68(arg0, temp_a1, temp_a2);
            temp_v1_4 = (arg0->unk0 * 8) + -(sp24 * 8) + &D_800E70E8;
            arg0->unkC = temp_v0_5->unkC + temp_v1_4->unk0;
            temp_t5_2 = (*(&D_800E86AB + D_8018EDF3) * 0x12) + temp_v0_5->unk10 + temp_v1_4->unk2;
            arg0->unk10 = temp_t5_2;
            arg0->unk1C = temp_t5_2 - temp_v0_5->unk10;
            arg0->unk15 = 1;
            arg0->unk4 = 2;
            return;
        default:                                    /* switch 2 */
            arg0->unk15 = 0;
            return;
        }
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800A9E58.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800A91D8(s16, s16); // extern
extern ? D_800E70A0;
extern s8 D_8018EDED;

void func_800AA280(void *arg0) {
    s8 temp_v1;
    void *temp_v0;

    temp_v1 = D_8018EDED;
    temp_v0 = (arg0->unk0 * 8) - 0x50 + &D_800E70A0;
    if ((temp_v1 == 7) || (temp_v1 == 8)) {
        arg0->unkC = temp_v0->unk0;
        arg0->unk10 = temp_v0->unk2;
        return;
    }
    func_800A91D8(temp_v0->unk0, temp_v0->unk2);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800AA280.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
s32 func_800B5B2C(?);                               /* extern */
s32 func_800CE720(? *, ? *, ?);                     /* extern */
s32 osPfsFindFile(? *, u16, s32, ? *, ? *, ? *);    /* extern */
s32 osPfsFreeBlocks(? *, s32 *);                    /* extern */
s32 osPfsNumFiles(? *, s32 *, s32 *);               /* extern */
extern ? D_8018E868;
extern ? D_8018EB84;
extern ? gSIEventMesgQueue;
static ? D_800E86AB;                                /* unable to generate initializer; const */
static ? D_800F2E64;                                /* unable to generate initializer; const */
static ? D_800F2E74;                                /* unable to generate initializer; const */
u16 D_800E86F0;                                     /* unable to generate initializer; const */

void func_800AA2EC(void *arg0) {
    s32 sp20;
    s32 temp_v0_2;
    s32 temp_v0_3;
    s8 temp_t6;
    s8 temp_v0;
    s32 phi_t1;

    temp_t6 = D_8018EDED;
    phi_t1 = 0;
    switch (temp_t6) {
    case 1:
    case 2:
    case 3:
    case 4:
        arg0->unk4 = 0;
        return;
    case 5:
    case 6:
    case 7:
    case 8:
        if ((arg0->unk4 == 0) && (temp_v0 = D_8018EDF3, (temp_v0 == 1)) && (*(&D_800E86AB + temp_v0) == 1)) {
            if (D_800E86F8 != 0) {
                sp20 = 0;
                temp_v0_2 = osPfsFindFile(&D_8018E868, D_800E86F0, D_800E86F4, &D_800F2E64, &D_800F2E74, &D_8018EB84);
                if (temp_v0_2 != 0) {
                    if (temp_v0_2 != 2) {
                        if (temp_v0_2 != 5) {
                            goto block_12;
                        }
                    } else {
block_12:
                        D_800E86F8 = 0;
                    }
                } else {
                    arg0->unk4 = 1;
                    phi_t1 = 1;
                }
            }
            if (phi_t1 == 0) {
                if (D_800E86F8 == 0) {
                    if (func_800B5B2C(0) == 0) {
                        arg0->unk4 = 2;
                        return;
                    }
                    temp_v0_3 = func_800CE720(&gSIEventMesgQueue, &D_8018E868, 0);
                    if (temp_v0_3 != 0) {
                        if (temp_v0_3 != 1) {
                            if (temp_v0_3 != 4) {
                                if (temp_v0_3 != 0xA) {
                                    if (temp_v0_3 == 0xB) {
                                        goto block_22;
                                    }
                                    goto block_24;
                                }
                                arg0->unk4 = 3;
                                return;
                            }
block_24:
                            arg0->unk4 = 3;
                            return;
                        }
block_22:
                        arg0->unk4 = 2;
                        return;
                    }
                    D_800E86F8 = 1;
                    if (osPfsFindFile(&D_8018E868, D_800E86F0, D_800E86F4, &D_800F2E64, &D_800F2E74, &D_8018EB84) == 0) {
                        arg0->unk4 = 1;
                        return;
                    }
                    if (osPfsNumFiles(&D_8018E868, &D_8018EB78, &D_8018EB7C) != 0) {
                        arg0->unk4 = 3;
                        return;
                    }
                    if (osPfsFreeBlocks(&D_8018E868, &D_8018EB80) != 0) {
                        arg0->unk4 = 3;
                        return;
                    }
                    D_8018EB80 = D_8018EB80 >> 8;
                    goto block_32;
                }
block_32:
                if (D_8018EB7C >= D_8018EB78) {
                    arg0->unk4 = 5;
                    return;
                }
                if (D_8018EB80 >= 0x79) {
                    arg0->unk4 = 1;
                    return;
                }
                arg0->unk4 = 5;
                /* Duplicate return node #37. Try simplifying control flow for better match */
                return;
            }
            /* Duplicate return node #37. Try simplifying control flow for better match */
            return;
        }
    default:
        return;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800AA2EC.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
? func_8009A594(s32, s32, s32, s32 *);              /* extern */
s32 random_int(?, s32);                             /* extern */
extern ? D_8018DEE4;
extern ? D_8018EDE8;
static ? D_800E8360;                                /* unable to generate initializer; const */
static ? D_800E8380;                                /* unable to generate initializer; const */
static ? D_800E83A0;                                /* unable to generate initializer; const */
static ? D_800E83C0;                                /* unable to generate initializer; const */
static ? D_800E83E0;                                /* unable to generate initializer; const */
static ? D_800E8400;                                /* unable to generate initializer; const */
static ? D_800E8440;                                /* unable to generate initializer; const */
static ? D_800E8460;                                /* unable to generate initializer; const */
static ? D_800E8480;                                /* unable to generate initializer; const */
static ? D_800E84A0;                                /* unable to generate initializer; const */

void func_800AA69C(void *arg0) {
    s32 sp30;
    s32 sp24;
    s32 *sp20;
    s32 *temp_a3;
    s32 temp_a0;
    s32 temp_a0_2;
    s32 temp_a0_3;
    s32 temp_a1;
    s32 temp_v0;
    s32 temp_v0_2;
    s32 temp_v1_2;
    s32 temp_v1_3;
    s32 temp_v1_4;
    s32 temp_v1_5;
    u32 temp_v1;
    s32 phi_a0;
    s32 phi_v0;
    s32 phi_v1;

    temp_a0 = arg0->unk0 - 0x2B;
    sp30 = temp_a0;
    temp_v0 = func_800AAFCC(temp_a0);
    temp_a1 = sp30;
    if (temp_v0 >= 0) {
        phi_a0 = 1;
    } else {
        phi_a0 = 0;
    }
    temp_v1 = arg0->unk8;
    switch (temp_v1) {
    case 0:
        if ((*(&D_8018EDE8 + temp_v0) != 0) && (phi_a0 != 0)) {
            arg0->unk8 = 1;
            func_8009A594(arg0->unk18, 0, segmented_to_virtual_dupe(*(&D_800E8380 + (temp_a1 * 4)), temp_a1));
            return;
        }
        sp30 = temp_a1;
        temp_v0_2 = random_int(0xC8, temp_a1);
        if (temp_v0_2 >= 0xC6) {
            arg0->unk8 = 4;
            func_8009A594(arg0->unk18, 0, segmented_to_virtual_dupe(*(&D_800E83E0 + (temp_a1 * 4)), temp_a1));
            return;
        }
        if (temp_v0_2 >= 0xC5) {
            arg0->unk8 = 5;
            func_8009A594(arg0->unk18, 0, segmented_to_virtual_dupe(*(&D_800E8400 + (temp_a1 * 4)), temp_a1));
            return;
        }
    default:
        return;
    case 1:
        temp_v1_2 = temp_a1 * 4;
        if (*(&D_8018DEE4 + (arg0->unk18 * 0x18)) >= *(&D_800E8440 + temp_v1_2)) {
            arg0->unk8 = 2;
            func_8009A594(arg0->unk18, 0, segmented_to_virtual_dupe(*(&D_800E83A0 + temp_v1_2), temp_a1));
            return;
        }
        if ((*(&D_8018EDE8 + temp_v0) == 0) && (phi_a0 != 0)) {
            arg0->unk8 = 3;
            sp24 = temp_v1_2;
            temp_a0_2 = arg0->unk18;
            func_8009A594(temp_a0_2, *(&D_800E8460 + temp_v1_2) - *(&D_8018DEE4 + (temp_a0_2 * 0x18)), segmented_to_virtual_dupe(*(&D_800E83C0 + temp_v1_2), temp_a1));
            return;
        }
        /* Duplicate return node #33. Try simplifying control flow for better match */
        return;
    case 2:
        if ((*(&D_8018EDE8 + temp_v0) == 0) && (phi_a0 != 0)) {
            arg0->unk8 = 3;
            func_8009A594(arg0->unk18, 0, segmented_to_virtual_dupe(*(&D_800E83C0 + (temp_a1 * 4)), temp_a1));
            return;
        }
        /* Duplicate return node #33. Try simplifying control flow for better match */
        return;
    case 3:
        temp_v1_3 = temp_a1 * 4;
        temp_a3 = temp_v1_3 + &D_800E8460;
        if (*(&D_8018DEE4 + (arg0->unk18 * 0x18)) >= *temp_a3) {
            arg0->unk8 = 0;
            func_8009A594(arg0->unk18, 0, segmented_to_virtual_dupe(*(&D_800E8360 + temp_v1_3), temp_a1));
            return;
        }
        if ((*(&D_8018EDE8 + temp_v0) != 0) && (phi_a0 != 0)) {
            arg0->unk8 = 1;
            sp20 = temp_a3;
            temp_a0_3 = arg0->unk18;
            func_8009A594(temp_a0_3, *temp_a3 - *(&D_8018DEE4 + (temp_a0_3 * 0x18)), segmented_to_virtual_dupe(*(&D_800E8380 + temp_v1_3), temp_a1), temp_a3);
            return;
        }
        /* Duplicate return node #33. Try simplifying control flow for better match */
        return;
    case 4:
    case 5:
        if ((*(&D_8018EDE8 + temp_v0) != 0) && (phi_a0 != 0)) {
            arg0->unk8 = 1;
            func_8009A594(arg0->unk18, 0, segmented_to_virtual_dupe(*(&D_800E8380 + (temp_a1 * 4)), temp_a1));
            return;
        }
        if (temp_v1 == 4) {
            temp_v1_4 = temp_a1 * 4;
            phi_v0 = *(&D_800E8480 + temp_v1_4);
            phi_v1 = temp_v1_4;
        } else {
            temp_v1_5 = temp_a1 * 4;
            phi_v0 = *(&D_800E84A0 + temp_v1_5);
            phi_v1 = temp_v1_5;
        }
        if (*(&D_8018DEE4 + (arg0->unk18 * 0x18)) >= phi_v0) {
            arg0->unk8 = 0;
            func_8009A594(arg0->unk18, 0, segmented_to_virtual_dupe(*(&D_800E8360 + phi_v1), temp_a1));
        }
        /* Duplicate return node #33. Try simplifying control flow for better match */
        return;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800AA69C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
void func_800AAA9C(s32 *arg0) {
    s32 *temp_a1;
    s32 temp_a0;
    s32 temp_t2;
    s32 temp_v0;
    u32 temp_t6;

    temp_t6 = arg0->unk4;
    temp_a1 = arg0;
    switch (temp_t6) {
    case 3:
        temp_a1->unk4 = 1;
        /* fallthrough */
    case 1:
        if (D_8018EDEE == 3) {
            temp_a1->unk1C = 0x20;
        } else {
            temp_v0 = temp_a1->unk1C;
            if (temp_v0 < 0x20) {
                temp_t2 = temp_v0 + (temp_v0 / 12) + 2;
                temp_a1->unk1C = temp_t2;
                if (temp_t2 >= 0x20) {
                    temp_a1->unk1C = 0x20;
                }
            }
        }
        /* fallthrough */
    case 0:
        temp_a0 = temp_a1->unk0;
        arg0 = temp_a1;
        if (func_800AAFCC(temp_a0 - 0x2B, temp_a1) >= 0) {
            arg0->unk4 = 2;
block_13:
            arg0->unk1C = 0;
        default:
            return;
        }
        arg0->unk4 = 1;
        return;
    case 4:
        arg0 = temp_a1;
        if (func_800AAFCC(temp_a1->unk0 - 0x2B, temp_a1) >= 0) {
            arg0->unk4 = 2;
            goto block_13;
        }
        /* Duplicate return node #14. Try simplifying control flow for better match */
        return;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800AAA9C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
void func_800AAB90(void *arg0) {
    s32 temp_t2;
    s32 temp_v0;
    u32 temp_t6;

    temp_t6 = arg0->unk4;
    switch (temp_t6) {
    case 1:
        if (arg0->unk1C > 0) {
            arg0->unk4 = 3;
            return;
        }
    default:
        return;
    case 2:
        arg0->unk4 = 4;
        return;
    case 3:
        temp_v0 = arg0->unk1C;
        if (temp_v0 > 0) {
            temp_t2 = (temp_v0 - (temp_v0 / 12)) - 2;
            arg0->unk1C = temp_t2;
            if (temp_t2 < 0) {
                arg0->unk1C = 0;
                return;
            }
            /* Duplicate return node #9. Try simplifying control flow for better match */
            return;
        }
        arg0->unk1C = 0;
        arg0->unk4 = 0;
        /* Duplicate return node #9. Try simplifying control flow for better match */
        return;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800AAB90.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
? func_8009A594(s32, ?, s32, void *);               /* extern */
? func_800A91D8(void *, s16, s16, void *);          /* extern */
static ? D_800E7108;                                /* unable to generate initializer; const */
static ? D_800E7188;                                /* unable to generate initializer; const */
static ? D_800E8340;                                /* unable to generate initializer; const */

void func_800AAC18(void *arg0) {
    s32 sp24;
    void *sp18;
    s32 temp_a0;
    s32 temp_a1;
    s32 temp_v0;
    s32 temp_v0_3;
    u32 temp_v1;
    void *temp_a3;
    void *temp_a3_2;
    void *temp_t0;
    void *temp_v0_2;
    void *temp_v0_4;
    u32 phi_v1;
    void *phi_a3;
    void *phi_t0;

    temp_v1 = arg0->unk4;
    temp_a3 = arg0;
    temp_a1 = arg0->unk0 - 0x2B;
    phi_v1 = temp_v1;
    phi_a3 = temp_a3;
    switch (temp_v1) {
    case 0:
        temp_a0 = temp_a1;
        if (D_8018EDEE == 3) {
            sp24 = temp_a1;
            arg0 = temp_a3;
            temp_v0 = func_800AAFCC(temp_a0, temp_a1, MIPS2C_ERROR(Read from unset register $a2), temp_a3);
            temp_a3_2 = arg0;
            if (temp_v0 >= 0) {
                temp_t0 = (D_800DC530 << 5) + (temp_v0 * 8) + &D_800E7188;
                temp_a3_2->unkC = temp_t0->unk0;
                temp_a3_2->unk4 = 2;
                temp_a3_2->unk8 = 2;
                temp_a3_2->unk10 = temp_t0->unk2;
                arg0 = temp_a3_2;
                func_8009A594(arg0->unk18, 0, segmented_to_virtual_dupe(*(&D_800E8340 + (temp_a1 * 4)), temp_a1, 2, temp_a3_2), arg0);
                return;
            }
        default:
            return;
        }
    case 1:
    case 3:
        temp_v0_2 = (temp_a1 * 8) + &D_800E7108;
        temp_a3->unkC = temp_v0_2->unk0;
        temp_a3->unk10 = temp_v0_2->unk2;
        return;
    case 2:
    case 4:
        if (temp_v1 == 2) {
            arg0 = temp_a3;
            temp_v0_3 = func_800AAFCC(temp_a1, temp_a1, 2, temp_a3);
            phi_a3 = arg0;
            if (temp_v0_3 >= 0) {
                sp18 = (D_800DC530 << 5) + (temp_v0_3 * 8) + &D_800E7188;
            }
            phi_v1 = arg0->unk4;
            phi_t0 = sp18;
            goto block_13;
        }
        temp_v0_4 = (temp_a1 * 8) + &D_800E7108;
        phi_t0 = temp_v0_4;
        if ((temp_a3->unkC == temp_v0_4->unk0) && (temp_a3->unk10 == temp_v0_4->unk2)) {
            temp_a3->unk4 = 0;
            return;
        }
block_13:
        if ((phi_v1 != 2) || (phi_a3->unk8 != 1)) {
            func_800A91D8(phi_a3, phi_t0->unk0, phi_t0->unk2, phi_a3);
        }
        /* Duplicate return node #16. Try simplifying control flow for better match */
        return;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800AAC18.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800AAF94(s32); // extern
extern ? gCharacterSelections;

void func_800AADD4(void *arg0) {
    s32 temp_v0;

    temp_v0 = arg0->unk0 - 0x34;
    arg0->unk14 = 0xE - (temp_v0 * 2);
    func_800AAF94(*(&gCharacterSelections + temp_v0) - 1);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800AADD4.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 func_800AAFCC(s32, void *); // extern

void func_800AAE18(void *arg0) {
    s32 temp_a0;
    s32 temp_v0;
    void *temp_a1;

    temp_a1 = arg0;
    temp_a0 = arg0->unk0;
    arg0 = temp_a1;
    temp_v0 = func_800AAFCC(temp_a0 - 0x2B, temp_a1);
    if (temp_v0 >= 0) {
        arg0->unk14 = 0xE - (temp_v0 * 2);
        return;
    }
    arg0->unk14 = 6;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800AAE18.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern s32 D_8018D9E0;
extern ? D_8018DEE0;

s32 *func_800AAE68(void) {
    s32 *temp_v1;
    s32 *phi_v1;

    phi_v1 = &D_8018D9E0;
loop_1:
    if ((D_8018EDF3 - 1 + 0xB) != *phi_v1) {
        temp_v1 = phi_v1 + 0x28;
        phi_v1 = temp_v1;
        if (&D_8018DEE0 < temp_v1) {
loop_3:
            goto loop_3;
        }
        goto loop_1;
    }
    return phi_v1;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800AAE68.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern s32 D_8018D9E0;
extern ? D_8018DEE0;

s32 *func_800AAEB4(s32 arg0) {
    s32 *temp_v1;
    s32 *phi_v1;

    phi_v1 = &D_8018D9E0;
loop_1:
    if ((arg0 + 0x2B) != *phi_v1) {
        temp_v1 = phi_v1 + 0x28;
        phi_v1 = temp_v1;
        if (&D_8018DEE0 < temp_v1) {
loop_3:
            goto loop_3;
        }
        goto loop_1;
    }
    return phi_v1;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800AAEB4.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern s32 D_8018D9E0;
extern ? D_8018DEE0;

s32 *func_800AAEF4(s32 arg0) {
    s32 *temp_v1;
    s32 *phi_v1;

    phi_v1 = &D_8018D9E0;
loop_1:
    if (arg0 != *phi_v1) {
        temp_v1 = phi_v1 + 0x28;
        phi_v1 = temp_v1;
        if (&D_8018DEE0 < temp_v1) {
loop_3:
            goto loop_3;
        }
        goto loop_1;
    }
    return phi_v1;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800AAEF4.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern s32 D_8018D9E0;
extern ? D_8018DEE0;

s32 *func_800AAF30(s32 arg0) {
    s32 *temp_v1;
    s32 *phi_v1;

    phi_v1 = &D_8018D9E0;
loop_1:
    if (arg0 != *phi_v1) {
        temp_v1 = phi_v1 + 0x28;
        phi_v1 = temp_v1;
        if (&D_8018DEE0 < temp_v1) {
            return NULL;
        }
        goto loop_1;
    }
    return phi_v1;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800AAF30.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void *func_800AAEB4(?); // extern

void func_800AAF94(void *arg0, ? arg1) {
    void *temp_v0;

    temp_v0 = func_800AAEB4(arg1);
    arg0->unkC = temp_v0->unkC;
    arg0->unk10 = temp_v0->unk10;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800AAF94.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern s8 gCharacterSelections;

s32 func_800AAFCC(s32 arg0) {
    s32 temp_v1;
    s8 *phi_a2;
    s32 phi_v1;
    s32 phi_v0;
    s32 phi_v1_2;

    phi_a2 = &gCharacterSelections;
    phi_v1 = 0;
    phi_v0 = 0;
loop_1:
    phi_v1_2 = phi_v1;
    if ((arg0 + 1) == *phi_a2) {
        phi_v0 = 1;
    } else {
        temp_v1 = phi_v1 + 1;
        phi_a2 += 1;
        phi_v1 = temp_v1;
        phi_v1_2 = temp_v1;
        if (temp_v1 != 4) {
            goto loop_1;
        }
    }
    if (phi_v0 != 0) {
        return phi_v1_2;
    }
    return -1;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800AAFCC.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
void func_800AB020(void *arg0) {
    s32 temp_t0;
    s32 temp_v0;
    u32 temp_t6;

    temp_t6 = arg0->unk4;
    switch (temp_t6) {
    case 1:
        arg0->unk4 = 4;
        /* fallthrough */
    case 4:
        temp_v0 = arg0->unk1C;
        if (temp_v0 > 0) {
            temp_t0 = (temp_v0 - (temp_v0 / 12)) - 2;
            arg0->unk1C = temp_t0;
            if (temp_t0 < 0) {
                arg0->unk1C = 0;
                return;
            }
        default:
            return;
        }
        arg0->unk1C = 0;
        arg0->unk4 = 0;
        return;
    case 2:
        arg0->unk4 = 3;
        /* Duplicate return node #8. Try simplifying control flow for better match */
        return;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800AB020.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
void func_800AB098(void *arg0) {
    s32 temp_t8;
    s32 temp_v0;
    u32 temp_t6;

    temp_t6 = arg0->unk4;
    switch (temp_t6) {
    case 0:
        if (arg0->unk0 == (gCupSelection + 0x53)) {
            arg0->unk4 = 2;
            return;
        }
        arg0->unk4 = 1;
        return;
    case 4:
        if (arg0->unk0 == (gCupSelection + 0x53)) {
            arg0->unk4 = 2;
            arg0->unk1C = 0;
            return;
        }
        arg0->unk4 = 1;
    case 1:
        temp_v0 = arg0->unk1C;
        temp_t8 = temp_v0 + 2;
        if ((temp_v0 < 0x20) && (arg0->unk1C = temp_t8, ((temp_t8 < 0x20) == 0))) {
            arg0->unk1C = 0x20;
            return;
        }
    default:
        return;
    case 3:
        if (arg0->unk0 == (gCupSelection + 0x53)) {
            arg0->unk4 = 2;
        }
        /* Duplicate return node #13. Try simplifying control flow for better match */
        return;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800AB098.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
? func_800A91D8(s16, s16);                          /* extern */
static ? D_800E7148;                                /* unable to generate initializer; const */

void func_800AB164(void *arg0) {
    void *sp1C;
    u32 temp_t1;
    void *temp_v0;
    void *temp_v0_2;

    if (arg0->unk0 == (gCupSelection + 0x53)) {
        arg0->unk14 = 0xA;
    } else {
        arg0->unk14 = 4;
    }
    temp_t1 = arg0->unk4;
    switch (temp_t1) {
    case 0:
        temp_v0 = (arg0->unk0 * 8) - 0x298 + &D_800E7148;
        arg0->unkC = temp_v0->unk0;
        arg0->unk10 = temp_v0->unk2;
        return;
    case 2:
        func_800A91D8(0x80, 0x3B);
        return;
    case 3:
        temp_v0_2 = (arg0->unk0 * 8) - 0x298 + &D_800E7148;
        sp1C = temp_v0_2;
        func_800A91D8(temp_v0_2->unk0, temp_v0_2->unk2);
        if ((temp_v0_2->unk0 == arg0->unkC) && (temp_v0_2->unk2 == arg0->unk10)) {
            arg0->unk4 = 0;
        }
        /* fallthrough */
    default:
        return;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800AB164.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern s8 gCupSelection;

void func_800AB260(void *arg0) {
    if ((arg0->unk0 - 0x58) == gCupSelection) {
        arg0->unk15 = 1;
        return;
    }
    arg0->unk15 = 0;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800AB260.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_8009A594(s32, ?, s32, void *); // extern
s32 segmented_to_virtual_dupe(s32, void *); // extern
extern ? D_800E7E34;
extern s8 gCupSelection;
extern ? gCupCourseOrder;

void func_800AB290(void *arg0) {
    s16 temp_t2;
    s8 temp_v0;
    void *temp_a3;

    temp_v0 = gCupSelection;
    temp_a3 = arg0;
    if (temp_v0 != arg0->unk1C) {
        arg0->unk1C = temp_v0;
        temp_t2 = *(&gCupCourseOrder - 0xBE + ((gCupSelection * 8) + (arg0->unk0 * 2)));
        arg0 = temp_a3;
        func_8009A594(arg0->unk18, 0, segmented_to_virtual_dupe(*(&D_800E7E34 + (temp_t2 * 4)), temp_a3), arg0);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800AB290.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 func_800AAEF4(s32, s32, void *); // extern
extern s8 D_8018EDEC;
extern s8 gCupSelection;

void func_800AB314(void *arg0) {
    s32 sp3C;
    void *sp24;
    void **sp1C;
    s32 temp_a1;
    s32 temp_a1_2;
    s32 temp_t2;
    s32 temp_t5;
    s32 temp_t7;
    s32 temp_v0;
    void **temp_v1;
    void **phi_v1;
    s32 phi_a1;
    s32 phi_v0;
    s8 phi_a0;
    s32 phi_a1_2;
    void **phi_v1_2;

    phi_v1 = &sp24;
    phi_a1 = 0;
    phi_a1_2 = 0;
    do {
        sp1C = phi_v1;
        sp3C = phi_a1;
        arg0 = arg0;
        temp_a1 = phi_a1 + 1;
        temp_v1 = phi_v1 + 4;
        temp_v1->unk-4 = func_800AAEF4(phi_a1 + 0x5F, phi_a1, arg0);
        phi_v1 = temp_v1;
        phi_a1 = temp_a1;
    } while (temp_a1 < 4);
    if (gModeSelection != GRAND_PRIX) {
        if (D_8018EDEC != 1) {
            arg0->unk4 = 0;
            arg0->unk20 = 0;
            if (gCupCourseSelection == CUP_COURSE_ONE) {
                sp24->unk15 = 1;
                if (arg0->unk1C != 0) {
                    arg0->unk1C = 0;
                }
            } else {
                sp24->unk15 = 0;
            }
            if (gCupCourseSelection == CUP_COURSE_TWO) {
                sp28->unk15 = 1;
                if (arg0->unk1C != 1) {
                    arg0->unk1C = 1;
                }
            } else {
                sp28->unk15 = 0;
            }
            if (gCupCourseSelection == CUP_COURSE_THREE) {
                sp2C->unk15 = 1;
                if (arg0->unk1C != 2) {
                    arg0->unk1C = 2;
                }
            } else {
                sp2C->unk15 = 0;
            }
            if (gCupCourseSelection == CUP_COURSE_FOUR) {
                sp30->unk15 = 1;
                if (arg0->unk1C != 3) {
                    arg0->unk1C = 3;
                    return;
                }
                // Duplicate return node #80. Try simplifying control flow for better match
                return;
            }
            sp30->unk15 = 0;
            return;
        }
        arg0->unk4 = 3;
        sp24->unk15 = 1;
        sp24->unk14 = 6;
        sp28->unk15 = 1;
        sp28->unk14 = 6;
        sp2C->unk15 = 1;
        sp2C->unk14 = 6;
        sp30->unk15 = 1;
        sp30->unk14 = 6;
        return;
    }
    temp_v0 = arg0->unk4;
    phi_v0 = temp_v0;
    phi_a0 = 1;
    if (temp_v0 != 0) {
        if (temp_v0 != 1) {
            if (temp_v0 != 2) {
                if (temp_v0 != 3) {

                } else if (D_8018EDEC != 3) {
                    arg0->unk4 = 0;
                    arg0->unk20 = 0;
                    arg0->unk1C = 0;
                    phi_v0 = 0;
                }
            } else {
                temp_t7 = arg0->unk20 + 1;
                arg0->unk20 = temp_t7;
                if (temp_t7 >= 0x1A) {
                    arg0->unk4 = 3;
                    arg0->unk20 = 0;
                }
                if (D_8018EDEC != 3) {
                    arg0->unk4 = 0;
                    arg0->unk20 = 0;
                    arg0->unk1C = 0;
                }
                phi_v0 = arg0->unk4;
            }
        } else if ((arg0->unk1C / 4) != gCupSelection) {
            arg0->unk4 = 0;
            arg0->unk20 = 0;
            arg0->unk1C = 0;
            phi_v0 = 0;
        } else {
            temp_t2 = arg0->unk20 + 1;
            arg0->unk20 = temp_t2;
            if (temp_t2 >= 0x1F) {
                arg0->unk20 = 0;
                arg0->unk1C = (gCupSelection * 4) + (((arg0->unk1C % 4) + 1) % 4);
                phi_v0 = arg0->unk4;
            } else {
                if (D_8018EDEC == 3) {
                    arg0->unk4 = 2;
                    arg0->unk20 = 0;
                }
                phi_v0 = arg0->unk4;
            }
        }
    } else {
        if ((arg0->unk1C / 4) == gCupSelection) {
            temp_t5 = arg0->unk20 + 1;
            arg0->unk20 = temp_t5;
            if (temp_t5 >= 0x33) {
                arg0->unk4 = 1;
                arg0->unk20 = 0;
                arg0->unk1C = (gCupSelection * 4) + 1;
            }
        } else {
            arg0->unk20 = 0;
            arg0->unk1C = gCupSelection * 4;
        }
        phi_a0 = 1;
        if (D_8018EDEC == 3) {
            arg0->unk4 = 2;
            arg0->unk20 = 0;
        }
        phi_v0 = arg0->unk4;
    }
    if ((phi_v0 != 0) && (phi_v0 != phi_a0)) {
        if (phi_v0 != 2) {
            if (phi_v0 != 3) {
                return;
            }
            sp24->unk15 = phi_a0;
            sp24->unk14 = 6;
            sp28->unk15 = phi_a0;
            sp28->unk14 = 6;
            sp2C->unk15 = phi_a0;
            sp2C->unk14 = 6;
            sp30->unk15 = phi_a0;
            sp30->unk14 = 6;
            return;
        }
        phi_v1_2 = &sp24;
        do {
            if (phi_a1_2 == (arg0->unk1C % 4)) {
                phi_v1_2->unk0->unk14 = 6;
            } else if (arg0->unk20 < (phi_a1_2 * 5)) {
                phi_v1_2->unk0->unk14 = 4;
            } else {
                phi_v1_2->unk0->unk14 = 8;
            }
            phi_v1_2->unk0->unk15 = phi_a0;
            if ((phi_a1_2 + 1) == (arg0->unk1C % 4)) {
                phi_v1_2->unk4->unk14 = 6;
            } else if (arg0->unk20 < ((phi_a1_2 * 5) + 5)) {
                phi_v1_2->unk4->unk14 = 4;
            } else {
                phi_v1_2->unk4->unk14 = 8;
            }
            temp_a1_2 = phi_a1_2 + 2;
            phi_v1_2->unk4->unk15 = phi_a0;
            phi_a1_2 = temp_a1_2;
            phi_v1_2 += 8;
        } while (temp_a1_2 != 4);
        return;
    }
    if ((arg0->unk1C & 3) == 0) {
        sp24->unk15 = phi_a0;
    } else {
        sp24->unk15 = 0;
    }
    sp24->unk14 = 6;
    if ((arg0->unk1C % 4) == 1) {
        sp28->unk15 = phi_a0;
    } else {
        sp28->unk15 = 0;
    }
    sp28->unk14 = 6;
    if ((arg0->unk1C % 4) == 2) {
        sp2C->unk15 = phi_a0;
    } else {
        sp2C->unk15 = 0;
    }
    sp2C->unk14 = 6;
    if ((arg0->unk1C % 4) == 3) {
        sp30->unk15 = phi_a0;
    } else {
        sp30->unk15 = 0;
    }
    sp30->unk14 = 6;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800AB314.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800A9208(s16); // extern
extern ? D_800E7248;
extern ? D_800E7258;
extern s8 D_8018EDEC;

void func_800AB904(void *arg0) {
    s16 temp_a1;
    s16 temp_a1_2;
    s8 temp_v0;

    temp_v0 = D_8018EDEC;
    if (temp_v0 != 1) {
        if ((temp_v0 != 2) && (temp_v0 != 3)) {
            return;
        }
        temp_a1 = *((arg0->unk0 * 8) - 0x328 + &D_800E7258);
        if (temp_a1 != arg0->unkC) {
            func_800A9208(temp_a1);
        }
        // Duplicate return node #8. Try simplifying control flow for better match
        return;
    }
    temp_a1_2 = *((arg0->unk0 * 8) - 0x328 + &D_800E7248);
    if (temp_a1_2 != arg0->unkC) {
        func_800A9208(temp_a1_2);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800AB904.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_8009A594(s32, ?, s32); // extern
? func_800A91D8(void *, s16, s16); // extern
s32 func_800B54C0(s8, s32); // extern
s32 segmented_to_virtual_dupe(s32); // extern
extern ? D_800E7268;
extern ? D_800E7E20;
extern s8 D_8018EDEC;
extern s8 gCupSelection;

void func_800AB9B0(void *arg0) {
    s32 temp_v0_2;
    s32 temp_v0_3;
    s8 temp_v0;
    void *temp_v1;

    temp_v0 = gCupSelection;
    if (temp_v0 != arg0->unk1C) {
        arg0->unk1C = temp_v0;
        temp_v0_2 = func_800B54C0(gCupSelection, gCCSelection);
        arg0->unk20 = temp_v0_2;
        func_8009A594(arg0->unk18, 0, segmented_to_virtual_dupe(*(&D_800E7E20 + (((gCCSelection / 2) * 0x10) + -(temp_v0_2 * 4)))));
        arg0->unkC = D_800E7268.unk0;
        arg0->unk10 = D_800E7268.unk2;
    }
    temp_v0_3 = arg0->unk4;
    temp_v1 = &D_800E7268 + (temp_v0_3 * 8);
    if (temp_v0_3 != 0) {
        if (temp_v0_3 != 1) {
            return;
        }
        func_800A91D8(arg0, temp_v1->unk0, temp_v1->unk2);
        if (D_8018EDEC == 1) {
            arg0->unk4 = 0;
        }
        // Duplicate return node #9. Try simplifying control flow for better match
        return;
    }
    func_800A91D8(arg0, temp_v1->unk0, temp_v1->unk2);
    if (D_8018EDEC == 3) {
        arg0->unk4 = 1;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800AB9B0.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern ? D_800E7430;

void func_800ABAE8(void *arg0) {
    s32 temp_v0;
    void *temp_v0_2;
    s32 phi_v1;

    temp_v0 = arg0->unk0;
    if (temp_v0 == 0x8C) {
        phi_v1 = 4;
    } else {
        phi_v1 = temp_v0 - 0x78;
    }
    temp_v0_2 = (phi_v1 * 8) + &D_800E7430;
    arg0->unkC = temp_v0_2->unk0;
    arg0->unk10 = temp_v0_2->unk2;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800ABAE8.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern ? D_800E7430;
extern s8 D_8018EDF7;

void func_800ABB24(void *arg0) {
    s32 temp_t7;
    s8 temp_v0;
    void *temp_v1;

    temp_v0 = D_8018EDF7;
    temp_v1 = ((temp_v0 / 4) * 8) + &D_800E7430;
    arg0->unkC = temp_v1->unk0 - 2;
    temp_t7 = arg0->unk1C + 0x10;
    arg0->unk10 = temp_v1->unk2 + ((temp_v0 % 4) * 0x32) + 0x13;
    arg0->unk1C = temp_t7;
    if (temp_t7 >= 0x100) {
        arg0->unk1C = temp_t7 - 0x100;
        arg0->unk20 = (arg0->unk20 + 1) % 3;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800ABB24.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern ? D_800E7430;

void func_800ABBCC(void *arg0) {
    s32 temp_v0;
    void *temp_v1;

    temp_v0 = arg0->unk0 - 0x7C;
    temp_v1 = ((temp_v0 / 4) * 8) + &D_800E7430;
    arg0->unkC = temp_v1->unk0;
    arg0->unk10 = temp_v1->unk2 + ((temp_v0 % 4) * 0x32) + 0x14;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800ABBCC.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800ABCF4(); // extern
extern s8 D_8018EE08;

void func_800ABC38(void *arg0) {
    s32 temp_v0;
    s32 temp_v0_2;
    s32 temp_v0_3;

    func_800ABCF4();
    temp_v0 = D_80164A28;
    if (temp_v0 != 1) {
        if (temp_v0 != 2) {
            if ((gModeSelection != GRAND_PRIX) || (gPlayerCountSelection1 != 1) || (D_8018EE08 != 0)) {
                goto block_13;
            }
            temp_v0_2 = arg0->unk10;
            if (temp_v0_2 >= -0x13) {
                arg0->unk10 = temp_v0_2 - 2;
                return;
            }
            goto block_13;
        }
        temp_v0_3 = arg0->unk10;
        if (temp_v0_3 >= -0x13) {
            arg0->unk10 = temp_v0_3 - 2;
            return;
        }
block_13:
        arg0->unk0 = 0;
        return;
    }
    arg0->unk15 = 1;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800ABC38.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 get_string_width(s32); // extern
? func_800A9208(void *, s32); // extern
extern s32 D_800DC540;
extern ? D_800E7500;
extern f64 D_800F2630;
extern f64 D_800F2638;
extern f64 D_800F2640;

void func_800ABCF4(void *arg0) {
    f64 temp_f0;
    s32 temp_t1;
    s32 temp_t1_2;
    s32 temp_v0;

    temp_v0 = arg0->unk4;
    if (temp_v0 != 0) {
        if (temp_v0 != 1) {
            if (temp_v0 != 2) {
                return;
            }
            func_800A9208(arg0, arg0->unk20);
            temp_t1 = arg0->unk18 + 1;
            temp_f0 = temp_t1 - 0xA;
            arg0->unk1C = (arg0->unk20 - arg0->unkC) / 4;
            arg0->unk18 = temp_t1;
            arg0->unk24 = (temp_f0 * D_800F2638 * temp_f0) + D_800F2640;
            if ((temp_t1 >= 9) && (arg0->unk24 > 1.0)) {
                arg0->unk24 = 1.0f;
            }
            // Duplicate return node #12. Try simplifying control flow for better match
            return;
        }
        goto block_5;
    }
    arg0->unkC = 0;
    arg0->unk4 = 1;
    arg0->unk20 = (get_string_width(*(&D_800E7500 + (D_800DC540 * 4))) / 2) + 0xA0;
block_5:
    func_800A9208(arg0, arg0->unk20);
    temp_t1_2 = (arg0->unk20 - arg0->unkC) / 4;
    arg0->unk1C = temp_t1_2;
    if (temp_t1_2 >= 9) {
        arg0->unk1C = 8;
    }
    arg0->unk24 = (arg0->unk1C * D_800F2630) + 1.0;
    if (arg0->unkC >= (arg0->unk20 - 0x14)) {
        arg0->unk4 = 2;
        arg0->unk18 = 0;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800ABCF4.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800ABF68(); // extern
extern s8 D_8018EE08;

void func_800ABEAC(void *arg0) {
    s32 temp_v0;
    s32 temp_v0_2;
    s32 temp_v0_3;

    func_800ABF68();
    temp_v0 = D_80164A28;
    if (temp_v0 != 1) {
        if (temp_v0 != 2) {
            if ((gModeSelection != GRAND_PRIX) || (gPlayerCountSelection1 != 1) || (D_8018EE08 != 0)) {
                goto block_13;
            }
            temp_v0_2 = arg0->unk10;
            if (temp_v0_2 < 0x104) {
                arg0->unk10 = temp_v0_2 + 2;
                return;
            }
            goto block_13;
        }
        temp_v0_3 = arg0->unk10;
        if (temp_v0_3 < 0x104) {
            arg0->unk10 = temp_v0_3 + 2;
            return;
        }
block_13:
        arg0->unk0 = 0;
        return;
    }
    arg0->unk15 = 1;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800ABEAC.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 get_string_width(s32); // extern
? func_800A9208(void *, s32); // extern
extern ? D_800E7524;
extern f64 D_800F2648;
extern f64 D_800F2650;
extern f64 D_800F2658;

void func_800ABF68(void *arg0) {
    f64 temp_f0;
    s32 temp_t3;
    s32 temp_t3_2;
    s32 temp_v0;

    temp_v0 = arg0->unk4;
    if (temp_v0 != 0) {
        if (temp_v0 != 1) {
            if (temp_v0 != 2) {
                return;
            }
            func_800A9208(arg0, arg0->unk20);
            temp_t3 = arg0->unk18 + 1;
            temp_f0 = temp_t3 - 0xA;
            arg0->unk1C = (arg0->unkC - arg0->unk20) / 4;
            arg0->unk18 = temp_t3;
            arg0->unk24 = (temp_f0 * D_800F2650 * temp_f0) + D_800F2658;
            if ((temp_t3 >= 9) && (arg0->unk24 > 1.0)) {
                arg0->unk24 = 1.0f;
            }
            // Duplicate return node #12. Try simplifying control flow for better match
            return;
        }
        goto block_5;
    }
    arg0->unkC = 0x140;
    arg0->unk4 = 1;
    arg0->unk20 = 0xA0 - (get_string_width(*(&D_800E7524 + (gCurrentCourseId * 4))) / 2);
block_5:
    func_800A9208(arg0, arg0->unk20);
    temp_t3_2 = (arg0->unkC - arg0->unk20) / 4;
    arg0->unk1C = temp_t3_2;
    if (temp_t3_2 >= 9) {
        arg0->unk1C = 8;
    }
    arg0->unk24 = (arg0->unk1C * D_800F2648) + 1.0;
    if ((arg0->unk20 + 0x14) >= arg0->unkC) {
        arg0->unk4 = 2;
        arg0->unk18 = 0;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800ABF68.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void func_800AC300(void *arg0) {
    s32 temp_t7;

    temp_t7 = arg0->unk1C + 1;
    arg0->unk1C = temp_t7;
    if (arg0->unk20 < temp_t7) {
        arg0->unk0 = 0;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800AC300.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800921B4(); // extern
? func_8009E650(?, ?, ?, ?); // extern
? func_800A9208(void *, ?); // extern
extern s32 D_800DDB24;
extern s8 D_8018D9D8;

void func_800AC324(void *arg0) {
    s32 temp_t1;
    s32 temp_v0;
    s32 temp_v0_2;

    temp_v0 = arg0->unk4;
    if (temp_v0 != 0) {
        if (temp_v0 != 1) {
            if (temp_v0 != 2) {
                if (temp_v0 != 3) {
                    return;
                }
                temp_v0_2 = arg0->unk1C;
                arg0->unkC = temp_v0_2;
                if (temp_v0_2 < 0x14A) {
                    if (D_8018D9D8 != 0) {
                        arg0->unk1C = temp_v0_2 + 0x20;
                        return;
                    }
                    arg0->unk1C = temp_v0_2 + 0x10;
                    return;
                }
                arg0->unk0 = 0;
                // Duplicate return node #17. Try simplifying control flow for better match
                return;
            }
            temp_t1 = arg0->unk20 + 1;
            arg0->unk20 = temp_t1;
            if (((D_8018D9D8 != 0) || (temp_t1 >= 0x5B)) && (D_800DDB24 != 0)) {
                arg0->unk4 = 3;
                arg0->unk1C = arg0->unkC;
                func_8009E650(0xAB, 0, 0, 0);
                return;
            }
            // Duplicate return node #17. Try simplifying control flow for better match
            return;
        }
        func_800A9208(arg0, 0xA0);
        if (arg0->unkC == 0xA0) {
            arg0->unk4 = 2;
            arg0->unk20 = 0;
            return;
        }
        return;
    }
    arg0->unkC = 0x14A;
    arg0->unk4 = 1;
    func_800921B4();
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800AC324.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
s8 *func_800921B4();                                /* extern */
s8 *func_800B536C(s32, s32, s32, void *);           /* extern */
s8 *func_800CA330(?, s32);                          /* extern */
s8 *play_sound2(?, s32, u8 *, void *);              /* extern */
extern s8 D_800DC5EC;
extern void *D_800DC5F0;
extern s16 D_8015F894;
extern ? D_80164360;
extern ? D_80164478;
extern s8 D_8018D9BC;
extern s8 D_8018D9D8;
extern s8 D_8018EDF3;
static s32 D_800DDB24 = 1;
static s8 gGP1stPlaceReward = 9;        /* const */
static s8 gGP2ndPlaceReward = 6;        /* const */
static s8 gGP3rdPlaceReward = 3;        /* const */
static s8 gGP4thPlaceReward = 1;        /* const */


//Something related to the point allotment screens at the end of a grand prix race
// Its unclear what exactly arg0 is, although unk4 of that struct(?) appears to be
// a form of a "current state" tracker. Each time this function runs it
// advances which "state" its in
s8 *func_800AC458(void *arg0) {
    s32 place;
    s32 sp18;
    s32 temp_a1;
    s32 temp_a1_2;
    s32 temp_a1_3;
    s32 temp_a1_4;
    s32 temp_a2;
    s32 temp_t2;
    s32 temp_t3;
    s32 temp_t3_2;
    s32 temp_t5;
    s32 temp_t7;
    s32 temp_t8;
    s32 temp_v0_3;
    s32 temp_v0_6;
    s8 *temp_v0;
    s8 *temp_v0_4;
    s8 *temp_v0_5;
    u16 temp_t4;
    u32 temp_v0_2;
    u8 *temp_a2_2;
    u8 temp_t0;
    void *temp_a3;
    void *temp_v1;
    void *temp_v1_2;
    s32 phi_a0;
    void *phi_a3;
    s32 phi_t1;
    s8 *phi_v0;
    s32 phi_a1;
    s8 *phi_v0_2;

    temp_v0_2 = arg0->unk4;
    temp_a3 = arg0;
    phi_a3 = temp_a3;
    phi_v0_2 = temp_v0_2;
    switch (temp_v0_2) {
    case 0:
        temp_a3->unkC = -0xA0;
        temp_a3->unk4 = 1;
        // Copy point rewards from data to some temp memory
        D_8018D9BC->unk0 = gGP1stPlaceReward;
        D_8018D9BC->unk1 = gGP2ndPlaceReward;
        D_8018D9BC->unk2 = gGP3rdPlaceReward;
        D_8018D9BC->unk3 = gGP4thPlaceReward;
        temp_a3->unk20 = temp_a3->unkC;
        return &D_8018D9BC;
    case 1:
        temp_a1 = temp_a3->unk20;
        temp_a3->unkC = temp_a1;
        phi_a0 = 0x10;
        if (D_8018D9D8 != 0) {
            phi_a0 = 0x20;
        }
        temp_a2 = temp_a1 + phi_a0;
        if (temp_a2 < 0) {
            temp_a3->unk20 = temp_a2;
            temp_v0 = D_800DC5EC;
            temp_v0->unk30 = temp_v0->unk30 + phi_a0;
            temp_v1 = D_800DC5F0;
            temp_v1->unk30 = temp_v1->unk30 - phi_a0;
            return temp_v0;
        }
        temp_a3->unk20 = 0;
        temp_a3->unkC = 0;
        temp_a3->unk4 = 2;
        temp_a3->unk1C = 0;
        D_800DC5EC->unk30 = 0xF0;
        D_800DC5F0->unk30 = 0x50;
        return &D_800DC5EC;
    case 2:
        temp_a3->unkC = 0;
        temp_t5 = temp_a3->unk1C + 1;
        temp_a3->unk1C = temp_t5;
        if (((D_8018D9D8 != 0) || (temp_t5 >= 0x1F)) && (D_800DDB24 != 0)) {
            temp_a3->unk4 = 3;
            temp_a3->unk1C = 0;
            temp_a3->unk20 = 0;
            return temp_v0_2;
        }
    default:
        return phi_v0_2;
    // Allocating point rewards for the players that finished the race
    // in 1st, 2nd, 3rd and 4th place
    case 3:
    case 4:
    case 5:
    case 6:
        temp_t3 = temp_a3->unk1C + 1;
        // Using the "state" variable to deduce which player we're allocating points for
        temp_a1_2 = temp_v0_2 - 3;
        temp_a3->unk1C = temp_t3;
        if (((temp_t3 % 3) == 0) || (D_8018D9D8 != 0)) {
            temp_a2_2 = D_8018D9BC + temp_a1_2;
            temp_t0 = *temp_a2_2;
            if (temp_t0 > 0) {
                *temp_a2_2 = temp_t0 - 1;
                temp_t4 = *(&gPlayers->characterId + (*(&D_80164360 + (temp_a1_2 * 2)) * 0xDD8));
                sp18 = 0;
                arg0 = temp_a3;
                gGPPointsByCharacterId[temp_t4] += 1;
                place = temp_a1_2;
                play_sound2(0x49008017, temp_a1_2, temp_a2_2, temp_a3);
                phi_a3 = arg0;
                if ((*(D_8018D9BC + temp_a1_2) == 0) && (arg0->unk20 == 0)) {
                    arg0->unk20 = 1;
                    arg0->unk1C = 0;
                }
            }
        }
        phi_t1 = 0;
        phi_v0_2 = &D_8018D9BC;
        if ((phi_a3->unk20 != 0) && ((temp_v0_6 = phi_a3->unk1C, phi_v0_2 = temp_v0_6, ((temp_v0_6 < 0xB) == 0)) || ((D_8018D9D8 != 0) && (temp_v0_6 >= 4)))) {
            phi_t1 = 1;
        }
        if (phi_t1 != 0) {
            temp_v0_3 = phi_a3->unk4;
            phi_a3->unk20 = 0;
            phi_a3->unk1C = 0;
            // If not done alloting points
            if (temp_v0_3 < 6) {
                phi_a3->unk4 = temp_v0_3 + 1;
                return temp_v0_3;
            }
            phi_a3->unk4 = 7;
            return temp_v0_3;
        }
        /* Duplicate return node #53. Try simplifying control flow for better match */
        return phi_v0_2;
    case 7:
        temp_t2 = temp_a3->unk1C + 1;
        temp_a3->unk1C = temp_t2;
        if ((((D_8018D9D8 != 0) && (temp_t2 >= 0xB)) || (temp_a3->unk1C >= 0x3D)) && (D_800DDB24 != 0)) {
            temp_a3->unk4 = 8;
            temp_a3->unk1C = 0;
            return temp_v0_2;
        }
        /* Duplicate return node #53. Try simplifying control flow for better match */
        return phi_v0_2;
    case 8:
        temp_t8 = temp_a3->unk1C + 1;
        temp_a3->unk1C = temp_t8;
        if (D_8018D9D8 != 0) {
            temp_a3->unk1C = temp_t8 + 5;
        }
        if (temp_a3->unk1C >= 0x29) {
            temp_a3->unk4 = 9;
            return temp_v0_2;
        }
        /* Duplicate return node #53. Try simplifying control flow for better match */
        return phi_v0_2;
    case 9:
        temp_t7 = temp_a3->unk1C - 1;
        temp_a3->unk1C = temp_t7;
        if (D_8018D9D8 != 0) {
            temp_a3->unk1C = temp_t7 - 5;
        }
        if ((temp_a3->unk1C <= 0) && (temp_a3->unk4 = 0xA, temp_a3->unk1C = 0, phi_a1 = 0, phi_v0_2 = gCharacterIdByGPOverallRank, (gCupCourseSelection == CUP_COURSE_FOUR))) {
            phi_v0 = gCharacterIdByGPOverallRank;
loop_41:
            if (*(&D_80164478 + (*phi_v0 * 2)) < D_8018EDF3) {
                return func_800B536C(phi_a1, phi_a1, 8, temp_a3);
            }
            temp_a1_3 = phi_a1 + 1;
            temp_v0_4 = phi_v0 + 1;
            phi_v0 = temp_v0_4;
            phi_a1 = temp_a1_3;
            if (temp_a1_3 == 8) {
                return temp_v0_4;
            }
            goto loop_41;
        }
        /* Duplicate return node #53. Try simplifying control flow for better match */
        return phi_v0_2;
    case 10:
        temp_t3_2 = temp_a3->unk1C + 1;
        temp_a3->unk1C = temp_t3_2;
        if (temp_t3_2 > 0) {
            temp_a3->unk4 = 0xB;
            temp_a3->unk1C = 0;
            return func_800921B4();
        }
        /* Duplicate return node #53. Try simplifying control flow for better match */
        return phi_v0_2;
    case 11:
        if ((D_8018D9D8 != 0) && (D_800DDB24 != 0)) {
            temp_a3->unk4 = 0xC;
            temp_a3->unk20 = temp_a3->unk10;
            return play_sound2(0x49008015);
        }
        /* Duplicate return node #53. Try simplifying control flow for better match */
        return phi_v0_2;
    case 12:
        temp_a1_4 = temp_a3->unk20;
        temp_a3->unk10 = temp_a1_4;
        if (temp_a1_4 < 0xF0) {
            temp_a3->unk20 = temp_a1_4 + 0x10;
            temp_v0_5 = D_800DC5EC;
            temp_v0_5->unk32 = temp_v0_5->unk32 + 0x10;
            temp_v1_2 = D_800DC5F0;
            temp_v1_2->unk32 = temp_v1_2->unk32 - 0x10;
            return temp_v0_5;
        }
        temp_a3->unk20 = 0;
        temp_a3->unk4 = 0xD;
        temp_a3->unk1C = 0;
        D_800DC5EC->unk32 = 0x12C;
        D_800DC5F0->unk32 = -0x3C;
        D_8015F894 = 4;
        phi_v0_2 = func_800CA330(0x19, temp_a1_4);
        /* Duplicate return node #53. Try simplifying control flow for better match */
        return phi_v0_2;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800AC458.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800A9208(?); // extern

void func_800AC978(void *arg0) {
    s32 temp_v0;
    s32 temp_v0_2;

    temp_v0 = arg0->unk4;
    if (temp_v0 != 0) {
        if (temp_v0 != 1) {
            if (temp_v0 != 2) {
                if (temp_v0 != 3) {
                    return;
                }
                temp_v0_2 = arg0->unk1C;
                if (temp_v0_2 != 0) {
                    arg0->unk1C = temp_v0_2 - 0x33;
                }
                // Duplicate return node #10. Try simplifying control flow for better match
                return;
            }
            // Duplicate return node #10. Try simplifying control flow for better match
            return;
        }
        func_800A9208(0xA0);
        if (arg0->unkC == 0xA0) {
            arg0->unk4 = 2;
            return;
        }
        return;
    }
    arg0->unkC = 0x14A;
    arg0->unk4 = 1;
    arg0->unk1C = 0xFF;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800AC978.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_8009DFE0(?, void *); // extern
s32 func_800B4520(void *); // extern
? func_800CA330(?); // extern
? play_sound2(?, void *); // extern
extern void *D_800DC4CC;
extern f64 D_800F26C0;
extern f64 D_800F26C8;
extern f64 D_800F26D0;

void func_800ACA14(void *arg0) {
    f64 temp_f0;
    f64 temp_f0_2;
    f64 temp_f0_3;
    s32 temp_a0;
    s32 temp_v0;
    s32 temp_v0_3;
    s32 temp_v0_4;
    u16 temp_v1;
    u16 temp_v1_2;
    void *temp_a1;
    void *temp_a1_2;
    void *temp_t5;
    void *temp_v0_2;
    s32 phi_a0;
    void *phi_a1;
    u16 phi_v1;
    void *phi_a1_2;
    s32 phi_v0;
    void *phi_a1_3;
    void *phi_a1_4;

    temp_v0 = arg0->unk4;
    temp_a1 = arg0;
    phi_a1_3 = temp_a1;
    phi_a1_4 = temp_a1;
    if (temp_v0 != 0) {
        if ((temp_v0 != 0xB) && (temp_v0 != 0xC)) {
            phi_v0 = arg0->unk20;
        } else {
            arg0 = temp_a1;
            temp_a1_2 = arg0;
            phi_a1 = temp_a1_2;
            phi_a1_4 = temp_a1_2;
            if (func_800B4520(temp_a1) != 0) {

            } else {
                temp_v0_2 = D_800DC4CC;
                temp_v1 = temp_v0_2->unk6;
                temp_a0 = temp_v1 | temp_v0_2->unkC;
                phi_a0 = temp_a0;
                phi_v1 = temp_v1;
                if ((temp_a0 & 0x800) != 0) {
                    temp_v0_3 = temp_a1_2->unk4;
                    if (temp_v0_3 >= 0xC) {
                        temp_a1_2->unk4 = temp_v0_3 - 1;
                        arg0 = temp_a1_2;
                        play_sound2(0x49008000, temp_a1_2);
                        temp_f0 = arg0->unk24;
                        phi_a1 = arg0;
                        if (temp_f0 < D_800F26C0) {
                            arg0->unk24 = temp_f0 + 4.0;
                        }
                        arg0->unk8 = -1;
                        temp_t5 = D_800DC4CC;
                        temp_v1_2 = temp_t5->unk6;
                        phi_a0 = temp_v1_2 | temp_t5->unkC;
                        phi_v1 = temp_v1_2;
                    }
                }
                phi_a1_2 = phi_a1;
                if ((phi_a0 & 0x400) != 0) {
                    temp_v0_4 = phi_a1->unk4;
                    if (temp_v0_4 < 0xC) {
                        phi_a1->unk4 = temp_v0_4 + 1;
                        arg0 = phi_a1;
                        play_sound2(0x49008000, phi_a1);
                        temp_f0_2 = arg0->unk24;
                        phi_a1_2 = arg0;
                        if (temp_f0_2 < D_800F26C8) {
                            arg0->unk24 = temp_f0_2 + 4.0;
                        }
                        arg0->unk8 = 1;
                        phi_v1 = D_800DC4CC->unk6;
                    }
                }
                phi_a1_4 = phi_a1_2;
                if ((phi_v1 & 0x9000) != 0) {
                    arg0 = phi_a1_2;
                    func_8009DFE0(0x1E, phi_a1_2);
                    func_800CA330(0x19);
                    play_sound2(0x4900801B);
                    temp_f0_3 = arg0->unk24;
                    phi_a1_4 = arg0;
                    if (temp_f0_3 < D_800F26D0) {
                        arg0->unk24 = temp_f0_3 + 4.0;
                    }
                }
            }
            goto block_24;
        }
    } else {
        if (temp_a1->unk20 >= 0xB) {
            temp_a1->unk1C = temp_a1->unk1C + 3;
        }
        if (temp_a1->unk1C >= 0x65) {
            temp_a1->unk4 = 0xB;
            temp_a1->unk1C = 0;
        }
block_24:
        phi_v0 = phi_a1_4->unk20;
        phi_a1_3 = phi_a1_4;
    }
    if (phi_v0 < 0x28) {
        phi_a1_3->unk20 = phi_v0 + 1;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800ACA14.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
? func_8009DFE0(?, void *);                         /* extern */
? func_8009E650(s32, ?, ?, s8);                     /* extern */
void *func_800AAEF4(?, void *);                     /* extern */
? play_sound2(?, void *);                           /* extern */

void func_800ACC50(void *arg0) {
    f64 temp_f0;
    f64 temp_f0_2;
    f64 temp_f0_3;
    s32 temp_a0;
    s32 temp_s0;
    s32 temp_t8;
    s32 temp_t9;
    s32 temp_v0_3;
    u16 temp_v1;
    u16 temp_v1_2;
    u32 temp_t6;
    u32 temp_v0_2;
    void *temp_a1;
    void *temp_a1_2;
    void *temp_t8_2;
    void *temp_v0;
    s32 phi_s0;
    s32 phi_a0;
    void *phi_a1;
    u16 phi_v1;
    void *phi_a1_2;
    temp_t6 = arg0->unk4;
    temp_a1 = arg0;
    switch (temp_t6) {
    case 0:
        temp_t8 = temp_a1->unk1C + 3;
        temp_a1->unk1C = temp_t8;
        if ((temp_t8 >= 0x65) && (temp_a1->unk4 = 1, temp_a1->unk1C = 0, phi_s0 = 0, (D_8018EDF3 > 0))) {
            do {
                func_8009E650(phi_s0 + 0xB1, 0, 0, 5 - phi_s0);
                temp_s0 = phi_s0 + 1;
                phi_s0 = temp_s0;
            } while (temp_s0 < D_8018EDF3);
            return;
        }
    default:
        return;
    case 1:
        arg0 = temp_a1;
        if (func_800AAEF4(0xB1, temp_a1)->unk4 >= 2) {
            arg0->unk4 = 2;
            return;
        }
        /* Duplicate return node #30. Try simplifying control flow for better match */
        return;
    case 2:
        temp_t9 = temp_a1->unk1C + 0x20;
        temp_a1->unk1C = temp_t9;
        if (temp_t9 >= 0x100) {
            if (gModeSelection == VERSUS) {
                temp_a1->unk4 = D_8018EDF4;
            } else {
                temp_a1->unk4 = D_8018EDF6;
            }
            temp_a1->unk1C = 0;
            return;
        }
        /* Duplicate return node #30. Try simplifying control flow for better match */
        return;
    case 10:
    case 11:
    case 12:
    case 13:
        arg0 = temp_a1;
        temp_a1_2 = arg0;
        phi_a1 = temp_a1_2;
        if (func_800B4520(arg0) == 0) {
            temp_v0 = D_800DC4CC;
            temp_v1 = temp_v0->unk6;
            temp_a0 = temp_v1 | temp_v0->unkC;
            phi_a0 = temp_a0;
            phi_v1 = temp_v1;
            if ((temp_a0 & 0x800) != 0) {
                temp_v0_2 = temp_a1_2->unk4;
                if (temp_v0_2 >= 0xB) {
                    temp_a1_2->unk4 = temp_v0_2 - 1;
                    arg0 = temp_a1_2;
                    play_sound2(0x49008000, temp_a1_2);
                    temp_f0 = arg0->unk24;
                    phi_a1 = arg0;
                    if (temp_f0 < 4.2) {
                        arg0->unk24 = temp_f0 + 4.0;
                    }
                    arg0->unk8 = -1;
                    temp_t8_2 = D_800DC4CC;
                    temp_v1_2 = temp_t8_2->unk6;
                    phi_a0 = temp_v1_2 | temp_t8_2->unkC;
                    phi_v1 = temp_v1_2;
                }
            }
            phi_a1_2 = phi_a1;
            if ((phi_a0 & 0x400) != 0) {
                temp_v0_3 = phi_a1->unk4;
                if (temp_v0_3 < 0xD) {
                    phi_a1->unk4 = temp_v0_3 + 1;
                    arg0 = phi_a1;
                    play_sound2(0x49008000, phi_a1);
                    temp_f0_2 = arg0->unk24;
                    phi_a1_2 = arg0;
                    if (temp_f0_2 < 4.2) {
                        arg0->unk24 = temp_f0_2 + 4.0;
                    }
                    arg0->unk8 = 1;
                    phi_v1 = D_800DC4CC->unk6;
                }
            }
            if ((phi_v1 & 0x9000) != 0) {
                arg0 = phi_a1_2;
                func_8009DFE0(0x1E, phi_a1_2);
                play_sound2(0x49008016);
                if (gModeSelection == VERSUS) {
                    D_8018EDF4 = arg0->unk4;
                } else {
                    D_8018EDF6 = arg0->unk4;
                }
                temp_f0_3 = arg0->unk24;
                if (temp_f0_3 < 4.2) {
                    arg0->unk24 = temp_f0_3 + 4.0;
                }
            }
        }
        /* Duplicate return node #30. Try simplifying control flow for better match */
        return;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800ACC50.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
? func_8009A640(s32, ?, s32, s32);                  /* extern */
? func_800A9208(void *, s16, s32);                  /* extern */
? func_800A9278(void *, s16);                       /* extern */
void *func_800AAEF4(?, s8, s32);                    /* extern */
? func_800C90F4(s32, s32, s32);                     /* extern */
? func_800CA24C(s32);                               /* extern */
extern ? D_801643B8;
extern ? D_8018DEE4;
static ? D_800E72F8;                                /* unable to generate initializer; const */
static ? D_800E7300;                                /* unable to generate initializer; const */
static ? D_800E8380;                                /* unable to generate initializer; const */
static ? D_800E83A0;                                /* unable to generate initializer; const */
static ? D_800E8440;                                /* unable to generate initializer; const */
static ? D_800E85F7;                                /* unable to generate initializer; const */
static ? D_800E86A8;                                /* unable to generate initializer; const */
static ? D_800EFD64;                                /* unable to generate initializer; const */

void func_800ACF40(void *arg0) {
    s16 *sp3C;
    s32 sp38;
    s32 sp34;
    s32 sp24;
    s16 *temp_v0_2;
    s32 temp_a0;
    s32 temp_a2;
    s32 temp_t7_2;
    s32 temp_v0;
    s32 temp_v0_3;
    s32 temp_v0_4;
    s8 temp_a1;
    u32 temp_t7;
    s32 phi_v1;

    temp_v0 = arg0->unk0;
    temp_t7 = arg0->unk4;
    temp_a1 = *(&D_800EFD64 + *(&D_800E85F7 + temp_v0));
    temp_a2 = temp_v0 - 0xB1;
    switch (temp_t7) {
    case 0:
        arg0->unkC = D_800E72F8.unk0;
        arg0->unk4 = 1;
        arg0->unk10 = D_800E72F8.unk2;
        return;
    case 1:
        temp_v0_2 = ((D_8018EDF3 << 5) + (temp_a2 * 8)) - 0x40 + &D_800E7300;
        sp3C = temp_v0_2;
        func_800A9208(arg0, *temp_v0_2, temp_a2);
        func_800A9278(arg0, sp3C->unk2);
        if (sp3C->unk0 == arg0->unkC) {
            arg0->unk4 = 2;
            arg0->unk20 = 0;
            return;
        }
    default:
        return;
    case 2:
        temp_v0_3 = gModeSelection;
        phi_v1 = 0;
        if (temp_v0_3 != 2) {
            if (temp_v0_3 != 3) {

            } else if (temp_a2 != D_800DC5E8) {
                goto block_11;
            }
        } else if (*(&D_801643B8 + (temp_a2 * 4)) != 0) {
block_11:
            phi_v1 = 1;
        }
        if ((phi_v1 == 0) && (temp_t7_2 = arg0->unk20 + 1, arg0->unk20 = temp_t7_2, ((temp_t7_2 < 0x1F) == 0)) && (sp34 = temp_a1, sp38 = temp_a2, ((func_800AAEF4(0xB0, temp_a1, temp_a2)->unk4 < 2) == 0))) {
            sp38 = temp_a2;
            func_8009A640(arg0->unk18, 0, temp_a2, segmented_to_virtual_dupe(*(&D_800E8380 + (temp_a1 * 4)), temp_a1, temp_a2));
            arg0->unk4 = 3;
            temp_a0 = temp_a2 & 0xFF;
            sp24 = temp_a0;
            func_800CA24C(temp_a0);
            func_800C90F4(temp_a0, (*(&D_800E86A8 + temp_a2) * 0x10) + 0x29008007, temp_a2);
            return;
        }
        /* Duplicate return node #18. Try simplifying control flow for better match */
        return;
    case 3:
        temp_v0_4 = temp_a1 * 4;
        if (*(&D_8018DEE4 + (arg0->unk18 * 0x18)) >= *(&D_800E8440 + temp_v0_4)) {
            sp38 = temp_a2;
            func_8009A640(arg0->unk18, 0, temp_a2, segmented_to_virtual_dupe(*(&D_800E83A0 + temp_v0_4), temp_a1, temp_a2));
            arg0->unk4 = 4;
        }
        /* Duplicate return node #18. Try simplifying control flow for better match */
        return;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800ACF40.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
? func_800921B4();                                  /* extern */
? func_8009E650(?, ?, ?, ?);                        /* extern */
? func_800A9208(void *, ?);                         /* extern */

void func_800AD1A4(void *arg0) {
    s32 temp_t2;
    s32 temp_v0;
    u32 temp_t6;

    temp_t6 = arg0->unk4;
    switch (temp_t6) {
    case 0:
        arg0->unkC = 0x14A;
        arg0->unk4 = 1;
        func_800921B4();
        func_8009E650(0xBB, 0, 0, 0);
        return;
    case 1:
        func_800A9208(arg0, 0xA0);
        if (arg0->unkC == 0xA0) {
            arg0->unk4 = 2;
            arg0->unk20 = 0;
            return;
        }
    default:
        return;
    case 2:
        temp_t2 = arg0->unk20 + 1;
        arg0->unk20 = temp_t2;
        if (temp_t2 >= 0x15) {
            arg0->unk4 = 3;
            return;
        }
        /* Duplicate return node #14. Try simplifying control flow for better match */
        return;
    case 3:
        if (D_8018D9D8 != 0) {
            func_800921B4();
            arg0->unk4 = 4;
            arg0->unk1C = arg0->unkC;
            func_8009E650(0xBA, 0, 0, 0);
            return;
        }
        /* Duplicate return node #14. Try simplifying control flow for better match */
        return;
    case 4:
        temp_v0 = arg0->unk1C;
        arg0->unkC = temp_v0;
        if (temp_v0 < 0x14A) {
            if (D_8018D9D8 != 0) {
                arg0->unk1C = temp_v0 + 0x20;
                return;
            }
            arg0->unk1C = temp_v0 + 0x10;
            return;
        }
        arg0->unk0 = 0;
        /* Duplicate return node #14. Try simplifying control flow for better match */
        return;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800AD1A4.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
s32 func_800B4520();                                /* extern */
s32 func_800B5F30();                                /* extern */
s32 func_800B6348(s32);                             /* extern */
? func_800B6708();                                  /* extern */
s32 osPfsFindFile(? *, u16, s32, ? *, ? *, ? *);    /* extern */
? play_sound2(?, u16);                              /* extern */
extern void *D_800DC5EC;
extern void *D_800DC5F0;
extern u16 D_80162DD4;
extern s32 D_80162DF8;
extern void *D_8018D9BC;
extern s8 D_8018D9D8;
extern ? D_8018E868;
extern s32 D_8018EB78;
extern s32 D_8018EB7C;
extern s32 D_8018EB80;
extern ? D_8018EB84;
extern s8 D_8018EDF5;
static u16 D_800E86F0;                              /* type too large by 2; unable to generate initializer; const */
static s32 D_800E86F4 = 0x4E4B544A;                 /* const */
static s8 D_800E86F8 = 0;                           /* const */
static ? D_800F2E64;                                /* unable to generate initializer; const */
static ? D_800F2E74;                                /* unable to generate initializer; const */

void func_800AD2E8(void *arg0) {
    s32 sp28;
    f64 temp_f0;
    f64 temp_f0_2;
    f64 temp_f0_3;
    f64 temp_f0_4;
    s32 temp_a0;
    s32 temp_a0_2;
    s32 temp_a2;
    s32 temp_v0_7;
    s32 temp_v0_8;
    s8 temp_t3;
    struct Controller *temp_t6;
    struct Controller *temp_v1_2;
    u16 temp_a1;
    u16 temp_a1_2;
    u32 temp_t2;
    u32 temp_t9;
    u32 temp_v0;
    u32 temp_v0_3;
    u32 temp_v0_4;
    u32 temp_v0_5;
    u32 temp_v0_6;
    void *temp_v0_2;
    void *temp_v1;
    s32 phi_a1;
    s32 phi_a0;
    u16 phi_a1_2;
    u16 phi_a1_3;
    s32 phi_v1;
    s32 phi_v1_2;

    temp_v0 = arg0->unk4;
    if (temp_v0 < 0x20) {
        switch (temp_v0) {                          /* switch 1 */
        case 0:                                     /* switch 1 */
            arg0->unkC = -0xA0;
            arg0->unk4 = 1;
            D_8018D9BC->unk0 = gGP1stPlaceReward;
            D_8018D9BC->unk1 = gGP2ndPlaceReward;
            D_8018D9BC->unk2 = gGP3rdPlaceReward;
            D_8018D9BC->unk3 = gGP4thPlaceReward;
            arg0->unk20 = arg0->unkC;
            return;
        case 1:                                     /* switch 1 */
            temp_a0 = arg0->unk20;
            arg0->unkC = temp_a0;
            phi_a1 = 0x10;
            if (D_8018D9D8 != 0) {
                phi_a1 = 0x20;
            }
            temp_a2 = temp_a0 + phi_a1;
            if (temp_a2 < 0) {
                arg0->unk20 = temp_a2;
                temp_v0_2 = D_800DC5EC;
                temp_v0_2->unk30 = temp_v0_2->unk30 + phi_a1;
                temp_v1 = D_800DC5F0;
                temp_v1->unk30 = temp_v1->unk30 - phi_a1;
                return;
            }
            arg0->unk20 = 0;
            arg0->unkC = 0;
            temp_t3 = D_8018EDF5;
            arg0->unk4 = temp_t3;
            if ((temp_t3 == 9) && (D_80162DF8 == 1)) {
                arg0->unk4 = temp_t3 - 1;
            }
            D_800DC5EC->unk30 = 0xF0;
            D_800DC5F0->unk30 = 0x50;
            return;
        case 5:                                     /* switch 1 */
        case 6:                                     /* switch 1 */
        case 7:                                     /* switch 1 */
        case 8:                                     /* switch 1 */
        case 9:                                     /* switch 1 */
        case 10:                                    /* switch 1 */
            if (func_800B4520() == 0) {
                temp_v1_2 = D_800DC4BC;
                temp_a1 = temp_v1_2->buttonPressed;
                temp_a0_2 = temp_a1 | temp_v1_2->stickPressed;
                phi_a0 = temp_a0_2;
                phi_a1_2 = temp_a1;
                if ((temp_a0_2 & 0x800) != 0) {
                    temp_v0_3 = arg0->unk4;
                    temp_t2 = temp_v0_3 - 1;
                    if (temp_v0_3 >= 6) {
                        arg0->unk4 = temp_t2;
                        if ((D_80162DF8 == 1) && (temp_t2 == 9)) {
                            arg0->unk4 = temp_t2 - 1;
                        }
                        play_sound2(0x49008000, temp_a1);
                        temp_f0 = arg0->unk24;
                        if (temp_f0 < 4.2) {
                            arg0->unk24 = temp_f0 + 4.0;
                        }
                        arg0->unk8 = -1;
                        temp_t6 = D_800DC4BC;
                        temp_a1_2 = temp_t6->buttonPressed;
                        phi_a0 = temp_a1_2 | temp_t6->stickPressed;
                        phi_a1_2 = temp_a1_2;
                    }
                }
                phi_a1_3 = phi_a1_2;
                if ((phi_a0 & 0x400) != 0) {
                    temp_v0_4 = arg0->unk4;
                    temp_t9 = temp_v0_4 + 1;
                    if (temp_v0_4 < 0xA) {
                        arg0->unk4 = temp_t9;
                        if ((D_80162DF8 == 1) && (temp_t9 == 9)) {
                            arg0->unk4 = temp_t9 + 1;
                        }
                        temp_v0_5 = arg0->unk4;
                        if ((temp_v0_5 == 0xA) && (D_80162DD4 != 0)) {
                            arg0->unk4 = temp_v0_5 - 2;
                            phi_a1_3 = D_800DC4BC->buttonPressed;
                        } else {
                            play_sound2(0x49008000, phi_a1_2);
                            temp_f0_2 = arg0->unk24;
                            if (temp_f0_2 < 4.2) {
                                arg0->unk24 = temp_f0_2 + 4.0;
                            }
                            arg0->unk8 = 1;
                            phi_a1_3 = D_800DC4BC->buttonPressed;
                        }
                    }
                }
                if ((phi_a1_3 & 0x9000) != 0) {
                    temp_v0_6 = arg0->unk4;
                    if (temp_v0_6 == 0xA) {
                        temp_f0_3 = arg0->unk24;
                        phi_v1 = 0;
                        if (temp_f0_3 < 4.2) {
                            arg0->unk24 = temp_f0_3 + 4.0;
                        }
                        if (D_800E86F8 != 0) {
                            sp28 = 0;
                            temp_v0_7 = osPfsFindFile(&D_8018E868, D_800E86F0, D_800E86F4, &D_800F2E64, &D_800F2E74, &D_8018EB84);
                            if (temp_v0_7 != 0) {
                                if (temp_v0_7 != 2) {
                                    if (temp_v0_7 != 5) {
                                        goto block_42;
                                    }
                                } else {
block_42:
                                    D_800E86F8 = 0;
                                }
                            } else {
                                func_800B6708();
                                arg0->unk4 = func_800B6348((gCupSelection * 4) + gCupCourseSelection) + 0x11;
                                sp28 = 1;
                                play_sound2(0x49008001);
                                phi_v1 = 1;
                            }
                        }
                        if (phi_v1 == 0) {
                            if (D_800E86F8 == 0) {
                                sp28 = phi_v1;
                                temp_v0_8 = func_800B5F30();
                                phi_v1_2 = phi_v1;
                                switch (temp_v0_8) { /* switch 2 */
                                case -1:            /* switch 2 */
                                    arg0->unk4 = 0xB;
                                    phi_v1_2 = 1;
                                    break;
                                case -3:            /* switch 2 */
                                case -2:            /* switch 2 */
                                    arg0->unk4 = 0xC;
                                    phi_v1_2 = 1;
                                    break;
                                case 1:             /* switch 2 */
                                case 11:            /* switch 2 */
                                    arg0->unk4 = 0xB;
                                    phi_v1_2 = 1;
                                    break;
                                case 10:            /* switch 2 */
                                    arg0->unk4 = 0xC;
                                    phi_v1_2 = 1;
                                    break;
                                default:            /* switch 2 */
                                    arg0->unk4 = 0xC;
                                    phi_v1_2 = 1;
                                    break;
                                }
                                if (phi_v1_2 != 0) {
                                    play_sound2(0x4900FF07);
                                    return;
                                }
                                if (osPfsFindFile(&D_8018E868, D_800E86F0, D_800E86F4, &D_800F2E64, &D_800F2E74, &D_8018EB84) == 0) {
                                    func_800B6708();
                                    arg0->unk4 = func_800B6348((gCupSelection * 4) + gCupCourseSelection) + 0x11;
                                    play_sound2(0x49008001);
                                    return;
                                }
                                goto block_56;
                            }
block_56:
                            if (D_8018EB7C >= D_8018EB78) {
                                arg0->unk4 = 0xE;
                                play_sound2(0x4900FF07);
                                return;
                            }
                            if (D_8018EB80 >= 0x79) {
                                arg0->unk4 = 0x13;
                                arg0->unk1C = 0;
                                play_sound2(0x49008001);
                                return;
                            }
                            arg0->unk4 = 0xE;
                            play_sound2(0x4900FF07);
                            return;
                        }
                        /* Duplicate return node #127. Try simplifying control flow for better match */
                        return;
                    }
                    arg0->unk1C = temp_v0_6;
                    D_8018EDF5 = temp_v0_6;
                    arg0->unk4 = 0x1E;
                    arg0->unk20 = arg0->unk10;
                    play_sound2(0x49008015, phi_a1_3);
                    temp_f0_4 = arg0->unk24;
                    if (temp_f0_4 < 4.2) {
                        arg0->unk24 = temp_f0_4 + 4.0;
                    }
                    /* Duplicate return node #127. Try simplifying control flow for better match */
                    return;
                }
                /* Duplicate return node #127. Try simplifying control flow for better match */
                return;
            }
            /* Duplicate return node #127. Try simplifying control flow for better match */
            return;
        }
    } else {
    case 2:                                         /* switch 1 */
    case 3:                                         /* switch 1 */
    case 4:                                         /* switch 1 */
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800AD2E8.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
? func_8009DFE0(?, void *, struct Controller *, s32 *); /* extern */
? func_800C9F90(?);                                 /* extern */
? func_800CA330(?);                                 /* extern */
? func_8028DF38(?, void *, struct Controller *, s32 *); /* extern */
? play_sound2(?, void *, struct Controller *, s32 *); /* extern */
static ? D_800F0B50;                                /* unable to generate initializer; const */
static ? D_800F0B54;                                /* unable to generate initializer; const */

void func_800ADF48(void *arg0) {
    struct Controller *sp18;
    f64 temp_f0;
    f64 temp_f0_2;
    f64 temp_f0_3;
    s32 temp_a0;
    s32 temp_t2;
    s32 temp_v0_2;
    s8 temp_v0_3;
    struct Controller *temp_a2;
    u16 temp_v1;
    u16 temp_v1_2;
    u32 temp_t7;
    u32 temp_v0;
    void *temp_a1;
    s32 phi_a0;
    void *phi_a1;
    u16 phi_v1;
    void *phi_a1_2;

    if (D_800DC5FC != 0) {
        temp_t7 = arg0->unk4;
        switch (temp_t7) {
        case 0:
            arg0->unk4 = *(&D_800F0B50 + gModeSelection);
            return;
        case 11:
        case 12:
        case 13:
        case 14:
        case 15:
        case 21:
        case 22:
        case 23:
        case 24:
        case 31:
        case 32:
        case 41:
        case 42:
        case 43:
        case 44:
            arg0 = arg0;
            temp_a1 = arg0;
            phi_a1 = temp_a1;
            if (func_800B4520(arg0) == 0) {
                temp_t2 = (D_800DC5FC * 0x10) - 0x10;
                temp_a2 = temp_t2 + gControllers;
                temp_v1 = temp_a2->buttonPressed;
                temp_a0 = temp_v1 | temp_a2->stickPressed;
                phi_a0 = temp_a0;
                phi_v1 = temp_v1;
                if ((temp_a0 & 0x800) != 0) {
                    temp_v0 = temp_a1->unk4;
                    if (*(&D_800F0B50 + gModeSelection) < temp_v0) {
                        temp_a1->unk4 = temp_v0 - 1;
                        sp18 = temp_a2;
                        arg0 = temp_a1;
                        play_sound2(0x49008000, temp_a1, temp_a2, &gModeSelection);
                        temp_f0 = arg0->unk24;
                        phi_a1 = arg0;
                        if (temp_f0 < 4.2) {
                            arg0->unk24 = temp_f0 + 4.0;
                        }
                        arg0->unk8 = -1;
                        temp_v1_2 = temp_a2->buttonPressed;
                        phi_a0 = temp_v1_2 | temp_a2->stickPressed;
                        phi_v1 = temp_v1_2;
                    }
                }
                phi_a1_2 = phi_a1;
                if ((phi_a0 & 0x400) != 0) {
                    temp_v0_2 = phi_a1->unk4;
                    if (temp_v0_2 < *(&D_800F0B54 + gModeSelection)) {
                        phi_a1->unk4 = temp_v0_2 + 1;
                        sp18 = temp_t2 + gControllers;
                        arg0 = phi_a1;
                        play_sound2(0x49008000, phi_a1, temp_t2 + gControllers, &gModeSelection);
                        temp_f0_2 = arg0->unk24;
                        phi_a1_2 = arg0;
                        if (temp_f0_2 < 4.2) {
                            arg0->unk24 = temp_f0_2 + 4.0;
                        }
                        arg0->unk8 = 1;
                        phi_v1 = (temp_t2 + gControllers)->buttonPressed;
                    }
                }
                if (((phi_v1 & 0x4000) != 0) && (temp_v0_3 = *(&D_800F0B50 + gModeSelection), (phi_a1_2->unk4 != temp_v0_3))) {
                    phi_a1_2->unk4 = temp_v0_3;
                    play_sound2(0x49008002, phi_a1_2, temp_t2 + gControllers, &gModeSelection);
                    return;
                }
                if ((phi_v1 & 0x9000) != 0) {
                    if (phi_a1_2->unk4 == *(&D_800F0B50 + gModeSelection)) {
                        phi_a1_2->unk4 = 0;
                        D_800DC5FC = 0;
                        func_8028DF38(0x1E, phi_a1_2, temp_t2 + gControllers, &gModeSelection);
                        func_800C9F90(0);
                        return;
                    }
                    arg0 = phi_a1_2;
                    func_8009DFE0(0x1E, phi_a1_2, temp_t2 + gControllers, &gModeSelection);
                    play_sound2(0x4900801B);
                    func_800CA330(0x3C);
                    temp_f0_3 = arg0->unk24;
                    if (temp_f0_3 < 4.2) {
                        arg0->unk24 = temp_f0_3 + 4.0;
                        return;
                    }
                    /* Duplicate return node #24. Try simplifying control flow for better match */
                    return;
                }
                /* Duplicate return node #24. Try simplifying control flow for better match */
                return;
            }
            /* Duplicate return node #24. Try simplifying control flow for better match */
            return;
        }
    } else {
        arg0->unk4 = 0;
    default:
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800ADF48.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
? func_8009DFE0(?);                                 /* extern */
? func_800B6708();                                  /* extern */
? func_800CA330(?);                                 /* extern */
? func_800CA388(?);                                 /* extern */
s32 osPfsFindFile(? *, u16, s32, ? *, ? *, ? *);    /* extern */
? play_sound2(?, s32);                              /* extern */
extern ? D_8018E868;
extern ? D_8018EB84;
extern ? D_8018EE10;
static ? D_800F2E64;                                /* unable to generate initializer; const */
static ? D_800F2E74;                                /* unable to generate initializer; const */
s16 D_800DC5B8;                                     /* unable to generate initializer */
u16 D_800E86F0;                                     /* unable to generate initializer; const */

void func_800AE218(void *arg0) {
    s32 sp28;
    f64 temp_f0;
    f64 temp_f0_10;
    f64 temp_f0_11;
    f64 temp_f0_2;
    f64 temp_f0_3;
    f64 temp_f0_4;
    f64 temp_f0_5;
    f64 temp_f0_6;
    f64 temp_f0_7;
    f64 temp_f0_8;
    f64 temp_f0_9;
    s32 temp_a0_4;
    s32 temp_a1;
    s32 temp_a1_2;
    s32 temp_a1_3;
    s32 temp_t5;
    s32 temp_t6_2;
    s32 temp_t9;
    s32 temp_v0;
    s32 temp_v0_3;
    s32 temp_v0_4;
    s32 temp_v1;
    s32 temp_v1_2;
    s32 temp_v1_3;
    s32 temp_v1_4;
    s32 temp_v1_5;
    u16 temp_a0;
    u16 temp_a0_2;
    u16 temp_a0_3;
    u16 temp_a0_5;
    u16 temp_a0_6;
    void *temp_t0;
    void *temp_t2;
    void *temp_t6;
    void *temp_v0_2;
    void *temp_v0_5;
    void *temp_v0_6;
    s32 phi_a1;
    u16 phi_a0;
    s32 phi_v1;
    s32 phi_v1_2;
    s32 phi_a1_2;
    s32 phi_a1_3;
    u16 phi_a0_2;

    if (arg0->unk4 != 0) {
        D_800DC5B8 = 0;
    }
    switch (arg0->unk4) {                           /* switch 1 */
    case 0:                                         /* switch 1 */
        temp_v0 = arg0->unk1C;
        if (temp_v0 < 0x1E) {
            arg0->unk1C = temp_v0 + 1;
        }
        if ((D_800DC4BC->unk6 & 0x1000) != 0) {
            arg0->unk4 = 0xF;
            play_sound2(0x49008005);
            return;
        }
        if (D_8018CAE0 != 0) {
            arg0->unk4 = 1;
            arg0->unk1C = 0;
            return;
        }
    default:                                        /* switch 1 */
        return;
    case 1:                                         /* switch 1 */
        temp_t5 = arg0->unk1C + 3;
        arg0->unk1C = temp_t5;
        if (temp_t5 >= 0x8D) {
            arg0->unk4 = 0xF;
            return;
        }
        /* Duplicate return node #109. Try simplifying control flow for better match */
        return;
    case 11:                                        /* switch 1 */
    case 12:                                        /* switch 1 */
    case 13:                                        /* switch 1 */
    case 14:                                        /* switch 1 */
    case 15:                                        /* switch 1 */
    case 16:                                        /* switch 1 */
        if (func_800B4520() == 0) {
            temp_v0_2 = D_800DC4BC;
            temp_a0 = temp_v0_2->unk6;
            temp_a1 = temp_a0 | temp_v0_2->unkC;
            phi_a1 = temp_a1;
            phi_a0 = temp_a0;
            if ((temp_a1 & 0x800) != 0) {
                temp_v1 = arg0->unk4;
                if (temp_v1 >= 0xC) {
                    arg0->unk4 = temp_v1 - 1;
                    play_sound2(0x49008000, temp_a1);
                    temp_f0 = arg0->unk24;
                    if (temp_f0 < 4.2) {
                        arg0->unk24 = temp_f0 + 4.0;
                    }
                    arg0->unk8 = -1;
                    temp_t2 = D_800DC4BC;
                    temp_a0_2 = temp_t2->unk6;
                    phi_a1 = temp_a0_2 | temp_t2->unkC;
                    phi_a0 = temp_a0_2;
                }
            }
            if ((phi_a1 & 0x400) != 0) {
                temp_v1_2 = arg0->unk4;
                if (temp_v1_2 < 0x10) {
                    arg0->unk4 = temp_v1_2 + 1;
                    play_sound2(0x49008000, phi_a1);
                    temp_f0_2 = arg0->unk24;
                    if (temp_f0_2 < 4.2) {
                        arg0->unk24 = temp_f0_2 + 4.0;
                    }
                    arg0->unk8 = 1;
                    phi_a0 = D_800DC4BC->unk6;
                }
            }
            if ((phi_a0 & 0x9000) != 0) {
                if (arg0->unk4 == 0x10) {
                    temp_f0_3 = arg0->unk24;
                    phi_v1 = 0;
                    if (temp_f0_3 < 4.2) {
                        arg0->unk24 = temp_f0_3 + 4.0;
                    }
                    if (D_800E86F8 != 0) {
                        sp28 = 0;
                        temp_v0_3 = osPfsFindFile(&D_8018E868, D_800E86F0, D_800E86F4, &D_800F2E64, &D_800F2E74, &D_8018EB84);
                        if (temp_v0_3 != 0) {
                            if (temp_v0_3 != 2) {
                                if (temp_v0_3 != 5) {
                                    goto block_34;
                                }
                            } else {
block_34:
                                D_800E86F8 = 0;
                            }
                        } else {
                            func_800B6708();
                            arg0->unk4 = func_800B6348((gCupSelection * 4) + gCupCourseSelection) + 0x1E;
                            phi_v1 = 1;
                        }
                    }
                    if (phi_v1 != 0) {
                        play_sound2(0x49008001);
                        return;
                    }
                    if (D_800E86F8 == 0) {
                        sp28 = phi_v1;
                        temp_v0_4 = func_800B5F30();
                        phi_v1_2 = phi_v1;
                        switch (temp_v0_4) {        /* switch 2 */
                        case -1:                    /* switch 2 */
                            arg0->unk4 = 0x15;
                            phi_v1_2 = 1;
                            break;
                        case -3:                    /* switch 2 */
                        case -2:                    /* switch 2 */
                            arg0->unk4 = 0x16;
                            phi_v1_2 = 1;
                            break;
                        case 1:                     /* switch 2 */
                        case 11:                    /* switch 2 */
                            arg0->unk4 = 0x15;
                            phi_v1_2 = 1;
                            break;
                        case 10:                    /* switch 2 */
                            arg0->unk4 = 0x16;
                            phi_v1_2 = 1;
                            break;
                        default:                    /* switch 2 */
                            arg0->unk4 = 0x16;
                            phi_v1_2 = 1;
                            break;
                        }
                        if (phi_v1_2 != 0) {
                            play_sound2(0x4900FF07);
                            return;
                        }
                        if (osPfsFindFile(&D_8018E868, D_800E86F0, D_800E86F4, &D_800F2E64, &D_800F2E74, &D_8018EB84) == 0) {
                            func_800B6708();
                            arg0->unk4 = func_800B6348((gCupSelection * 4) + gCupCourseSelection) + 0x1E;
                            play_sound2(0x49008001);
                            return;
                        }
                        goto block_49;
                    }
block_49:
                    if (D_8018EB7C >= D_8018EB78) {
                        arg0->unk4 = 0x18;
                        play_sound2(0x4900FF07);
                        return;
                    }
                    if (D_8018EB80 >= 0x79) {
                        arg0->unk4 = 0x20;
                        arg0->unk1C = 0;
                        play_sound2(0x49008001);
                        return;
                    }
                    arg0->unk4 = 0x18;
                    play_sound2(0x4900FF07);
                    return;
                }
                func_8009DFE0(0x1E);
                play_sound2(0x49008016);
                func_800CA330(0x19);
                func_800CA388(0x19);
                temp_f0_4 = arg0->unk24;
                if (temp_f0_4 < 4.2) {
                    arg0->unk24 = temp_f0_4 + 4.0;
                    return;
                }
                /* Duplicate return node #109. Try simplifying control flow for better match */
                return;
            }
            /* Duplicate return node #109. Try simplifying control flow for better match */
            return;
        }
        /* Duplicate return node #109. Try simplifying control flow for better match */
        return;
    case 21:                                        /* switch 1 */
    case 22:                                        /* switch 1 */
    case 23:                                        /* switch 1 */
    case 24:                                        /* switch 1 */
    case 25:                                        /* switch 1 */
    case 26:                                        /* switch 1 */
    case 41:                                        /* switch 1 */
        if (((D_800DC4BC->unk6 & 0xD000) != 0) && (arg0->unk4 = 0x10, play_sound2(0x49008002), temp_f0_5 = arg0->unk24, (temp_f0_5 < 4.2))) {
            arg0->unk24 = temp_f0_5 + 4.0;
            return;
        }
        /* Duplicate return node #109. Try simplifying control flow for better match */
        return;
    case 30:                                        /* switch 1 */
    case 31:                                        /* switch 1 */
        arg0->unk20 = arg0->unk4 - 0x1E;
        if (func_800B639C((gCupSelection * 4) + gCupCourseSelection) != arg0->unk20) {
            temp_v0_5 = D_800DC4BC;
            temp_a1_2 = temp_v0_5->unk6 | temp_v0_5->unkC;
            phi_a1_2 = temp_a1_2;
            if ((temp_a1_2 & 0x800) != 0) {
                temp_v1_3 = arg0->unk4;
                if (temp_v1_3 >= 0x1F) {
                    arg0->unk4 = temp_v1_3 - 1;
                    play_sound2(0x49008000, temp_a1_2);
                    temp_f0_6 = arg0->unk24;
                    if (temp_f0_6 < 4.2) {
                        arg0->unk24 = temp_f0_6 + 4.0;
                    }
                    arg0->unk8 = -1;
                    temp_t0 = D_800DC4BC;
                    phi_a1_2 = temp_t0->unk6 | temp_t0->unkC;
                }
            }
            if ((phi_a1_2 & 0x400) != 0) {
                temp_v1_4 = arg0->unk4;
                if (temp_v1_4 < 0x1F) {
                    arg0->unk4 = temp_v1_4 + 1;
                    play_sound2(0x49008000, phi_a1_2);
                    temp_f0_7 = arg0->unk24;
                    if (temp_f0_7 < 4.2) {
                        arg0->unk24 = temp_f0_7 + 4.0;
                    }
                    arg0->unk8 = 1;
                }
            }
        }
        temp_a0_3 = D_800DC4BC->unk6;
        if ((temp_a0_3 & 0x4000) != 0) {
            arg0->unk4 = 0x10;
            play_sound2(0x49008002);
            return;
        }
        if ((temp_a0_3 & 0x9000) != 0) {
            temp_a0_4 = arg0->unk20;
            if (((temp_a0_4 << 7) + &D_8018EE10)->unk4 == 0) {
                arg0->unk4 = 0x28;
                arg0->unk1C = 0;
            } else if (func_800B63F0(temp_a0_4) == 0) {
                arg0->unk4 = 0x1A;
            } else {
                arg0->unk4 = 0x23;
            }
            play_sound2(0x49008001);
            temp_f0_8 = arg0->unk24;
            if (temp_f0_8 < 4.2) {
                arg0->unk24 = temp_f0_8 + 4.0;
                return;
            }
            /* Duplicate return node #109. Try simplifying control flow for better match */
            return;
        }
        /* Duplicate return node #109. Try simplifying control flow for better match */
        return;
    case 32:                                        /* switch 1 */
        if ((arg0->unk1C == 1) && (func_800B6A68() != 0)) {
            arg0->unk4 = 0x19;
            return;
        }
        temp_t9 = arg0->unk1C + 1;
        arg0->unk1C = temp_t9;
        if (temp_t9 >= 2) {
            arg0->unk4 = 0x1E;
            return;
        }
        /* Duplicate return node #109. Try simplifying control flow for better match */
        return;
    case 35:                                        /* switch 1 */
    case 36:                                        /* switch 1 */
        temp_v0_6 = D_800DC4BC;
        temp_a0_5 = temp_v0_6->unk6;
        temp_a1_3 = temp_a0_5 | temp_v0_6->unkC;
        phi_a1_3 = temp_a1_3;
        phi_a0_2 = temp_a0_5;
        if (((temp_a1_3 & 0x800) != 0) && (arg0->unk4 >= 0x24)) {
            arg0->unk4 = arg0->unk4 - 1;
            play_sound2(0x49008000, temp_a1_3);
            temp_f0_9 = arg0->unk24;
            if (temp_f0_9 < 4.2) {
                arg0->unk24 = temp_f0_9 + 4.0;
            }
            arg0->unk8 = -1;
            temp_t6 = D_800DC4BC;
            temp_a0_6 = temp_t6->unk6;
            phi_a1_3 = temp_a0_6 | temp_t6->unkC;
            phi_a0_2 = temp_a0_6;
        }
        if ((phi_a1_3 & 0x400) != 0) {
            temp_v1_5 = arg0->unk4;
            if (temp_v1_5 < 0x24) {
                arg0->unk4 = temp_v1_5 + 1;
                play_sound2(0x49008000, phi_a1_3);
                temp_f0_10 = arg0->unk24;
                if (temp_f0_10 < 4.2) {
                    arg0->unk24 = temp_f0_10 + 4.0;
                }
                arg0->unk8 = 1;
                phi_a0_2 = D_800DC4BC->unk6;
            }
        }
        if ((phi_a0_2 & 0x4000) != 0) {
            arg0->unk4 = arg0->unk20 + 0x1E;
            play_sound2(0x49008002);
            return;
        }
        if ((phi_a0_2 & 0x9000) != 0) {
            if (arg0->unk4 == 0x24) {
                arg0->unk4 = 0x28;
                arg0->unk1C = 0;
                play_sound2(0x49008001);
                temp_f0_11 = arg0->unk24;
                if (temp_f0_11 < 4.2) {
                    arg0->unk24 = temp_f0_11 + 4.0;
                    return;
                }
                /* Duplicate return node #109. Try simplifying control flow for better match */
                return;
            }
            arg0->unk4 = arg0->unk20 + 0x1E;
            play_sound2(0x49008002);
            return;
        }
        /* Duplicate return node #109. Try simplifying control flow for better match */
        return;
    case 40:                                        /* switch 1 */
        if (arg0->unk1C == 1) {
            if (osPfsFindFile(&D_8018E868, D_800E86F0, D_800E86F4, &D_800F2E64, &D_800F2E74, &D_8018EB84) != 0) {
                arg0->unk4 = 0x29;
                play_sound2(0x4900FF07);
                return;
            }
            if (func_800B6178(arg0->unk20) != 0) {
                arg0->unk4 = 0x29;
                play_sound2(0x4900FF07);
                return;
            }
            goto block_107;
        }
block_107:
        temp_t6_2 = arg0->unk1C + 1;
        arg0->unk1C = temp_t6_2;
        if (temp_t6_2 >= 2) {
            arg0->unk4 = 0x10;
        }
        /* Duplicate return node #109. Try simplifying control flow for better match */
        return;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800AE218.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
s32 get_string_width(? *);                             /* extern */
? func_800A9208(void *, ?);                         /* extern */
? func_800A94C8(void *, ?, ?);                      /* extern */
? func_800C90F4(?, s32);                            /* extern */

void func_800AEC54(void *arg0) {
    s32 temp_t5;
    s32 temp_t9;
    u32 temp_t6;

    temp_t6 = arg0->unk4;
    switch (temp_t6) {
    case 0:
        arg0->unkC = (get_string_width("NOW-MEET THE COURSE GHOST!!!") / 2) + 0x140;
        arg0->unk10 = 0xDA;
        arg0->unk4 = 1;
        func_800C90F4(0, (D_80162DE4 * 0x10) + 0x29008001);
        return;
    case 1:
        func_800A9208(arg0, 0xA0);
        if (arg0->unkC == 0xA0) {
            arg0->unk4 = 2;
            arg0->unk1C = 0;
            return;
        }
    default:
        return;
    case 2:
        temp_t5 = arg0->unk1C + 1;
        arg0->unk1C = temp_t5;
        if (temp_t5 >= 0x3D) {
            arg0->unk4 = 3;
            arg0->unk1C = 0;
            return;
        }
        /* Duplicate return node #12. Try simplifying control flow for better match */
        return;
    case 4:
        temp_t9 = arg0->unk1C + 1;
        arg0->unk1C = temp_t9;
        if (temp_t9 >= 6) {
            arg0->unk0 = 0;
            return;
        }
    case 3:
        func_800A94C8(arg0, 0xA0, -1);
        if (((arg0->unkC + 0x14) == -(get_string_width("NOW-MEET THE COURSE GHOST!!!") / 2)) && (arg0->unk4 == 3)) {
            arg0->unk4 = 4;
        }
        /* Duplicate return node #12. Try simplifying control flow for better match */
        return;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800AEC54.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_8009A594(s32, ?, s32, void *); // extern
s32 func_800B5B94(); // extern
? func_800B6708(); // extern
s32 segmented_to_virtual_dupe(s32, void *); // extern
extern ? D_800E7E34;
extern s8 D_8018EDF7;
extern ? D_8018EE10;
extern ? gCupCourseOrder;

void func_800AEDBC(void *arg0) {
    s8 temp_v0;
    s8 temp_v0_2;
    void *temp_a3;

    temp_v0 = D_8018EDF7;
    temp_a3 = arg0;
    if (temp_v0 != arg0->unk1C) {
        arg0->unk1C = temp_v0;
        temp_v0_2 = D_8018EDF7;
        arg0 = temp_a3;
        func_8009A594(arg0->unk18, 0, segmented_to_virtual_dupe(*(&D_800E7E34 + (*(&gCupCourseOrder + (((temp_v0_2 / 4) * 8) + ((temp_v0_2 % 4) * 2))) * 4)), temp_a3), arg0);
        if (func_800B5B94() == 0) {
            func_800B6708();
            return;
        }
        D_8018EE10.unk4 = 0;
        D_8018EE10.unk84 = 0;
        // Duplicate return node #4. Try simplifying control flow for better match
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800AEDBC.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern s8 D_8018EDEC;

void func_800AEE90(void *arg0) {
    if (D_8018EDEC != 0xB) {
        arg0->unk15 = 0;
        return;
    }
    arg0->unk15 = 1;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800AEE90.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern s8 D_8018EDEC;

void func_800AEEBC(void *arg0) {
    if (D_8018EDEC != 0xC) {
        arg0->unk15 = 0;
        return;
    }
    arg0->unk15 = 1;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800AEEBC.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern s8 D_8018EDEC;

void func_800AEEE8(void *arg0) {
    if (D_8018EDEC != 0xD) {
        arg0->unk15 = 0;
        return;
    }
    arg0->unk15 = 1;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800AEEE8.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 func_800B4E24(?); // extern
extern u32 D_8018CA78;
extern s8 D_8018CAE0;
extern s8 D_8018ED90;

void func_800AEF14(s32 *arg0) {
    if (D_8018CAE0 != 0) {
        if (D_8018CA78 < (func_800B4E24(4) & 0xFFFFF)) {
            D_8018ED90 = 1;
        }
        *arg0 = 0;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800AEF14.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern s32 D_80162DF8;
extern s8 D_8018CAE0;

void func_800AEF74(void *arg0) {
    s32 temp_v0;

    temp_v0 = arg0->unk4;
    if (temp_v0 != 0) {
        if (temp_v0 != 1) {
            if (temp_v0 != 2) {
                return;
            }
            // Duplicate return node #10. Try simplifying control flow for better match
            return;
        }
        arg0->unk1C = arg0->unk1C + 1;
        if (D_8018CAE0 == 1) {
            arg0->unk4 = 2;
        }
        // Duplicate return node #10. Try simplifying control flow for better match
        return;
    }
    if (D_80162DF8 == 1) {
        arg0->unk4 = 1;
        arg0->unk1C = 0;
        return;
    }
    if (D_8018CAE0 == 1) {
        arg0->unk4 = 2;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800AEF74.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
? func_8009DFE0(?);                                 /* extern */
? func_8009E650(s32, ?, ?, ?);                      /* extern */
? func_800CA330(?);                                 /* extern */
? func_800CA388(?);                                 /* extern */
? play_sound2(?);                                   /* extern */

void func_800AF004(void *arg0) {
    s32 temp_t1;
    s32 temp_t6_2;
    s32 temp_t8;
    u32 temp_t6;
    u32 temp_t9;
    void *temp_v0;

    temp_t6 = arg0->unk4;
    switch (temp_t6) {
    case 0:
        temp_t8 = arg0->unk1C + 3;
        arg0->unk1C = temp_t8;
        if (temp_t8 >= 0x65) {
            arg0->unk1C = 0;
            arg0->unk4 = 1;
            gCupSelection = gCupSelection % 4;
            gCCSelection = gCCSelection % 4;
            func_8009E650(0x12C, 0, 0, 4);
            return;
        }
    default:
        return;
    case 1:
    case 2:
    case 3:
    case 4:
        temp_t6_2 = arg0->unk1C + 1;
        arg0->unk1C = temp_t6_2;
        if (temp_t6_2 >= 9) {
            arg0->unk1C = 0;
            temp_t9 = arg0->unk4 + 1;
            arg0->unk4 = temp_t9;
            func_8009E650(temp_t9 + 0x12B, 0, 0, 4);
            return;
        }
        /* Duplicate return node #13. Try simplifying control flow for better match */
        return;
    case 5:
        temp_t1 = arg0->unk1C + 1;
        arg0->unk1C = temp_t1;
        if ((temp_t1 >= 0x65) && ((temp_v0 = D_800DC4CC, (temp_v0->unk6 != 0)) || (temp_v0->unkC != 0))) {
            arg0->unk4 = 6;
            arg0->unk1C = 0;
            if (D_802874F5 < 3) {
                play_sound2(0x49008016);
                return;
            }
            play_sound2(0x4900801B);
            return;
        }
        /* Duplicate return node #13. Try simplifying control flow for better match */
        return;
    case 6:
        func_8009DFE0(0x1E);
        func_800CA330(0x19);
        func_800CA388(0x19);
        arg0->unk4 = 7;
        /* Duplicate return node #13. Try simplifying control flow for better match */
        return;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800AF004.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800A91D8(s16, s16); // extern
extern ? D_800E7458;
extern ? D_800E7480;

void func_800AF1AC(void *arg0) {
    void *sp18;
    s32 temp_v0;
    s32 temp_v1;
    void *temp_v0_2;
    void *temp_v0_3;

    temp_v0 = arg0->unk4;
    temp_v1 = arg0->unk0 - 0x12C;
    if (temp_v0 != 0) {
        if (temp_v0 != 1) {
            if (temp_v0 != 2) {
                return;
            }
            // Duplicate return node #8. Try simplifying control flow for better match
            return;
        }
        temp_v0_2 = (temp_v1 * 8) + &D_800E7480;
        sp18 = temp_v0_2;
        func_800A91D8(temp_v0_2->unk0, temp_v0_2->unk2);
        if ((temp_v0_2->unk0 == arg0->unkC) && (temp_v0_2->unk2 == arg0->unk10)) {
            arg0->unk4 = 2;
        }
        return;
    }
    temp_v0_3 = (temp_v1 * 8) + &D_800E7458;
    arg0->unkC = temp_v0_3->unk0;
    arg0->unk4 = 1;
    arg0->unk10 = temp_v0_3->unk2;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800AF1AC.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
? func_8009A640(s32, ?, s32, s32);                  /* extern */
? func_800A91D8(void *, s16, s16);                  /* extern */
? func_800C90F4(?, s32);                            /* extern */
? func_800CA0A0();                                  /* extern */
? func_800CA0B8(? *, ? *);                          /* extern */
s32 segmented_to_virtual_dupe(s32, ? *);            /* extern */
extern ? D_8018DEE4;
extern ? D_802874D8;
static ? D_800E7458;                                /* unable to generate initializer; const */
static ? D_800E7480;                                /* unable to generate initializer; const */
static ? D_800E8380;                                /* unable to generate initializer; const */
static ? D_800E83A0;                                /* unable to generate initializer; const */
static ? D_800E8440;                                /* unable to generate initializer; const */
static ? D_800EFD64;                                /* unable to generate initializer; const */

void func_800AF270(void *arg0) {
    s32 sp30;
    void *sp20;
    s32 temp_t2;
    s32 temp_v1;
    s32 temp_v1_2;
    s8 temp_t6;
    s8 temp_v0;
    u32 temp_t8;
    void *temp_v0_2;
    void *temp_v0_3;

    temp_t6 = D_802874D8.unk1E;
    sp30 = temp_t6;
    temp_t8 = arg0->unk4;
    temp_v0 = *(&D_800EFD64 + temp_t6);
    temp_v1 = arg0->unk0 - 0x12C;
    switch (temp_t8) {
    case 0:
        temp_v0_2 = (temp_v1 * 8) + &D_800E7458;
        arg0->unkC = temp_v0_2->unk0;
        arg0->unk4 = 1;
        arg0->unk10 = temp_v0_2->unk2;
        return;
    case 1:
        temp_v0_3 = (temp_v1 * 8) + &D_800E7480;
        sp20 = temp_v0_3;
        func_800A91D8(arg0, temp_v0_3->unk0, temp_v0_3->unk2);
        if ((temp_v0_3->unk0 == arg0->unkC) && (temp_v0_3->unk2 == arg0->unk10)) {
            arg0->unk4 = 2;
            arg0->unk20 = 0;
            return;
        }
    default:
        return;
    case 2:
        temp_t2 = arg0->unk20 + 1;
        arg0->unk20 = temp_t2;
        if (temp_t2 >= 0x1F) {
            if (D_802874D8.unk1D >= 3) {
                arg0->unk4 = 4;
                func_800CA0B8(&D_800E8380, &D_802874D8);
                func_800C90F4(0, (sp30 * 0x10) + 0x29008003);
                func_800CA0A0();
                return;
            }
            arg0->unk4 = 3;
            func_8009A640(arg0->unk18, 0, sp30, segmented_to_virtual_dupe(*(&D_800E8380 + (temp_v0 * 4)), &D_802874D8));
            func_800CA0B8();
            func_800C90F4(0, (sp30 * 0x10) + 0x29008007);
            func_800CA0A0();
            return;
        }
        /* Duplicate return node #12. Try simplifying control flow for better match */
        return;
    case 3:
        temp_v1_2 = temp_v0 * 4;
        if (*(&D_8018DEE4 + (arg0->unk18 * 0x18)) >= *(&D_800E8440 + temp_v1_2)) {
            func_8009A640(arg0->unk18, 0, sp30, segmented_to_virtual_dupe(*(&D_800E83A0 + temp_v1_2), &D_802874D8));
            arg0->unk4 = 4;
        }
        /* Duplicate return node #12. Try simplifying control flow for better match */
        return;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800AF270.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800AF4DC(); // extern
? func_800AF740(); // extern
extern ? D_802850CC;

void func_800AF480(s32 *arg0) {
    s8 temp_v1;

    temp_v1 = *(&D_802850CC + ((*arg0 - 0x190) * 0x10));
    if ((temp_v1 == 0) || (temp_v1 != 1)) {
        func_800AF4DC();
        return;
    }
    func_800AF740();
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800AF480.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
? func_800A9208(void *, s32);                       /* extern */
? func_800A94C8(void *, s32, ?);                    /* extern */
static ? D_802850C0;                                /* unable to generate initializer */
static ? D_802854B0;                                /* unable to generate initializer */

void func_800AF4DC(void *arg0) {
    void *sp20;
    f64 temp_f0;
    s32 temp_t6;
    s32 temp_t6_2;
    s32 temp_v0;
    u32 temp_t9;
    void *temp_v1;

    temp_t9 = arg0->unk4;
    temp_v0 = arg0->unk0 - 0x190;
    temp_v1 = (temp_v0 * 0x10) + &D_802850C0;
    arg0->unk10 = temp_v1->unk6;
    switch (temp_t9) {
    case 0:
        arg0->unk4 = 1;
        arg0->unkC = temp_v1->unk4;
        sp20 = temp_v1;
        arg0->unk20 = ((get_string_width(*(&D_802854B0 + (temp_v0 * 4))) * temp_v1->unk0) / 2.0f) + temp_v1->unk8;
        /* fallthrough */
    case 1:
        func_800A9208(arg0, arg0->unk20);
        temp_t6 = (arg0->unk20 - arg0->unkC) / 4;
        arg0->unk1C = temp_t6;
        if (temp_t6 >= 9) {
            arg0->unk1C = 8;
        }
        arg0->unk24 = (arg0->unk1C * 0.05) + 1.0;
        if (arg0->unkC >= (arg0->unk20 - 0x14)) {
            arg0->unk4 = 2;
            arg0->unk18 = 0;
            return;
        }
    default:
        return;
    case 2:
        func_800A9208(arg0, arg0->unk20);
        temp_t6_2 = arg0->unk18 + 1;
        temp_f0 = temp_t6_2 - 0xA;
        arg0->unk1C = (arg0->unk20 - arg0->unkC) / 4;
        arg0->unk18 = temp_t6_2;
        arg0->unk24 = (temp_f0 * 0.0085 * temp_f0) + 0.4;
        if ((temp_t6_2 >= 9) && (arg0->unk24 > 1.0)) {
            arg0->unk4 = 3;
            arg0->unk24 = 1.0f;
            return;
        }
        /* Duplicate return node #14. Try simplifying control flow for better match */
        return;
    case 3:
        if (D_8018ED91 != 0) {
            arg0->unk4 = 4;
            return;
        }
        /* Duplicate return node #14. Try simplifying control flow for better match */
        return;
    case 4:
        func_800A94C8(arg0, arg0->unk20, 1);
        if (arg0->unk10 > 480.0) {
            arg0->unk0 = 0;
        }
        /* Duplicate return node #14. Try simplifying control flow for better match */
        return;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800AF4DC.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
? func_800A9208(void *, s32);                       /* extern */
? func_800A94C8(void *, s32, ?);                    /* extern */
static ? D_802850C0;                                /* unable to generate initializer */
static ? D_802854B0;                                /* unable to generate initializer */

void func_800AF740(void *arg0) {
    void *sp20;
    f64 temp_f0;
    s32 temp_t6;
    s32 temp_t6_2;
    s32 temp_v0;
    u32 temp_t9;
    void *temp_v1;

    temp_t9 = arg0->unk4;
    temp_v0 = arg0->unk0 - 0x190;
    temp_v1 = (temp_v0 * 0x10) + &D_802850C0;
    arg0->unk10 = temp_v1->unk6;
    switch (temp_t9) {
    case 0:
        arg0->unk4 = 1;
        arg0->unkC = temp_v1->unk4;
        sp20 = temp_v1;
        arg0->unk20 = temp_v1->unk8 - ((get_string_width(*(&D_802854B0 + (temp_v0 * 4))) * temp_v1->unk0) / 2.0f);
        /* fallthrough */
    case 1:
        func_800A9208(arg0, arg0->unk20);
        temp_t6 = (arg0->unkC - arg0->unk20) / 4;
        arg0->unk1C = temp_t6;
        if (temp_t6 >= 9) {
            arg0->unk1C = 8;
        }
        arg0->unk24 = (arg0->unk1C * 0.05) + 1.0;
        if ((arg0->unk20 + 0x14) >= arg0->unkC) {
            arg0->unk4 = 2;
            arg0->unk18 = 0;
            return;
        }
    default:
        return;
    case 2:
        func_800A9208(arg0, arg0->unk20);
        temp_t6_2 = arg0->unk18 + 1;
        temp_f0 = temp_t6_2 - 0xA;
        arg0->unk1C = (arg0->unkC - arg0->unk20) / 4;
        arg0->unk18 = temp_t6_2;
        arg0->unk24 = (temp_f0 * 0.0085 * temp_f0) + 0.4;
        if ((temp_t6_2 >= 9) && (arg0->unk24 > 1.0)) {
            arg0->unk4 = 3;
            arg0->unk24 = 1.0f;
            return;
        }
        /* Duplicate return node #14. Try simplifying control flow for better match */
        return;
    case 3:
        if (D_8018ED91 != 0) {
            arg0->unk4 = 4;
            return;
        }
        /* Duplicate return node #14. Try simplifying control flow for better match */
        return;
    case 4:
        func_800A94C8(arg0, arg0->unk20, -1);
        if (arg0->unk10 > 480.0) {
            arg0->unk0 = 0;
        }
        /* Duplicate return node #14. Try simplifying control flow for better match */
        return;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80091750/func_800AF740.s")
#endif
