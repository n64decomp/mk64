#include <ultra64.h>
#include <macros.h>
#include <math_util.h>
#include <variables.h>
#include <main.h>

// Location based from sm64.
// This may need to be moved before framebuffers.c
// If math_util has data that does not line-up with trig_tables.
#include "trig_tables.inc.c"

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_802B4F60(s32 arg0, ? arg2, ? arg3) {
    ? sp30;
    f32 sp2C;
    f32 sp1C;
    f32 temp_f2;
    ? phi_v0;

    vec3f_copy(&sp1C);
    temp_f2 = sp6C + ((sp3C * sp1C) + (sp4C * sp20) + (sp5C * sp24));
    sp2C = temp_f2;
    func_802B6434(sp1C, sp20, &sp1C, &sp30);
    phi_v0 = 1;
    if (temp_f2 <= 0.0f) {
        phi_v0 = 0;
    }
    return phi_v0;
}
#else
GLOBAL_ASM("asm/non_matchings/math_util/func_802B4F60.s")
#endif

s32 func_802B4FF8(Mat4 arg0, s32 arg1) {
    if (D_80150112 >= 0x80) {
        return 0;
    }
    func_802B75F8(&gGfxPool->mtxPool[D_80150112 + 0x32B], arg0);
    switch (arg1) {                                 /* irregular */
        case 0:
            gSPMatrix(gDisplayListHead++, VIRTUAL_TO_PHYSICAL(&gGfxPool->mtxPool[D_80150112 + 0x32B]), G_MTX_NOPUSH | G_MTX_LOAD | G_MTX_MODELVIEW);
            D_80150112 += 1;
            break;
        case 1:
            gSPMatrix(gDisplayListHead++, VIRTUAL_TO_PHYSICAL(&gGfxPool->mtxPool[D_80150112 + 0x32B]), G_MTX_PUSH | G_MTX_LOAD | G_MTX_MODELVIEW);
            D_80150112 += 1;
            break;
        case 3:
            gSPMatrix(gDisplayListHead++, VIRTUAL_TO_PHYSICAL(&gGfxPool->mtxPool[D_80150112 + 0x32B]), G_MTX_PUSH | G_MTX_MUL | G_MTX_MODELVIEW);
            D_80150112 += 1;
            break;
        case 2:
            gSPMatrix(gDisplayListHead++, VIRTUAL_TO_PHYSICAL(&gGfxPool->mtxPool[D_80150112 + 0x32B]), G_MTX_NOPUSH | G_MTX_MUL | G_MTX_MODELVIEW);
            D_80150112 += 1;
            break;
    }
    return 1;
}

f32 func_802B51E8(Vec3f arg0, Vec3f arg1) {
    f32 temp_f12;
    f32 temp_f14;
    f32 temp_f2;

    temp_f2 = arg1[0] - arg0[0];
    temp_f12 = arg1[1] - arg0[1];
    temp_f14 = arg1[2] - arg0[2];
    return (temp_f2 * temp_f2) + (temp_f12 * temp_f12) + temp_f14 + temp_f14;
}

u32 func_802B5224(Vec3f arg0, Vec3f arg1) {
    f32 temp_v1;
    f32 temp_v2;
    temp_v1 = arg1[0] - arg0[0];
    temp_v2 = arg1[2] - arg0[2];

    return func_802B7830(temp_v1, temp_v2);
}

u32 func_802B5258(Vec3f arg0, Vec3s arg1) {
    f32 temp_v1;
    f32 temp_v2;
    temp_v1 = arg1[0] - arg0[0];
    temp_v2 = arg1[2] - arg0[2];
    
    return func_802B7830(temp_v1, temp_v2);
}

/*
The difference between this and plain vec3f_copy is the return value.
_alternate returns nothing while plain _copy returns a local variable address
*/
void vec3f_set(Vec3f arg0, f32 arg1, f32 arg2, f32 arg3) {
    arg0[0] = arg1;
    arg0[1] = arg2;
    arg0[2] = arg3;
}

void vec3s_set(Vec3s arg0, s16 arg1, s16 arg2, s16 arg3) {
    arg0[0] = arg1;
    arg0[1] = arg2;
    arg0[2] = arg3;
}

// These functions have bogus return values.
// Disable the compiler warning.
#pragma GCC diagnostic push

#ifdef __GNUC__
#if defined(__clang__)
  #pragma GCC diagnostic ignored "-Wreturn-stack-address"
#else
  #pragma GCC diagnostic ignored "-Wreturn-local-addr"
#endif
#endif

void *vec3f_copy(Vec3f dest, Vec3f src) {
    dest[0] = src[0];
    dest[1] = src[1];
    dest[2] = src[2];
    return &dest; //! warning: function returns address of local variable
}

void vec3s_copy(Vec3s dest, Vec3s src) {
    dest[0] = src[0];
    dest[1] = src[1];
    dest[2] = src[2];
}

UNUSED void *sm64_vec3f_set(Vec3f dest, f32 x, f32 y, f32 z) {
    dest[0] = x;
    dest[1] = y;
    dest[2] = z;
    return &dest;
}

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
void func_802B5350(void *arg0, void *arg1) {
    s32 temp_v0;
    void *temp_a2;
    void *temp_v1;
    void *phi_a2;
    void *phi_v1;
    s32 phi_v0;

    phi_a2 = arg0;
    phi_v1 = arg1;
    phi_v0 = 0;
    do {
        temp_v0 = phi_v0 + 1;
        temp_v1 = phi_v1 + 0x10;
        temp_v1->unk-10 = phi_a2->unk0;
        temp_a2 = phi_a2 + 0x10;
        temp_v1->unk-C = phi_a2->unk4;
        temp_v1->unk-8 = temp_a2->unk-8;
        temp_v1->unk-4 = temp_a2->unk-4;
        phi_a2 = temp_a2;
        phi_v1 = temp_v1;
        phi_v0 = temp_v0;
    } while (temp_v0 != 4);
}
#else
GLOBAL_ASM("asm/non_matchings/math_util/func_802B5350.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
void func_802B5398(void *arg0, s32 *arg1, s32 arg2) {
    void *temp_a0;
    s32 *phi_a1;
    void *phi_a0;
    s32 phi_a2;

    phi_a1 = arg1;
    phi_a0 = arg0;
    phi_a2 = arg2 - 1;
    if (arg2 > 0) {
        do {
            temp_a0 = phi_a0 + 4;
            temp_a0->unk-4 = *phi_a1;
            phi_a1 += 4;
            phi_a0 = temp_a0;
            phi_a2 += -1;
        } while (phi_a2 > 0);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/math_util/func_802B5398.s")
#endif

void mtxf_identity(Mat4 mtx) {
    register s32 i;
    register s32 k;

    for (i = 0; i < 4; i++) {
        for (k = 0; k < 4; k++) {
            mtx[i][k] = (i == k) ? 1.0f : 0.0f;
        }
    } 
}

void func_802B5450(Mat4 arg0, Mat4 arg1, Mat4 arg2) {
    arg1[3][0] = arg0[3][0] + arg2[0][0];
    arg1[3][1] = arg0[3][1] + arg2[0][1];
    arg1[3][2] = arg0[3][2] + arg2[0][2];
    arg1[3][3] = arg0[3][3];
    arg1[0][0] = arg0[0][0];
    arg1[0][1] = arg0[0][1];
    arg1[0][2] = arg0[0][2];
    arg1[0][3] = arg0[0][3];
    arg1[1][0] = arg0[1][0];
    arg1[1][1] = arg0[1][1];
    arg1[1][2] = arg0[1][2];
    arg1[1][3] = arg0[1][3];
    arg1[2][0] = arg0[2][0];
    arg1[2][1] = arg0[2][1];
    arg1[2][2] = arg0[2][2];
    arg1[2][3] = arg0[2][3];
}

UNUSED void func_802B54EC(Mat4 arg0, Mat4 arg1, Mat4 arg2) {
    arg1[3][0] = arg0[3][0] + arg2[0][0];
    arg1[3][1] = arg0[3][1] + arg2[0][1];
    arg1[3][2] = arg0[3][2] + arg2[0][2];
}

void mtxf_translate(Mat4 dest, Vec3f b) {
    mtxf_identity(dest);
    dest[3][0] = b[0];
    dest[3][1] = b[1];
    dest[3][2] = b[2];
}

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
f32 cosf(f32, f32);                                 /* extern */
? mtxf_identity(f32);                               /* extern */
f32 sinf(f32);                                      /* extern */
static f64 D_802B9FB0 = 0.017453292222222222;

void func_802B5564(void *arg0, s16 *arg1, f32 arg2, f32 arg3, f32 arg4, f32 arg5, f32 arg6) {
    f32 sp20;
    f32 sp1C;
    f32 temp_f10;
    f32 temp_f10_2;
    f32 temp_f12;
    f32 temp_f12_2;
    f32 temp_f12_3;
    f32 temp_f12_4;
    f32 temp_f14;
    f32 temp_f14_2;
    f32 temp_f14_3;
    f32 temp_f14_4;
    f32 temp_f16;
    f32 temp_f16_2;
    f32 temp_f18;
    f32 temp_f2;
    f64 temp_f0;
    s32 temp_v1;
    u32 temp_t8;
    void *temp_v0;
    void *temp_v0_2;
    f32 phi_f10;
    void *phi_v0;
    f32 phi_f16;
    f32 phi_f12;
    f32 phi_f14;
    s32 phi_v1;
    f32 phi_f10_2;
    void *phi_v0_2;
    f32 phi_f16_2;
    f32 phi_f12_2;
    f32 phi_f14_2;

    temp_f14 = arg2;
    arg2 = temp_f14;
    mtxf_identity(temp_f14);
    temp_f14_2 = arg2 * D_802B9FB0;
    temp_f12 = temp_f14_2 / 2.0f;
    sp1C = temp_f12;
    sp20 = cosf(temp_f12, temp_f14_2);
    temp_f2 = sp20 / sinf(temp_f12);
    temp_f18 = arg4 + arg5;
    temp_f12_2 = arg4 - arg5;
    arg0->unk2C = -1.0f;
    arg0->unk14 = temp_f2;
    arg0->unk28 = temp_f18 / temp_f12_2;
    arg0->unk0 = temp_f2 / arg3;
    arg0->unk3C = 0.0f;
    arg0->unk38 = (2.0f * arg4 * arg5) / temp_f12_2;
    temp_f16 = arg0->unk4;
    temp_f10 = arg0->unk0 * arg6;
    temp_f12_3 = arg0->unk8;
    temp_f14_3 = arg0->unkC;
    phi_f10 = temp_f10;
    phi_v0 = arg0;
    phi_f16 = temp_f16;
    phi_f12 = temp_f12_3;
    phi_f14 = temp_f14_3;
    phi_v1 = 1;
    phi_f10_2 = temp_f10;
    phi_v0_2 = arg0;
    phi_f16_2 = temp_f16;
    phi_f12_2 = temp_f12_3;
    phi_f14_2 = temp_f14_3;
    if (1 != 4) {
        do {
            temp_f16_2 = phi_v0->unk14;
            temp_f12_4 = phi_v0->unk18;
            temp_v1 = phi_v1 + 1;
            temp_f14_4 = phi_v0->unk1C;
            phi_v0->unk0 = phi_f10;
            temp_f10_2 = phi_v0->unk10 * arg6;
            phi_v0->unk4 = phi_f16 * arg6;
            phi_v0->unk8 = phi_f12 * arg6;
            temp_v0 = phi_v0 + 0x10;
            temp_v0->unk-4 = phi_f14 * arg6;
            phi_f10 = temp_f10_2;
            phi_v0 = temp_v0;
            phi_f16 = temp_f16_2;
            phi_f12 = temp_f12_4;
            phi_f14 = temp_f14_4;
            phi_v1 = temp_v1;
            phi_f10_2 = temp_f10_2;
            phi_v0_2 = temp_v0;
            phi_f16_2 = temp_f16_2;
            phi_f12_2 = temp_f12_4;
            phi_f14_2 = temp_f14_4;
        } while (temp_v1 != 4);
    }
    temp_v0_2 = phi_v0_2 + 0x10;
    temp_v0_2->unk-10 = phi_f10_2;
    temp_v0_2->unk-C = phi_f16_2 * arg6;
    temp_v0_2->unk-8 = phi_f12_2 * arg6;
    temp_v0_2->unk-4 = phi_f14_2 * arg6;
    if (arg1 != 0) {
        temp_f0 = temp_f18;
        if (temp_f0 <= 2.0) {
            *arg1 = 0xFFFF;
            return;
        }
        temp_t8 = 131072.0 / temp_f0;
        *arg1 = temp_t8;
        if ((temp_t8 & 0xFFFF) <= 0) {
            *arg1 = 1;
        }
        /* Duplicate return node #7. Try simplifying control flow for better match */
    }
}
#else
GLOBAL_ASM("asm/non_matchings/math_util/func_802B5564.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
void func_802B5794(void *arg0, void *arg1, void *arg2) {
    f32 sp4C;
    f32 sp48;
    f32 sp30;
    f32 temp_f10;
    f32 temp_f12;
    f32 temp_f12_2;
    f32 temp_f14;
    f32 temp_f14_2;
    f32 temp_f16;
    f32 temp_f16_2;
    f32 temp_f16_3;
    f32 temp_f18;
    f32 temp_f18_2;
    f32 temp_f20;
    f32 temp_f20_2;
    f32 temp_f22;
    f32 temp_f22_2;
    f32 temp_f28;
    f32 temp_f2;
    f32 temp_f2_2;
    f32 temp_f6;

    temp_f12 = arg2->unk0 - arg1->unk0;
    temp_f14 = arg2->unk4 - arg1->unk4;
    temp_f2 = arg2->unk8 - arg1->unk8;
    temp_f16 = -1.0 / sqrtf((temp_f12 * temp_f12) + (temp_f14 * temp_f14) + (temp_f2 * temp_f2));
    temp_f12_2 = temp_f12 * temp_f16;
    temp_f14_2 = temp_f14 * temp_f16;
    temp_f2_2 = temp_f2 * temp_f16;
    temp_f16_2 = 0.0f - (1.0f * temp_f12_2);
    temp_f22 = 1.0 / sqrtf((temp_f2_2 * temp_f2_2) + 0.0f + (temp_f16_2 * temp_f16_2));
    temp_f28 = temp_f2_2 * temp_f22;
    temp_f18 = temp_f16_2 * temp_f22;
    temp_f6 = temp_f14_2 * temp_f18;
    sp30 = temp_f18;
    temp_f20 = temp_f6 - (temp_f2_2 * 0.0f);
    temp_f16_3 = (temp_f2_2 * temp_f28) - (temp_f12_2 * sp30);
    temp_f18_2 = (temp_f12_2 * 0.0f) - (temp_f14_2 * temp_f28);
    temp_f22_2 = 1.0 / sqrtf((temp_f20 * temp_f20) + (temp_f16_3 * temp_f16_3) + (temp_f18_2 * temp_f18_2));
    temp_f20_2 = temp_f20 * temp_f22_2;
    temp_f10 = temp_f18_2 * temp_f22_2;
    sp4C = temp_f16_3 * temp_f22_2;
    sp48 = temp_f10;
    arg0->unk0 = temp_f28;
    arg0->unk10 = 0.0f;
    arg0->unk20 = sp30;
    arg0->unk30 = -((arg1->unk8 * sp30) + ((arg1->unk0 * temp_f28) + (arg1->unk4 * 0.0f)));
    arg0->unk4 = temp_f20_2;
    arg0->unk24 = sp48;
    arg0->unk14 = sp4C;
    arg0->unk8 = temp_f12_2;
    arg0->unk18 = temp_f14_2;
    arg0->unk28 = temp_f2_2;
    arg0->unk34 = -((arg1->unk8 * sp48) + ((arg1->unk0 * temp_f20_2) + (arg1->unk4 * sp4C)));
    arg0->unkC = 0.0f;
    arg0->unk1C = 0.0f;
    arg0->unk2C = 0.0f;
    arg0->unk3C = 1.0f;
    arg0->unk38 = -((arg1->unk8 * temp_f2_2) + ((arg1->unk0 * temp_f12_2) + (arg1->unk4 * temp_f14_2)));
}
#else
GLOBAL_ASM("asm/non_matchings/math_util/func_802B5794.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
? mtxf_identity(void *);                            /* extern */
f32 sins(s32);                             /* extern */
f32 coss(s32);                             /* extern */

void func_802B59DC(void *arg0, s32 arg1) {
    f32 sp2C;
    f32 sp28;
    s32 sp24;
    f32 temp_f0;
    s32 temp_a0;

    temp_a0 = arg1 & 0xFFFF;
    sp24 = temp_a0;
    temp_f0 = sins(temp_a0);
    sp2C = temp_f0;
    sp28 = coss(temp_a0);
    mtxf_identity(arg0);
    arg0->unk18 = temp_f0;
    arg0->unk24 = -temp_f0;
    arg0->unk14 = sp28;
    arg0->unk28 = sp28;
}
#else
GLOBAL_ASM("asm/non_matchings/math_util/func_802B59DC.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
//This function did not have a glabel in the original assembly, as such it may
//be unused/unnamed
? mtxf_identity(void *);                            /* extern */
f32 sins(s32);                             /* extern */
f32 coss(s32);                             /* extern */

void func_802B5A44(void *arg0, s32 arg1) {
    f32 sp2C;
    f32 sp28;
    s32 sp24;
    f32 temp_f0;
    s32 temp_a0;

    temp_a0 = arg1 & 0xFFFF;
    sp24 = temp_a0;
    temp_f0 = sins(temp_a0);
    sp2C = temp_f0;
    sp28 = coss(temp_a0);
    mtxf_identity(arg0);
    arg0->unk20 = temp_f0;
    arg0->unk8 = -temp_f0;
    arg0->unk0 = sp28;
    arg0->unk28 = sp28;
}
#else
GLOBAL_ASM("asm/non_matchings/math_util/func_802B5A44.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
//This function did not have a glabel in the original assembly, as such it may
//be unused/unnamed
? mtxf_identity(void *);                            /* extern */
f32 sins(s32);                             /* extern */
f32 coss(s32);                             /* extern */

void func_802B5AAC(void *arg0, s32 arg1) {
    f32 sp2C;
    f32 sp28;
    s32 sp24;
    f32 temp_f0;
    s32 temp_a0;

    temp_a0 = arg1 & 0xFFFF;
    sp24 = temp_a0;
    temp_f0 = sins(temp_a0);
    sp2C = temp_f0;
    sp28 = coss(temp_a0);
    mtxf_identity(arg0);
    arg0->unk4 = temp_f0;
    arg0->unk10 = -temp_f0;
    arg0->unk0 = sp28;
    arg0->unk14 = sp28;
}
#else
GLOBAL_ASM("asm/non_matchings/math_util/func_802B5AAC.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
f32 sins(u16);                             /* extern */
f32 coss(u16);                             /* extern */

void func_802B5B14(void *arg0, void *arg1) {
    f32 sp70;
    f32 sp6C;
    f32 sp68;
    f32 sp60;
    f32 sp5C;
    f32 sp58;
    f32 sp50;
    f32 sp4C;
    f32 sp48;
    f32 sp40;
    f32 sp3C;
    f32 sp38;
    f32 sp30;
    f32 sp2C;
    f32 sp28;
    f32 temp_f0;
    f32 temp_f10;
    f32 temp_f12;
    f32 temp_f18;
    f32 temp_f20;
    f32 temp_f4;
    f32 temp_f6;

    sp38 = sins(arg1->unk0);
    temp_f20 = coss(arg1->unk0);
    sp30 = sins(arg1->unk2);
    sp2C = coss(arg1->unk2);
    sp28 = sins(arg1->unk4);
    temp_f0 = coss(arg1->unk4);
    temp_f4 = arg0->unk0;
    temp_f12 = sp38 * sp30;
    sp3C = temp_f4;
    sp40 = arg0->unk4;
    temp_f6 = (sp2C * temp_f0) + (temp_f12 * sp28);
    sp48 = temp_f6;
    sp58 = (-sp2C * sp28) + (temp_f12 * temp_f0);
    sp68 = temp_f20 * sp30;
    sp4C = temp_f20 * sp28;
    temp_f18 = sp38 * sp2C;
    sp5C = temp_f20 * temp_f0;
    sp6C = -sp38;
    temp_f10 = (-sp30 * temp_f0) + (temp_f18 * sp28);
    sp50 = temp_f10;
    sp60 = (sp30 * sp28) + (temp_f18 * temp_f0);
    sp70 = temp_f20 * sp2C;
    arg0->unk0 = (temp_f10 * sp40) + ((temp_f4 * temp_f6) + (sp40 * sp4C));
    arg0->unk4 = (sp60 * sp40) + ((temp_f4 * sp58) + (sp40 * sp5C));
    arg0->unk8 = (sp70 * sp40) + ((sp3C * sp68) + (sp40 * sp6C));
}
#else
GLOBAL_ASM("asm/non_matchings/math_util/func_802B5B14.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
f32 sins(s32);                             /* extern */
f32 coss(s32);                             /* extern */

void func_802B5CAC(u16 arg0, s32 arg1, void *arg2) {
    f32 sp2C;
    f32 sp28;
    f32 sp24;
    s32 sp1C;
    f32 temp_f10;
    s32 temp_a0;

    temp_a0 = arg1 & 0xFFFF;
    sp1C = temp_a0;
    sp2C = sins(temp_a0);
    sp28 = coss(temp_a0);
    sp1C = arg0;
    sp24 = sins(arg0);
    temp_f10 = sp28 * coss(arg0);
    arg2->unk0 = sp28 * sp24;
    arg2->unk4 = sp2C;
    arg2->unk8 = -temp_f10;
}
#else
GLOBAL_ASM("asm/non_matchings/math_util/func_802B5CAC.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
//This function did not have a glabel in the original assembly, as such it may
//be unused/unnamed
? func_802B5D64(?, s16, s16, ?);                    /* extern */

void func_802B5D30(s16 arg0, s16 arg1, ? arg2) {
    func_802B5D64(0x9000000, arg0, arg1, arg2);
}
#else
GLOBAL_ASM("asm/non_matchings/math_util/func_802B5D30.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
f32 sins(s32);                             /* extern */
f32 coss(s32);                             /* extern */
extern ? gSegmentTable;

void func_802B5D64(u32 arg0, u16 arg1, s32 arg2, s32 arg3) {
    f32 sp48;
    f32 sp44;
    f32 sp40;
    s8 sp2E;
    s8 sp2D;
    s8 sp2C;
    s32 sp20;
    f32 temp_f10;
    s32 temp_a0;
    s32 temp_a0_2;
    s32 temp_v0;
    s32 temp_v0_2;
    void *temp_s0;
    void *temp_s0_2;
    void *temp_s0_3;
    void *phi_s0;
    s32 phi_v0;
    void *phi_s0_2;
    s32 phi_v0_2;

    temp_a0 = arg2 & 0xFFFF;
    temp_s0 = *(&gSegmentTable + ((arg0 >> 0x18) * 4)) + (arg0 & 0xFFFFFF) + 0x80000000;
    sp20 = temp_a0;
    sp48 = sins(temp_a0);
    sp44 = coss(temp_a0);
    sp20 = arg1;
    sp40 = sins(arg1);
    temp_a0_2 = arg3 & 3;
    temp_f10 = sp44 * coss(arg1) * -120.0f;
    sp2C = sp44 * sp40 * 120.0f;
    sp2D = 120.0f * sp48;
    sp2E = temp_f10;
    phi_v0 = 0;
    phi_v0_2 = 0;
    if (arg3 > 0) {
        phi_s0 = temp_s0;
        phi_s0_2 = temp_s0;
        if (temp_a0_2 != 0) {
            do {
                temp_v0 = phi_v0 + 1;
                temp_s0_2 = phi_s0 + 0x18;
                temp_s0_2->unk-8 = sp2C;
                temp_s0_2->unk-7 = sp2D;
                temp_s0_2->unk-6 = sp2E;
                phi_s0 = temp_s0_2;
                phi_v0 = temp_v0;
                phi_s0_2 = temp_s0_2;
                phi_v0_2 = temp_v0;
            } while (temp_a0_2 != temp_v0);
            if (temp_v0 != arg3) {
                goto loop_4;
            }
        } else {
            do {
loop_4:
                temp_v0_2 = phi_v0_2 + 4;
                temp_s0_3 = phi_s0_2 + 0x60;
                temp_s0_3->unk-50 = sp2C;
                temp_s0_3->unk-4F = sp2D;
                temp_s0_3->unk-4E = sp2E;
                temp_s0_3->unk-38 = sp2C;
                temp_s0_3->unk-37 = sp2D;
                temp_s0_3->unk-36 = sp2E;
                temp_s0_3->unk-20 = sp2C;
                temp_s0_3->unk-1F = sp2D;
                temp_s0_3->unk-1E = sp2E;
                temp_s0_3->unk-8 = sp2C;
                temp_s0_3->unk-7 = sp2D;
                temp_s0_3->unk-6 = sp2E;
                phi_s0_2 = temp_s0_3;
                phi_v0_2 = temp_v0_2;
            } while (temp_v0_2 != arg3);
        }
    }
}
#else
GLOBAL_ASM("asm/non_matchings/math_util/func_802B5D64.s")
#endif

void func_802B5F00(Mat4 arg0, f32 arg1) {
    arg0[0][0] *= arg1;
    arg0[1][0] *= arg1;
    arg0[2][0] *= arg1;
    arg0[0][1] *= arg1;
    arg0[1][1] *= arg1;
    arg0[2][1] *= arg1;
    arg0[0][2] *= arg1;
    arg0[1][2] *= arg1;
    arg0[2][2] *= arg1;
}

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
f32 sins(u16);                             /* extern */
f32 coss(u16);                             /* extern */

void func_802B5F74(Mat4 arg0, Vec3f arg1, Vec3s arg2) {
    f32 sp3C;
    f32 sp34;
    f32 sp30;
    f32 sp2C;
    f32 temp_f0;
    f32 temp_f12;
    f32 temp_f12_2;
    f32 temp_f20;
    f32 temp_f6;

    sp3C = sins(arg2->unk0);
    temp_f20 = coss(arg2->unk0);
    sp34 = sins(arg2->unk2);
    sp30 = coss(arg2->unk2);
    sp2C = sins(arg2->unk4);
    temp_f0 = coss(arg2->unk4);
    temp_f12 = sp3C * sp34;
    temp_f6 = temp_f12 * temp_f0;
    arg0->unk0 = (sp30 * temp_f0) + (temp_f12 * sp2C);
    arg0->unk20 = temp_f20 * sp34;
    arg0->unk10 = (-sp30 * sp2C) + temp_f6;
    arg0->unk24 = -sp3C;
    temp_f12_2 = sp3C * sp30;
    arg0->unk4 = temp_f20 * sp2C;
    arg0->unk30 = arg1->unk0;
    arg0->unk14 = temp_f20 * temp_f0;
    arg0->unk34 = arg1->unk4;
    arg0->unk8 = (-sp34 * temp_f0) + (temp_f12_2 * sp2C);
    arg0->unk28 = temp_f20 * sp30;
    arg0->unk18 = (sp34 * sp2C) + (temp_f12_2 * temp_f0);
    arg0->unkC = 0.0f;
    arg0->unk1C = 0.0f;
    arg0->unk2C = 0.0f;
    arg0->unk3C = 1.0f;
    arg0->unk38 = arg1->unk8;
}
#else
GLOBAL_ASM("asm/non_matchings/math_util/func_802B5F74.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
//This function did not have a glabel in the original assembly, as such it may
//be unused/unnamed
f32 sins(u16);                             /* extern */
f32 coss(u16);                             /* extern */

void func_802B60B4(void *arg0, void *arg1, void *arg2) {
    f32 sp3C;
    f32 sp34;
    f32 sp30;
    f32 sp2C;
    f32 temp_f0;
    f32 temp_f12;
    f32 temp_f12_2;
    f32 temp_f20;
    f32 temp_f6;

    sp3C = sins(arg2->unk0);
    temp_f20 = coss(arg2->unk0);
    sp34 = sins(arg2->unk2);
    sp30 = coss(arg2->unk2);
    sp2C = sins(arg2->unk4);
    temp_f0 = coss(arg2->unk4);
    temp_f12 = sp3C * sp34;
    temp_f6 = temp_f12 * temp_f0;
    arg0->unk0 = (sp30 * temp_f0) + (temp_f12 * sp2C);
    arg0->unk8 = temp_f20 * sp34;
    arg0->unk4 = (-sp30 * sp2C) + temp_f6;
    arg0->unk10 = temp_f20 * sp2C;
    temp_f12_2 = sp3C * sp30;
    arg0->unk14 = temp_f20 * temp_f0;
    arg0->unkC = arg1->unk0;
    arg0->unk18 = -sp3C;
    arg0->unk1C = arg1->unk2;
    arg0->unk20 = (-sp34 * temp_f0) + (temp_f12_2 * sp2C);
    arg0->unk28 = temp_f20 * sp30;
    arg0->unk24 = (sp34 * sp2C) + (temp_f12_2 * temp_f0);
    arg0->unk30 = 0.0f;
    arg0->unk34 = 0.0f;
    arg0->unk38 = 0.0f;
    arg0->unk3C = 1.0f;
    arg0->unk2C = arg1->unk4;
}
#else
GLOBAL_ASM("asm/non_matchings/math_util/func_802B60B4.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
//This function did not have a glabel in the original assembly, as such it may
//be unused/unnamed
f32 sins(u16);                             /* extern */
f32 coss(u16);                             /* extern */

void func_802B6214(void *arg0, void *arg1, void *arg2) {
    f32 sp3C;
    f32 sp34;
    f32 sp30;
    f32 sp2C;
    f32 temp_f0;
    f32 temp_f12;
    f32 temp_f12_2;
    f32 temp_f20;
    f32 temp_f6;

    sp3C = sins(arg2->unk0);
    temp_f20 = coss(arg2->unk0);
    sp34 = sins(arg2->unk2);
    sp30 = coss(arg2->unk2);
    sp2C = sins(arg2->unk4);
    temp_f0 = coss(arg2->unk4);
    temp_f12 = sp3C * sp34;
    temp_f6 = temp_f12 * temp_f0;
    arg0->unk0 = (sp30 * temp_f0) + (temp_f12 * sp2C);
    arg0->unk20 = temp_f20 * sp34;
    arg0->unk10 = (-sp30 * sp2C) + temp_f6;
    arg0->unk4 = temp_f20 * sp2C;
    temp_f12_2 = sp3C * sp30;
    arg0->unk14 = temp_f20 * temp_f0;
    arg0->unk30 = arg1->unk0;
    arg0->unk24 = -sp3C;
    arg0->unk34 = arg1->unk2;
    arg0->unk8 = (-sp34 * temp_f0) + (temp_f12_2 * sp2C);
    arg0->unk28 = temp_f20 * sp30;
    arg0->unk18 = (sp34 * sp2C) + (temp_f12_2 * temp_f0);
    arg0->unkC = 0.0f;
    arg0->unk1C = 0.0f;
    arg0->unk2C = 0.0f;
    arg0->unk3C = 1.0f;
    arg0->unk38 = arg1->unk4;
}
#else
GLOBAL_ASM("asm/non_matchings/math_util/func_802B6214.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
//This function did not have a glabel in the original assembly, as such it may
//be unused/unnamed
void func_802B6374(void *arg0) {
    f32 temp_f0;
    f32 temp_f12;
    f32 temp_f14;
    f32 temp_f18;
    f32 temp_f2;

    temp_f12 = arg0->unk0;
    temp_f14 = arg0->unk4;
    temp_f2 = arg0->unk8;
    temp_f0 = sqrtf((temp_f2 * temp_f2) + ((temp_f12 * temp_f12) + (temp_f14 * temp_f14)));
    temp_f18 = temp_f14 / temp_f0;
    arg0->unk0 = temp_f12 / temp_f0;
    arg0->unk4 = temp_f18;
    arg0->unk8 = temp_f2 / temp_f0;
}
#else
GLOBAL_ASM("asm/non_matchings/math_util/func_802B6374.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
void func_802B63B8(void *arg0, void *arg1) {
    f32 temp_f12;
    f32 temp_f14;
    f32 temp_f16;
    f32 temp_f2;
    f32 temp_f6;

    temp_f12 = arg0->unk0;
    temp_f14 = arg0->unk4;
    temp_f2 = arg0->unk8;
    temp_f6 = arg1->unk18 * temp_f12;
    temp_f16 = (temp_f2 * arg1->unk14) + ((arg1->unkC * temp_f12) + (arg1->unk10 * temp_f14));
    arg0->unk0 = (temp_f2 * arg1->unk8) + ((arg1->unk0 * temp_f12) + (arg1->unk4 * temp_f14));
    arg0->unk4 = temp_f16;
    arg0->unk8 = (temp_f2 * arg1->unk20) + (temp_f6 + (arg1->unk1C * temp_f14));
}
#else
GLOBAL_ASM("asm/non_matchings/math_util/func_802B63B8.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
void func_802B6434(void *arg0, void *arg1) {
    f32 temp_f12;
    f32 temp_f14;
    f32 temp_f16;
    f32 temp_f2;
    f32 temp_f6;

    temp_f12 = arg0->unk0;
    temp_f14 = arg0->unk4;
    temp_f2 = arg0->unk8;
    temp_f6 = arg1->unk20 * temp_f12;
    temp_f16 = (temp_f2 * arg1->unk18) + ((arg1->unk10 * temp_f12) + (arg1->unk14 * temp_f14));
    arg0->unk0 = (temp_f2 * arg1->unk8) + ((arg1->unk0 * temp_f12) + (arg1->unk4 * temp_f14));
    arg0->unk4 = temp_f16;
    arg0->unk8 = (temp_f2 * arg1->unk28) + (temp_f6 + (arg1->unk24 * temp_f14));
}
#else
GLOBAL_ASM("asm/non_matchings/math_util/func_802B6434.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
//This function did not have a glabel in the original assembly, as such it may
//be unused/unnamed
void func_802B64B0(s32 arg0, ? arg1, ? arg2, ? arg3) {

}
#else
GLOBAL_ASM("asm/non_matchings/math_util/func_802B64B0.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
f32 sins(s32, void *);                     /* extern */
f32 coss(s32);                             /* extern */

void func_802B64C4(void *arg0, s32 arg1) {
    f32 sp2C;
    s32 sp18;
    f32 temp_f0;
    f32 temp_f10;
    f32 temp_f12;
    f32 temp_f2;
    f32 temp_f4;
    s32 temp_a0;
    void *temp_a2;

    temp_a2 = arg0;
    temp_a0 = arg1 & 0xFFFF;
    sp18 = temp_a0;
    arg0 = temp_a2;
    sp2C = sins(temp_a0, temp_a2);
    temp_f0 = coss(temp_a0);
    temp_f2 = arg0->unk0;
    temp_f12 = arg0->unk8;
    temp_f4 = temp_f0 * temp_f2;
    arg0->unk4 = arg0->unk4;
    temp_f10 = sp2C * temp_f2;
    arg0->unk0 = temp_f4 - (sp2C * temp_f12);
    arg0->unk8 = temp_f10 + (temp_f0 * temp_f12);
}
#else
GLOBAL_ASM("asm/non_matchings/math_util/func_802B64C4.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
? func_802B6A84(f32, ?, f32 *, s16, f32, ?, f32);   /* extern */
f32 func_802B7CE8(f32, f32, s32);                   /* extern */
f32 sins(u16);                             /* extern */
f32 coss(u16);                             /* extern */
static f64 D_802B9FB8 = 3.141592653589793;
static f64 D_802B9FC0 = 360.0;

void func_802B6540(void *arg0, f32 arg1, f32 arg2, f32 arg3, u16 arg4) {
    f32 spAC;
    f32 spA8;
    f32 spA4;
    f32 spA0;
    f32 sp9C;
    f32 sp98;
    f32 sp94;
    f32 sp90;
    f32 sp8C;
    f32 sp78;
    f32 sp68;
    f32 sp40;
    s32 sp38;
    f32 temp_f0;
    f32 temp_f0_2;
    s32 temp_a0;
    s32 temp_a0_2;
    s32 temp_v0;
    s32 temp_v0_2;
    s32 phi_a0;
    s32 phi_v0;
    f32 *phi_v1;
    s32 phi_a0_2;
    s32 phi_v0_2;
    f32 *phi_v1_2;
    f32 *phi_a3;
    f32 *phi_a3_2;

    sp38 = arg4;
    sp40 = sins(arg4);
    temp_f0 = coss(arg4);
    sp8C = temp_f0;
    spAC = temp_f0;
    sp94 = -sp40;
    sp9C = 1.0f;
    spA8 = 0.0f;
    spA0 = 0.0f;
    spA4 = sp40;
    sp98 = 0.0f;
    sp90 = 0.0f;
    if (arg2 == 1.0f) {
        phi_a0 = 0;
        phi_a3 = &sp68;
        do {
            phi_v0 = 0;
            phi_v1 = phi_a3;
loop_3:
            if ((phi_a0 * 4) == phi_v0) {
                *phi_v1 = 1.0f;
            } else {
                *phi_v1 = 0.0f;
            }
            temp_v0 = phi_v0 + 4;
            phi_v0 = temp_v0;
            phi_v1 += 4;
            if (temp_v0 != 0xC) {
                goto loop_3;
            }
            temp_a0 = phi_a0 + 1;
            phi_a0 = temp_a0;
            phi_a3 += 0xC;
        } while (temp_a0 != 3);
    } else {
        phi_a0_2 = 0;
        phi_a3_2 = &sp68;
        if (arg2 == -1.0f) {
            do {
                phi_v0_2 = 0;
                phi_v1_2 = phi_a3_2;
loop_12:
                if ((phi_a0_2 * 4) == phi_v0_2) {
                    *phi_v1_2 = 1.0f;
                } else {
                    *phi_v1_2 = 0.0f;
                }
                temp_v0_2 = phi_v0_2 + 4;
                phi_v0_2 = temp_v0_2;
                phi_v1_2 += 4;
                if (temp_v0_2 != 0xC) {
                    goto loop_12;
                }
                temp_a0_2 = phi_a0_2 + 1;
                phi_a0_2 = temp_a0_2;
                phi_a3_2 += 0xC;
            } while (temp_a0_2 != 3);
            sp78 = -1.0f;
        } else {
            temp_f0_2 = sqrtf((arg1 * arg1) + (arg3 * arg3));
            func_802B6A84(arg1, 0, &sp68, -(D_802B9FC0 - ((func_802B7CE8(arg2, 0.0f, 0) * 180.0f) / D_802B9FB8)), -arg3 / temp_f0_2, 0, arg1 / temp_f0_2);
        }
    }
    arg0->unk0 = (sp80 * sp94) + ((sp8C * sp68) + (sp90 * sp74));
    arg0->unkC = (sp80 * spA0) + ((sp98 * sp68) + (sp9C * sp74));
    arg0->unk18 = (sp80 * spAC) + ((spA4 * sp68) + (spA8 * sp74));
    arg0->unk4 = (sp84 * sp94) + ((sp8C * sp6C) + (sp90 * sp78));
    arg0->unk10 = (sp84 * spA0) + ((sp98 * sp6C) + (sp9C * sp78));
    arg0->unk1C = (sp84 * spAC) + ((spA4 * sp6C) + (spA8 * sp78));
    arg0->unk8 = (sp88 * sp94) + ((sp8C * sp70) + (sp90 * sp7C));
    arg0->unk14 = (sp88 * spA0) + ((sp98 * sp70) + (sp9C * sp7C));
    arg0->unk20 = (sp88 * spAC) + ((spA4 * sp70) + (spA8 * sp7C));
}
#else
GLOBAL_ASM("asm/non_matchings/math_util/func_802B6540.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
? func_802B6A84(f32, f32, f32 *, s16, f32, ?, f32); /* extern */
f32 func_802B7CE8(f32, f32, s32, f32 *);            /* extern */
static f64 D_802B9FC8 = 3.141592653589793;
static f64 D_802B9FD0 = 360.0;

void func_802B68F8(f32 *arg0, f32 arg1, f32 arg2, f32 arg3) {
    f32 temp_f0;
    f32 temp_f14;
    s32 temp_a0;
    s32 temp_a0_2;
    s32 temp_v0;
    s32 temp_v0_2;
    s32 phi_a0;
    s32 phi_v0;
    f32 *phi_v1;
    s32 phi_a0_2;
    s32 phi_v0_2;
    f32 *phi_v1_2;
    f32 *phi_a3;
    f32 *phi_a3_2;

    temp_f14 = arg1;
    if (arg2 == 1.0f) {
        phi_a0 = 0;
        phi_a3 = arg0;
        do {
            phi_v0 = 0;
            phi_v1 = phi_a3;
loop_3:
            if ((phi_a0 * 4) == phi_v0) {
                *phi_v1 = 1.0f;
            } else {
                *phi_v1 = 0.0f;
            }
            temp_v0 = phi_v0 + 4;
            phi_v0 = temp_v0;
            phi_v1 += 4;
            if (temp_v0 != 0xC) {
                goto loop_3;
            }
            temp_a0 = phi_a0 + 1;
            phi_a0 = temp_a0;
            phi_a3 += 0xC;
        } while (temp_a0 != 3);
        return;
    }
    phi_a0_2 = 0;
    phi_a3_2 = arg0;
    if (arg2 == -1.0f) {
        do {
            phi_v0_2 = 0;
            phi_v1_2 = phi_a3_2;
loop_12:
            if ((phi_a0_2 * 4) == phi_v0_2) {
                *phi_v1_2 = 1.0f;
            } else {
                *phi_v1_2 = 0.0f;
            }
            temp_v0_2 = phi_v0_2 + 4;
            phi_v0_2 = temp_v0_2;
            phi_v1_2 += 4;
            if (temp_v0_2 != 0xC) {
                goto loop_12;
            }
            temp_a0_2 = phi_a0_2 + 1;
            phi_a0_2 = temp_a0_2;
            phi_a3_2 += 0xC;
        } while (temp_a0_2 != 3);
        arg0->unk10 = -1.0f;
        return;
    }
    arg1 = temp_f14;
    temp_f0 = sqrtf((arg1 * arg1) + (arg3 * arg3));
    func_802B6A84(arg3, arg1, arg0, -(D_802B9FD0 - ((func_802B7CE8(arg2, temp_f14, 0, arg0) * 180.0f) / D_802B9FC8)), -arg3 / temp_f0, 0, arg1 / temp_f0);
}
#else
GLOBAL_ASM("asm/non_matchings/math_util/func_802B68F8.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
//This function did not have a glabel in the original assembly, as such it may
//be unused/unnamed
f32 sins(s32, void *);                     /* extern */
f32 coss(s32);                             /* extern */

void func_802B6A84(void *arg0, s32 arg1, f32 arg2, f32 arg3, f32 arg4) {
    f32 sp54;
    s32 sp34;
    f32 sp30;
    f32 sp2C;
    f32 temp_f0;
    f32 temp_f10;
    f32 temp_f12;
    f32 temp_f12_2;
    f32 temp_f14;
    f32 temp_f14_2;
    f32 temp_f16;
    f32 temp_f2;
    f32 temp_f2_2;
    f32 temp_f6;
    s32 temp_a0;
    void *temp_a2;

    temp_a2 = arg0;
    temp_a0 = arg1 & 0xFFFF;
    sp34 = temp_a0;
    arg0 = temp_a2;
    sp54 = sins(temp_a0, temp_a2);
    temp_f0 = coss(temp_a0);
    temp_f12 = arg2 * arg2;
    temp_f6 = 1.0f - temp_f0;
    arg0->unk0 = ((1.0f - temp_f12) * temp_f0) + temp_f12;
    sp34 = (bitwise s32) temp_f6;
    temp_f2 = arg3 * arg4 * temp_f6;
    temp_f14 = arg2 * sp54;
    temp_f16 = arg3 * arg3;
    arg0->unk1C = temp_f2 - temp_f14;
    arg0->unk14 = temp_f14 + temp_f2;
    arg0->unk10 = ((1.0f - temp_f16) * temp_f0) + temp_f16;
    sp2C = arg3 * sp54;
    temp_f10 = arg4 * arg2 * (bitwise f32) sp34;
    sp30 = temp_f10;
    arg0->unk18 = sp2C + temp_f10;
    temp_f12_2 = arg4 * arg4;
    arg0->unk8 = sp30 - sp2C;
    arg0->unk20 = ((1.0f - temp_f12_2) * temp_f0) + temp_f12_2;
    temp_f2_2 = arg2 * arg3 * (bitwise f32) sp34;
    temp_f14_2 = arg4 * sp54;
    arg0->unkC = temp_f2_2 - temp_f14_2;
    arg0->unk4 = temp_f14_2 + temp_f2_2;
}
#else
GLOBAL_ASM("asm/non_matchings/math_util/func_802B6A84.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
//This function did not have a glabel in the original assembly, as such it may
//be unused/unnamed
f32 sins(f32, s32, void *);                /* extern */
f32 coss(s32);                             /* extern */

void func_802B6BC0(void *arg0, s32 arg1, f32 arg2, f32 arg3, f32 arg4) {
    f32 sp3C;
    f32 sp30;
    s32 sp2C;
    f32 sp28;
    f32 sp24;
    f32 temp_f0;
    f32 temp_f12;
    f32 temp_f14;
    f32 temp_f18;
    f32 temp_f6;
    s32 temp_a0;
    void *temp_a2;

    temp_f14 = arg2;
    temp_a2 = arg0;
    temp_a0 = arg1 & 0xFFFF;
    sp2C = temp_a0;
    arg0 = temp_a2;
    arg2 = temp_f14;
    sp3C = sins(temp_f14, temp_a0, temp_a2);
    temp_f18 = coss(temp_a0);
    temp_f0 = sqrtf((arg2 * arg2) + (arg4 * arg4));
    if (temp_f0 != 0.0f) {
        temp_f12 = 1.0f / temp_f0;
        sp2C = (bitwise s32) -arg4;
        temp_f6 = sp3C * arg3;
        sp28 = temp_f6;
        sp30 = temp_f12;
        arg0->unk0 = (((bitwise f32) sp2C * temp_f18) - (sp28 * arg2)) * temp_f12;
        sp24 = temp_f18 * arg3;
        arg0->unk18 = -arg2;
        arg0->unkC = ((arg4 * sp3C) - (sp24 * arg2)) * temp_f12;
        arg0->unk4 = sp3C * temp_f0;
        arg0->unk10 = temp_f18 * temp_f0;
        arg0->unk1C = -arg3;
        arg0->unk8 = ((temp_f18 * arg2) - (temp_f6 * arg4)) * sp30;
        arg0->unk14 = ((-sp3C * arg2) - (sp24 * arg4)) * sp30;
        arg0->unkC = 0.0f;
        arg0->unk18 = 0.0f;
        arg0->unk24 = 0.0f;
        arg0->unk20 = sp2C;
        return;
    }
    arg0->unk4 = 0.0f;
    arg0->unk1C = 0.0f;
    arg0->unk8 = 0.0f;
    arg0->unk14 = 0.0f;
    arg0->unkC = 0.0f;
    arg0->unk18 = 0.0f;
    arg0->unk24 = 0.0f;
    arg0->unk0 = 1.0f;
    arg0->unk10 = 1.0f;
    arg0->unk20 = (bitwise s32) 1.0f;
}
#else
GLOBAL_ASM("asm/non_matchings/math_util/func_802B6BC0.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
//This function did not have a glabel in the original assembly, as such it may
//be unused/unnamed
f32 sins(s32);                             /* extern */
f32 coss(s32);                             /* extern */

void func_802B6D58(void *arg0, void *arg1, void *arg2) {
    f32 sp3C;
    f32 sp34;
    f32 sp30;
    f32 sp2C;
    f32 temp_f0;
    f32 temp_f0_2;
    f32 temp_f0_3;
    f32 temp_f0_4;
    f32 temp_f12;
    f32 temp_f12_2;
    f32 temp_f20;
    f32 temp_f6;

    sp3C = sins(arg2->unk0 & 0xFFFF);
    temp_f20 = coss(arg2->unk0 & 0xFFFF);
    temp_f0 = sins(arg2->unk4 & 0xFFFF);
    sp34 = temp_f0;
    temp_f0_2 = coss(arg2->unk4 & 0xFFFF);
    sp30 = temp_f0_2;
    temp_f0_3 = sins(arg2->unk8 & 0xFFFF);
    sp2C = temp_f0_3;
    temp_f0_4 = coss(arg2->unk8 & 0xFFFF);
    temp_f12 = sp3C * temp_f0;
    temp_f6 = temp_f12 * temp_f0_4;
    arg0->unk0 = (temp_f0_2 * temp_f0_4) + (temp_f12 * temp_f0_3);
    arg0->unk20 = temp_f20 * temp_f0;
    arg0->unk10 = (-temp_f0_2 * temp_f0_3) + temp_f6;
    arg0->unk24 = -sp3C;
    temp_f12_2 = sp3C * temp_f0_2;
    arg0->unk4 = temp_f20 * temp_f0_3;
    arg0->unk30 = arg1->unk0;
    arg0->unk14 = temp_f20 * temp_f0_4;
    arg0->unk34 = arg1->unk4;
    arg0->unk8 = (-temp_f0 * temp_f0_4) + (temp_f12_2 * temp_f0_3);
    arg0->unk28 = temp_f20 * temp_f0_2;
    arg0->unk18 = (temp_f0 * temp_f0_3) + (temp_f12_2 * temp_f0_4);
    arg0->unkC = 0.0f;
    arg0->unk1C = 0.0f;
    arg0->unk2C = 0.0f;
    arg0->unk3C = 1.0f;
    arg0->unk38 = arg1->unk8;
}
#else
GLOBAL_ASM("asm/non_matchings/math_util/func_802B6D58.s")
#endif

void func_802B71CC(Mat4 arg0, Mat4 arg1, Mat4 arg2) {
    Mat4 product;
    product[0][0] = (arg1[0][0] * arg2[0][0]) + (arg1[0][1] * arg2[1][0]) + (arg1[0][2] * arg2[2][0]) + (arg1[0][3] * arg2[3][0]);
    product[0][1] = (arg1[0][0] * arg2[0][1]) + (arg1[0][1] * arg2[1][1]) + (arg1[0][2] * arg2[2][1]) + (arg1[0][3] * arg2[3][1]);
    product[0][2] = (arg1[0][0] * arg2[0][2]) + (arg1[0][1] * arg2[1][2]) + (arg1[0][2] * arg2[2][2]) + (arg1[0][3] * arg2[3][2]);
    product[0][3] = (arg1[0][0] * arg2[0][3]) + (arg1[0][1] * arg2[1][3]) + (arg1[0][2] * arg2[2][3]) + (arg1[0][3] * arg2[3][3]);
    product[1][0] = (arg1[1][0] * arg2[0][0]) + (arg1[1][1] * arg2[1][0]) + (arg1[1][2] * arg2[2][0]) + (arg1[1][3] * arg2[3][0]);
    product[1][1] = (arg1[1][0] * arg2[0][1]) + (arg1[1][1] * arg2[1][1]) + (arg1[1][2] * arg2[2][1]) + (arg1[1][3] * arg2[3][1]);
    product[1][2] = (arg1[1][0] * arg2[0][2]) + (arg1[1][1] * arg2[1][2]) + (arg1[1][2] * arg2[2][2]) + (arg1[1][3] * arg2[3][2]);
    product[1][3] = (arg1[1][0] * arg2[0][3]) + (arg1[1][1] * arg2[1][3]) + (arg1[1][2] * arg2[2][3]) + (arg1[1][3] * arg2[3][3]);
    product[2][0] = (arg1[2][0] * arg2[0][0]) + (arg1[2][1] * arg2[1][0]) + (arg1[2][2] * arg2[2][0]) + (arg1[2][3] * arg2[3][0]);
    product[2][1] = (arg1[2][0] * arg2[0][1]) + (arg1[2][1] * arg2[1][1]) + (arg1[2][2] * arg2[2][1]) + (arg1[2][3] * arg2[3][1]);
    product[2][2] = (arg1[2][0] * arg2[0][2]) + (arg1[2][1] * arg2[1][2]) + (arg1[2][2] * arg2[2][2]) + (arg1[2][3] * arg2[3][2]);
    product[2][3] = (arg1[2][0] * arg2[0][3]) + (arg1[2][1] * arg2[1][3]) + (arg1[2][2] * arg2[2][3]) + (arg1[2][3] * arg2[3][3]);
    product[3][0] = (arg1[3][0] * arg2[0][0]) + (arg1[3][1] * arg2[1][0]) + (arg1[3][2] * arg2[2][0]) + (arg1[3][3] * arg2[3][0]);
    product[3][1] = (arg1[3][0] * arg2[0][1]) + (arg1[3][1] * arg2[1][1]) + (arg1[3][2] * arg2[2][1]) + (arg1[3][3] * arg2[3][1]);
    product[3][2] = (arg1[3][0] * arg2[0][2]) + (arg1[3][1] * arg2[1][2]) + (arg1[3][2] * arg2[2][2]) + (arg1[3][3] * arg2[3][2]);
    product[3][3] = (arg1[3][0] * arg2[0][3]) + (arg1[3][1] * arg2[1][3]) + (arg1[3][2] * arg2[2][3]) + (arg1[3][3] * arg2[3][3]);
    func_802B5398(arg0, product, 0x10);
}

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
void func_802B75F8(void *arg0, f32 *arg1) {
    s32 sp14;
    f32 *temp_a2;
    f32 temp_f18;
    f32 temp_f18_2;
    s32 *temp_a0;
    s32 temp_a3;
    void *temp_a2_2;
    void *temp_v0;
    void *temp_v0_2;
    void *temp_v1;
    void *temp_v1_2;
    void *temp_v1_3;
    f32 phi_f18;
    void *phi_v0;
    void *phi_v1;
    f32 *phi_a2;
    s32 phi_a3;
    f32 phi_f18_2;
    void *phi_v0_2;
    void *phi_v1_2;
    f32 *phi_a2_2;

    temp_v1 = arg0 + 0x20;
    temp_a0 = &sp14;
    temp_f18 = *arg1 * 65536.0f;
    phi_f18 = temp_f18;
    phi_v0 = arg0;
    phi_v1 = temp_v1;
    phi_a2 = arg1;
    phi_a3 = 4;
    phi_f18_2 = temp_f18;
    phi_v0_2 = arg0;
    phi_v1_2 = temp_v1;
    phi_a2_2 = arg1;
    if (4 != 0x10) {
        do {
            temp_a3 = phi_a3 + 4;
            temp_a2 = phi_a2 + 0x10;
            temp_v0 = phi_v0 + 8;
            temp_v1_2 = phi_v1 + 8;
            sp14 = phi_f18;
            temp_v0->unk-8 = temp_a0->unk0;
            temp_v1_2->unk-8 = temp_a0->unk2;
            sp14 = temp_a2->unk-C * 65536.0f;
            temp_v0->unk-6 = temp_a0->unk0;
            temp_v1_2->unk-6 = temp_a0->unk2;
            sp14 = temp_a2->unk-8 * 65536.0f;
            temp_v0->unk-4 = temp_a0->unk0;
            temp_v1_2->unk-4 = temp_a0->unk2;
            sp14 = temp_a2->unk-4 * 65536.0f;
            temp_v0->unk-2 = temp_a0->unk0;
            temp_v1_2->unk-2 = temp_a0->unk2;
            temp_f18_2 = temp_a2->unk0 * 65536.0f;
            phi_f18 = temp_f18_2;
            phi_v0 = temp_v0;
            phi_v1 = temp_v1_2;
            phi_a2 = temp_a2;
            phi_a3 = temp_a3;
            phi_f18_2 = temp_f18_2;
            phi_v0_2 = temp_v0;
            phi_v1_2 = temp_v1_2;
            phi_a2_2 = temp_a2;
        } while (temp_a3 != 0x10);
    }
    temp_a2_2 = phi_a2_2 + 0x10;
    temp_v0_2 = phi_v0_2 + 8;
    temp_v1_3 = phi_v1_2 + 8;
    sp14 = phi_f18_2;
    temp_v0_2->unk-8 = temp_a0->unk0;
    temp_v1_3->unk-8 = temp_a0->unk2;
    sp14 = temp_a2_2->unk-C * 65536.0f;
    temp_v0_2->unk-6 = temp_a0->unk0;
    temp_v1_3->unk-6 = temp_a0->unk2;
    sp14 = temp_a2_2->unk-8 * 65536.0f;
    temp_v0_2->unk-4 = temp_a0->unk0;
    temp_v1_3->unk-4 = temp_a0->unk2;
    sp14 = temp_a2_2->unk-4 * 65536.0f;
    temp_v0_2->unk-2 = temp_a0->unk0;
    temp_v1_3->unk-2 = temp_a0->unk2;
}
#else
GLOBAL_ASM("asm/non_matchings/math_util/func_802B75F8.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
extern u16 gArctanTable;
static f32 D_802B9FD8 = 1000000.0f;

u16 func_802B7790(f32 arg0, f32 arg1) {
    f32 temp_f0;

    if (arg1 == 0.0f) {
        return gArctanTable;
    }
    temp_f0 = arg0 / arg1;
    if (D_802B9FD8 < temp_f0) {
        if (arg0 > 0.0f) {
            return 0x4000;
        }
        return 0xC000;
    }
    return (&gArctanTable)[(temp_f0 * 1024.0f) + 0.5f];
}
#else
GLOBAL_ASM("asm/non_matchings/math_util/func_802B7790.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
s32 func_802B7790(f32, f32);                        /* extern */

s32 func_802B7830(f32 arg0, f32 arg1) {
    f32 temp_f20;
    f32 temp_f20_2;
    f32 temp_f22;
    s32 phi_v1;

    if (arg0 >= 0.0f) {
        if (arg1 >= 0.0f) {
            if (arg0 <= arg1) {
                phi_v1 = func_802B7790() & 0xFFFF;
            } else {
                phi_v1 = (0x4000 - func_802B7790(arg1, arg0)) & 0xFFFF;
            }
        } else {
            temp_f20 = -arg1;
            if (temp_f20 < arg0) {
                phi_v1 = (func_802B7790(temp_f20, arg0) + 0x4000) & 0xFFFF;
            } else {
                phi_v1 = (0x8000 - func_802B7790(arg0, temp_f20)) & 0xFFFF;
            }
        }
    } else {
        temp_f22 = -arg0;
        if (arg1 < 0.0f) {
            temp_f20_2 = -arg1;
            if (temp_f22 <= temp_f20_2) {
                phi_v1 = (func_802B7790(temp_f22, temp_f20_2) + 0x8000) & 0xFFFF;
            } else {
                phi_v1 = (0xC000 - func_802B7790(temp_f20_2, temp_f22)) & 0xFFFF;
            }
        } else if (arg1 < temp_f22) {
            phi_v1 = (func_802B7790(arg1, temp_f22) + 0xC000) & 0xFFFF;
        } else {
            phi_v1 = -func_802B7790(temp_f22, arg1) & 0xFFFF;
        }
    }
    return phi_v1;
}
#else
GLOBAL_ASM("asm/non_matchings/math_util/func_802B7830.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
//s16 func_802B7830();                                /* extern */

f32 func_802B79B8(f32 arg0) {
    return func_802B7830(arg0, 0.0f);
}
#else
GLOBAL_ASM("asm/non_matchings/math_util/func_802B79B8.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
//This function did not have a glabel in the original assembly, as such it may
//be unused/unnamed
static f32 D_802B9FDC = -0.01600503f;
static f32 D_802B9FE0 = 0.00283406f;
static f32 D_802B9FE4 = -0.07495445f;
static f32 D_802B9FE8 = 0.04258761f;
static f32 D_802B9FEC = -0.14202571f;
static f32 D_802B9FF0 = 0.10636754f;
static f32 D_802B9FF4 = -0.33333066f;
static f32 D_802B9FF8 = 0.19992484f;
static f64 D_802BA000 = 1.5707963267948966;
static f64 D_802BA008 = 1.5707963267948966;
static f32 D_802BA010 = 3.1415927f;

f32 func_802B79F0(f32 arg0, f32 arg1) {
    f32 temp_f0;
    f32 temp_f14;
    f32 temp_f16;
    f32 temp_f2;
    s32 phi_v0;
    f32 phi_f16;
    f32 phi_f2;

    phi_v0 = 0;
    phi_f16 = arg0 / arg1;
    if (fabs(arg1) < fabs(arg0)) {
        phi_v0 = 1;
    }
    if (phi_v0 != 0) {
        phi_f16 = arg1 / arg0;
    }
    temp_f0 = phi_f16 * phi_f16;
    temp_f2 = temp_f0 * temp_f0;
    temp_f16 = phi_f16 + (((((temp_f2 * (D_802B9FDC + (temp_f0 * D_802B9FE0))) + D_802B9FE4 + (temp_f0 * D_802B9FE8)) * (temp_f2 * temp_f2)) + ((D_802B9FEC + (temp_f0 * D_802B9FF0)) * temp_f2) + D_802B9FF4 + (temp_f0 * D_802B9FF8)) * (phi_f16 * temp_f0));
    if (phi_v0 != 0) {
        if (arg0 < 0.0f) {
            return -D_802BA000 - temp_f16;
        }
        return D_802BA008 - temp_f16;
    }
    if (arg1 >= 0.0f) {
        return temp_f16;
    }
    temp_f14 = D_802BA010;
    phi_f2 = temp_f16 + temp_f14;
    if (arg0 < 0.0f) {
        phi_f2 = temp_f16 - temp_f14;
    }
    return phi_f2;
}
#else
GLOBAL_ASM("asm/non_matchings/math_util/func_802B79F0.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
//This function did not have a glabel in the original assembly, as such it may
//be unused/unnamed
f32 func_802B79B8();                                /* extern */
static f64 D_802BA018 = 3.141592653589793;

s32 func_802B7B50(void) {
    return ((func_802B79B8() * 32768.0f) / D_802BA018) & 0xFFFF;
}
#else
GLOBAL_ASM("asm/non_matchings/math_util/func_802B7B50.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
//This function did not have a glabel in the original assembly, as such it may
//be unused/unnamed
//? func_802B79B8(?);                                 /* extern */

void func_802B7C18(void) {
    func_802B79B8(0x3F800000);
}
#else
GLOBAL_ASM("asm/non_matchings/math_util/func_802B7C18.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
s16 func_802B7830(?);                               /* extern */

s16 func_802B7C40(void) {
    return func_802B7830(0x3F800000);
}
#else
GLOBAL_ASM("asm/non_matchings/math_util/func_802B7C40.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
//This function did not have a glabel in the original assembly, as such it may
//be unused/unnamed
? func_802B79B8(f32);                               /* extern */

void func_802B7C6C(f32 arg0) {
    func_802B79B8(sqrtf(1.0 - (arg0 * arg0)));
}
#else
GLOBAL_ASM("asm/non_matchings/math_util/func_802B7C6C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
s16 func_802B7830(f32);                             /* extern */

s16 func_802B7CA8(f32 arg0) {
    return func_802B7830(sqrtf(1.0 - (arg0 * arg0)));
}
#else
GLOBAL_ASM("asm/non_matchings/math_util/func_802B7CA8.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
? func_802B79B8(f32, f32);                          /* extern */

void func_802B7CE8(f32 arg0) {
    func_802B79B8(sqrtf(1.0 - (arg0 * arg0)), arg0);
}
#else
GLOBAL_ASM("asm/non_matchings/math_util/func_802B7CE8.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
//This function did not have a glabel in the original assembly, as such it may
//be unused/unnamed
f32 func_802B79B8(f32, f32);                        /* extern */
static f64 D_802BA020 = 3.141592653589793;

s16 func_802B7D28(f32 arg0) {
    return (func_802B79B8(sqrtf(1.0 - (arg0 * arg0)), arg0) * 32768.0f) / D_802BA020;
}
#else
GLOBAL_ASM("asm/non_matchings/math_util/func_802B7D28.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
extern u16 D_802BA290;

u16 random_u16(void) {
    s32 temp_a1;
    s32 temp_t5;
    s32 temp_t8;
    s32 temp_v0_2;
    u16 temp_t4;
    u16 temp_v0;
    u16 phi_v0;

    temp_v0 = D_802BA290;
    phi_v0 = temp_v0;
    if (temp_v0 == 0x560A) {
        D_802BA290 = 0;
        phi_v0 = 0 & 0xFFFF;
    }
    temp_t8 = (phi_v0 << 8) ^ phi_v0;
    temp_a1 = temp_t8 & 0xFF;
    temp_t4 = (temp_a1 << 8) + ((temp_t8 & 0xFF00) >> 8);
    temp_t5 = ((temp_a1 * 2) ^ temp_t4) & 0xFFFF;
    D_802BA290 = temp_t4;
    if ((temp_t5 & 1) == 0) {
        temp_v0_2 = ((temp_t5 >> 1) ^ 0xFF80) & 0xFFFF;
        if (temp_v0_2 == 0xAA55) {
            D_802BA290 = 0;
        } else {
            D_802BA290 = temp_v0_2 ^ 0x1FF4;
        }
    } else {
        D_802BA290 = (temp_t5 >> 1) ^ 0xFF80 ^ 0x8180;
    }
    return D_802BA290;
}
#else
GLOBAL_ASM("asm/non_matchings/math_util/random_u16.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
u32 random_u16();                                   /* extern */
static f64 D_802BA028 = 65535.0;

s32 random_int(u16 arg0) {
    f64 temp_f8;
    f64 phi_f8;

    temp_f8 = arg0;
    phi_f8 = temp_f8;
    if (arg0 < 0) {
        phi_f8 = temp_f8 + 4294967296.0;
    }
    return ((random_u16() / D_802BA028) * phi_f8) & 0xFFFF;
}
#else
GLOBAL_ASM("asm/non_matchings/math_util/random_int.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
s16 func_802B7830(f32, f32);                        /* extern */

s16 func_802B7F34(f32 arg0, f32 arg1, f32 arg2, f32 arg3) {
    return func_802B7830(arg2 - arg0, arg3 - arg1);
}
#else
GLOBAL_ASM("asm/non_matchings/math_util/func_802B7F34.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
s16 func_802B7F34(f32, f32, ?32, ?32);              /* extern */

void func_802B7F7C(void *arg0, void *arg1, void *arg2) {
    f32 sp2C;
    f32 sp28;
    f32 sp24;
    ?32 sp20;
    ?32 sp1C;
    ?32 sp18;
    ?32 temp_f0;
    ?32 temp_f2;
    f32 temp_f12;
    f32 temp_f14;

    temp_f14 = arg0->unk0;
    sp28 = arg0->unk4;
    temp_f12 = arg0->unk8;
    temp_f2 = arg1->unk0;
    sp1C = arg1->unk4;
    temp_f0 = arg1->unk8;
    sp2C = temp_f14;
    sp24 = temp_f12;
    sp20 = temp_f2;
    sp18 = temp_f0;
    arg2->unk2 = func_802B7F34(temp_f12, temp_f14, temp_f0, temp_f2);
    arg2->unk0 = func_802B7F34(sp28, sp24, sp1C, temp_f0);
    arg2->unk4 = func_802B7F34(sp2C, sp28, sp20, sp1C);
}
#else
GLOBAL_ASM("asm/non_matchings/math_util/func_802B7F7C.s")
#endif

f32 sins(u16 arg0) {
    return gSineTable[arg0 >> 4];
}

f32 coss(u16 arg0) {
    return gCosineTable[arg0 >> 4];
}

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
? func_802B8058(s32 arg0, s32 arg1, s32 arg2) {
    s32 temp_t7;
    s32 temp_t8;
    s32 temp_v1;

    temp_v1 = arg0 & 0xFFFF;
    temp_t7 = arg1 & 0xFFFF;
    temp_t8 = arg2 & 0xFFFF;
    if (temp_t7 < temp_v1) {
        if (temp_t7 >= temp_t8) {
            return 0;
        }
        if (temp_t8 >= temp_v1) {
            return 0;
        }
        /* Duplicate return node #8. Try simplifying control flow for better match */
        return 1;
    }
    if ((temp_t7 >= temp_t8) && (temp_t8 >= temp_v1)) {
        return 0;
    }
    return 1;
}
#else
GLOBAL_ASM("asm/non_matchings/math_util/func_802B8058.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
s32 func_802B5224(f32, f32, u16);                   /* extern */
u16 func_802B7CA8(f32, f32);                        /* extern */
s32 func_802B8058(s32, s32, u16, u16);              /* extern */

f32 func_802B80D0(Vec3f arg0, Vec3f arg1, u16 arg2, f32 arg3, f32 arg4, f32 arg5) {
    u16 sp5E;
    u16 sp5A;
    s32 sp28;
    s32 sp24;
    s32 sp20;
    f32 temp_f0;
    f32 temp_f0_2;
    f32 temp_f14;
    f32 temp_f20;
    f32 temp_f2;
    f32 temp_f2_2;
    s32 temp_t6;
    s32 temp_t7;
    s32 temp_v1;
    s32 temp_v1_2;
    u16 temp_a2;
    u16 temp_a3;
    u16 temp_v0;

    temp_f14 = arg3;
    temp_f0 = arg1->unk0 - arg0->unk0;
    temp_a3 = arg2;
    temp_f0_2 = temp_f0 * temp_f0;
    if (arg5 < temp_f0_2) {
        return -1.0f;
    }
    temp_f2 = arg1->unk8 - arg0->unk8;
    temp_f2_2 = temp_f2 * temp_f2;
    if (arg5 < temp_f2_2) {
        return -1.0f;
    }
    temp_f20 = temp_f0_2 + temp_f2_2;
    if (temp_f20 < temp_f14) {
        return temp_f20;
    }
    if (arg5 < temp_f20) {
        return -1.0f;
    }
    arg2 = temp_a3;
    arg3 = temp_f14;
    temp_a2 = func_802B5224(arg5, temp_f14, temp_a3) & 0xFFFF;
    if (arg3 == 0.0f) {
        temp_v1 = (arg4 * 0xB6) & 0xFFFF;
        if (func_802B8058((arg2 + temp_v1) & 0xFFFF, (arg2 - temp_v1) & 0xFFFF, temp_a2, arg2) == 1) {
            return temp_f20;
        }
        return -1.0f;
    }
    temp_v1_2 = (arg4 * 0xB6) & 0xFFFF;
    temp_t7 = (arg2 - temp_v1_2) & 0xFFFF;
    temp_t6 = (arg2 + temp_v1_2) & 0xFFFF;
    sp24 = temp_t6;
    sp20 = temp_t7;
    sp5E = temp_a2;
    arg3 = arg3;
    if (func_802B8058(temp_t6, temp_t7, temp_a2, arg2) == 1) {
        return temp_f20;
    }
    temp_v0 = func_802B7CA8(arg3 / temp_f20, arg3);
    sp5A = temp_v0;
    sp28 = sp5E;
    if (func_802B8058(unksp26, unksp22, (sp5E + temp_v0) & 0xFFFF, sp5E) == 1) {
        return temp_f20;
    }
    if (func_802B8058(unksp26, unksp22, (sp5E - sp5A) & 0xFFFF, sp5E) == 1) {
        return temp_f20;
    }
    return -1.0f;
}
#else
GLOBAL_ASM("asm/non_matchings/math_util/func_802B80D0.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
//This function did not have a glabel in the original assembly, as such it may
//be unused/unnamed
? sins(s32);                               /* extern */
? coss(s32);                               /* extern */
extern ? gSegmentTable;

void func_802B8414(u32 arg0, void *arg1, u16 arg2, s32 arg3, s32 arg4) {
    f32 sp48;
    f32 sp44;
    f32 sp40;
    s8 sp3E;
    s8 sp3D;
    s8 sp3C;
    s32 sp20;
    s32 temp_a0;
    s32 temp_a1;
    s32 temp_v0;
    s32 temp_v0_2;
    void *temp_s0;
    void *temp_s0_2;
    void *temp_s0_3;
    void *phi_s0;
    s32 phi_v0;
    void *phi_s0_2;
    s32 phi_v0_2;

    temp_a0 = arg3 & 0xFFFF;
    temp_s0 = *(&gSegmentTable + ((arg0 >> 0x18) * 4)) + (arg0 & 0xFFFFFF) + 0x80000000;
    sp20 = temp_a0;
    sins(temp_a0);
    coss(temp_a0);
    sp20 = arg2;
    sins(arg2);
    coss(arg2);
    sp40 = 0.0f;
    sp44 = 0.0f;
    sp48 = 1.0f;
    temp_a1 = arg4 & 3;
    sp3C = ((arg1->unk20 * 1.0f) + ((sp40 * arg1->unk0) + (sp44 * arg1->unk10))) * 127.0f;
    sp3D = ((arg1->unk24 * 1.0f) + ((sp40 * arg1->unk4) + (sp44 * arg1->unk14))) * 127.0f;
    sp3E = ((arg1->unk28 * 1.0f) + ((sp40 * arg1->unk8) + (sp44 * arg1->unk18))) * 127.0f;
    phi_v0 = 0;
    phi_v0_2 = 0;
    if (arg4 > 0) {
        phi_s0 = temp_s0;
        phi_s0_2 = temp_s0;
        if (temp_a1 != 0) {
            do {
                temp_v0 = phi_v0 + 1;
                temp_s0_2 = phi_s0 + 0x18;
                temp_s0_2->unk-8 = sp3C;
                temp_s0_2->unk-7 = sp3D;
                temp_s0_2->unk-6 = sp3E;
                phi_s0 = temp_s0_2;
                phi_v0 = temp_v0;
                phi_s0_2 = temp_s0_2;
                phi_v0_2 = temp_v0;
            } while (temp_a1 != temp_v0);
            if (temp_v0 != arg4) {
                goto loop_4;
            }
        } else {
            do {
loop_4:
                temp_v0_2 = phi_v0_2 + 4;
                temp_s0_3 = phi_s0_2 + 0x60;
                temp_s0_3->unk-50 = sp3C;
                temp_s0_3->unk-4F = sp3D;
                temp_s0_3->unk-4E = sp3E;
                temp_s0_3->unk-38 = sp3C;
                temp_s0_3->unk-37 = sp3D;
                temp_s0_3->unk-36 = sp3E;
                temp_s0_3->unk-20 = sp3C;
                temp_s0_3->unk-1F = sp3D;
                temp_s0_3->unk-1E = sp3E;
                temp_s0_3->unk-8 = sp3C;
                temp_s0_3->unk-7 = sp3D;
                temp_s0_3->unk-6 = sp3E;
                phi_s0_2 = temp_s0_3;
                phi_v0_2 = temp_v0_2;
            } while (temp_v0_2 != arg4);
        }
    }
}
#else
GLOBAL_ASM("asm/non_matchings/math_util/func_802B8414.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 792017ad9d422c2467bd42686f383a5c41f41c75
UNUSED void func_802B8614(Player *player) {
    f64 sp78;
    f64 sp70;
    f64 sp68;
    f64 sp58;
    f64 sp50;
    f64 sp48;
    f64 sp40;
    f64 sp38;
    f64 temp_f12;
    f64 temp_f14;
    f64 temp_f16;
    f64 temp_f18;
    f64 temp_f20;
    f64 temp_f2;
    f64 temp_f30;
    f64 temp_f4;
    f64 temp_f6;

    temp_f6 = (f64) player->boundingBoxCorners[1].cornerX;
    sp78 = temp_f6;
    sp70 = (f64) player->boundingBoxCorners[1].cornerGroundY;
    sp68 = (f64) player->boundingBoxCorners[1].cornerZ;
    temp_f30 = (f64) player->boundingBoxCorners[0].cornerX;
    sp58 = (f64) player->boundingBoxCorners[0].cornerGroundY;
    sp50 = (f64) player->boundingBoxCorners[0].cornerZ;
    sp48 = (f64) player->boundingBoxCorners[3].cornerX;
    sp40 = (f64) player->boundingBoxCorners[3].cornerGroundY;
    temp_f4 = (f64) player->boundingBoxCorners[3].cornerZ;
    temp_f2 = sp58 - sp70;
    sp38 = temp_f4;
    temp_f12 = temp_f4 - sp50;
    temp_f14 = sp50 - sp68;
    temp_f16 = sp40 - sp58;
    temp_f18 = sp48 - temp_f30;
    temp_f20 = temp_f30 - temp_f6;
    if (0.0 == 0.0) {
        player->unk_058 = 0.0f;
        player->unk_060 = 0.0f;
        player->unk_05C = 1.0f;
        return;
    }
    player->unk_058 = (f32) ((f64) (f32) ((temp_f2 * temp_f12) - (temp_f14 * temp_f16)) / 0.0);
    player->unk_05C = (f32) ((f64) (f32) ((temp_f14 * temp_f18) - (temp_f20 * temp_f12)) / 0.0);
    player->unk_060 = (f32) ((f64) (f32) ((temp_f20 * temp_f16) - (temp_f2 * temp_f18)) / 0.0);
}
#else
GLOBAL_ASM("asm/non_matchings/math_util/func_802B8614.s")
#endif
