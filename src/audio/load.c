#include <ultra64.h>
#include <macros.h>

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? osPiStartDma(? *, ?, ?, s32, void *, u32, OSMesgQueue *); // extern
extern OSMesgQueue D_803B6720;
extern ? D_803B6740;

void func_800BAA80(s32 arg0, void *arg1, u32 arg2) {
    osInvalDCache(arg1, arg2);
    osPiStartDma(&D_803B6740, 1, 0, arg0, arg1, arg2, &D_803B6720);
    osRecvMesg(&D_803B6720, NULL, 1);
}
#else
GLOBAL_ASM("asm/non_matchings/audio/load/func_800BAA80.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? osPiStartDma(s32, ?, ?, s32, void *, u32, s32); // extern

void func_800BAAF8(s32 arg0, void *arg1, u32 arg2, s32 arg3, s32 arg4) {
    osInvalDCache(arg1, arg2);
    osPiStartDma(arg4, 0, 0, arg0, arg1, arg2, arg3);
}
#else
GLOBAL_ASM("asm/non_matchings/audio/load/func_800BAAF8.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? osPiStartDma(s32, ?, ?, s32, void *, u32, s32); // extern

void func_800BAB58(s32 *arg0, void **arg1, s32 *arg2, s32 arg3, s32 arg4) {
    s32 temp_v0;
    u32 phi_s0;

    temp_v0 = *arg2;
    phi_s0 = temp_v0;
    if (temp_v0 >= 0x1000) {
        phi_s0 = 0x1000;
    }
    *arg2 = temp_v0 - phi_s0;
    osInvalDCache(*arg1, phi_s0);
    osPiStartDma(arg4, 0, 0, *arg0, *arg1, phi_s0, arg3);
    *arg0 = *arg0 + phi_s0;
    *arg1 = *arg1 + phi_s0;
}
#else
GLOBAL_ASM("asm/non_matchings/audio/load/func_800BAB58.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern ? D_803B6758;
extern u32 D_803B6E58;
extern u32 D_803B6E5C;
extern s32 D_803B6E60;
extern ? D_803B6E68;
extern ? D_803B6F68;
extern u8 D_803B706A;
extern u8 D_803B706B;

void func_800BAC04(void) {
    u32 temp_v0;
    u32 temp_v0_2;
    u8 temp_t4;
    u8 temp_t6;
    u8 temp_t6_2;
    u8 temp_t8;
    u8 temp_v1;
    u8 temp_v1_2;
    u8 temp_v1_3;
    u8 temp_v1_4;
    ? *phi_a0;
    s8 phi_v0;
    void *phi_a0_2;
    s8 phi_v0_2;

    phi_a0 = &D_803B6758;
    phi_v0 = 0;
    if (D_803B6E5C != 0) {
        do {
            temp_v1 = phi_a0->unkE;
            temp_t6 = temp_v1 - 1;
            if (temp_v1 != 0) {
                phi_a0->unkE = temp_t6;
                if ((temp_t6 & 0xFF) == 0) {
                    temp_v1_2 = D_803B706A;
                    temp_t8 = D_803B706A;
                    *(&D_803B6E68 + temp_v1_2) = phi_v0;
                    D_803B706A = temp_v1_2 + 1;
                    phi_a0->unkD = temp_t8;
                }
            }
            temp_v0 = phi_v0 + 1;
            phi_a0 += 0x10;
            phi_v0 = temp_v0;
        } while (temp_v0 < D_803B6E5C);
    }
    phi_v0_2 = D_803B6E5C;
    if (D_803B6E5C < D_803B6E58) {
        phi_a0_2 = (D_803B6E5C * 0x10) + &D_803B6758;
        do {
            temp_v1_3 = phi_a0_2->unkE;
            temp_t4 = temp_v1_3 - 1;
            if (temp_v1_3 != 0) {
                phi_a0_2->unkE = temp_t4;
                if ((temp_t4 & 0xFF) == 0) {
                    temp_v1_4 = D_803B706B;
                    temp_t6_2 = D_803B706B;
                    *(&D_803B6F68 + temp_v1_4) = phi_v0_2;
                    D_803B706B = temp_v1_4 + 1;
                    phi_a0_2->unkD = temp_t6_2;
                }
            }
            temp_v0_2 = phi_v0_2 + 1;
            phi_a0_2 += 0x10;
            phi_v0_2 = temp_v0_2;
        } while (temp_v0_2 < D_803B6E58);
    }
    D_803B6E60 = 0;
}
#else
GLOBAL_ASM("asm/non_matchings/audio/load/func_800BAC04.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? osPiStartDma(void *, ?, ?, s32, s32, s32, ? *); // extern
extern ? D_803B6008;
extern ? D_803B6120;
extern ? D_803B6758;
extern u32 D_803B6E58;
extern u32 D_803B6E5C;
extern ? D_803B6E68;
extern ? D_803B6F68;
extern u8 D_803B7068;
extern u8 D_803B7069;
extern u8 D_803B706B;
extern s32 D_803B70BC;

s32 func_800BAD0C(s32 arg0, s32 arg1, s32 arg2, u8 *arg3) {
    void *sp40;
    s32 sp30;
    s32 temp_s0;
    s32 temp_t9;
    s32 temp_v0_2;
    s32 temp_v0_4;
    s32 temp_v1_6;
    u16 temp_v0_6;
    u32 temp_a1;
    u32 temp_a1_2;
    u32 temp_v1;
    u32 temp_v1_3;
    u32 temp_v1_4;
    u8 *temp_v0_3;
    u8 *temp_v0_5;
    u8 temp_a0;
    u8 temp_a1_3;
    u8 temp_a1_4;
    u8 temp_a3;
    u8 temp_t2;
    u8 temp_t2_2;
    u8 temp_v0;
    u8 temp_v1_2;
    u8 temp_v1_5;
    void *temp_t0;
    void *temp_t0_2;
    void *phi_t0;
    u32 phi_v1;
    void *phi_a0;
    u8 phi_v1_2;
    s32 phi_t3;
    void *phi_t0_2;
    s32 phi_t2;

    phi_t3 = 0;
    phi_t3 = 0;
    if ((arg2 != 0) || (temp_a1 = D_803B6E5C, temp_v0 = *arg3, phi_v1 = 0, ((temp_v0 < temp_a1) == 0))) {
        temp_a1_2 = D_803B6E58;
        temp_v1_3 = D_803B6E5C;
        phi_v1_2 = temp_v1_3;
        if (temp_v1_3 < temp_a1_2) {
            phi_a0 = (temp_v1_3 * 0x10) + &D_803B6758;
loop_4:
            temp_v0_4 = arg0 - phi_a0->unk4;
            if ((temp_v0_4 >= 0) && ((phi_a0->unkA - arg1) >= temp_v0_4)) {
                if (phi_a0->unkE == 0) {
                    temp_a1_3 = D_803B7069;
                    if (D_803B706B != temp_a1_3) {
                        temp_a3 = phi_a0->unkD;
                        temp_v0_5 = &D_803B6F68 + temp_a1_3;
                        if (temp_a1_3 != temp_a3) {
                            *(&D_803B6F68 + temp_a3) = *temp_v0_5;
                            (&D_803B6758 + (*temp_v0_5 * 0x10))->unkD = phi_a0->unkD;
                        }
                        D_803B7069 = temp_a1_3 + 1;
                    }
                }
                phi_a0->unkE = 0x3C;
                *arg3 = phi_v1_2;
                return (phi_a0->unk0 + arg0) - phi_a0->unk4;
            }
            temp_v1_4 = phi_v1_2 + 1;
            phi_a0 += 0x10;
            phi_v1_2 = temp_v1_4;
            if (temp_v1_4 >= temp_a1_2) {
                sp40 = phi_a0;
                goto block_14;
            }
            goto loop_4;
        }
block_14:
        temp_a1_4 = D_803B7069;
        phi_t0_2 = sp40;
        if ((D_803B706B != temp_a1_4) && (arg2 != 0)) {
            temp_t2 = *(&D_803B6F68 + temp_a1_4);
            D_803B7069 = temp_a1_4 + 1;
            sp30 = temp_t2;
            phi_t3 = 1;
            phi_t0_2 = &D_803B6758 + (temp_t2 * 0x10);
        }
        goto block_27;
    }
    temp_t0 = &D_803B6758 + (temp_v0 * 0x10);
    phi_t0 = temp_t0;
    phi_t0_2 = temp_t0;
    if (temp_a1 != 0) {
loop_19:
        temp_v1 = phi_v1 + 1;
        temp_v0_2 = arg0 - phi_t0->unk4;
        phi_v1 = temp_v1;
        if ((temp_v0_2 >= 0) && ((phi_t0->unkA - arg1) >= temp_v0_2)) {
            if (phi_t0->unkE == 0) {
                temp_v1_2 = D_803B7068;
                temp_a0 = phi_t0->unkD;
                temp_v0_3 = &D_803B6E68 + temp_v1_2;
                if (temp_v1_2 != temp_a0) {
                    *(&D_803B6E68 + temp_a0) = *temp_v0_3;
                    (&D_803B6758 + (*temp_v0_3 * 0x10))->unkD = phi_t0->unkD;
                }
                D_803B7068 = temp_v1_2 + 1;
            }
            phi_t0->unkE = 2;
            return (phi_t0->unk0 + arg0) - phi_t0->unk4;
        }
        temp_t0_2 = &D_803B6758 + (phi_v1 * 0x10);
        phi_t0 = temp_t0_2;
        phi_t0_2 = temp_t0_2;
        if (temp_v1 >= temp_a1) {
            goto block_27;
        }
        goto loop_19;
    }
block_27:
    phi_t2 = sp30;
    if (phi_t3 == 0) {
        temp_v1_5 = D_803B7068;
        temp_t2_2 = *(&D_803B6E68 + temp_v1_5);
        D_803B7068 = temp_v1_5 + 1;
        phi_t0_2 = &D_803B6758 + (temp_t2_2 * 0x10);
        phi_t2 = temp_t2_2;
    }
    temp_v0_6 = phi_t0_2->unkA;
    temp_s0 = arg0 & ~0xF;
    phi_t0_2->unkE = 2;
    phi_t0_2->unk4 = temp_s0;
    phi_t0_2->unk8 = temp_v0_6;
    temp_v1_6 = D_803B70BC;
    temp_t9 = temp_v1_6 * 0x18;
    D_803B70BC = temp_v1_6 + 1;
    sp30 = phi_t2;
    sp40 = phi_t0_2;
    osPiStartDma(temp_t9 + &D_803B6120, 0, 0, temp_s0, phi_t0_2->unk0, temp_v0_6, &D_803B6008);
    *arg3 = phi_t2;
    return (arg0 - temp_s0) + phi_t0_2->unk0;
}
#else
GLOBAL_ASM("asm/non_matchings/audio/load/func_800BAD0C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 func_800B8FFC(? *, s32, u32); // extern
extern ? D_803BFBE8;
extern ? D_803B6758;
extern u32 D_803B6E58;
extern u32 D_803B6E5C;
extern s8 D_803B6E68;
extern ? D_803B6F68;
extern s8 D_803B7068;
extern s8 D_803B7069;
extern s8 D_803B706A;
extern s8 D_803B706B;
extern s16 D_803B7088;
extern s32 D_803B70A8;
extern s32 D_803B70B0;

void func_800BB030(s32 arg0, u32 arg2) {
    s32 temp_a1;
    s32 temp_a1_2;
    s32 temp_s0;
    s32 temp_s0_3;
    s32 temp_v0;
    s32 temp_v0_3;
    s8 temp_v0_4;
    u32 temp_a1_3;
    u32 temp_a2;
    u32 temp_a2_2;
    u32 temp_a2_3;
    u32 temp_s0_2;
    u32 temp_s0_4;
    u32 temp_v0_2;
    u32 temp_v0_5;
    void *temp_v1;
    void *temp_v1_2;
    s32 phi_a1;
    u32 phi_a2;
    s32 phi_s0;
    s8 phi_s0_2;
    s8 *phi_v0;
    ? *phi_v1;
    void *phi_v0_2;
    s32 phi_a1_2;
    s32 phi_s0_3;
    u32 phi_a2_2;
    s8 phi_s0_4;
    s8 *phi_a0;
    s8 phi_v0_3;
    void *phi_v1_2;
    s32 phi_a3;
    void *phi_v0_4;
    u32 phi_a2_3;

    D_803B70A8 = 0x5A0;
    phi_a1 = 0x5A0;
    phi_a2 = arg2;
    phi_s0 = 0;
    phi_s0_3 = 0;
    if ((D_803B70B0 * 3 * D_803B7088) > 0) {
loop_1:
        temp_v0 = func_800B8FFC(&D_803BFBE8, phi_a1, phi_a2);
        temp_a2 = D_803B6E58;
        temp_v1 = &D_803B6758 + (temp_a2 * 0x10);
        temp_v1->unk0 = temp_v0;
        phi_a2 = temp_a2;
        if (temp_v0 == 0) {

        } else {
            temp_a1 = D_803B70A8;
            temp_s0 = phi_s0 + 1;
            temp_v1->unk4 = 0;
            temp_v1->unk8 = 0;
            temp_v1->unkC = 0;
            temp_v1->unkE = 0;
            D_803B6E58 = temp_a2 + 1;
            temp_v1->unkA = temp_a1;
            phi_a1 = temp_a1;
            phi_s0 = temp_s0;
            if (temp_s0 >= (D_803B70B0 * 3 * D_803B7088)) {

            } else {
                goto loop_1;
            }
        }
    }
    temp_a2_2 = D_803B6E58;
    phi_s0_2 = 0;
    phi_a2_2 = temp_a2_2;
    if (temp_a2_2 != 0) {
        phi_v0 = &D_803B6E68;
        phi_v1 = &D_803B6758;
        do {
            *phi_v0 = phi_s0_2;
            phi_v1->unkD = phi_s0_2;
            temp_s0_2 = phi_s0_2 + 1;
            phi_s0_2 = temp_s0_2;
            phi_v0 += 1;
            phi_v1 += 0x10;
        } while (temp_s0_2 < temp_a2_2);
    }
    phi_a3 = temp_a2_2;
    if (temp_a2_2 < 0x100) {
        phi_v0_2 = temp_a2_2 + &D_803B6E68;
        do {
            temp_v0_2 = phi_v0_2 + 1;
            temp_v0_2->unk-1 = 0;
            phi_v0_2 = temp_v0_2;
        } while (temp_v0_2 < &D_803B6F68);
    }
    D_803B7068 = 0;
    D_803B706A = temp_a2_2;
    D_803B6E5C = temp_a2_2;
    D_803B70A8 = 0x180;
    if (D_803B70B0 > 0) {
        phi_a1_2 = 0x180;
loop_13:
        temp_v0_3 = func_800B8FFC(&D_803BFBE8, phi_a1_2, D_803B6E58);
        temp_a2_3 = D_803B6E58;
        temp_s0_3 = phi_s0_3 + 1;
        temp_v1_2 = &D_803B6758 + (temp_a2_3 * 0x10);
        temp_v1_2->unk0 = temp_v0_3;
        phi_s0_3 = temp_s0_3;
        phi_a2_3 = temp_a2_3;
        if (temp_v0_3 == 0) {

        } else {
            temp_a1_2 = D_803B70A8;
            temp_v1_2->unk4 = 0;
            temp_v1_2->unk8 = 0;
            temp_v1_2->unkC = 0;
            temp_v1_2->unkE = 0;
            D_803B6E58 = temp_a2_3 + 1;
            temp_v1_2->unkA = temp_a1_2;
            phi_a1_2 = temp_a1_2;
            if (temp_s0_3 >= D_803B70B0) {
                phi_a2_3 = D_803B6E58;
            } else {
                goto loop_13;
            }
        }
        phi_a2_2 = phi_a2_3;
        phi_a3 = phi_a2_3;
    }
    temp_a1_3 = D_803B6E5C;
    phi_s0_4 = temp_a1_3;
    if (temp_a1_3 < phi_a2_2) {
        temp_v0_4 = temp_a1_3 * 0;
        phi_a0 = temp_v0_4 + &D_803B6F68;
        phi_v0_3 = temp_v0_4;
        phi_v1_2 = (temp_a1_3 * 0x10) + &D_803B6758;
        do {
            *phi_a0 = phi_s0_4;
            temp_s0_4 = phi_s0_4 + 1;
            phi_v1_2->unkD = phi_v0_3;
            phi_s0_4 = temp_s0_4;
            phi_a0 += 1;
            phi_v0_3 += 1;
            phi_v1_2 += 0x10;
        } while (temp_s0_4 < phi_a2_2);
    }
    if (phi_a3 < 0x100) {
        phi_v0_4 = phi_a3 + &D_803B6F68;
        do {
            temp_v0_5 = phi_v0_4 + 1;
            temp_v0_5->unk-1 = temp_a1_3;
            phi_v0_4 = temp_v0_5;
        } while (temp_v0_5 < &D_803B7068);
    }
    D_803B7069 = 0;
    D_803B706B = phi_a2_2 - temp_a1_3;
}
#else
GLOBAL_ASM("asm/non_matchings/audio/load/func_800BB030.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 func_800B8FFC(? *, s32, void *); // extern
? func_800BAA80(s32, s32, s32, void *); // extern
extern ? D_803BFBE8;

void func_800BB304(void *arg0) {
    s32 sp1C;
    s32 temp_a0;
    s32 temp_a1;
    s32 temp_a1_2;
    s32 temp_a2;
    s32 temp_v0;
    void *temp_a3;
    void *temp_a3_2;

    temp_a3 = arg0;
    if (arg0 == 0) {
        return;
    }
    if (temp_a3->unk1 == 1) {
        temp_a1 = temp_a3->unk10;
        arg0 = temp_a3;
        temp_v0 = func_800B8FFC(&D_803BFBE8, temp_a1, temp_a3);
        temp_a3_2 = arg0;
        temp_a1_2 = temp_v0;
        if (temp_v0 == 0) {
            return;
        }
        temp_a0 = temp_a3_2->unk4;
        temp_a2 = temp_a3_2->unk10;
        arg0 = temp_a3_2;
        sp1C = temp_a1_2;
        func_800BAA80(temp_a0, temp_a1_2, temp_a2, temp_a3_2);
        arg0->unk1 = 0x81;
        arg0->unk4 = temp_a1_2;
        // Duplicate return node #6. Try simplifying control flow for better match
    }
}
#else
GLOBAL_ASM("asm/non_matchings/audio/load/func_800BB304.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800BB304(s32); // extern
void *func_800BC948(); // extern
void *func_800BC9F8(?); // extern

void func_800BB388(s32 arg1, ? arg2) {
    void *sp1C;
    void *temp_ret;
    void *temp_v0;
    void *temp_v0_2;

    if (arg1 < 0x7F) {
        temp_ret = func_800BC948();
        temp_v0 = temp_ret;
        if (temp_v0 == 0) {
            return;
        }
        if (temp_v0->unk1 != 0) {
            sp1C = temp_v0;
            func_800BB304(temp_v0->unk8);
        }
        sp1C = temp_ret;
        func_800BB304(temp_ret->unk10);
        if (temp_ret->unk2 != 0x7F) {
            func_800BB304(temp_ret->unk18);
            return;
        }
        // Duplicate return node #11. Try simplifying control flow for better match
        return;
    }
    if (arg1 == 0x7F) {
        temp_v0_2 = func_800BC9F8(arg2);
        if (temp_v0_2 == 0) {
            return;
        }
        func_800BB304(temp_v0_2->unk4);
        // Duplicate return node #11. Try simplifying control flow for better match
    }
}
#else
GLOBAL_ASM("asm/non_matchings/audio/load/func_800BB388.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void func_800BB43C(void *arg0, s32 arg1) {
    s16 temp_v1;
    s32 temp_v0;
    void *phi_a2;
    s32 phi_v0;
    s32 phi_v1;

    temp_v1 = arg0->unk2;
    phi_a2 = arg0;
    phi_v0 = 0;
    phi_v1 = temp_v1;
    if (temp_v1 > 0) {
        do {
            temp_v0 = phi_v0 + 1;
            phi_v0 = temp_v0;
            if (phi_a2->unk8 != 0) {
                phi_a2->unk4 = phi_a2->unk4 + arg1;
                phi_v1 = arg0->unk2;
            }
            phi_a2 += 8;
        } while (temp_v0 < phi_v1);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/audio/load/func_800BB43C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 func_800B8FFC(? *, s32, s32); // extern
? func_800BAA80(s32, s32, s32, s32); // extern
extern ? D_803BFBE8;

void func_800BB484(void **arg0, s32 arg1, s32 arg2) {
    void *sp2C;
    s32 sp28;
    s32 sp24;
    s32 temp_a3_2;
    s32 temp_v0_2;
    u8 temp_a0;
    void *temp_a3;
    void *temp_v0;

    temp_v0 = *arg0;
    temp_a3 = temp_v0 + arg1;
    if (temp_v0 != 0) {
        *arg0 = temp_a3;
        temp_a0 = temp_a3->unk1;
        if (temp_a0 == 0) {
            temp_a3->unk4 = temp_a3->unk4 + arg2;
            temp_a3->unk8 = temp_a3->unk8 + arg1;
            temp_a3->unkC = temp_a3->unkC + arg1;
            temp_a3->unk1 = 1;
            return;
        }
        if (temp_a0 == 0x80) {
            temp_a3_2 = temp_a3->unk4 + arg2;
            sp28 = temp_a3_2;
            sp2C = temp_a3;
            temp_v0_2 = func_800B8FFC(&D_803BFBE8, temp_a3->unk10, temp_a3_2);
            if (temp_v0_2 == 0) {
                temp_a3->unk4 = temp_a3_2;
                temp_a3->unk1 = 1;
            } else {
                sp24 = temp_v0_2;
                sp2C = temp_a3;
                func_800BAA80(temp_a3_2, temp_v0_2, temp_a3->unk10, temp_a3_2);
                temp_a3->unk1 = 0x81;
                temp_a3->unk4 = temp_v0_2;
            }
            (temp_v0 + arg1)->unk8 = (temp_v0 + arg1)->unk8 + arg1;
            (temp_v0 + arg1)->unkC = (temp_v0 + arg1)->unkC + arg1;
        }
        // Duplicate return node #8. Try simplifying control flow for better match
    }
}
#else
GLOBAL_ASM("asm/non_matchings/audio/load/func_800BB484.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800BB624(s32, s32, u8, u8); // extern
extern s32 D_803B7074;
extern s32 D_803B7080;

void func_800BB584(s32 arg0) {
    s32 sp18;
    s32 temp_v1;
    s32 temp_v1_2;
    void *temp_v0;
    void *temp_v0_2;
    void *temp_v0_3;
    s32 phi_a1;

    temp_v1 = D_803B7074;
    temp_v0 = temp_v1 + (arg0 * 8);
    if (temp_v0->unk8 == 0) {
        phi_a1 = (temp_v1 + (temp_v0->unk4 * 8))->unk4;
    } else {
        phi_a1 = temp_v0->unk4;
    }
    temp_v1_2 = arg0 * 0xC;
    temp_v0_2 = D_803B7080 + temp_v1_2;
    sp18 = temp_v1_2;
    func_800BB624(temp_v0_2->unk4 - 4, phi_a1, temp_v0_2->unk1, temp_v0_2->unk2);
    temp_v0_3 = D_803B7080 + temp_v1_2;
    temp_v0_3->unk8 = temp_v0_3->unk4->unk-4;
}
#else
GLOBAL_ASM("asm/non_matchings/audio/load/func_800BB584.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800BB484(void *, void **, ?); // extern

void func_800BB624(void **arg0, ? arg1, s32 arg2, s32 arg3) {
    s32 temp_s2;
    void **temp_s2_2;
    void **temp_v0_2;
    void *temp_s0;
    void *temp_s0_2;
    void *temp_t2;
    void *temp_v0;
    void *temp_v0_3;
    s32 phi_s4;
    s32 phi_s2;
    void **phi_s2_2;

    temp_v0 = *arg0;
    if ((temp_v0 != 0) && (arg3 != 0)) {
        *arg0 = temp_v0 + arg0;
        phi_s2 = 0;
        if (arg3 != 0) {
            phi_s4 = 0;
            do {
                temp_v0_2 = *arg0 + phi_s4;
                temp_s0 = *temp_v0_2;
                temp_s0_2 = temp_s0 + arg0;
                if (temp_s0 != 0) {
                    *temp_v0_2 = temp_s0_2;
                    if (temp_s0_2->unk2 == 0) {
                        func_800BB484(temp_s0_2 + 4, arg0, arg1);
                        temp_s0_2->unk2 = 1;
                        temp_s0_2->unkC = temp_s0_2->unkC + arg0;
                    }
                }
                temp_s2 = phi_s2 + 1;
                phi_s4 += 4;
                phi_s2 = temp_s2;
            } while (temp_s2 != arg3);
        }
    }
    phi_s2_2 = arg0 + 4;
    if (arg2 != 0) {
        do {
            temp_v0_3 = *phi_s2_2;
            temp_t2 = temp_v0_3 + arg0;
            if (temp_v0_3 != 0) {
                *phi_s2_2 = temp_t2;
                if (temp_t2->unk0 == 0) {
                    func_800BB484(temp_t2 + 8, arg0, arg1);
                    func_800BB484(temp_t2 + 0x10, arg0, arg1);
                    func_800BB484(temp_t2 + 0x18, arg0, arg1);
                    temp_t2->unk0 = 1;
                    temp_t2->unk4 = temp_t2->unk4 + arg0;
                }
            }
            temp_s2_2 = phi_s2_2 + 4;
            phi_s2_2 = temp_s2_2;
        } while (((arg2 * 4) + arg0 + 4) != temp_s2_2);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/audio/load/func_800BB624.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 func_800B93BC(? *, ?, s32, ?, s32); // extern
? func_800BAA80(s32, s32, s32); // extern
? func_800BB584(s32); // extern
extern ? D_803AFE18;
extern ? D_803B03C0;
extern s32 D_803B7070;
extern s32 D_803B7080;

s32 func_800BB780(s32 arg0, ? arg1) {
    s32 sp54;
    s32 sp2C;
    s32 sp28;
    s32 temp_a2;
    s32 temp_v0_2;
    u8 *temp_v0_3;
    void *temp_v0;

    temp_v0 = D_803B7070 + (arg0 * 8);
    temp_a2 = ((temp_v0->unk8 + 0x1E) & ~0xF) - 0x10;
    sp54 = temp_a2;
    sp28 = temp_v0->unk4;
    temp_v0_2 = func_800B93BC(&D_803AFE18, 1, temp_a2, arg1, arg0);
    if (temp_v0_2 == 0) {
        return 0;
    }
    sp2C = temp_v0_2;
    func_800BAA80(sp28 + 0x10, temp_v0_2, temp_a2);
    (D_803B7080 + (arg0 * 0xC))->unk4 = sp2C + 4;
    func_800BB584(arg0);
    temp_v0_3 = arg0 + &D_803B03C0;
    if (*temp_v0_3 != 5) {
        *temp_v0_3 = 2;
    }
    return sp2C;
}
#else
GLOBAL_ASM("asm/non_matchings/audio/load/func_800BB780.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 func_800B93BC(? *, ?, s32, ?, s32); // extern
? func_800BAB58(void *, void *, void *, OSMesgQueue *, void *); // extern
extern ? D_803AFE18;
extern ? D_803B03C0;
extern s32 D_803B7070;
extern s32 D_803B7080;

s32 func_800BB864(s32 arg0, ? arg1, void *arg2) {
    s32 sp64;
    s32 sp3C;
    s32 sp38;
    OSMesgQueue *sp2C;
    OSMesgQueue *temp_a3;
    s32 temp_a2;
    s32 temp_v0_2;
    s32 temp_v1;
    u8 *temp_v0_3;
    void *temp_v0;

    temp_v0 = D_803B7070 + (arg0 * 8);
    temp_a2 = ((temp_v0->unk8 + 0x1E) & ~0xF) - 0x10;
    sp64 = temp_a2;
    sp38 = temp_v0->unk4;
    temp_v0_2 = func_800B93BC(&D_803AFE18, 1, temp_a2, arg1, arg0);
    sp3C = temp_v0_2;
    if (temp_v0_2 == 0) {
        return 0;
    }
    arg2->unk6 = arg0;
    temp_v1 = arg0 * 0xC;
    (D_803B7080 + temp_v1)->unk4 = temp_v0_2 + 4;
    temp_a3 = arg2 + 0x108;
    (D_803B7080 + temp_v1)->unk8 = 0;
    arg2->unk13C = temp_v0_2;
    arg2->unk144 = temp_a2;
    arg2->unk140 = sp38 + 0x10;
    sp2C = temp_a3;
    osCreateMesgQueue(temp_a3, arg2 + 0x120, 1);
    arg2->unk0 = arg2->unk0 | 8;
    func_800BAB58(arg2 + 0x140, arg2 + 0x13C, arg2 + 0x144, temp_a3, arg2 + 0x124);
    temp_v0_3 = arg0 + &D_803B03C0;
    if (*temp_v0_3 != 5) {
        *temp_v0_3 = 1;
    }
    return sp3C;
}
#else
GLOBAL_ASM("asm/non_matchings/audio/load/func_800BB864.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 func_800B93BC(? *, ?, s32, ?, s32); // extern
? func_800BAA80(s32, s32, s32); // extern
extern ? D_803AFC48;
extern ? D_803B0400;
extern s32 D_803B706C;

s32 func_800BB99C(s32 arg0, ? arg1) {
    s32 sp2C;
    s32 sp28;
    s32 sp24;
    s32 temp_t9;
    s32 temp_v0;
    u8 *temp_v0_3;
    void *temp_v0_2;

    temp_v0_2 = D_803B706C + (arg0 * 8);
    temp_t9 = (temp_v0_2->unk8 + 0xF) & ~0xF;
    sp2C = temp_t9;
    sp24 = temp_v0_2->unk4;
    temp_v0 = func_800B93BC(&D_803AFC48, 1, temp_t9, arg1, arg0);
    if (temp_v0 == 0) {
        return 0;
    }
    sp28 = temp_v0;
    func_800BAA80(sp24, temp_v0, sp2C);
    temp_v0_3 = arg0 + &D_803B0400;
    if (*temp_v0_3 != 5) {
        *temp_v0_3 = 2;
    }
    return temp_v0;
}
#else
GLOBAL_ASM("asm/non_matchings/audio/load/func_800BB99C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 func_800B93BC(? *, ?, s32, ?, s32); // extern
? func_800BAA80(s32, s32, s32); // extern
? func_800BAAF8(s32, s32, s32, OSMesgQueue *, void *); // extern
extern ? D_803AFC48;
extern ? D_803B0400;
extern s32 D_803B706C;

s32 func_800BBA50(s32 arg0, ? arg1, u8 *arg2) {
    s32 sp3C;
    OSMesgQueue *sp34;
    OSMesgQueue *temp_a3;
    s32 temp_a2;
    s32 temp_s0;
    s32 temp_v0;
    u8 *temp_v0_3;
    u8 *temp_v0_4;
    void *temp_v0_2;

    temp_v0_2 = D_803B706C + (arg0 * 8);
    temp_a2 = (temp_v0_2->unk8 + 0xF) & ~0xF;
    temp_s0 = temp_a2;
    sp3C = temp_v0_2->unk4;
    temp_v0 = func_800B93BC(&D_803AFC48, 1, temp_a2, arg1, arg0);
    if (temp_v0 == 0) {
        return 0;
    }
    if (temp_s0 < 0x41) {
        func_800BAA80(sp3C, temp_v0, temp_s0);
        temp_v0_3 = arg0 + &D_803B0400;
        if (*temp_v0_3 != 5) {
            *temp_v0_3 = 2;
        }
    } else {
        func_800BAA80(sp3C, temp_v0, 0x40);
        temp_a3 = arg2 + 0xD4;
        sp34 = temp_a3;
        osCreateMesgQueue(temp_a3, arg2 + 0xEC, 1);
        *arg2 = *arg2 | 0x10;
        func_800BAAF8(sp3C + 0x40, temp_v0 + 0x40, temp_s0 - 0x40, temp_a3, arg2 + 0xF0);
        temp_v0_4 = arg0 + &D_803B0400;
        if (*temp_v0_4 != 5) {
            *temp_v0_4 = 1;
        }
    }
    return temp_v0;
}
#else
GLOBAL_ASM("asm/non_matchings/audio/load/func_800BBA50.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 func_800B9A90(s32, ?, u8); // extern
extern ? D_803B03C0;
extern s32 D_803B7078;

s32 func_800BBBA0(s32 arg0, s32 *arg1, s32 *arg2) {
    s32 temp_v0;
    u16 temp_s1;
    u8 temp_s0;
    u8 temp_s2;
    u8 temp_t0;
    s32 phi_s1;
    s32 phi_v1;
    u8 phi_s2;
    s32 phi_s7;
    s32 phi_s7_2;

    *arg2 = 0;
    *arg1 = 0;
    temp_v0 = D_803B7078;
    temp_s1 = *(temp_v0 + (arg0 * 2));
    temp_s2 = *(temp_s1 + temp_v0);
    phi_s1 = (temp_s1 + 1) & 0xFFFF;
    phi_s2 = temp_s2;
    phi_s7 = 0;
    phi_s7_2 = 0;
    if (temp_s2 != 0) {
        do {
            temp_s0 = *(phi_s1 + D_803B7078);
            phi_s1 = (phi_s1 + 1) & 0xFFFF;
            phi_v1 = 0;
            if (((*(&D_803B03C0 + temp_s0) < 2) ^ 1) == 1) {
                phi_v1 = func_800B9A90(1, 2, temp_s0);
            }
            if (phi_v1 == 0) {
                *arg2 = *arg2 + 1;
                phi_s7_2 = temp_s0 & 0xFF;
            } else {
                *arg1 = *arg1 + 1;
            }
            temp_t0 = (phi_s2 - 1) & 0xFF;
            phi_s2 = temp_t0;
            phi_s7 = phi_s7_2;
        } while (temp_t0 != 0);
    }
    return phi_s7;
}
#else
GLOBAL_ASM("asm/non_matchings/audio/load/func_800BBBA0.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 func_800B9A90(s32, ?, u8); // extern
s32 func_800BB780(u8, ?); // extern
extern ? D_803B03C0;
extern s32 D_803B7078;

s32 func_800BBCD0(s32 arg0, s8 *arg1) {
    s32 sp34;
    s32 sp30;
    s32 temp_v0;
    u16 temp_s1;
    u8 temp_s0;
    u8 temp_s2;
    u8 temp_t6;
    s32 phi_s1;
    s32 phi_v1;
    u8 phi_s2;
    s32 phi_v1_2;

    temp_v0 = D_803B7078;
    temp_s1 = *(temp_v0 + (arg0 * 2));
    temp_s2 = *(temp_s1 + temp_v0);
    phi_s1 = (temp_s1 + 1) & 0xFFFF;
    phi_s2 = temp_s2;
    if (temp_s2 != 0) {
        do {
            temp_s0 = *(phi_s1 + D_803B7078);
            phi_s1 = (phi_s1 + 1) & 0xFFFF;
            phi_v1 = 0;
            if (((*(&D_803B03C0 + temp_s0) < 2) ^ 1) == 1) {
                phi_v1 = func_800B9A90(1, 2, temp_s0);
            }
            phi_v1_2 = phi_v1;
            if (phi_v1 == 0) {
                phi_v1_2 = func_800BB780(temp_s0, 2);
            }
            temp_t6 = (phi_s2 - 1) & 0xFF;
            phi_s2 = temp_t6;
        } while (temp_t6 != 0);
        sp34 = phi_v1_2;
        sp30 = temp_s0;
    }
    *arg1 = sp30;
    return sp34;
}
#else
GLOBAL_ASM("asm/non_matchings/audio/load/func_800BBCD0.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 func_800B9A90(?, ?, u32); // extern
s32 func_800BB99C(u32, ?, u32); // extern
? func_800BBCD0(u32, ? *, u32); // extern
extern s32 D_800EA5DC;
extern ? D_803B03C0;
extern s32 D_803B706C;
extern u16 D_803B707C;

void func_800BBDDC(u32 arg0, s32 arg1) {
    ? sp23;
    s32 sp1C;
    s32 temp_t6;
    void *temp_v0;
    u32 phi_a2;
    u32 phi_a2_2;
    s32 phi_v1;
    u32 phi_a2_3;

    temp_t6 = arg1 & 0xFF;
    phi_a2 = arg0;
    if (arg0 < D_803B707C) {
        temp_v0 = D_803B706C + (arg0 * 8);
        if (temp_v0->unk8 == 0) {
            phi_a2 = temp_v0->unk4;
        }
        D_800EA5DC = 0x19710515;
        phi_a2_2 = phi_a2;
        if ((temp_t6 & 2) != 0) {
            sp1C = temp_t6;
            arg0 = phi_a2;
            func_800BBCD0(phi_a2, &sp23, phi_a2);
            phi_a2_2 = arg0;
        }
        phi_a2_3 = phi_a2_2;
        if ((arg1 & 0xFF & 1) != 0) {
            phi_v1 = 0;
            if (((*(&D_803B03C0 + phi_a2_2) < 2) ^ 1) == 1) {
                arg0 = phi_a2_2;
                phi_v1 = func_800B9A90(0, 2, phi_a2_2);
                phi_a2_3 = arg0;
            }
            if ((phi_v1 == 0) && (func_800BB99C(phi_a2_3, 2, phi_a2_3) == 0)) {
                D_800EA5DC = 0x76557364;
                return;
            }
            goto block_11;
        }
block_11:
        D_800EA5DC = 0x76557364;
        // Duplicate return node #12. Try simplifying control flow for better match
    }
}
#else
GLOBAL_ASM("asm/non_matchings/audio/load/func_800BBDDC.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800BBF44(); // extern
extern s32 D_800EA5DC;

void func_800BBEF0(s32 arg2) {
    if (arg2 == 0) {
        D_800EA5DC = 0x19710515;
    }
    func_800BBF44();
    if (arg2 == 0) {
        D_800EA5DC = 0x76557364;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/audio/load/func_800BBEF0.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 func_800B9A90(?, ?, s8); // extern
s32 func_800BB864(s32, ?, void *); // extern
s32 func_800BB99C(s8, ?); // extern
s32 func_800BBA50(s8, ?, void *); // extern
s32 func_800BBBA0(s8, s32 *, s32 *); // extern
s32 func_800BBCD0(s8, void *, s32 *); // extern
? func_800BEF2C(void *); // extern
? func_800C11B0(s32); // extern
extern ? D_803B1510;
extern s32 D_803B706C;
extern u16 D_803B707C;

void func_800BBF44(s32 arg0, u32 arg1, s32 arg2) {
    s32 sp3C;
    s32 sp2C;
    s32 sp28;
    s32 sp24;
    s32 *temp_a1;
    s32 *temp_a2;
    s32 temp_a0;
    s32 temp_v0_2;
    s32 temp_v0_3;
    void *temp_s0;
    void *temp_v0;
    s8 phi_s1;
    s32 phi_v0;
    s32 phi_v1;

    phi_s1 = arg1;
    if (arg1 < D_803B707C) {
        temp_v0 = D_803B706C + (arg1 * 8);
        if (temp_v0->unk8 == 0) {
            phi_s1 = temp_v0->unk4;
        }
        temp_s0 = (arg0 * 0x148) + &D_803B1510;
        func_800BEF2C(temp_s0);
        temp_a1 = &sp28;
        temp_a2 = &sp2C;
        if (arg2 != 0) {
            sp2C = 0;
            sp28 = 0;
            temp_v0_2 = func_800BBBA0(phi_s1, temp_a1, temp_a2);
            temp_a0 = temp_v0_2;
            if (sp2C == 1) {
                sp24 = temp_v0_2;
                if (func_800BB864(temp_a0, 2, temp_s0) != 0) {
                    temp_s0->unk5 = sp24;
                    goto block_10;
                }
                // Duplicate return node #17. Try simplifying control flow for better match
                return;
            }
            if (func_800BBCD0(phi_s1, temp_s0 + 5) == 0) {
                return;
            }
            goto block_10;
        }
        if (func_800BBCD0(phi_s1, temp_s0 + 5, temp_a2) != 0) {
block_10:
            temp_s0->unk4 = phi_s1;
            temp_v0_3 = func_800B9A90(0, 2, phi_s1);
            phi_v1 = temp_v0_3;
            if (temp_v0_3 == 0) {
                if ((temp_s0->unk0 * 8) >= 0) {
                    if (arg2 != 0) {
                        phi_v0 = func_800BBA50(phi_s1, 2, temp_s0);
                    } else {
                        phi_v0 = func_800BB99C(phi_s1, 2);
                    }
                    phi_v1 = phi_v0;
                    if (phi_v0 != 0) {
                        goto block_16;
                    }
                }
            } else {
block_16:
                sp3C = phi_v1;
                func_800C11B0(arg0);
                temp_s0->unk88 = 0;
                temp_s0->unkE = 0;
                temp_s0->unk0 = temp_s0->unk0 | 0x80;
                temp_s0->unk14 = phi_v1;
                temp_s0->unk70 = phi_v1;
            }
        }
        // Duplicate return node #17. Try simplifying control flow for better match
    }
}
#else
GLOBAL_ASM("asm/non_matchings/audio/load/func_800BBF44.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
/*
Failed to decompile function audio_init:

Last instruction is missing a delay slot:
jr $ra
*/
#else
GLOBAL_ASM("asm/non_matchings/audio/load/audio_init.s")
#endif
