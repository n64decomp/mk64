#include <ultra64.h>
#include <macros.h>
#include <defines.h>
#include <functions.h>
#include "code_80071F00.h"

s32 find_unused_obj_index(s32* arg0) {
    s32 temp_v0;
    s32 temp_v1;

    temp_v1 = D_80183D5C;
    temp_v0 = 0; do
    {
        ++temp_v1;
        ++temp_v0;

        if (temp_v1 == 0x226) {
            temp_v1 = 0;
        }

    } while ((D_80165C18[temp_v1].unk_0CA != 0) && (temp_v0 != 0x226));

    D_80165C18[temp_v1].unk_0CA = 1;

    *arg0 = temp_v1;
    D_80183D5C = temp_v1;
    return temp_v1;
}

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80072428(s32, s32 *); // extern
extern ? D_80165CE2;

void func_80071F6C(s32 *arg0) {
    s32 *temp_a1;
    s32 temp_a0;

    temp_a1 = arg0;
    temp_a0 = *arg0;
    arg0 = temp_a1;
    func_80072428(temp_a0, temp_a1);
    *(&D_80165CE2 + (*arg0 * 0xE0)) = 0;
    *arg0 = -1;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80071F6C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 find_unused_obj_index(s32 *, s32); // extern

s32 func_80072044(s32* arg0, s32 *arg1, s32 arg2) {
    s32 sp24;
    s32 sp20;
    s32 temp_t0;
    s32 temp_v0;
    s32 temp_v0_2;
    s32 temp_v1;
    s32 *phi_a0;
    s32 phi_v1;
    s32 phi_v0;
    s32 phi_v1_2;
    s32 phi_a0_2;
    s32 phi_v0_2;
    s32 phi_v0_3;

    temp_v0 = *arg1;
    phi_v1 = 0;
    phi_v1_2 = 0;
    phi_v0_2 = temp_v0;
    if (temp_v0 >= arg2) {
        *arg1 = 0;
        phi_v0_2 = 0;
    }
    phi_a0 = (phi_v0_2 * 4) + arg0;
    phi_v0 = phi_v0_2;
    if (arg2 > 0) {
loop_3:
        temp_t0 = phi_v0 + 1;
        phi_v0_3 = temp_t0;
        if (*phi_a0 == -1) {
            sp24 = phi_v1;
            temp_v0_2 = find_unused_obj_index(phi_a0, -1);
            *arg1 = *arg1 + 1;
            sp20 = temp_v0_2;
            phi_v1_2 = phi_v1;
        } else {
            *arg1 = temp_t0;
            if (temp_t0 >= arg2) {
                *arg1 = 0;
                phi_v0_3 = 0;
            }
            temp_v1 = phi_v1 + 1;
            phi_a0 = (phi_v0_3 * 4) + arg0;
            phi_v1 = temp_v1;
            phi_v0 = phi_v0_3;
            phi_v1_2 = temp_v1;
            if (temp_v1 != arg2) {
                goto loop_3;
            }
        }
    }
    phi_a0_2 = sp20;
    if (phi_v1_2 == arg2) {
        phi_a0_2 = -1;
    }
    return phi_a0_2;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80072044.s")
#endif

void func_80071F6C(); // extern

void func_80072100(void) {
    func_80071F6C();
}

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800721E8(s32, ?); // extern

void func_80072120(s32 *arg0, s32 arg1) {
    s32 temp_s0;
    s32 *phi_s1;
    s32 phi_s0;

    phi_s1 = arg0;
    phi_s0 = 0;
    if (arg1 > 0) {
        do {
            func_800721E8(*phi_s1, 0x600000);
            temp_s0 = phi_s0 + 1;
            phi_s1 += 4;
            phi_s0 = temp_s0;
        } while (temp_s0 != arg1);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80072120.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern s32 D_80162DF8;

void func_80072180(void) {
    u16 temp_v0;

    if (gModeSelection == TIME_TRIALS) {
        temp_v0 = gPlayerOne->unk_000;
        if (((temp_v0 & 0x8000) != 0) && ((temp_v0 & 0x1100) == 0)) {
            D_80162DF8 = 1;
        }
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80072180.s")
#endif

void func_800721C0(s32 arg0, s32 arg1) {
    D_80165C18[arg0].unk_054 |= arg1;
}

void func_800721E8(s32 arg0, s32 arg1) {
    D_80165C18[arg0].unk_054 &= ~arg1;
}

UNUSED void func_80072214(s32 arg0, s32 arg1) {
    D_80165C18[arg0].unk_054 ^= arg1;
}

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern ? D_80165C6C;

? func_8007223C(s32 arg0, s32 arg1) {
    ? phi_v1;

    phi_v1 = 0;
    if ((*(&D_80165C6C + (arg0 * 0xE0)) & arg1) != 0) {
        phi_v1 = 1;
    }
    return phi_v1;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_8007223C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern ? D_80165C6C;

? func_80072270(s32 arg0, s32 arg1) {
    ? phi_v1;

    phi_v1 = 0;
    if ((*(&D_80165C6C + (arg0 * 0xE0)) & arg1) == 0) {
        phi_v1 = 1;
    }
    return phi_v1;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80072270.s")
#endif

void func_800722A4(s32 arg0, s32 arg1) {
    D_80165C18[arg0].unk_058 |= arg1;
}

void func_800722CC(s32 arg0, s32 arg1) {
    D_80165C18[arg0].unk_058 &= ~arg1;
}

UNUSED void func_800722F8(s32 arg0, s32 arg1) {
    D_80165C18[arg0].unk_058 ^= arg1;
}

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern ? D_80165C70;

? func_80072320(s32 arg0, s32 arg1) {
    ? phi_v1;

    phi_v1 = 0;
    if ((*(&D_80165C70 + (arg0 * 0xE0)) & arg1) != 0) {
        phi_v1 = 1;
    }
    return phi_v1;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80072320.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern ? D_80165C70;

? func_80072354(s32 arg0, s32 arg1) {
    ? phi_v1;

    phi_v1 = 0;
    if ((*(&D_80165C70 + (arg0 * 0xE0)) & arg1) == 0) {
        phi_v1 = 1;
    }
    return phi_v1;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80072354.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern ? D_80165CE3;

void func_80072388(s32 arg0, s8 arg1) {
    *(&D_80165CE3 + (arg0 * 0xE0)) = arg1;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80072388.s")
#endif

void func_800723A4(s32 arg0, s32 arg1) {
    D_80165C18[arg0].unk_054 = 0;
    D_80165C18[arg0].unk_058 = 0;
    D_80165C18[arg0].unk_05C = 0;
    D_80165C18[arg0].unk_0CD = 0;
    D_80165C18[arg0].unk_0CF = 0;
    func_80072388(arg0, 0);
    D_80165C18[arg0].unk_0D8 = arg1;
    D_80165C18[arg0].unk_0A6 = 1;
}

UNUSED void func_80072408(s32 arg0) {
    func_80072388(arg0, 0);
}

void func_80072428(s32 arg0) {
    D_80165C18[arg0].unk_0A6 = 0;
    D_80165C18[arg0].unk_0D8 = 0;
    func_80072388(arg0, 0);
    D_80165C18[arg0].unk_054 = 0;
    D_80165C18[arg0].unk_058 = 0;
    D_80165C18[arg0].unk_05C = 0;
    func_80086F60(arg0);
}

void func_80072488(s32 arg0) {
    func_80072388(arg0,  0);
    func_800721E8(arg0, 0x2000);
    ++D_80165C18[arg0].unk_0A6;
}

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern ? D_80165CEF;

void func_800724DC(s32 arg0) {
    *(&D_80165CEF + (arg0 * 0xE0)) = 0;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_800724DC.s")
#endif

void func_800724F8(s32 arg0, s32 arg1) {
    D_80165C18[arg0].unk_084[D_80165C18[arg0].unk_0D7] = arg1;
    ++D_80165C18[arg0].unk_0D7;
}

s16 func_80072530(s32 arg0) {
    --D_80165C18[arg0].unk_0D7;
    return D_80165C18[arg0].unk_084[D_80165C18[arg0].unk_0D7];
}

void func_80072568(s32 arg0, s32 arg1) {
    func_80072388(arg0, 0);
    func_800721E8(arg0, 0x2000);
    func_800721E8(arg0, 8);
    func_80072488(arg0);
    func_800724F8(arg0, D_80165C18[arg0].unk_0A6);
    D_80165C18[arg0].unk_0A6 = arg1;
}

void func_800725E8(s32 arg0, s32 arg1, s32 arg2) {
    func_80072388(arg0, 0);
    func_800721E8(arg0, 0x2000);
    func_800721E8(arg0, 8);
    D_80165C18[arg0].unk_0A6 = arg2;
    func_800724F8(arg0, D_80165C18[arg0].unk_0A6);
    D_80165C18[arg0].unk_0A6 =  arg1;
}

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800721E8(s32, ?); // extern
? func_80072388(?); // extern
s16 func_80072530(s32); // extern
extern ? D_80165CBE;

void func_8007266C(s32 arg0) {
    func_80072388(0);
    func_800721E8(arg0, 0x2000);
    func_800721E8(arg0, 8);
    *(&D_80165CBE + (arg0 * 0xE0)) = func_80072530(arg0);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_8007266C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800721E8(s32, ?); // extern
? func_80072388(?); // extern
extern ? D_80165CBE;

void func_800726CC(s32 arg0, s32 arg1) {
    func_80072388(0);
    func_800721E8(arg0, 0x2000);
    *(&D_80165CBE + (arg0 * 0xE0)) = arg1;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_800726CC.s")
#endif

s32 func_8007278C(s32 arg0, s32 arg1) {
    s32 phi_v1;

    phi_v1 = 0;
    if (D_80165C18[arg0].unk_0CB == 0) {
        func_80072388(arg0, 1);
        D_80165C18[arg0].unk_050 = arg1;
    }

    --D_80165C18[arg0].unk_050;
    if (D_80165C18[arg0].unk_050 < 0) {
        func_80072388(arg0, 0);
        func_80072488(arg0);
        phi_v1 = 1;
    }
    
    return phi_v1;
}

UNUSED s32 func_8007281C(s32 arg0, s32 arg1) {
    s32 phi_a2;

    phi_a2 = 0;
    if (D_80165C18[arg0].unk_0CB == 0) {
        func_80072388(arg0, 1);
        D_80165C18[arg0].unk_050 = random_int((u16) arg1);
    }

    --D_80165C18[arg0].unk_050;
    if (D_80165C18[arg0].unk_050 < 0) {
        func_80072388(arg0, 0);
        func_80072488(arg0);
        phi_a2 = 1;
    }
    
    return phi_a2;
}

UNUSED s32 func_800728B0(s32 arg0, s32 arg1, s32 arg2) {
    s32 phi_a3;

    phi_a3 = 0;
    if (D_80165C18[arg0].unk_0CB == 0) {
        func_80072388(arg0, 1);
        D_80165C18[arg0].unk_050 = random_int((u16) arg2) + arg1;
    }

    --D_80165C18[arg0].unk_050;
    if (D_80165C18[arg0].unk_050 < 0) {
        func_80072388(arg0, 0);
        func_80072488(arg0);
        phi_a3 = 1;
    }
    
    return phi_a3;
}

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern ? D_80165CBE;

void func_80072950(s32 arg0, s32 arg1, s32 arg2, s16 arg3) {
    if (arg1 == arg2) {
        *(&D_80165CBE + (arg0 * 0xE0)) = arg3;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80072950.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern ? D_80165CBA;

void func_800729B4(s32 arg0, s16 arg1) {
    *(&D_80165CBA + (arg0 * 0xE0)) = arg1;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_800729B4.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern ? D_80165CBC;

void func_800729D0(s32 arg0, s16 arg1) {
    *(&D_80165CBC + (arg0 * 0xE0)) = arg1;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_800729D0.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_8005AB20(); // extern
? func_80072488(s32); // extern
? func_8028EDA8(); // extern
extern ? D_8018CA70;
extern s32 D_8018D2A4;
extern s32 D_8018D2BC;

void func_800729EC(s32 arg0) {
    s8 temp_v1;
    u32 temp_v0;
    ? *phi_v0;

    func_8028EDA8();
    func_80072488(arg0);
    D_8018D2BC = 1;
    D_8018D2A4 = 1;
    if (gCurrentCourseId != 4) {
        temp_v1 = D_8018EDF3;
        phi_v0 = &D_8018CA70;
        if (temp_v1 > 0) {
            do {
                temp_v0 = phi_v0 + 0x84;
                temp_v0->unk-3 = 1;
                phi_v0 = temp_v0;
            } while (temp_v0 < ((temp_v1 * 0x84) + &D_8018CA70));
        }
    }
    func_8005AB20();
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_800729EC.s")
#endif

s32 func_80072AAC(s32 arg0, s32 arg1, s32 arg2) {
    s32 phi_v1;

    phi_v1 = 0;
    if (D_80165C18[arg0].unk_0CB == 0) {

        func_80072388(arg0, 1);
        D_80165C18[arg0].unk_0D2 = arg1;
        D_80165C18[arg0].unk_050 = arg2;
    }

    --D_80165C18[arg0].unk_050;
    if (D_80165C18[arg0].unk_050 < 0) {
        func_80072388(arg0, 0);
        func_80072488(arg0);
        phi_v1 = 1;
    }

    return phi_v1;
}

s32 func_80072B48(s32 arg0, s32 arg1) {
    s32 phi_v1;

    phi_v1 = 0;
    if (D_80165C18[arg0].unk_0CB == 0) {
        func_80072388(arg0, 1);
        func_800721C0(arg0, 0x80000);
        D_80165C18[arg0].unk_0D2 = D_8018D140;
        D_80165C18[arg0].unk_050 = arg1;
    }

    --D_80165C18[arg0].unk_050;
    if (D_80165C18[arg0].unk_050 < 0) {
        func_800721E8(arg0, 0x80000);
        func_80072388(arg0, 0);
        func_80072488(arg0);
        phi_v1 = 1;
    }

    return phi_v1;
}

void func_80072C00(s32 arg0, s32 arg1, s32 arg2, s32 arg3) {
    if (func_80072270(arg0, 0x2000) != 0) {
        D_80165C18[arg0].unk_050 = arg2;
        D_80165C18[arg0].unk_0D2 = arg1;
        D_80165C18[arg0].unk_0D4 = 1;
        D_80165C18[arg0].unk_0CC = arg3;
        func_800721C0(arg0, 0x2000);
        return;
    }

    --D_80165C18[arg0].unk_050;
    if (D_80165C18[arg0].unk_050 < 0) {
        D_80165C18[arg0].unk_050 = arg2;
        --D_80165C18[arg0].unk_0D4;
        if ((D_80165C18[arg0].unk_0D4 & 1) != 0) {
            func_800721E8(arg0, 0x80000);
        } else {
            func_800721C0(arg0, 0x80000);
        }

        if (D_80165C18[arg0].unk_0D4 < 0) {
            D_80165C18[arg0].unk_0D4 = 1;

            if (D_80165C18[arg0].unk_0CC > 0) {
                --D_80165C18[arg0].unk_0CC;
            }

            if (D_80165C18[arg0].unk_0CC == 0) {
                func_800721E8(arg0, 0x2000);
                func_80072488(arg0);
            }
        }
    }
}

void func_80072D3C(s32 arg0, s32 arg1, s32 arg2, s32 arg3, s32 arg4) {
    if (func_80072270(arg0, 0x2000) != 0) {
        D_80165C18[arg0].unk_050 = arg3;
        D_80165C18[arg0].unk_0D2 = arg1;
        D_80165C18[arg0].unk_0D4 = 1;
        D_80165C18[arg0].unk_0CC = arg4;
        func_800721C0(arg0, 0x2000);
        return;
    }

    --D_80165C18[arg0].unk_050;
    if (D_80165C18[arg0].unk_050 < 0) {
        D_80165C18[arg0].unk_050 = arg3;
        --D_80165C18[arg0].unk_0D4;
        if ((D_80165C18[arg0].unk_0D4 & 1) != 0) {
            D_80165C18[arg0].unk_0D2 = arg1;
        } else {
            D_80165C18[arg0].unk_0D2 = arg2;
        }
        
        if (D_80165C18[arg0].unk_0D4 < 0) {
            D_80165C18[arg0].unk_0D4 = 1;
            if (D_80165C18[arg0].unk_0CC > 0) {
                --D_80165C18[arg0].unk_0CC;
            }

            if (D_80165C18[arg0].unk_0CC == 0) {
                func_800721E8(arg0, 0x2000);
                func_80072488(arg0);
            }
        }
    }
}

s32 func_80072E54(s32 arg0, s32 arg1, s32 arg2, s32 arg3, s32 arg4, s32 arg5) {
    s32 sp24;

    sp24 = 0;
    if (func_80072270(arg0, 0x2000) != 0) {
        D_80165C18[arg0].unk_0D2 = arg1;
        D_80165C18[arg0].unk_050 = arg4;
        D_80165C18[arg0].unk_0CC = arg5;
        func_80072388(arg0, 1);
        func_800721C0(arg0, 0x2000);
    } else {
        --D_80165C18[arg0].unk_050;
        if (D_80165C18[arg0].unk_050 <= 0) {
            D_80165C18[arg0].unk_050 = arg4;
            D_80165C18[arg0].unk_0D2 += arg3;
            if (arg2 < D_80165C18[arg0].unk_0D2) {

                if (D_80165C18[arg0].unk_0CC > 0) {
                    --D_80165C18[arg0].unk_0CC;
                }
                if (D_80165C18[arg0].unk_0CC == 0) {
                    D_80165C18[arg0].unk_0D2 = arg2;
                    func_800721E8(arg0, 0x2000);
                    func_80072388(arg0, 0);
                    func_80072488(arg0);
                    sp24 = 1;
                } else {
                    D_80165C18[arg0].unk_0D2 = arg1;
                }
            }
        }
    }
    return sp24;
}

s32 func_80072F88(s32 arg0, s32 arg1, s32 arg2, s32 arg3, s32 arg4, s32 arg5) {
    s32 sp24;

    sp24 = 0;
    if (func_80072270(arg0, 0x2000) != 0) {
        D_80165C18[arg0].unk_0D2 = arg1;
        D_80165C18[arg0].unk_050 = arg4;
        D_80165C18[arg0].unk_0CC = arg5;
        func_80072388(arg0, 1);
        func_800721C0(arg0, 0x2000);
    } else {
        --D_80165C18[arg0].unk_050;
        if (D_80165C18[arg0].unk_050 <= 0) {
            D_80165C18[arg0].unk_050 = arg4;
            D_80165C18[arg0].unk_0D2 -= arg3;
            if (D_80165C18[arg0].unk_0D2 < arg2) {
                if (D_80165C18[arg0].unk_0CC > 0) {
                    --D_80165C18[arg0].unk_0CC;
                }
                if (D_80165C18[arg0].unk_0CC == 0) {
                    D_80165C18[arg0].unk_0D2 = arg2;
                    func_800721E8(arg0, 0x2000);
                    func_80072388(arg0, 0);
                    func_80072488(arg0);
                    sp24 = 1;
                } else {
                    D_80165C18[arg0].unk_0D2 = arg1;
                }
            }
        }
    }
    return sp24;
}

s32 func_800730BC(s32 arg0, s32 arg1, s32 arg2, s32 arg3, s32 arg4, s32 arg5) {
    s32 sp24;

    sp24 = 0;
    if (func_80072270(arg0 ,0x2000) != 0) {
        D_80165C18[arg0].unk_0D2 = arg1;
        D_80165C18[arg0].unk_050 = arg4;
        D_80165C18[arg0].unk_0CC = arg5;
        func_80072388(arg0, 1);
        func_800721C0(arg0, 0x2000);
        func_800721E8(arg0, 0x4000);
    } else {
        --D_80165C18[arg0].unk_050;
        if (D_80165C18[arg0].unk_050 <= 0) {
            D_80165C18[arg0].unk_050 = arg4;
            if (func_80072270(arg0, 0x4000) != 0) {
                D_80165C18[arg0].unk_0D2 += arg3;
                if (D_80165C18[arg0].unk_0D2 >= arg2) {
                    D_80165C18[arg0].unk_0D2 = arg2;
                    func_800721C0(arg0, 0x4000);
                }
            } else {
                D_80165C18[arg0].unk_0D2 -= arg3;
                if (arg1 >= D_80165C18[arg0].unk_0D2) {
                    D_80165C18[arg0].unk_0D2 = arg1;
                    if (D_80165C18[arg0].unk_0CC > 0) {
                        --D_80165C18[arg0].unk_0CC;
                    }

                    if (D_80165C18[arg0].unk_0CC == 0) {
                        func_800721E8(arg0, 0x80);
                        func_800721E8(arg0, 0x2000);
                        func_80072388(arg0, 0);
                        func_80072488(arg0);
                        sp24 = 1;
                    } else {
                        func_800721E8(arg0, 0x4000);
                        func_800721C0(arg0, 0x80);
                    }
                }
            }
        }
    }
    return sp24;
}

s32 func_8007326C(s32 arg0, s32 arg1, s32 arg2, s32 arg3, s32 arg4, s32 arg5) {
    s32 sp24;

    sp24 = 0;
    if (func_80072270(arg0, 0x2000) != 0) {
        D_80165C18[arg0].unk_0D2 = arg1;
        D_80165C18[arg0].unk_050 = arg4;
        D_80165C18[arg0].unk_0CC = arg5;
        func_80072388(arg0, 1);
        func_800721C0(arg0, 0x2000);
        func_800721E8(arg0, 0x4000);
    } else {
        --D_80165C18[arg0].unk_050;
        if (D_80165C18[arg0].unk_050 <= 0) {
            D_80165C18[arg0].unk_050 = arg4;
            if (func_80072270(arg0, 0x4000) != 0) {
                D_80165C18[arg0].unk_0D2 -= arg3;
                if (arg2 >= D_80165C18[arg0].unk_0D2) {
                    D_80165C18[arg0].unk_0D2 = arg2;
                    func_800721C0(arg0, 0x4000);
                }
            } else {
                D_80165C18[arg0].unk_0D2 += arg3;
                if (D_80165C18[arg0].unk_0D2 >= arg1) {
                    D_80165C18[arg0].unk_0D2 = arg1;
                    if (D_80165C18[arg0].unk_0CC > 0) {
                        --D_80165C18[arg0].unk_0CC;
                    }
                    if (D_80165C18[arg0].unk_0CC == 0) {
                        func_800721E8(arg0, 0x2000);
                        func_80072388(arg0, 0);
                        func_80072488(arg0);
                        sp24 = 1;
                    } else {
                        func_800721E8(arg0, 0x4000);
                    }
                }
            }
        }
    }
    return sp24;
}

void func_80073404(s32 arg0, u8 arg1, u8 arg2, s32 arg3) {
  D_80165C18[arg0].unk_074 = arg3;
  D_80165C18[arg0].unk_0D9 = arg1;
  D_80165C18[arg0].unk_0DA = arg2;
  D_80165C18[arg0].unk_0D2 = 0;
  D_80165C18[arg0].unk_0D3 = -1;
  D_80165C18[arg0].unk_054 = 0;
}

void func_80073444(s32 arg0, s32* arg1, s32* arg2, u8 arg3, u16 arg4) {
    D_80165C18[arg0].unk_068 = arg1;
    D_80165C18[arg0].unk_06C = arg2;
    D_80165C18[arg0].unk_0D9 = arg3;
    D_80165C18[arg0].unk_0DA = arg4;
    D_80165C18[arg0].unk_0D2 = 0;
    D_80165C18[arg0].unk_0D3 = -1;
    D_80165C18[arg0].unk_054 = 0;
}

UNUSED void func_8007348C(s32 arg0, s32* arg1, u8 arg2, u8 arg3, s32 arg4) {
    D_80165C18[arg0].unk_060 = arg1;
    D_80165C18[arg0].unk_068 = arg1;
    D_80165C18[arg0].unk_0D9 = arg2;
    D_80165C18[arg0].unk_0DA = arg3;
    D_80165C18[arg0].unk_074 = arg4;
    D_80165C18[arg0].unk_0D2 = 0;
    D_80165C18[arg0].unk_0D3 = -1;
    D_80165C18[arg0].unk_054 = 0;
}

UNUSED void func_800734D4() {
}

void func_800734DC(s32 arg0) {
    D_80165C18[arg0].unk_060 = D_80165C18[arg0].unk_068 + (D_80165C18[arg0].unk_0D2 << 7);
    D_80165C18[arg0].unk_064 = D_80165C18[arg0].unk_06C;
}

void func_80073514(s32 arg0) {
    D_80165C18[arg0].unk_060 = D_80165C18[arg0].unk_068;
    D_80165C18[arg0].unk_064 = D_80165C18[arg0].unk_06C + (D_80165C18[arg0].unk_0D9 * D_80165C18[arg0].unk_0DA * D_80165C18[arg0].unk_0D2);
}

UNUSED void func_80073568() {
}

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern ? D_80165C18;
extern s32 D_8018D1EC;

// separated from asm in code_80071F00/func_80073514.s
UNUSED void func_80073570(s32 arg0) {
    s16 *temp_v0;
    s32 temp_t7;

    temp_t7 = D_8018D1EC + 1;
    D_8018D1EC = temp_t7;
    if (temp_t7 == 5) {
        D_8018D1EC = 0;
    }
    temp_v0 = (arg0 * 0xE0) + 0xA6 + &D_80165C18;
    *temp_v0 = (s16) (*temp_v0 + 1);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80073570.s")
#endif 

void func_800735BC(s32 arg0, s32 arg1, f32 arg2) {
    D_80165C18[arg0].unk_054 = 0;
    D_80165C18[arg0].unk_070 = arg1;
    D_80165C18[arg0].unk_000 = arg2;
    func_80072488(arg0);
}

void func_80073600(s32 arg0) {
    func_80072388(arg0, 0);
    D_80165C18[arg0].unk_0D6 = 0;
    D_80165C18[arg0].unk_04C = -1;
    func_800721E8(arg0, 0x8000);
}

void func_80073654(s32 arg0) {
    func_800721E8(arg0, 0x8000);
    ++D_80165C18[arg0].unk_0D6;
}

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800721E8(?); // extern
extern ? D_80165CEE;

// separated from asm in code_80071F00/func_80073654.s
UNUSED void func_8007369C(s32 arg0, s32 arg1) {
    func_800721E8(0x8000);
    *(&D_80165CEE + (arg0 * 0xE0)) = (s8) arg1;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_8007369C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800721E8(?); // extern
extern ? D_80165CEE;

void func_800736E0(s32 arg0) {
    func_800721E8(0x8000);
    *(&D_80165CEE + (arg0 * 0xE0)) = 1;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_800736E0.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800721E8(?); // extern
extern ? D_80165CEE;

void func_80073720(s32 arg0) {
    func_800721E8(0x8000);
    *(&D_80165CEE + (arg0 * 0xE0)) = 0;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80073720.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800721C0(s32, ?); // extern
? func_800721E8(s32, ?); // extern
s32 func_80072270(?); // extern
? func_80073654(s32); // extern
extern ? D_80165C18;
extern ? D_80165C64;

s32 func_8007375C(s32 arg0, s32 arg1) {
    s32 sp24;
    s32 temp_t1;
    void *temp_v0;

    sp24 = 0;
    if (func_80072270(0x8000) != 0) {
        *(&D_80165C64 + (arg0 * 0xE0)) = arg1;
        func_800721C0(arg0, 0x8000);
    }
    temp_v0 = (arg0 * 0xE0) + &D_80165C18;
    temp_t1 = temp_v0->unk4C - 1;
    temp_v0->unk4C = temp_t1;
    if (temp_t1 < 0) {
        func_800721E8(arg0, 0x8000);
        func_80073654(arg0);
        sp24 = 1;
    }
    return sp24;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_8007375C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern ? D_80165CE7;

void func_80073800(s32 arg0, s8 arg1) {
    *(&D_80165CE7 + (arg0 * 0xE0)) = arg1;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80073800.s")
#endif

void func_8007381C(s32 arg0) {
    ++D_80165C18[arg0].unk_0DC;
}

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80073800(?); // extern
extern ? D_80165CF4;

void func_80073844(s32 arg0) {
    func_80073800(0);
    *(&D_80165CF4 + (arg0 * 0xE0)) = 1;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80073844.s")
#endif

void func_80073884(s32 arg0) {
    D_80165C18[arg0].unk_0DC = 0;
    D_80165C18[arg0].unk_0CF = 0;
}

s32 func_800738A8(s32 arg0, s16* arg1, s32 arg2, s32 arg3, s32 arg4, s32 arg5, s32 arg6) {
    s32 phi_t0;

    phi_t0 = 0;
    if (D_80165C18[arg0].unk_0CF == 0) {
        *arg1 = arg2;
        D_80165C18[arg0].unk_0AC = arg5;
        D_80165C18[arg0].unk_0D0 = arg6;
        func_80073800(arg0, 1);
    } else {
        --D_80165C18[arg0].unk_0AC;
        if (D_80165C18[arg0].unk_0AC < 0) {
            D_80165C18[arg0].unk_0AC = arg5;
            *arg1 += arg4;
            if (arg3 < *arg1) {
                if (D_80165C18[arg0].unk_0D0 > 0) {
                    --D_80165C18[arg0].unk_0D0;
                }

                if (D_80165C18[arg0].unk_0D0 == 0) {
                    *arg1 = arg3;
                    func_80073800(arg0, 0);
                    func_8007381C(arg0);
                    phi_t0 = 1;
                } else {
                    *arg1 = arg2;
                }
            }
        }
    }

    return phi_t0;
}

void func_80073998(s32 arg0, s16* arg1, s32 arg2, s32 arg3, s32 arg4, s32 arg5, s32 arg6) {
    func_800738A8(arg0, arg1, arg2, arg3, arg4, arg5, arg6);
}

UNUSED void func_800739CC(s32 arg0, s16* arg1, s32 arg2, s32 arg3, s32 arg4, s32 arg5, s32 arg6) {
    if (*arg1 < arg3) {
        func_800738A8(arg0, arg1, arg2, arg3, arg4, arg5, arg6);
    }
}

s32 func_80073A10(s32 arg0, s16* arg1, s32 arg2, s32 arg3, s32 arg4, s32 arg5, s32 arg6) {
    s32 phi_t0;

    phi_t0 = 0;
    if (D_80165C18[arg0].unk_0CF == 0) {
        *arg1 = arg2;
        D_80165C18[arg0].unk_0AC = arg5;
        D_80165C18[arg0].unk_0D0 = arg6;
        func_80073800(arg0, 1);
    } else {
        --D_80165C18[arg0].unk_0AC;
        if (D_80165C18[arg0].unk_0AC < 0) {
            D_80165C18[arg0].unk_0AC = arg5;
            *arg1 -= arg4;
            if (*arg1 < arg3) {
                if (D_80165C18[arg0].unk_0D0 > 0) {
                    --D_80165C18[arg0].unk_0D0;
                }

                if (D_80165C18[arg0].unk_0D0 == 0) {
                    *arg1 = arg3;
                    func_80073800(arg0, 0);
                    func_8007381C(arg0);
                    phi_t0 = 1;
                } else {
                    *arg1 = arg2;
                }
            }
        }
    }

    return phi_t0;
}

s32 func_80073B00(s32 arg0, s16* arg1, s32 arg2, s32 arg3, s32 arg4, s32 arg5, s32 arg6) {
    return func_80073A10(arg0, arg1, arg2, arg3, arg4, arg5, arg6);
}

s32 func_80073B34(s32 arg0, s16* arg1, s32 arg2, s32 arg3, s32 arg4, s32 arg5, s32 arg6) {
    if (arg3 < *arg1) {
        return func_80073A10(arg0, arg1, arg2, arg3, arg4, arg5, arg6);
    }
}

s32 func_80073B78(s32 arg0, s32 arg1, s16* arg2, s32 arg3, s32 arg4, s32 arg5, s32 arg6, s32 arg7) {
    s32 phi_t0;

    phi_t0 = 0;
    if (D_80165C18[arg1].unk_0CF == 0) {
        D_80165C18[arg1].unk_0AC = arg6;
        if (arg0 != 0) {
            *arg2 = arg3;
        }
        D_80165C18[arg1].unk_0D0 = arg7;
        func_80073800(arg1, 1);
    } else {
        --D_80165C18[arg1].unk_0AC;
        if (D_80165C18[arg1].unk_0AC < 0) {
            D_80165C18[arg1].unk_0AC = arg6;
            if (D_80165C18[arg1].unk_0CF == 1) {
                *arg2 += arg5;
                if (*arg2 >= arg4) {
                    *arg2 = arg4;
                    ++D_80165C18[arg1].unk_0CF;
                }
            } else {
                *arg2 -= arg5;
                if (arg3 >= *arg2) {
                    *arg2 = arg3;
                    if (D_80165C18[arg1].unk_0D0 > 0) {
                        --D_80165C18[arg1].unk_0D0;
                    }
                    if (D_80165C18[arg1].unk_0D0 == 0) {
                        func_80073800(arg1, 0);
                        func_8007381C(arg1);
                        phi_t0 = 1;
                    } else {
                        D_80165C18[arg1].unk_0CF = 1;
                    }
                }
            }
        }
    }

    return phi_t0;
}

void func_80073CB0(s32 arg0, s16* arg1, s32 arg2, s32 arg3, s32 arg4, s32 arg5, s32 arg6) {
    func_80073B78(1, arg0, arg1, arg2, arg3, arg4, arg5, arg6);
}

void func_80073D0C(s32 arg0, s16* arg1, s32 arg2, s32 arg3, s32 arg4, s32 arg5, s32 arg6) {
    func_80073B78(0, arg0, arg1, arg2, arg3, arg4, arg5, arg6);
}

UNUSED void func_80073D68(s32 arg0, s16* arg1, s16 arg2, s32 arg3) {
    *arg1 = *arg1 + arg3;
    if (*arg1 >= arg2) {
        *arg1 = arg2;
        func_80073800(arg0, 0);
        func_8007381C(arg0);
    }
}

void func_80073DC0(s32 arg0, s16* arg1, s16 arg2, s32 arg3) {
    *arg1 = *arg1 - arg3;
    if (arg2 >= *arg1) {
        *arg1 = arg2;
        func_80073800(arg0, 0);
        func_8007381C(arg0);
    }
}

s32 func_80073E18(s32 arg0, u16* arg1, u16 arg2, s32 arg3) {
    s32 phi_t0;
    s32 temp_v1;

    phi_t0 = 0;
    if (D_80165C18[arg0].unk_0CF == 0) {
        func_80073800(arg0, 1);
        D_80165C18[arg0].unk_048 = arg3;
    }

    temp_v1 = D_80165C18[arg0].unk_048 - arg2;
    if (temp_v1 <= 0) {
        *arg1 += D_80165C18[arg0].unk_048;
        func_80073800(arg0, 0);
        phi_t0 = 1;
    } else {
        *arg1 += arg2;
        D_80165C18[arg0].unk_048 = temp_v1;
    }
    
    return phi_t0;
}

UNUSED s32 func_80073ED4(s32 arg0, u16* arg1, u16 arg2, s32 arg3) {
    s32 phi_t0;
    s32 temp_v1;

    phi_t0 = 0;
    if (D_80165C18[arg0].unk_0CF == 0) {
        func_80073800(arg0, 1);
        D_80165C18[arg0].unk_048 = arg3;
    }

    temp_v1 = D_80165C18[arg0].unk_048 - arg2;
    if (temp_v1 <= 0) {
        *arg1 += D_80165C18[arg0].unk_048;
        func_80073800(arg0, 0);
        phi_t0 = 1;
    } else {
        *arg1 -= arg2;
        D_80165C18[arg0].unk_048 = temp_v1;
    }
    return phi_t0;
}

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern ? D_80165CE5;

void func_80073F90(s32 arg0, s8 arg1) {
    *(&D_80165CE5 + (arg0 * 0xE0)) = arg1;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80073F90.s")
#endif

void func_80073FAC(s32 arg0) {
    ++D_80165C18[arg0].unk_0DB;
}

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80073F90(?); // extern
extern ? D_80165CF3;

void func_80073FD4(s32 arg0) {
    func_80073F90(0);
    *(&D_80165CF3 + (arg0 * 0xE0)) = 1;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80073FD4.s")
#endif

s32 func_8007401C(s32 arg0, f32* arg1, f32 arg2, f32 arg3, f32 arg4, s32 arg5, s32 arg6) {
    s32 phi_a3;

    phi_a3 = 0;
    if (D_80165C18[arg0].unk_0CD == 0) {
        *arg1 = arg2;
        D_80165C18[arg0].unk_0AA = arg5;
        D_80165C18[arg0].unk_0CE = arg6;
        func_80073F90(arg0, 1);
    } else {
        --D_80165C18[arg0].unk_0AA;
        if ((s32) D_80165C18[arg0].unk_0AA < 0) {
            D_80165C18[arg0].unk_0AA = arg5;
            *arg1 += arg4;
            if (arg3 < *arg1) {
                if ((s32) D_80165C18[arg0].unk_0CE > 0) {
                    --D_80165C18[arg0].unk_0CE;
                }
                if (D_80165C18[arg0].unk_0CE == 0) {
                    *arg1 = arg3;
                    func_80073F90(arg0, 0);
                    func_80073FAC(arg0);
                    phi_a3 = 1;
                } else {
                    *arg1 = arg2;
                }
            }
        }
    }
    
    return phi_a3;
}

s32 func_80074118(s32 arg0, f32* arg1, f32 arg2, f32 arg3, f32 arg4, s32 arg5, s32 arg6) {
    return func_8007401C(arg0, arg1, arg2, arg3, arg4, arg5, arg6);
}

s32 func_8007415C(s32 arg0, f32* arg1, f32 arg2, f32 arg3, f32 arg4, s32 arg5, s32 arg6) {
    if (*arg1 < arg3) {
        return func_8007401C(arg0, arg1, arg2, arg3, arg4, arg5, arg6);
    }
}

s32 func_800741B4(s32 arg0, f32* arg1, f32 arg2, f32 arg3, f32 arg4, s32 arg5, s32 arg6) {
    if (D_80165C18[arg0].unk_0CD == 0) {
        *arg1 = arg2;
        D_80165C18[arg0].unk_0AA = arg5;
        D_80165C18[arg0].unk_0CE = arg6;
        func_80073F90(arg0, 1);
    } else {
        D_80165C18[arg0].unk_0AA += -1;
        if (D_80165C18[arg0].unk_0AA < 0) {
            D_80165C18[arg0].unk_0AA = arg5;
            *arg1 -= arg4;
            if (*arg1 < arg3) {
                if (D_80165C18[arg0].unk_0CE > 0) {
                    --D_80165C18[arg0].unk_0CE;
                }
                if (D_80165C18[arg0].unk_0CE == 0) {
                    *arg1 = arg3;
                    func_80073F90(arg0, 0);
                    func_80073FAC(arg0);
                } else {
                    *arg1 = arg2;
                }
            }
        }
    }
    
    return 0;
}


UNUSED void func_800742A8(s32 arg0, f32* arg1, f32 arg2, f32 arg3, f32 arg4, s32 arg5, s32 arg6) {
    func_800741B4(arg0, arg1, arg2, arg3, arg4, arg5, arg6);
}

UNUSED void func_800742EC(s32 arg0, f32* arg1, f32 arg2, f32 arg3, f32 arg4, s32 arg5, s32 arg6) {
    if (arg3 < *arg1) {
        func_800741B4(arg0, arg1, arg2, arg3, arg4, arg5, arg6);
    }
}

void func_80074344(s32 arg0, f32* arg1, f32 arg2, f32 arg3, f32 arg4, s32 arg5, s32 arg6) {
    if (D_80165C18[arg0].unk_0CD == 0) {
        *arg1 = arg2;
        D_80165C18[arg0].unk_0AA = arg5;
        D_80165C18[arg0].unk_0CE = arg6;
        func_80073F90(arg0, 1);
        return;
    }

    --D_80165C18[arg0].unk_0AA;
    if (D_80165C18[arg0].unk_0AA < 0) {
        D_80165C18[arg0].unk_0AA = arg5;
        if (D_80165C18[arg0].unk_0CD == 1) {
            *arg1 += arg4;
            if (arg3 <= *arg1) {
                *arg1 = arg3;
                ++D_80165C18[arg0].unk_0CD;
            }
        } else {
            *arg1 -= arg4;
            if (*arg1 <= arg2) {
                *arg1 = arg2;

                if (D_80165C18[arg0].unk_0CE > 0) {
                    --D_80165C18[arg0].unk_0CE;
                }
                if (D_80165C18[arg0].unk_0CE == 0) {
                    func_80073F90(arg0, 0);
                    func_80073FAC(arg0);
                } else {
                    D_80165C18[arg0].unk_0CD = 1;
                }
            }
        }
    }
}

void func_80074478(s32 arg0) {
    D_80165C18[arg0].unk_054 |= 1;
}

void func_800744A0(s32 arg0) {
    D_80165C18[arg0].unk_054 &= ~1;
}

void func_800744CC(void) {
    if (D_8018D224 != 0) {
        osRecvMesg(&gDmaMesgQueue, &gMainReceivedMesg, OS_MESG_BLOCK);
        D_8018D224 = 0;
    }
}

void func_80074510(void* arg0, void* arg1, s32 arg2) {
    func_800744CC();
    osPiStartDma(&gDmaIoMesg, OS_MESG_PRI_NORMAL, OS_READ, (uintptr_t) arg0, arg1, arg2, &gDmaMesgQueue);
    D_8018D224 = 1;
}

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80074510(void *, s32); // extern
extern ? _other_texturesSegmentRomStart;

void func_80074574(s32 arg0, u16 arg2, s32 arg3) {
    func_80074510((arg0 & 0xFFFFFF) + &_other_texturesSegmentRomStart, arg2 * (arg3 & 0xFFFF));
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80074574.s")
#endif

void func_800745C8(s32 arg0, s32 arg1) {
    s32 phi_a1;

    if ((D_80165C18[arg0].unk_054 & 1) != 0) {
        phi_a1 = 0;
        if (D_80165C18[arg0].unk_068 != D_80165C18[arg0].unk_060) {
            D_80165C18[arg0].unk_060 = D_80165C18[arg0].unk_068;
        }

        D_80165C18[arg0].unk_054 ^= 2;
        if ((D_80165C18[arg0].unk_054 & 2) != 0) {
            phi_a1 = 1;
        }
        
        D_80165C18[arg0].unk_064 = (D_80165C18[arg0].unk_0D9 * D_80165C18[arg0].unk_0DA * phi_a1) + arg1;
        func_800744A0(arg0);
    }
}

void func_8007466C(s32 arg0, s32 arg1) {
    s32 phi_a1;

    if ((D_80165C18[arg0].unk_054 & 1) != 0) {
        D_80165C18[arg0].unk_060 = D_80165C18[arg0].unk_068 + (D_80165C18[arg0].unk_0D3 << 7) ;
        D_80165C18[arg0].unk_054 ^= 2;
        phi_a1 = 0;
        if ((D_80165C18[arg0].unk_054 & 2) != 0) {
            phi_a1 = 1;
        }
        D_80165C18[arg0].unk_064 = (D_80165C18[arg0].unk_0D9 * D_80165C18[arg0].unk_0DA * phi_a1) + arg1;
        func_800744A0(arg0);
    }
}

void func_80074704(s32 arg0, s32 arg1) {
    s32 phi_a1;
    
    if ((D_80165C18[arg0].unk_054 & 1) != 0) {
        D_80165C18[arg0].unk_060 = D_80165C18[arg0].unk_068;
        D_80165C18[arg0].unk_054 ^= 2;
        phi_a1 = 0;
        if ((D_80165C18[arg0].unk_054 & 2) != 0) {
            phi_a1 = 1;
        }
        D_80165C18[arg0].unk_064 = (D_80165C18[arg0].unk_0D9 * D_80165C18[arg0].unk_0DA * phi_a1) + arg1;
        func_800744A0(arg0);
    }
}

s32 func_80074790(s32 arg0, s32 arg1) {
    s32 phi_a2;

    D_80165C18[arg0].unk_054 ^= 4;
    phi_a2 = 0;
    if ((D_80165C18[arg0].unk_054 & 4) != 0) {
        phi_a2 = 1;
    }
    return (D_80165C18[arg0].unk_0D9 * D_80165C18[arg0].unk_0DA * phi_a2) + arg1;
}

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80074478(s32); // extern
? func_80074574(s32, s32, u8, u8); // extern
s32 func_80074790(); // extern
extern ? D_80165C18;

void func_800747F0(s32 arg0) {
    s32 sp24;
    void *sp1C;
    s8 temp_v0;
    void *temp_v1;

    temp_v1 = (arg0 * 0xE0) + &D_80165C18;
    temp_v0 = temp_v1->unkD2;
    if (temp_v0 != temp_v1->unkD3) {
        sp1C = temp_v1;
        sp24 = (temp_v0 * temp_v1->unkD9 * temp_v1->unkDA) + temp_v1->unk6C;
        func_80074574(sp24, func_80074790(), temp_v1->unkD9, temp_v1->unkDA);
        temp_v1->unkD3 = temp_v1->unkD2;
        func_80074478(arg0);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_800747F0.s")
#endif

void func_80074894(s32 arg0, s32 arg1) {
    func_800747F0(arg0);
    func_800745C8(arg0, arg1);
}

void func_800748C4(s32 arg0, s32 arg1) {
    func_800747F0(arg0);
    func_8007466C(arg0, arg1);
}

void func_800748F4(s32 arg0, s32 arg1) {
    func_800747F0(arg0);
    func_80074704(arg0, arg1);
}

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80072488(s32, s32, s32); // extern
? func_8008B80C(s32, ?, ?, ?); // extern
extern ? D_800E6F30;
extern ? D_800E6F48;
extern f32 D_800EEA80;
extern f64 D_800EEA88;
extern f64 D_800EEA90;
extern f64 D_800EEA98;
extern f64 D_800EEAA0;
extern f64 D_800EEAA8;
extern s16 D_80165718;
extern s16 D_80165720;
extern s16 D_80165728;
extern u16 D_80165748;
extern ? D_80165C18;
extern f32 D_8018D01C;

void func_80074924(s32 arg0) {
    s32 sp2C;
    s32 sp28;
    s32 sp24;
    s32 sp20;
    s16 temp_v0;
    s32 temp_t4;
    void *temp_s0;
    void *temp_v0_2;
    void *temp_v1;

    temp_s0 = (arg0 * 0xE0) + &D_80165C18;
    temp_s0->unk0 = D_800EEA80;
    temp_v0 = gCurrentCourseId;
    if (temp_v0 != 0) {
        if (temp_v0 != 7) {
            if (temp_v0 != 8) {

            } else {
                sp2C = random_int(0x12C);
                sp28 = random_int(D_80165748);
                sp24 = random_int(0x96);
                sp20 = random_int(0x2000);
                temp_s0->unk10 = ((D_80165718 + D_800EEA90) - sp2C) * D_8018D01C;
                temp_s0->unk14 = D_80165720 + sp28;
                temp_s0->unk18 = (D_80165728 + 200.0) - sp24;
            }
        } else {
            sp2C = random_int(0x168);
            sp28 = random_int(D_80165748);
            sp24 = random_int(0xB4);
            sp20 = random_int(0x2000);
            temp_s0->unk10 = ((D_80165718 + D_800EEA88) - sp2C) * D_8018D01C;
            temp_s0->unk14 = D_80165720 + sp28;
            temp_s0->unk18 = (D_80165728 + 200.0) - sp24;
        }
    } else {
        sp2C = random_int(0xC8);
        sp28 = random_int(D_80165748);
        sp24 = random_int(0x96);
        sp20 = random_int(0x2000);
        temp_s0->unk10 = ((D_80165718 + 100.0) - sp2C) * D_8018D01C;
        temp_s0->unk14 = D_80165720 + sp28;
        temp_s0->unk18 = (D_80165728 + 200.0) - sp24;
    }
    func_8008B80C(arg0, 0, 0, 0);
    if (D_8018EDF3 == 1) {
        temp_s0->unk3C = ((sp2C % 4) * 0.25) + D_800EEA98;
    } else {
        temp_s0->unk3C = ((sp2C % 3) * D_800EEAA0) + D_800EEAA8;
    }
    temp_t4 = (sp2C % 8) * 3;
    temp_v0_2 = temp_t4 + &D_800E6F30;
    temp_v1 = temp_t4 + &D_800E6F48;
    temp_s0->unk90 = sp20 - 0x1000;
    temp_s0->unk84 = temp_v0_2->unk0;
    temp_s0->unk86 = temp_v0_2->unk1;
    temp_s0->unk88 = temp_v0_2->unk2;
    temp_s0->unk8A = temp_v1->unk0;
    temp_s0->unk8C = temp_v1->unk1;
    temp_s0->unk8E = temp_v1->unk2;
    if ((sp2C & 1) != 0) {
        temp_s0->unk92 = (sp20 / 0x20) + 0x100;
    } else {
        temp_s0->unk92 = -0x100 - (sp20 / 0x20);
    }
    temp_s0->unkA0 = 0xE6;
    func_80072488(arg0, sp20, sp2C);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80074924.s")
#endif

void func_80074D94(s32 arg0) {
    if (D_80165C18[arg0].unk_0AE == 1) {
        if ((D_80165740 <= D_80165C18[arg0].unk_02C) && (s16_step_down_towards(&D_80165C18[arg0].unk_0A0, 0, 8) != 0)) {
            func_80086F60(arg0);
        }
        func_800877C4(arg0);
    }
    func_8008BF18(arg0);
}

void func_80074E28(s32 arg0) {
    switch (D_80165C18[arg0].unk_0A6) {
    case 1:
        func_80074924(arg0);
        break;
    case 2:
        if (func_8007278C(arg0, 1) != 0) {
            func_80086E70(arg0);
            break;
        }
    case 0:
        break;
    case 3:
        func_80041480(&D_80165C18[arg0].unk_084[6], -0x1000, 0x1000, &D_80165C18[arg0].unk_084[7]);
        if (D_80165C18[arg0].unk_0AE == 0) {
            func_80072428(arg0);
        }
        break;
    }
}

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80072100(s32 *); // extern
? func_80074D94(s32); // extern
? func_80074E28(s32); // extern
extern s16 D_80165730;
extern s16 D_80165738;
extern ? D_80165C18;
extern s32 D_8018C630;

void func_80074EE8(void) {
    s16 temp_v0;
    s32 temp_s0;
    s32 temp_s3;
    void *temp_s1;
    s32 *phi_s2;
    s32 phi_s3;
    s32 phi_v0;
    s32 phi_s4;
    s32 phi_s4_2;
    s32 phi_s4_3;

    temp_v0 = D_80165738;
    phi_s3 = 0;
    phi_s4 = 0;
    phi_v0 = temp_v0;
    phi_s4_3 = 0;
    if (temp_v0 > 0) {
        phi_s2 = &D_8018C630;
        do {
            temp_s0 = *phi_s2;
            phi_s4_2 = phi_s4_3;
            if (temp_s0 != -1) {
                temp_s1 = &D_80165C18 + (temp_s0 * 0xE0);
                if (temp_s1->unkA6 != 0) {
                    func_80074E28(temp_s0);
                    func_80074D94(temp_s0);
                    if (temp_s1->unkA6 == 0) {
                        func_80072100(phi_s2);
                    }
                    phi_v0 = D_80165738;
                    phi_s4_2 = phi_s4_3 + 1;
                }
            }
            temp_s3 = phi_s3 + 1;
            phi_s2 += 4;
            phi_s3 = temp_s3;
            phi_s4 = phi_s4_2;
            phi_s4_3 = phi_s4_2;
        } while (temp_s3 < phi_v0);
    }
    if (phi_s4 == 0) {
        D_80165730 = 0;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80074EE8.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80072428(s32); // extern
? func_80072488(s32); // extern
? func_80086F60(s32); // extern
s32 func_80087E08(s32, s32, ?, s32, s32, s32); // extern
? func_8008BF18(s32); // extern
extern ? D_8016582C;
extern ? D_80165C18;

void func_80074FD8(s32 arg0) {
    void *sp28;
    s16 temp_v0;
    s32 temp_t6;
    void *temp_v1;

    temp_t6 = arg0 * 0xE0;
    temp_v1 = temp_t6 + &D_80165C18;
    temp_v0 = temp_v1->unkA6;
    if (temp_v0 != 0) {
        if (temp_v0 != 1) {
            if (temp_v0 != 2) {
                return;
            }
            func_80086F60(arg0);
            func_80072428(arg0);
            // Duplicate return node #8. Try simplifying control flow for better match
            return;
        }
        sp28 = temp_v1;
        if (func_80087E08(arg0, temp_v1->unk3C, 0x3DF5C28F, temp_v1->unk34, temp_v1->unkC0, 0x64) != 0) {
            sp28 = temp_v1;
            func_80072488(arg0);
        }
        sp28 = temp_t6 + &D_80165C18;
        func_8008BF18(arg0);
        (temp_t6 + &D_80165C18)->unkB2 = (temp_t6 + &D_80165C18)->unkB2 + D_8016582C.unk0;
        (temp_t6 + &D_80165C18)->unkB4 = (temp_t6 + &D_80165C18)->unkB4 + D_8016582C.unk2;
        (temp_t6 + &D_80165C18)->unkB6 = (temp_t6 + &D_80165C18)->unkB6 + D_8016582C.unk4;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80074FD8.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800723A4(?); // extern
extern f64 D_800EEAB0;
extern f64 D_800EEAB8;
extern f64 D_800EEAC0;
extern f64 D_800EEAC8;
extern ? D_80165C18;

void func_800750D8(s32 arg0, s32 arg1, void *arg2, s32 arg3, s32 arg4) {
    s32 sp24;
    s32 sp20;
    void *sp18;
    f64 temp_f18;
    s16 temp_a0;
    s32 temp_v0;
    s32 temp_v0_2;
    void *temp_v1;
    f64 phi_f18;

    func_800723A4(0);
    sp24 = random_int(0x1F4);
    temp_v0 = random_int(0x32);
    temp_v1 = (arg0 * 0xE0) + &D_80165C18;
    temp_v1->unkD5 = arg3;
    temp_v1->unk0 = (sp24 * D_800EEAB0) + D_800EEAB8;
    temp_v1->unk3C = (temp_v0 * D_800EEAC0) + 2.0;
    temp_v1->unkC0 = (arg1 << 0x10) / arg4;
    temp_v1->unk34 = ((temp_v0 % 5) * D_800EEAC8) + 1.0;
    sp20 = temp_v0;
    sp18 = temp_v1;
    temp_v1->unk10 = (arg2->unk0 + (temp_v0 / 2)) - 12.0f;
    temp_v0_2 = random_int(0xA);
    temp_f18 = temp_v0_2;
    phi_f18 = temp_f18;
    if (temp_v0_2 < 0) {
        phi_f18 = temp_f18 + 4294967296.0;
    }
    temp_a0 = temp_v0 * 0x50;
    temp_v1->unk14 = phi_f18 + (arg2->unk4 - 10.0);
    temp_v1->unkB2 = sp24 << 7;
    temp_v1->unkB4 = temp_a0;
    temp_v1->unkB6 = temp_a0;
    temp_v1->unk18 = (arg2->unk8 + (temp_v0 / 2)) - 12.0f;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_800750D8.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 func_80072044(? *, ? *, ?); // extern
? func_800750D8(s32, s32, s32, s32, s32); // extern
extern ? D_80183E38;
extern ? D_80183E4C;
extern ? D_80183E5C;
extern ? D_8018C1B0;
extern ? D_8018C3F0;
extern ? D_8018C630;

void func_80075304(s32 arg0, s32 arg1, s32 arg2, s32 arg3) {
    s32 sp48;
    s32 temp_s1;
    s32 phi_s0;
    s32 phi_s1;
    s32 phi_v0;

    phi_s1 = 0;
    if (arg3 > 0) {
        phi_s0 = sp48;
loop_2:
        if (arg1 != 1) {
            if (arg1 != 2) {
                if (arg1 != 3) {

                } else {
                    phi_v0 = func_80072044(&D_8018C630, &D_80183E5C, 0x80);
                    goto block_9;
                }
            } else {
                phi_v0 = func_80072044(&D_8018C3F0, &D_80183E4C, 0x80);
                goto block_9;
            }
        } else {
            phi_v0 = func_80072044(&D_8018C1B0, &D_80183E38, 0x80);
block_9:
            phi_s0 = phi_v0;
        }
        if (phi_s0 != -1) {
            func_800750D8(phi_s0, phi_s1, arg0, arg2, arg3);
            temp_s1 = phi_s1 + 1;
            phi_s1 = temp_s1;
            if (temp_s1 == arg3) {
                sp48 = phi_s0;
            } else {
                goto loop_2;
            }
        }
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80075304.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80072100(s32); // extern
? func_80074FD8(s32); // extern
extern ? D_8016582C;
extern ? D_80165C18;
extern ? D_8018C1B0;
extern ? D_8018C3F0;
extern ? D_8018C630;

void func_8007542C(s32 arg0) {
    ? *sp44;
    s32 temp_a0;
    s32 temp_s2;
    void *temp_s0;
    s32 *phi_v0;
    s32 phi_s2;
    ? *phi_s3;
    ? *phi_s3_2;
    s32 phi_s1;
    ? *phi_s3_3;

    D_8016582C.unk0 = D_8016582C.unk0 + 0x2000;
    D_8016582C.unk2 = D_8016582C.unk2 + 0x1000;
    D_8016582C.unk4 = D_8016582C.unk4 + 0x1800;
    phi_s2 = 0;
    phi_s3_2 = sp44;
    phi_s1 = 0;
    do {
        phi_s3 = phi_s3_2;
        if (arg0 != 1) {
            if (arg0 != 2) {
                if (arg0 != 3) {
                    phi_v0 = phi_s3_2 + phi_s1;
                } else {
                    phi_s3_3 = &D_8018C630;
                    goto block_8;
                }
            } else {
                phi_s3_3 = &D_8018C3F0;
                goto block_8;
            }
        } else {
            phi_s3_3 = &D_8018C1B0;
block_8:
            phi_v0 = phi_s1 + phi_s3_3;
            phi_s3 = phi_s3_3;
        }
        temp_a0 = *phi_v0;
        phi_s3_2 = phi_s3;
        if (temp_a0 != -1) {
            temp_s0 = (temp_a0 * 0xE0) + &D_80165C18;
            if (temp_s0->unkA6 != 0) {
                func_80074FD8(temp_a0);
                if (temp_s0->unkA6 == 0) {
                    func_80072100((phi_s2 * 4) + phi_s3);
                }
            }
        }
        temp_s2 = phi_s2 + 1;
        phi_s2 = temp_s2;
        phi_s1 += 4;
    } while (temp_s2 != 0x80);
    sp44 = phi_s3;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_8007542C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800723A4(?, void *); // extern
extern ? D_80165C18;

void func_80075574(s32 arg0, void *arg1, f32 arg2) {
    void *sp18;
    void *temp_a2;
    void *temp_v1;

    temp_a2 = arg1;
    arg1 = temp_a2;
    func_800723A4(0, temp_a2);
    temp_v1 = (arg0 * 0xE0) + &D_80165C18;
    temp_v1->unk10 = arg1->unk0;
    temp_v1->unk14 = arg1->unk4;
    sp18 = temp_v1;
    temp_v1->unk3C = arg2;
    temp_v1->unk18 = arg1->unk8;
    temp_v1->unkA4 = random_int(0x64) + 0x1E;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80075574.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 func_80072044(? *, ? *, ?); // extern
? func_80075574(s32, s32, s32); // extern
extern ? D_80183E4C;
extern ? D_80183E5C;
extern ? D_8018C3F0;
extern ? D_8018C630;

s32 func_800755FC(s32 arg0, s32 arg1, s32 arg2) {
    s32 sp1C;
    s32 temp_v0;
    s32 temp_v0_2;
    s32 phi_a0;

    if (arg0 == 0) {
        temp_v0 = func_80072044(&D_8018C3F0, &D_80183E4C, 0x80);
        phi_a0 = temp_v0;
        if (temp_v0 != -1) {
            sp1C = temp_v0;
            func_80075574(temp_v0, arg1, arg2);
            goto block_5;
        }
    } else {
        temp_v0_2 = func_80072044(&D_8018C630, &D_80183E5C, 0x80);
        phi_a0 = temp_v0_2;
        if (temp_v0_2 != -1) {
            sp1C = temp_v0_2;
            func_80075574(temp_v0_2, arg1, arg2);
block_5:
            phi_a0 = sp1C;
        }
    }
    return phi_a0;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_800755FC.s")
#endif

void func_80075698(s32 arg0) {
    D_80165C18[arg0].unk_0D5 = 1;
    D_80165C18[arg0].unk_064 = D_8018D490;
    D_80165C18[arg0].unk_06C = D_8018D490;
    D_80165C18[arg0].unk_0A0 = 0xFF;
    D_80165C18[arg0].unk_0C0 = 0;
    D_80165C18[arg0].unk_0B2 = 0;
    D_80165C18[arg0].unk_0B6 = 0;
    D_80165C18[arg0].unk_028 = 0.0f;
    D_80165C18[arg0].unk_02C = 0.0f;
    D_80165C18[arg0].unk_030 = 0.0f;
    D_80165C18[arg0].unk_000 = 0.5f;
    func_80072488(arg0);
}

void func_80075714(s32 arg0) {
    switch (D_80165C18[arg0].unk_0A6) {
    case 1:
        func_80075698(arg0);
        break;
    case 2:
        D_80165C18[arg0].unk_03C -= D_800EEAD0;
        f32_step_up_towards(&D_80165C18[arg0].unk_02C, 100.0f, D_80165C18[arg0].unk_03C);
        func_8007415C(arg0, &D_80165C18[arg0].unk_000, 0.55f, 1.0f, D_800EEAD8, 1, 0);
        if (func_80073B00(arg0, &D_80165C18[arg0].unk_0A0, 0xFF, 0x1E, 7, 0, 0) != 0) {
            func_80072488(arg0);
        }
        break;
    case 3:
        func_80072428(arg0);
        break;
    case 0:
        break;
    }
    
    func_8008BF18(arg0);
}

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80072100(s32 *); // extern
? func_80075714(s32); // extern
extern s32 D_801636A0;
extern s32 D_801637AC;
extern s16 D_8016578C;
extern s16 D_80165790;
extern ? D_80165C18;
extern s32 D_8018C3F0;
extern ? D_8018C5F0;
extern s32 D_8018C630;
extern ? D_8018C830;

void func_80075838(void) {
    s16 temp_v0;
    s16 temp_v0_2;
    s32 *temp_s1;
    s32 *temp_s1_2;
    s32 temp_a0;
    s32 temp_a0_2;
    void *temp_s0;
    void *temp_s0_2;
    s32 *phi_s1;
    s32 phi_s2;
    s32 *phi_s1_2;
    s32 phi_s2_2;
    s32 phi_s2_3;
    s32 phi_s2_4;

    temp_v0 = D_8016578C;
    if (temp_v0 != 0) {
        D_8016578C = temp_v0 - 1;
    }
    temp_v0_2 = D_80165790;
    if (temp_v0_2 != 0) {
        D_80165790 = temp_v0_2 - 1;
    }
    phi_s2_3 = 0;
    phi_s2_4 = 0;
    if ((D_801636A0 != 0) || (D_8016578C != 0)) {
        phi_s1 = &D_8018C3F0;
        do {
            temp_a0 = *phi_s1;
            phi_s2 = phi_s2_3;
            if (temp_a0 != -1) {
                temp_s0 = &D_80165C18 + (temp_a0 * 0xE0);
                if (temp_s0->unkA6 != 0) {
                    func_80075714(temp_a0);
                    if (temp_s0->unkA6 == 0) {
                        func_80072100(phi_s1);
                    }
                    phi_s2 = phi_s2_3 + 1;
                }
            }
            temp_s1 = phi_s1 + 4;
            phi_s1 = temp_s1;
            phi_s2_3 = phi_s2;
        } while (temp_s1 != &D_8018C5F0);
        if (phi_s2 != 0) {
            D_8016578C = 0x64;
        }
    }
    if ((D_801637AC != 0) || (D_80165790 != 0)) {
        phi_s1_2 = &D_8018C630;
        do {
            temp_a0_2 = *phi_s1_2;
            phi_s2_2 = phi_s2_4;
            if (temp_a0_2 != -1) {
                temp_s0_2 = &D_80165C18 + (temp_a0_2 * 0xE0);
                if (temp_s0_2->unkA6 != 0) {
                    func_80075714(temp_a0_2);
                    if (temp_s0_2->unkA6 == 0) {
                        func_80072100(phi_s1_2);
                    }
                    phi_s2_2 = phi_s2_4 + 1;
                }
            }
            temp_s1_2 = phi_s1_2 + 4;
            phi_s1_2 = temp_s1_2;
            phi_s2_4 = phi_s2_2;
        } while (temp_s1_2 != &D_8018C830);
        if (phi_s2_2 != 0) {
            D_80165790 = 0x64;
        }
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80075838.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800723A4(?, void *); // extern
extern ? D_80165C18;

void func_800759EC(s32 arg0, void *arg1, f32 arg2) {
    void *temp_a2;
    void *temp_v0;

    temp_a2 = arg1;
    arg1 = temp_a2;
    func_800723A4(0, temp_a2);
    temp_v0 = (arg0 * 0xE0) + &D_80165C18;
    temp_v0->unk10 = arg1->unk0;
    temp_v0->unk14 = arg1->unk4;
    temp_v0->unkA4 = 0xFF;
    temp_v0->unkA2 = 0x96;
    temp_v0->unk3C = arg2;
    temp_v0->unk18 = arg1->unk8;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_800759EC.s")
#endif

s32 func_80075A6C(s32 arg0, s32 arg1, f32 arg2) {
    s32 temp_v0;

    if (arg0 == 0) {
        temp_v0 = func_80072044(&D_8018C3F0, &D_80183E4C, 0x80);
        if (temp_v0 != -1) {
            func_800759EC(temp_v0, arg1, arg2);
        }
    } else {
        temp_v0 = func_80072044(&D_8018C630, &D_80183E5C, 0x80);
        if (temp_v0 != -1) {
            func_800759EC(temp_v0, arg1, arg2);
        }
    }
    
    return temp_v0;
}

void func_80075B08(s32 arg0) {
    D_80165C18[arg0].unk_0D5 = 6;
    D_80165C18[arg0].unk_064 = D_8018D490;
    D_80165C18[arg0].unk_06C = D_8018D490;
    D_80165C18[arg0].unk_0A0 = 0xFF;
    D_80165C18[arg0].unk_0C0 = 0;
    D_80165C18[arg0].unk_0B2 = 0;
    D_80165C18[arg0].unk_0B6 = 0;
    D_80165C18[arg0].unk_028 = 0.0f;
    D_80165C18[arg0].unk_02C = 0.0f;
    D_80165C18[arg0].unk_030 = 0.0f;
    D_80165C18[arg0].unk_000 = 0.5f;
    func_80072488(arg0);
}

void func_80075B84(s32 arg0) {
    switch (D_80165C18[arg0].unk_0A6) {
    case 1:
        func_80075B08(arg0);
        break;
    case 2:
        D_80165C18[arg0].unk_03C -= D_800EEAE0;
        f32_step_up_towards(&D_80165C18[arg0].unk_02C, 100.0f, D_80165C18[arg0].unk_03C);
        func_8007415C(arg0, &D_80165C18[arg0].unk_000, 0.55f, 1.0f, D_800EEAE8, 1, 0);
        if (func_80073B00(arg0, &D_80165C18[arg0].unk_0A0, 0xFF, 0x1E, 7, 0, 0) != 0) {
            func_80072488(arg0);
        }
        break;
    case 3:
        func_80072428(arg0);
        break;
    case 0:
        break;
    }

    func_8008BF18(arg0);
}

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80072100(s32 *); // extern
? func_80075B84(s32); // extern
extern s32 D_801637E8;
extern s32 D_80163814;
extern s16 D_8016578C;
extern s16 D_80165790;
extern ? D_80165C18;
extern s32 D_8018C3F0;
extern ? D_8018C5F0;
extern s32 D_8018C630;
extern ? D_8018C830;

void func_80075CA8(void) {
    s16 temp_v0;
    s16 temp_v0_2;
    s32 *temp_s1;
    s32 *temp_s1_2;
    s32 temp_a0;
    s32 temp_a0_2;
    void *temp_s0;
    void *temp_s0_2;
    s32 *phi_s1;
    s32 phi_s2;
    s32 *phi_s1_2;
    s32 phi_s2_2;
    s32 phi_s2_3;
    s32 phi_s2_4;

    temp_v0 = D_8016578C;
    if (temp_v0 != 0) {
        D_8016578C = temp_v0 - 1;
    }
    temp_v0_2 = D_80165790;
    if (temp_v0_2 != 0) {
        D_80165790 = temp_v0_2 - 1;
    }
    phi_s2_3 = 0;
    phi_s2_4 = 0;
    if ((D_801637E8 != 0) || (D_8016578C != 0)) {
        phi_s1 = &D_8018C3F0;
        do {
            temp_a0 = *phi_s1;
            phi_s2 = phi_s2_3;
            if (temp_a0 != -1) {
                temp_s0 = &D_80165C18 + (temp_a0 * 0xE0);
                if (temp_s0->unkA6 != 0) {
                    func_80075B84(temp_a0);
                    if (temp_s0->unkA6 == 0) {
                        func_80072100(phi_s1);
                    }
                    phi_s2 = phi_s2_3 + 1;
                }
            }
            temp_s1 = phi_s1 + 4;
            phi_s1 = temp_s1;
            phi_s2_3 = phi_s2;
        } while (temp_s1 != &D_8018C5F0);
        if (phi_s2 != 0) {
            D_8016578C = 0x64;
        }
    }
    if ((D_80163814 != 0) || (D_80165790 != 0)) {
        phi_s1_2 = &D_8018C630;
        do {
            temp_a0_2 = *phi_s1_2;
            phi_s2_2 = phi_s2_4;
            if (temp_a0_2 != -1) {
                temp_s0_2 = &D_80165C18 + (temp_a0_2 * 0xE0);
                if (temp_s0_2->unkA6 != 0) {
                    func_80075B84(temp_a0_2);
                    if (temp_s0_2->unkA6 == 0) {
                        func_80072100(phi_s1_2);
                    }
                    phi_s2_2 = phi_s2_4 + 1;
                }
            }
            temp_s1_2 = phi_s1_2 + 4;
            phi_s1_2 = temp_s1_2;
            phi_s2_4 = phi_s2_2;
        } while (temp_s1_2 != &D_8018C830);
        if (phi_s2_2 != 0) {
            D_80165790 = 0x64;
        }
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80075CA8.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800723A4(?, void *); // extern
extern ? D_80165C18;

void func_80075E5C(s32 arg0, void *arg1, u16 arg2, f32 arg3, s32 arg4) {
    void *temp_a3;
    void *temp_v0;

    temp_a3 = arg1;
    arg1 = temp_a3;
    func_800723A4(0, temp_a3);
    temp_v0 = (arg0 * 0xE0) + &D_80165C18;
    temp_v0->unkD5 = 5;
    temp_v0->unk0 = 0.5f;
    temp_v0->unk10 = arg1->unk0;
    temp_v0->unk14 = arg1->unk4;
    temp_v0->unkBE = 0xC00;
    temp_v0->unkC2 = 0;
    temp_v0->unk34 = arg3 * 4.0;
    temp_v0->unkA4 = 0xFF;
    temp_v0->unkA2 = 0xFF;
    temp_v0->unk48 = arg4 * 2;
    temp_v0->unk18 = arg1->unk8;
    temp_v0->unkC0 = arg2;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80075E5C.s")
#endif

s32 func_80075F28(s32 arg0, u16 arg1, s32 arg2, s32 arg3) {
    s32 temp_v0;

    temp_v0 = func_80072044(&D_8018C1B0, &D_80183E38, 0x80);
    if (temp_v0 != -1) {
        func_80075E5C(temp_v0, arg0, arg1, arg2, arg3);
    }
    return temp_v0;
}

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 func_80075F28(s32, s32, ?, s32); // extern

void func_80075F98(s32 arg0, s32 arg1, ? arg2) {
    s32 temp_s0;
    s32 phi_s0;

    phi_s0 = 0;
loop_1:
    temp_s0 = phi_s0 + 1;
    phi_s0 = temp_s0;
    if (func_80075F28(arg0, arg1 & 0xFFFF & 0xFFFF, arg2, phi_s0) != -1) {
        if (temp_s0 != 0xA) {
            goto loop_1;
        }
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80075F98.s")
#endif

void func_8007601C(s32 arg0) {
    if (D_80165C18[arg0].unk_04C > 0) {
        --D_80165C18[arg0].unk_04C;
        if (D_80165C18[arg0].unk_04C == 0) {
            func_800722CC(arg0, 1);
        }
    }

    if (D_80165C18[arg0].unk_048 > 0) {
        --D_80165C18[arg0].unk_048;
        if (D_80165C18[arg0].unk_048 == 0) {
            func_800C9EF4(&D_80165C18[arg0].unk_004, 0x5102800A);
        }
    }

    if (D_80165C18[arg0].unk_04C == 0) {
        func_8008A6DC(arg0, 300.0f);
        if ((func_8007223C(arg0, 0x40000) != 0) && (func_80072354(arg0, 1) != 0)) {
            func_800722A4(arg0, 1);
            func_80075F98(&D_80165C18[arg0].unk_004, (u16) D_80165C18[arg0].unk_0C0, 1.0f);
            func_800C9D80(&D_80165C18[arg0].unk_004, &D_80165C18[arg0].unk_038, 0x5102800A);
            if (D_80165C18[arg0].unk_0A4 > 0) {
                --D_80165C18[arg0].unk_0A4;
                D_80165C18[arg0].unk_04C = 0x5A;
            } else {
                D_80165C18[arg0].unk_04C = 0x12C;
            }

            D_80165C18[arg0].unk_048 = 0x3C;
        }
    }

    if (func_8008A8B0(9, 0xB) == 0) {
        D_80165C18[arg0].unk_0A4 = 2;
    }
}

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_8007601C(s32); // extern
extern s32 D_8018BFA8;
extern ? D_8018BFB8;

void func_8007614C(void) {
    s32 *temp_s0;
    s32 *phi_s0;

    phi_s0 = &D_8018BFA8;
    do {
        func_8007601C(*phi_s0);
        temp_s0 = phi_s0 + 4;
        phi_s0 = temp_s0;
    } while (temp_s0 != &D_8018BFB8);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_8007614C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800723A4(?, void *); // extern
extern ? D_80165C18;

void func_80076194(s32 arg0, void *arg1, f32 arg2, s32 arg3) {
    void *temp_a2;
    void *temp_v0;

    temp_a2 = arg1;
    arg1 = temp_a2;
    func_800723A4(0, temp_a2);
    temp_v0 = (arg0 * 0xE0) + &D_80165C18;
    temp_v0->unkD5 = 4;
    temp_v0->unk0 = 1.0f;
    temp_v0->unk10 = arg1->unk0;
    temp_v0->unk14 = arg1->unk4;
    temp_v0->unkBE = 0xC00;
    temp_v0->unkC2 = 0;
    temp_v0->unkC0 = 0x2100;
    temp_v0->unk18 = arg1->unk8;
    if (gIsMirrorMode != 0) {
        temp_v0->unkC0 = -0x1F00;
    }
    temp_v0->unkA4 = 0xFF;
    temp_v0->unkA2 = 0xFF;
    temp_v0->unk48 = arg3 * 2;
    temp_v0->unk34 = arg2 * 8.0;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80076194.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 func_80072044(? *, ? *, ?); // extern
? func_80076194(s32, s32, s32, s32); // extern
extern ? D_80183E38;
extern ? D_8018C1B0;

s32 func_80076278(s32 arg0, s32 arg1, s32 arg2) {
    s32 sp1C;
    s32 temp_v0;
    s32 phi_a0;

    temp_v0 = func_80072044(&D_8018C1B0, &D_80183E38, 0x80);
    phi_a0 = temp_v0;
    if (temp_v0 != -1) {
        sp1C = temp_v0;
        func_80076194(temp_v0, arg0, arg1, arg2);
        phi_a0 = sp1C;
    }
    return phi_a0;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80076278.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 func_80076278(s32, ?, s32); // extern

void func_800762DC(s32 arg0, ? arg1) {
    s32 temp_s0;
    s32 phi_s0;

    phi_s0 = 0;
loop_1:
    temp_s0 = phi_s0 + 1;
    phi_s0 = temp_s0;
    if (func_80076278(arg0, arg1, phi_s0) != -1) {
        if (temp_s0 != 0x14) {
            goto loop_1;
        }
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_800762DC.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80072488(s32); // extern
? func_8008B80C(s32, ?, ?, ?); // extern
? func_8008B8BC(?, ?, ?); // extern
extern ? D_0D02BC58;
extern ? D_80165C18;

void func_8007634C(s32 arg0) {
    void *temp_v0;

    temp_v0 = (arg0 * 0xE0) + &D_80165C18;
    temp_v0->unk64 = &D_0D02BC58;
    temp_v0->unk6C = &D_0D02BC58;
    temp_v0->unkA0 = 0xFF;
    func_8008B8BC(0, 0, 0);
    func_8008B80C(arg0, 0, 0, 0);
    func_80072488(arg0);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_8007634C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
? s16_step_towards(void *, ?, ?);                      /* extern */
? f32_step_towards(void *, ?, ?);                      /* extern */
? func_80072428(s32);                               /* extern */
? func_80072488(s32);                               /* extern */
s32 func_80073B00(s32, void *, ?, ?, s32, s32, s32); /* extern */
? func_8007634C(s32);                               /* extern */
? func_80086E70(s32);                               /* extern */
? func_80086F60(s32);                               /* extern */
extern ? D_80165C18;

void func_800763CC(s32 arg0) {
    u16 temp_t8;
    void *temp_s0;

    temp_s0 = (arg0 * 0xE0) + &D_80165C18;
    temp_t8 = temp_s0->unkA6;
    switch (temp_t8) {
    case 1:
        func_8007634C(arg0);
        return;
    case 2:
        if (func_8007278C(arg0, temp_s0->unk48) != 0) {
            func_80086E70(arg0);
            return;
        }
    default:
        return;
    case 3:
        if (temp_s0->unkD5 == 4) {
            f32_step_towards(temp_s0, 0x40800000, 0x3DCCCCCD);
            s16_step_towards(temp_s0 + 0xA4, 0, 0x18);
            s16_step_towards(temp_s0 + 0xA2, 0x80, 0xC);
        } else {
            f32_step_towards(temp_s0, 0x3F800000, 0x3DCCCCCD);
            s16_step_towards(temp_s0 + 0xA4, 0, 0x18);
            s16_step_towards(temp_s0 + 0xA2, 0x80, 0xC);
        }
        if ((temp_s0->unkAE >= 2) && (func_80073B00(arg0, temp_s0 + 0xA0, 0xFF, 0x50, 0x20, 0, 0) != 0)) {
            func_80072488(arg0);
            return;
        }
        /* Duplicate return node #12. Try simplifying control flow for better match */
        return;
    case 4:
        func_80072428(arg0);
        func_80086F60(arg0);
        /* Duplicate return node #12. Try simplifying control flow for better match */
        return;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_800763CC.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? u16_step_down_towards(void *, ?, ?); // extern
? func_80086FD4(s32); // extern
s32 func_80087060(s32, ?); // extern
? func_80087844(s32); // extern
? func_8008BF18(s32); // extern
extern ? D_80165C18;

void func_80076538(s32 arg0) {
    s16 temp_v1;
    void *temp_s0;

    temp_s0 = (arg0 * 0xE0) + &D_80165C18;
    temp_v1 = temp_s0->unkAE;
    if (temp_v1 != 0) {
        if (temp_v1 != 1) {
            if (temp_v1 != 2) {

            } else {
                u16_step_down_towards(temp_s0 + 0xBE, 0, 0x400);
                goto block_11;
            }
        } else {
            if (temp_s0->unkD5 == 4) {
                if (func_80087060(arg0, 0xE) != 0) {
                    func_80086FD4(arg0);
                }
            } else if (func_80087060(arg0, 2) != 0) {
                func_80086FD4(arg0);
            }
block_11:
        }
    }
    if (temp_s0->unkAE > 0) {
        func_80087844(arg0);
        func_8008BF18(arg0);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80076538.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 func_8007223C(s32, ?); // extern
? func_800722A4(s32, ?); // extern
? func_800722CC(s32, ?); // extern
s32 func_80072354(s32, ?); // extern
? func_800762DC(void *, ?); // extern
? func_8008A6DC(s32, ?); // extern
s32 func_8008A8B0(?, ?); // extern
? func_800C9D80(void *, void *, ?); // extern
? func_800C9EF4(void *, ?); // extern
extern ? D_80165C18;
extern s32 D_80183F28;

void func_8007661C(void) {
    void *sp24;
    s16 temp_v0_3;
    s32 temp_s1;
    s32 temp_t0;
    s32 temp_t8;
    s32 temp_v0;
    s32 temp_v0_2;
    void *temp_s0;

    temp_s1 = D_80183F28;
    temp_s0 = (temp_s1 * 0xE0) + &D_80165C18;
    temp_v0 = temp_s0->unk4C;
    temp_t8 = temp_v0 - 1;
    if (temp_v0 > 0) {
        temp_s0->unk4C = temp_t8;
        if (temp_t8 == 0) {
            func_800722CC(temp_s1, 1);
        }
    }
    temp_v0_2 = temp_s0->unk48;
    temp_t0 = temp_v0_2 - 1;
    if (temp_v0_2 > 0) {
        temp_s0->unk48 = temp_t0;
        if (temp_t0 == 0) {
            func_800C9EF4(temp_s0 + 4, 0x51038009);
        }
    }
    if (temp_s0->unk4C == 0) {
        func_8008A6DC(temp_s1, 0x443B8000);
        if ((func_8007223C(temp_s1, 0x40000) != 0) && (func_80072354(temp_s1, 1) != 0)) {
            sp24 = temp_s0 + 4;
            func_800722A4(temp_s1, 1);
            func_800762DC(sp24, 0x3F800000);
            func_800C9D80(sp24, temp_s0 + 0x38, 0x51038009);
            temp_v0_3 = temp_s0->unkA4;
            if (temp_v0_3 > 0) {
                temp_s0->unkA4 = temp_v0_3 - 1;
                temp_s0->unk4C = 0x5A;
            } else {
                temp_s0->unk4C = 0x12C;
            }
            temp_s0->unk48 = 0x3C;
        }
    }
    if (func_8008A8B0(4, 5) == 0) {
        temp_s0->unkA4 = 2;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_8007661C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800723A4(?, void *); // extern
extern ? D_80165C18;

void func_8007675C(s32 arg0, void *arg1, s32 arg2) {
    void *temp_a3;
    void *temp_v0;

    temp_a3 = arg1;
    arg1 = temp_a3;
    func_800723A4(0, temp_a3);
    temp_v0 = (arg0 * 0xE0) + &D_80165C18;
    temp_v0->unkD5 = 9;
    temp_v0->unk0 = 1.0f;
    temp_v0->unk10 = arg1->unk0;
    temp_v0->unk14 = arg1->unk2;
    temp_v0->unkBE = 0xC00;
    temp_v0->unkC0 = 0x2100;
    temp_v0->unkC2 = 0;
    temp_v0->unkA4 = 0xFF;
    temp_v0->unkA2 = 0xFF;
    temp_v0->unk34 = 8.0f;
    temp_v0->unk3C = 8.0f;
    temp_v0->unk48 = arg2;
    temp_v0->unk18 = arg1->unk4;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_8007675C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 func_80072044(? *, ? *, ?); // extern
? func_8007675C(s32, s32, s32); // extern
extern ? D_80183E38;
extern ? D_8018C1B0;

s32 func_80076828(s32 arg0, s32 arg1) {
    s32 sp1C;
    s32 temp_v0;
    s32 phi_a0;

    temp_v0 = func_80072044(&D_8018C1B0, &D_80183E38, 0x80);
    phi_a0 = temp_v0;
    if (temp_v0 != -1) {
        sp1C = temp_v0;
        func_8007675C(temp_v0, arg0, arg1);
        phi_a0 = sp1C;
    }
    return phi_a0;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80076828.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80072488(s32); // extern
? func_8008B80C(s32, ?, ?, ?); // extern
? func_8008B8BC(?, ?, ?); // extern
extern ? D_0D02BC58;
extern ? D_80165C18;

void func_80076958(s32 arg0) {
    void *temp_v0;

    temp_v0 = (arg0 * 0xE0) + &D_80165C18;
    temp_v0->unk64 = &D_0D02BC58;
    temp_v0->unk6C = &D_0D02BC58;
    temp_v0->unkA0 = 0xFF;
    func_8008B8BC(0, 0, 0);
    func_8008B80C(arg0, 0, 0, 0);
    func_80072488(arg0);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80076958.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
? s16_step_towards(void *, ?, ?);                      /* extern */
? f32_step_towards(void *, ?, ?);                      /* extern */
? func_80072428(s32);                               /* extern */
? func_80072488(s32);                               /* extern */
s32 func_80073B00(s32, void *, ?, ?, s32, s32, s32); /* extern */
? func_80076958(s32);                               /* extern */
? func_80086E70(s32);                               /* extern */
? func_80086F60(s32);                               /* extern */
extern ? D_80165C18;

void func_800769D8(s32 arg0) {
    u16 temp_t8;
    void *temp_s0;

    temp_s0 = (arg0 * 0xE0) + &D_80165C18;
    temp_t8 = temp_s0->unkA6;
    switch (temp_t8) {
    case 1:
        func_80076958(arg0);
        return;
    case 2:
        if (func_8007278C(arg0, temp_s0->unk48) != 0) {
            func_80086E70(arg0);
            return;
        }
    default:
        return;
    case 3:
        f32_step_towards(temp_s0, 0x40000000, 0x3D4CCCCD);
        s16_step_towards(temp_s0 + 0xA4, 0, 0x18);
        if ((temp_s0->unkAE >= 2) && (func_80073B00(arg0, temp_s0 + 0xA0, 0xFF, 0x50, 0x20, 0, 0) != 0)) {
            func_80072488(arg0);
            return;
        }
        /* Duplicate return node #9. Try simplifying control flow for better match */
        return;
    case 4:
        func_80072428(arg0);
        func_80086F60(arg0);
        /* Duplicate return node #9. Try simplifying control flow for better match */
        return;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_800769D8.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80086FD4(s32); // extern
s32 func_80087060(?, void *); // extern
? func_800877C4(s32); // extern
? func_8008BF18(s32); // extern
extern ? D_80165C18;

void func_80076AEC(s32 arg0) {
    void *sp20;
    s16 temp_v1;
    s32 temp_t6;
    void *temp_a2;
    s32 phi_v1;

    temp_t6 = arg0 * 0xE0;
    temp_a2 = temp_t6 + &D_80165C18;
    temp_v1 = temp_a2->unkAE;
    phi_v1 = temp_v1;
    if ((temp_v1 != 0) && (temp_v1 == 1)) {
        sp20 = temp_a2;
        if (func_80087060(0xA, temp_a2) != 0) {
            sp20 = temp_a2;
            func_80086FD4(arg0);
        }
        phi_v1 = (temp_t6 + &D_80165C18)->unkAE;
    }
    if (phi_v1 > 0) {
        func_800877C4(arg0);
        func_8008BF18(arg0);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80076AEC.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80072100(s32 *); // extern
? func_8007614C(); // extern
? func_800763CC(s32); // extern
? func_80076538(s32); // extern
? func_8007661C(); // extern
? func_800769D8(s32); // extern
? func_80076AEC(s32); // extern
extern ? D_80165C18;
extern s32 D_8018C1B0;
extern ? D_8018C3B0;

void func_80076B84(void) {
    s32 *temp_s2;
    s32 temp_s0;
    u8 temp_v0;
    void *temp_s1;
    s32 *phi_s2;

    func_8007661C();
    func_8007614C();
    phi_s2 = &D_8018C1B0;
    do {
        temp_s0 = *phi_s2;
        if (temp_s0 != -1) {
            temp_s1 = &D_80165C18 + (temp_s0 * 0xE0);
            if (temp_s1->unkA6 != 0) {
                temp_v0 = temp_s1->unkD5;
                if ((temp_v0 == 4) || (temp_v0 == 5)) {
                    func_800763CC(temp_s0);
                    func_80076538(temp_s0);
                    goto block_8;
                }
                if (temp_v0 == 9) {
                    func_800769D8(temp_s0);
                    func_80076AEC(temp_s0);
block_8:
                }
                if (temp_s1->unkA6 == 0) {
                    func_80072100(phi_s2);
                }
            }
        }
        temp_s2 = phi_s2 + 4;
        phi_s2 = temp_s2;
    } while (temp_s2 != &D_8018C3B0);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80076B84.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800723A4(s16); // extern
? func_8008B7D4(s32, s32, s32, s32); // extern
? func_8008B80C(s32, ?, ?, ?); // extern
? func_8008B8BC(s32, ?, ?, ?); // extern
extern ? D_0D02BC58;
extern f32 D_800EEB14;
extern ? D_80165C18;

void func_80076C9C(s32 arg0, void *arg1, s16 arg2) {
    void *sp20;
    void *temp_v0;

    func_800723A4(arg2);
    temp_v0 = (arg0 * 0xE0) + &D_80165C18;
    temp_v0->unkD5 = 0xA;
    temp_v0->unk64 = &D_0D02BC58;
    temp_v0->unk6C = &D_0D02BC58;
    temp_v0->unk0 = D_800EEB14;
    sp20 = temp_v0;
    func_8008B7D4(arg0, arg1->unk0, arg1->unk4, arg1->unk8);
    temp_v0->unkA4 = 0xFF;
    temp_v0->unk34 = 0.0f;
    func_8008B8BC(arg0, 0, 0, 0);
    func_8008B80C(arg0, 0, 0, 0);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80076C9C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 func_80072044(? *, ? *, ?); // extern
? func_80076C9C(s32, s32, s16); // extern
extern ? D_80183E6C;
extern ? D_8018C870;

void func_80076D70(s32 arg0, ? arg1, s16 arg2) {
    s32 temp_v0;

    temp_v0 = func_80072044(&D_8018C870, &D_80183E6C, 0x40);
    if (temp_v0 != -1) {
        func_80076C9C(temp_v0, arg0, arg2);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80076D70.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80072488(); // extern
? func_80086E70(s32); // extern
extern ? D_80165CED;

void func_80076DC4(s32 arg0) {
    func_80072488();
    if (*(&D_80165CED + (arg0 * 0xE0)) != 0xB) {
        func_80086E70(arg0);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80076DC4.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80072428(); // extern
? func_80072488(s32); // extern
s32 func_80073B00(void *, ?, ?, s32, s32, s32); // extern
? func_80076DC4(); // extern
? func_80086F60(s32); // extern
extern ? D_80165C18;

void func_80076E14(s32 arg0) {
    s16 temp_v0;
    void *temp_v1;

    temp_v1 = (arg0 * 0xE0) + &D_80165C18;
    temp_v0 = temp_v1->unkA6;
    if (temp_v0 != 0) {
        if (temp_v0 != 1) {
            if (temp_v0 != 2) {
                if (temp_v0 != 3) {
                    return;
                }
                func_80072428();
                func_80086F60(arg0);
                // Duplicate return node #10. Try simplifying control flow for better match
                return;
            }
            if ((temp_v1->unkAE >= 2) && (func_80073B00(temp_v1 + 0xA0, 0xFF, 0x50, 0x20, 0, 0) != 0)) {
                func_80072488(arg0);
                return;
            }
            // Duplicate return node #10. Try simplifying control flow for better match
            return;
        }
        func_80076DC4();
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80076E14.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80086FD4(); // extern
? func_8008BF18(s32); // extern
extern ? D_80165CC6;

void func_80076ED8(s32 arg0) {
    s16 temp_v0;

    temp_v0 = *(&D_80165CC6 + (arg0 * 0xE0));
    if ((temp_v0 != 0) && (temp_v0 == 1)) {
        func_80086FD4();
    }
    func_8008BF18(arg0);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80076ED8.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80072100(s32 *); // extern
? func_80076E14(s32); // extern
? func_80076ED8(s32); // extern
extern ? D_80165C18;
extern s32 D_8018C870;
extern ? D_8018C970;

void func_80076F2C(void) {
    s32 *temp_s1;
    s32 temp_s0;
    void *temp_s2;
    s32 *phi_s1;

    phi_s1 = &D_8018C870;
    do {
        temp_s0 = *phi_s1;
        if (temp_s0 != -1) {
            temp_s2 = &D_80165C18 + (temp_s0 * 0xE0);
            if (temp_s2->unkA6 != 0) {
                func_80076E14(temp_s0);
                func_80076ED8(temp_s0);
                if (temp_s2->unkA6 == 0) {
                    func_80072100(phi_s1);
                }
            }
        }
        temp_s1 = phi_s1 + 4;
        phi_s1 = temp_s1;
    } while (temp_s1 != &D_8018C970);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80076F2C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800723A4(?); // extern
? func_8008B80C(s32, ?, ?, ?); // extern
? func_8008B8BC(s32, ?, ?, ?); // extern
extern ? D_0D02BC58;
extern ? D_800E6788;
extern f32 D_800EEB18;
extern ? D_80165C18;
extern f32 D_8018D01C;

void func_80076FEC(s32 arg0, s32 arg1) {
    void *temp_v0;
    void *temp_v1;

    func_800723A4(3);
    temp_v1 = (arg1 * 6) + &D_800E6788;
    temp_v0 = (arg0 * 0xE0) + &D_80165C18;
    temp_v0->unkD5 = 0xB;
    temp_v0->unk64 = &D_0D02BC58;
    temp_v0->unk6C = &D_0D02BC58;
    temp_v0->unk0 = D_800EEB18;
    temp_v0->unkA4 = 0xFF;
    temp_v0->unkA2 = 0xFF;
    temp_v0->unkA0 = 0xFF;
    temp_v0->unk10 = temp_v1->unk0 * D_8018D01C;
    temp_v0->unk14 = temp_v1->unk2;
    temp_v0->unk34 = 0.0f;
    temp_v0->unk18 = temp_v1->unk4;
    func_8008B8BC(arg0, 0, 0, 0);
    func_8008B80C(arg0, 0, 0, 0);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80076FEC.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 func_80072044(? *, ? *, ?); // extern
? func_80076FEC(s32, s32); // extern
extern ? D_80183E6C;
extern ? D_8018C870;

void func_800770F0(s32 arg0) {
    s32 temp_v0;

    temp_v0 = func_80072044(&D_8018C870, &D_80183E6C, 0x40);
    if (temp_v0 != -1) {
        func_80076FEC(temp_v0, arg0);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_800770F0.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_8005C674(s8, s16 *, s16 *, s16 *); // extern
? func_8005C6B4(s8, s16 *, s16 *, s16 *); // extern
? func_800723A4(s32); // extern
? func_8008751C(s32); // extern
? func_8008B7D4(s32, s32, s32, s32); // extern
? func_8008B80C(s32, ?, ?, ?); // extern
? func_8008B8BC(s32, ?, ?, ?); // extern
extern f32 D_800EEB1C;
extern f64 D_800EEB20;
extern f64 D_800EEB28;
extern ? D_80165C18;

void func_80077138(s32 arg0, void *arg1, s32 arg2) {
    s8 sp37;
    s16 sp34;
    s16 sp32;
    s16 sp30;
    f64 temp_f10;
    f64 temp_f4;
    s32 temp_v0;
    s32 temp_v0_2;
    s8 temp_t9;
    s8 temp_v0_3;
    s8 temp_v0_4;
    u16 temp_v1;
    void *temp_s0;
    f64 phi_f4;
    f64 phi_f10;

    func_800723A4(arg2);
    temp_s0 = (arg0 * 0xE0) + &D_80165C18;
    temp_s0->unkD5 = 0xC;
    temp_s0->unk0 = D_800EEB1C;
    func_8008B7D4(arg0, arg1->unk0, arg1->unk4, arg1->unk8);
    func_8008B8BC(arg0, 0, 0, 0);
    func_8008B80C(arg0, 0, 0, 0);
    if (arg2 != 0) {
        if (arg2 != 1) {

        } else {
            temp_s0->unk3C = 1.5f;
            temp_v0 = random_int(0x64);
            temp_f4 = temp_v0;
            phi_f4 = temp_f4;
            if (temp_v0 < 0) {
                phi_f4 = temp_f4 + 4294967296.0;
            }
            temp_s0->unk34 = (phi_f4 * D_800EEB28) + 0.5;
            temp_s0->unkC0 = random_int(0x40) << 0xA;
            func_8008751C(arg0);
            temp_s0->unk8E = 0x32;
        }
    } else {
        temp_s0->unk3C = -1.0f;
        temp_v0_2 = random_int(0x4B);
        temp_f10 = temp_v0_2;
        phi_f10 = temp_f10;
        if (temp_v0_2 < 0) {
            phi_f10 = temp_f10 + 4294967296.0;
        }
        temp_s0->unk34 = (phi_f10 * D_800EEB20) + 0.25;
        temp_s0->unkC0 = random_int(0x40) << 0xA;
        func_8008751C(arg0);
        temp_s0->unk8E = 0x1E;
    }
    temp_v0_3 = random_int(0xC);
    if (temp_v0_3 < 9) {
        func_8005C674(temp_v0_3, &sp34, &sp32, &sp30);
        temp_s0->unk48 = 0;
        temp_s0->unk84 = sp34;
        temp_s0->unk86 = sp32;
        temp_s0->unk88 = sp30;
    } else {
        temp_v0_4 = random_int(3);
        temp_t9 = temp_v0_4;
        sp37 = temp_v0_4;
        func_8005C6B4(temp_t9, &sp34, &sp32, &sp30);
        temp_s0->unk48 = 1;
        temp_s0->unk84 = sp34;
        temp_s0->unk86 = sp32;
        temp_s0->unk88 = sp30;
        temp_s0->unk8C = sp37;
    }
    temp_s0->unkA0 = 0xFF;
    temp_v1 = temp_s0->unkC0;
    temp_s0->unk8A = random_int(0x800) + 0x400;
    if ((temp_v1 < 0x3000) || (temp_v1 >= 0xB001)) {
        temp_s0->unk8A = -temp_s0->unk8A;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80077138.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 func_80072044(? *, ? *, ?); // extern
? func_80077138(s32, s32, s32); // extern
extern ? D_80183E5C;
extern ? D_8018C630;

void func_800773D8(s32 arg0, s32 arg1) {
    s32 temp_v0;

    temp_v0 = func_80072044(&D_8018C630, &D_80183E5C, 0x80);
    if (temp_v0 != -1) {
        func_80077138(temp_v0, arg0, arg1);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_800773D8.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80072488(); // extern
? func_80086E70(s32); // extern

void func_80077428(s32 arg0) {
    func_80072488();
    func_80086E70(arg0);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80077428.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? f32_step_up_towards(void *, ?, ?, s32); // extern
? func_8005C6B4(s8, s16 *, s16 *, s16 *); // extern
? func_80072428(s32); // extern
s32 func_80073B00(s32, void *, ?, ?, s32, s32, s32); // extern
? func_80077428(s32, s32); // extern
? func_80086F60(s32); // extern
extern ? D_80165C18;

void func_80077450(s32 arg0) {
    s16 sp3C;
    s16 sp3A;
    s16 sp38;
    s16 temp_v0;
    s32 temp_a3;
    void *temp_a0;
    void *temp_s0;

    temp_s0 = (arg0 * 0xE0) + &D_80165C18;
    temp_v0 = temp_s0->unkA6;
    temp_a3 = arg0;
    if (temp_v0 != 0) {
        if (temp_v0 != 1) {
            temp_a0 = temp_s0;
            if (temp_v0 != 2) {

            } else {
                arg0 = temp_a3;
                f32_step_up_towards(temp_a0, 0x3DCCCCCD, 0x3C23D70A, temp_a3);
                if ((temp_s0->unk8 <= temp_s0->unk8E) && (func_80073B00(arg0, temp_s0 + 0xA0, 0xFF, 0, 0x10, 0, 0) != 0)) {
                    func_80086F60(arg0);
                    func_80072428(arg0);
                }
            }
        } else {
            func_80077428(temp_a3, temp_a3);
        }
    }
    if (temp_s0->unk48 != 0) {
        temp_s0->unk8C = (temp_s0->unk8C + 1) % 3;
        func_8005C6B4(temp_s0->unk8D, &sp3C, &sp3A, &sp38);
        temp_s0->unk84 = sp3C;
        temp_s0->unk86 = sp3A;
        temp_s0->unk88 = sp38;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80077450.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80087710(); // extern
? func_8008BF18(s32); // extern
extern f64 D_800EEB30;
extern ? D_80165C18;

void func_80077584(s32 arg0) {
    f64 temp_f0;
    s16 temp_v1;
    void *temp_v0;

    temp_v0 = (arg0 * 0xE0) + &D_80165C18;
    temp_v1 = temp_v0->unkAE;
    if ((temp_v1 != 0) && (temp_v1 == 1) && (temp_v0->unkD8 != 0)) {
        temp_f0 = temp_v0->unk3C;
        if (temp_f0 >= -0.5) {
            temp_v0->unk3C = temp_f0 - D_800EEB30;
        } else {
            temp_v0->unk40 = 0.0f;
            temp_v0->unk38 = 0.0f;
        }
    }
    temp_v0->unkB6 = temp_v0->unkB6 + temp_v0->unk8A;
    func_80087710();
    func_8008BF18(arg0);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80077584.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80072100(s32 *); // extern
? func_80077450(s32); // extern
? func_80077584(s32); // extern
extern ? D_80165C18;
extern s32 D_8018C630;
extern ? D_8018C830;

void func_80077640(void) {
    s32 *temp_s1;
    s32 temp_s0;
    void *temp_s2;
    s32 *phi_s1;

    phi_s1 = &D_8018C630;
    do {
        temp_s0 = *phi_s1;
        if (temp_s0 != -1) {
            temp_s2 = &D_80165C18 + (temp_s0 * 0xE0);
            if (temp_s2->unkA6 != 0) {
                func_80077450(temp_s0);
                func_80077584(temp_s0);
                if (temp_s2->unkA6 == 0) {
                    func_80072100(phi_s1);
                }
            }
        }
        temp_s1 = phi_s1 + 4;
        phi_s1 = temp_s1;
    } while (temp_s1 != &D_8018C830);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80077640.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800723A4(?); // extern
? func_8008B888(s32, ?, s32, ?); // extern
? func_8008B8BC(s32, s32, u16, u16); // extern
? func_8008BD14(s32, s16, s16, s16, s32, s32, s32); // extern
extern ? D_0D028DD8;
extern f32 D_800EEB38;
extern ? D_80165C18;

void func_80077700(s32 arg0, void *arg1, s32 arg2) {
    u16 sp3E;
    u16 sp3C;
    void *sp34;
    s16 temp_v1;
    s32 temp_s0;
    void *temp_v0;

    func_800723A4(0);
    temp_v0 = (arg0 * 0xE0) + &D_80165C18;
    temp_v0->unkD5 = 7;
    temp_v0->unk60 = &D_0D028DD8;
    temp_v0->unk68 = &D_0D028DD8;
    temp_v0->unk0 = D_800EEB38;
    temp_v0->unk44 = arg1->unk4;
    temp_v1 = gCurrentCourseId;
    if (temp_v1 != 0) {
        if (temp_v1 != 4) {
            if (temp_v1 != 7) {
                if (temp_v1 != 8) {

                } else {
                    sp34 = temp_v0;
                    func_8008BD14(arg0, arg1->unk0, arg1->unk4 + 25.0, arg1->unk8, 0x14, 0x1E, 0x14);
                    temp_v0->unk34 = 1.5f;
                    temp_v0->unk3C = 1.0f;
                }
            } else {
                sp34 = temp_v0;
                func_8008BD14(arg0, arg1->unk0, arg1->unk4 + 30.0, arg1->unk8, 0x10, 0x28, 0x10);
                temp_v0->unk34 = 2.0f;
                temp_v0->unk3C = 2.0f;
            }
        } else {
            sp34 = temp_v0;
            func_8008BD14(arg0, arg1->unk0, arg1->unk4 + 25.0, arg1->unk8, 0x14, 0x1E, 0x14);
            temp_v0->unk34 = 2.0f;
            temp_v0->unk3C = 2.0f;
        }
    } else {
        sp34 = temp_v0;
        func_8008BD14(arg0, arg1->unk0, arg1->unk4 + 25.0, arg1->unk8, 0x14, 0x1E, 0x14);
        temp_v0->unk34 = 1.5f;
        temp_v0->unk3C = 1.5f;
    }
    temp_s0 = (random_int(0x10) << 0xC) & 0xFFFF;
    sp3E = random_int(0x10) << 0xC;
    sp3C = random_int(0x10) << 0xC;
    func_8008B888(arg0, 0, ((arg2 * 0xFFFF) / 0x14) & 0xFFFF, 0);
    func_8008B8BC(arg0, temp_s0 & 0xFFFF, sp3E, sp3C);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80077700.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 func_80072044(? *, ? *, ?); // extern
? func_80077700(s32, s32, s32); // extern
extern ? D_80183E7C;
extern ? D_8018C970;

s32 func_80077A54(s32 arg0, s32 arg1) {
    s32 sp1C;
    s32 temp_v0;
    s32 phi_a0;

    temp_v0 = func_80072044(&D_8018C970, &D_80183E7C, 0x40);
    phi_a0 = temp_v0;
    if (temp_v0 != -1) {
        sp1C = temp_v0;
        func_80077700(temp_v0, arg0, arg1);
        phi_a0 = sp1C;
    }
    return phi_a0;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80077A54.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 func_80077A54(s32, s32); // extern

void func_80077AB0(s32 arg0, ? arg1) {
    s32 temp_s0;
    s32 phi_s0;

    phi_s0 = 0;
loop_1:
    temp_s0 = phi_s0 + 1;
    phi_s0 = temp_s0;
    if (func_80077A54(arg0, phi_s0) != -1) {
        if (temp_s0 != 0x14) {
            goto loop_1;
        }
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80077AB0.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80072488(); // extern
? func_80086E70(s32); // extern

void func_80077B14(s32 arg0) {
    func_80072488();
    func_80086E70(arg0);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80077B14.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80072428(); // extern
? func_80072488(); // extern
? func_80077B14(); // extern
extern ? D_80165C18;

void func_80077B3C(s32 arg0) {
    s16 temp_v0;
    void *temp_v1;

    temp_v1 = (arg0 * 0xE0) + &D_80165C18;
    temp_v0 = temp_v1->unkA6;
    if (temp_v0 != 0) {
        if (temp_v0 != 1) {
            if (temp_v0 != 2) {
                if (temp_v0 != 3) {
                    return;
                }
                func_80072428();
                // Duplicate return node #9. Try simplifying control flow for better match
                return;
            }
            if (temp_v1->unkAE == 0) {
                func_80072488();
                return;
            }
            // Duplicate return node #9. Try simplifying control flow for better match
            return;
        }
        func_80077B14();
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80077B3C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80086F60(s32); // extern
s32 func_80087B84(s32, ?, s32); // extern
? func_80087E08(s32, s32, ?, s32, s32, s32); // extern
? func_8008BF18(s32); // extern
extern ? D_80165C18;

void func_80077BCC(s32 arg0) {
    s16 temp_v0;
    void *temp_s0;

    temp_s0 = (arg0 * 0xE0) + &D_80165C18;
    temp_v0 = temp_s0->unkAE;
    if (temp_v0 != 1) {
        if (temp_v0 != 2) {

        } else if (func_80087B84(arg0, 0x3ECCCCCD, temp_s0->unk44) != 0) {
            func_80086F60(arg0);
        }
    } else {
        func_80087E08(arg0, temp_s0->unk3C, 0x3E4CCCCD, temp_s0->unk34, temp_s0->unkC0, 0xA);
    }
    func_8008BF18(arg0);
    temp_s0->unkB2 = temp_s0->unkB2 + 0x1000;
    temp_s0->unkB4 = temp_s0->unkB4 + 0x1000;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80077BCC.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80072100(s32 *); // extern
? func_80077B3C(s32); // extern
? func_80077BCC(s32); // extern
extern ? D_80165C18;
extern s32 D_8018C970;
extern ? D_8018CA70;

void func_80077C9C(void) {
    s32 *temp_s1;
    s32 temp_s0;
    void *temp_s2;
    s32 *phi_s1;

    phi_s1 = &D_8018C970;
    do {
        temp_s0 = *phi_s1;
        if (temp_s0 != -1) {
            temp_s2 = &D_80165C18 + (temp_s0 * 0xE0);
            if (temp_s2->unkA6 != 0) {
                func_80077B3C(temp_s0);
                func_80077BCC(temp_s0);
                if (temp_s2->unkA6 == 0) {
                    func_80072100(phi_s1);
                }
            }
        }
        temp_s1 = phi_s1 + 4;
        phi_s1 = temp_s1;
    } while (temp_s1 != &D_8018CA70);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80077C9C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800723A4(s32, ?, s32, void *); // extern
extern s32 D_8016559C;
extern ? D_80165C18;
extern ? D_8018CC80;
extern s16 D_8018D17C;
extern s32 D_8018D1F0;

void func_80077D5C(s32 arg0) {
    s32 temp_a0;
    s32 temp_a1;
    s32 temp_a2;
    void *temp_a3;
    s16 phi_v0;
    s32 phi_a1;

    if ((D_8016559C == 0) && (temp_a2 = D_8018D1F0, phi_a1 = 0, (temp_a2 > 0))) {
        temp_a3 = (arg0 * 4) + &D_8018CC80;
        phi_v0 = D_8018D17C;
loop_3:
        D_8018D17C = phi_v0 + 1;
        temp_a1 = phi_a1 + 1;
        phi_a1 = temp_a1;
        if (D_8018D17C >= temp_a2) {
            D_8018D17C = 0;
        }
        temp_a0 = *(temp_a3 + (D_8018D17C * 4));
        phi_v0 = D_8018D17C;
        if ((&D_80165C18 + (temp_a0 * 0xE0))->unkA6 == 0) {
            func_800723A4(temp_a0, 1, temp_a2, temp_a3);
            return;
        }
        if (temp_a1 >= temp_a2) {
            // Duplicate return node #8. Try simplifying control flow for better match
            return;
        }
        goto loop_3;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80077D5C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800721C0(?); // extern
? func_80072488(s32); // extern
? func_80086EF0(s32); // extern
extern ? D_0D005770;
extern ? D_0D0293D8;
extern f32 D_800EEB3C;
extern ? D_80165C18;

void func_80077E20(s32 arg0) {
    void *sp18;
    void *temp_v0;

    temp_v0 = (arg0 * 0xE0) + &D_80165C18;
    temp_v0->unk64 = &D_0D0293D8;
    temp_v0->unk6C = &D_0D0293D8;
    temp_v0->unk74 = &D_0D005770;
    temp_v0->unkDA = 0x10;
    temp_v0->unkD9 = 0x10;
    sp18 = temp_v0;
    temp_v0->unk0 = D_800EEB3C;
    func_800721C0(0x10);
    func_80086EF0(arg0);
    temp_v0->unkA0 = 0xFF;
    temp_v0->unkD5 = 0;
    temp_v0->unkA4 = 0;
    func_80072488(arg0);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80077E20.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800721C0(?); // extern
? func_800721E8(?); // extern
extern ? D_80165C40;
extern f32 D_8018D1E8;
extern s16 D_8018D208;
extern s16 D_8018D210;
extern s16 D_8018D218;

void func_80077EB8(s32 arg0, s32 arg1, void *arg2) {
    s16 temp_v0;

    temp_v0 = arg2->unk26 - arg1;
    if ((temp_v0 >= D_8018D210) || (D_8018D208 >= temp_v0)) {
        *(&D_80165C40 + (arg0 * 0xE0)) = D_8018D218 + (D_8018D1E8 * temp_v0);
        func_800721C0(0x10);
        return;
    }
    func_800721E8(0x10);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80077EB8.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80077EB8(s32, u16, void *, void *); // extern
? func_80086F60(s32, void *); // extern
? func_80086FD4(s32); // extern
? func_800877C4(s32); // extern
? func_8008BAB4(s32, ?, ?, void *); // extern
? func_8008BF18(s32); // extern
? func_8008BFC0(s32); // extern
extern f64 D_800EEB40;
extern ? D_80165C18;

void func_80077F64(s32 arg0, void *arg1) {
    f64 temp_f6;
    s16 temp_v0;
    s32 temp_v0_2;
    void *temp_s0;
    f64 phi_f6;

    temp_s0 = (arg0 * 0xE0) + &D_80165C18;
    temp_v0 = temp_s0->unkAE;
    if (temp_v0 != 0) {
        if (temp_v0 != 1) {
            if (temp_v0 != 2) {
                if (temp_v0 != 3) {
                    return;
                }
                func_80086F60(arg0, arg1);
                // Duplicate return node #11. Try simplifying control flow for better match
                return;
            }
            func_80077EB8(arg0, temp_s0->unkC0, arg1, arg1);
            func_800877C4(arg0);
            func_8008BF18(arg0);
            func_8008BFC0(arg0);
            if (temp_s0->unk8 <= 0.0f) {
                func_80086FD4(arg0);
                return;
            }
            // Duplicate return node #11. Try simplifying control flow for better match
            return;
        }
        arg1 = arg1;
        temp_s0->unkC0 = (random_int(0x4000) + arg1->unk26) - 0x2000;
        func_8008BAB4(arg0, 0xB4, 0x14, arg1);
        temp_v0_2 = random_int(0x64);
        temp_f6 = temp_v0_2;
        phi_f6 = temp_f6;
        if (temp_v0_2 < 0) {
            phi_f6 = temp_f6 + 4294967296.0;
        }
        temp_s0->unk28 = 0.0f;
        temp_s0->unk2C = 0.0f;
        temp_s0->unk3C = -0.75 - (phi_f6 * D_800EEB40);
        func_80086FD4(arg0);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80077F64.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80072428(); // extern
? func_80072488(s32); // extern
? func_80077E20(); // extern
? func_80077F64(); // extern
extern ? D_80165C18;

void func_800780CC(s32 arg0) {
    void *sp18;
    s16 temp_v0;
    void *temp_v1;

    temp_v1 = (arg0 * 0xE0) + &D_80165C18;
    temp_v0 = temp_v1->unkA6;
    if (temp_v0 != 0) {
        if (temp_v0 != 1) {
            if (temp_v0 != 2) {
                if (temp_v0 != 3) {
                    return;
                }
                func_80072428();
                // Duplicate return node #9. Try simplifying control flow for better match
                return;
            }
            sp18 = temp_v1;
            func_80077F64();
            if (temp_v1->unkAE == 0) {
                func_80072488(arg0);
                return;
            }
            // Duplicate return node #9. Try simplifying control flow for better match
            return;
        }
        func_80077E20();
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_800780CC.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80077D5C(); // extern
? func_800780CC(s32, ?); // extern
extern ? D_80165C18;
extern ? D_8018CC80;
extern s32 D_8018D1F0;

void func_80078170(s32 arg0, ? arg1) {
    s32 temp_a0;
    s32 temp_s1;
    s32 temp_v0;
    s32 *phi_s0;
    s32 phi_s1;
    s32 phi_v0;

    func_80077D5C();
    temp_v0 = D_8018D1F0;
    phi_s1 = 0;
    phi_v0 = temp_v0;
    if (temp_v0 > 0) {
        phi_s0 = (arg0 * 4) + &D_8018CC80;
        do {
            temp_a0 = *phi_s0;
            if ((&D_80165C18 + (temp_a0 * 0xE0))->unkA6 != 0) {
                func_800780CC(temp_a0, arg1);
                phi_v0 = D_8018D1F0;
            }
            temp_s1 = phi_s1 + 1;
            phi_s0 += 4;
            phi_s1 = temp_s1;
        } while (temp_s1 < phi_v0);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80078170.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80072488(s32); // extern
? func_80086EF0(); // extern
extern ? D_0D005770;
extern ? D_0D0293D8;
extern f32 D_800EEB48;
extern ? D_80165C18;

void func_80078220(s32 arg0) {
    void *temp_v0;

    temp_v0 = (arg0 * 0xE0) + &D_80165C18;
    temp_v0->unk64 = &D_0D0293D8;
    temp_v0->unk6C = &D_0D0293D8;
    temp_v0->unk74 = &D_0D005770;
    temp_v0->unk0 = D_800EEB48;
    func_80086EF0();
    func_80072488(arg0);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80078220.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80086F60(s32); // extern
? func_80086FD4(s32); // extern
s16 func_800872D8(s32, s32); // extern
? func_800877C4(s32); // extern
? func_8008BF18(s32); // extern
f32 sins(u16); // extern
f32 coss(u16); // extern
extern f64 D_800EEB50;
extern f64 D_800EEB58;
extern f64 D_800EEB60;
extern f64 D_800EEB68;
extern f64 D_800EEB70;
extern f64 D_800EEB78;
extern f64 D_800EEB80;
extern ? D_80165C18;

void func_80078288(s32 arg0) {
    s16 sp3E;
    s16 sp3C;
    s16 sp3A;
    u16 sp36;
    f32 sp24;
    Player *temp_v0_2;
    f32 temp_f2;
    f32 temp_f2_2;
    f32 temp_f8;
    f32 temp_f8_2;
    f64 temp_f18;
    f64 temp_f18_2;
    s16 temp_v0;
    s32 temp_v0_3;
    s32 temp_v0_4;
    s32 temp_v0_5;
    s32 temp_v0_6;
    s32 temp_v0_7;
    u16 temp_a0;
    u16 temp_a0_2;
    u16 temp_t1;
    u16 temp_t3;
    u16 temp_t6;
    void *temp_s0;
    f32 phi_f8;
    f64 phi_f18;
    f32 phi_f8_2;
    f64 phi_f18_2;

    temp_s0 = (arg0 * 0xE0) + &D_80165C18;
    temp_v0 = temp_s0->unkAE;
    if (temp_v0 != 0) {
        if (temp_v0 != 1) {
            if (temp_v0 != 2) {
                if (temp_v0 != 3) {
                    return;
                }
                func_80086F60(arg0);
                // Duplicate return node #20. Try simplifying control flow for better match
                return;
            }
            func_800877C4(arg0);
            temp_t1 = temp_s0->unkBE + temp_s0->unkC4;
            temp_s0->unkBE = temp_t1;
            temp_s0->unk28 = temp_s0->unk1C * sins(temp_t1 & 0xFFFF);
            func_8008BF18(arg0);
            if (temp_s0->unk8 <= 0.0) {
                func_80086FD4(arg0);
            }
            temp_s0->unkB4 = func_800872D8(arg0, camera1);
            return;
        }
        if (D_800DC50C != CREDITS_SEQUENCE) {
            sp3A = ((gPlayerOneCopy->unk_094 / 18.0f) * 216.0f) / 2.0f;
            sp3E = (random_int(0xF) - sp3A) + 0x2D;
            sp3C = random_int(0x12C) + 0x1E;
            temp_t6 = (((random_int(0x3000) - 0x1800) / ((sp3A / 0xF) + 1)) + camera1->unk26) & 0xFFFF;
            temp_a0 = temp_t6;
            sp36 = temp_t6;
            temp_v0_2 = gPlayerOneCopy;
            temp_f2 = sp3C;
            temp_s0->unk10 = (sins(temp_a0) * temp_f2) + temp_v0_2->posX;
            sp24 = temp_f2;
            temp_s0->unk14 = sp3E + temp_v0_2->unk_074;
            temp_s0->unk18 = (coss(sp36) * temp_f2) + gPlayerOneCopy->posZ;
            temp_s0->unkC4 = random_int(0x400) + 0x100;
            temp_v0_3 = random_int(0x64);
            temp_f8 = temp_v0_3;
            phi_f8 = temp_f8;
            if (temp_v0_3 < 0) {
                phi_f8 = temp_f8 + 4294967296.0f;
            }
            temp_s0->unk1C = (phi_f8 * D_800EEB50) + 2.0;
            temp_v0_4 = random_int(0x32);
            temp_f18 = temp_v0_4;
            phi_f18 = temp_f18;
            if (temp_v0_4 < 0) {
                phi_f18 = temp_f18 + 4294967296.0;
            }
            temp_s0->unk28 = 0.0f;
            temp_s0->unk2C = 0.0f;
            temp_s0->unk3C = D_800EEB60 - (phi_f18 * D_800EEB58);
            func_80086FD4(arg0);
            return;
        }
        sp3C = random_int(0x64) + 0x28;
        temp_t3 = ((random_int(0x3000) + camera1->unk26) - 0x1800) & 0xFFFF;
        temp_a0_2 = temp_t3;
        sp36 = temp_t3;
        temp_v0_5 = camera1;
        temp_f2_2 = sp3C;
        temp_s0->unk10 = (sins(temp_a0_2) * temp_f2_2) + temp_v0_5->unk0;
        sp24 = temp_f2_2;
        temp_s0->unk14 = temp_v0_5->unk4 + D_800EEB68;
        temp_s0->unk18 = (coss(sp36) * temp_f2_2) + camera1->unk8;
        temp_s0->unkC4 = random_int(0x400) + 0x100;
        temp_v0_6 = random_int(0x64);
        temp_f8_2 = temp_v0_6;
        phi_f8_2 = temp_f8_2;
        if (temp_v0_6 < 0) {
            phi_f8_2 = temp_f8_2 + 4294967296.0f;
        }
        temp_s0->unk1C = (phi_f8_2 * D_800EEB70) + 2.0;
        temp_v0_7 = random_int(0x32);
        temp_f18_2 = temp_v0_7;
        phi_f18_2 = temp_f18_2;
        if (temp_v0_7 < 0) {
            phi_f18_2 = temp_f18_2 + 4294967296.0;
        }
        temp_s0->unk28 = 0.0f;
        temp_s0->unk2C = 0.0f;
        temp_s0->unk3C = D_800EEB80 - (phi_f18_2 * D_800EEB78);
        func_80086FD4(arg0);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80078288.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80072428(); // extern
? func_80072488(s32); // extern
? func_80078220(); // extern
? func_80078288(); // extern
extern ? D_80165C18;

void func_800786EC(s32 arg0) {
    void *sp18;
    s16 temp_v0;
    void *temp_v1;

    temp_v1 = (arg0 * 0xE0) + &D_80165C18;
    temp_v0 = temp_v1->unkA6;
    if (temp_v0 != 0) {
        if (temp_v0 != 1) {
            if (temp_v0 != 2) {
                if (temp_v0 != 3) {
                    return;
                }
                func_80072428();
                // Duplicate return node #9. Try simplifying control flow for better match
                return;
            }
            sp18 = temp_v1;
            func_80078288();
            if (temp_v1->unkAE == 0) {
                func_80072488(arg0);
                return;
            }
            // Duplicate return node #9. Try simplifying control flow for better match
            return;
        }
        func_80078220();
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_800786EC.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800723A4(s32, ?, s32, ? *); // extern
extern ? D_80165C18;
extern ? D_8018C1B0;
extern s16 D_8018D174;

void func_80078790(void) {
    s32 temp_a2;
    s32 temp_v1;
    s16 phi_v0;
    s32 phi_v1;

    phi_v0 = D_8018D174;
    phi_v1 = 0;
loop_1:
    D_8018D174 = phi_v0 + 1;
    temp_v1 = phi_v1 + 1;
    phi_v1 = temp_v1;
    if (D_8018D174 >= 0x32) {
        D_8018D174 = 0;
    }
    temp_a2 = *(&D_8018C1B0 + (D_8018D174 * 4));
    phi_v0 = D_8018D174;
    if ((&D_80165C18 + (temp_a2 * 0xE0))->unkA6 == 0) {
        func_800723A4(temp_a2, 1, temp_a2, &D_8018C1B0);
        return;
    }
    if (temp_v1 == 0x32) {
        return;
    }
    goto loop_1;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80078790.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800786EC(s32); // extern
? func_80078790(); // extern
extern ? D_80165C18;
extern s32 D_8018C1B0;
extern ? D_8018C278;

void func_80078838(void) {
    s32 *temp_s0;
    s32 temp_a0;
    s32 *phi_s0;

    if (D_800DC50C != CREDITS_SEQUENCE) {
        func_80078790();
    } else {
        func_80078790();
        func_80078790();
        func_80078790();
        func_80078790();
    }
    phi_s0 = &D_8018C1B0;
    do {
        temp_a0 = *phi_s0;
        if ((&D_80165C18 + (temp_a0 * 0xE0))->unkA6 != 0) {
            func_800786EC(temp_a0);
        }
        temp_s0 = phi_s0 + 4;
        phi_s0 = temp_s0;
    } while (temp_s0 != &D_8018C278);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80078838.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800721C0(?); // extern
? func_800721E8(?); // extern
extern ? D_80165CB4;
extern f32 D_8018D1E8;
extern s16 D_8018D208;
extern s16 D_8018D210;
extern s16 D_8018D218;

void func_800788F8(s32 arg0, s32 arg1, void *arg2) {
    s16 temp_v0;

    temp_v0 = arg2->unk26 + arg1;
    if ((temp_v0 >= D_8018D210) && (D_8018D208 >= temp_v0)) {
        *(&D_80165CB4 + (arg0 * 0xE0)) = D_8018D218 + (D_8018D1E8 * temp_v0);
        func_800721C0(0x10);
        return;
    }
    func_800721E8(0x10);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_800788F8.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800788F8(s32, u16, ?); // extern
extern ? D_8018CC80;
extern s32 D_8018D1F0;

void func_800789AC(s32 arg0, ? arg1, s32 arg2) {
    s32 temp_s0;
    s32 *phi_s1;
    s32 phi_s0;

    phi_s0 = 0;
    if (D_8018D1F0 > 0) {
        phi_s1 = (arg0 * 4) + &D_8018CC80;
        do {
            func_800788F8(*phi_s1, *((phi_s0 * 8) + arg2), arg1);
            temp_s0 = phi_s0 + 1;
            phi_s1 += 4;
            phi_s0 = temp_s0;
        } while (temp_s0 < D_8018D1F0);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_800789AC.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
? func_80073CB0(s32, void *, ?, ?, s32, s32, s32);  /* extern */
? func_800788F8(s32, u16, s32);                     /* extern */
extern ? D_80165C18;
extern ? D_8018CC80;

void func_80078A44(s32 arg0, s32 arg1, s32 arg2) {
    s32 temp_s0;
    s32 temp_s3;
    u32 temp_hi;
    s32 *phi_s4;
    u32 phi_s3;

    phi_s3 = 0;
    if (D_8018D1F0 > 0) {
        phi_s4 = (arg0 * 4) + &D_8018CC80;
        do {
            temp_s0 = *phi_s4;
            func_800788F8(temp_s0, *((phi_s3 * 8) + arg2), arg1);
            temp_hi = phi_s3 % 5;
            switch (temp_hi) {
            case 0:
                func_80073CB0(temp_s0, &D_80165C18 + (temp_s0 * 0xE0) + 0xA0, 0x28, 0xB4, 0xFF, 0, -1);
                break;
            case 1:
                func_80073CB0(temp_s0, &D_80165C18 + (temp_s0 * 0xE0) + 0xA0, 0x80, 0xFF, 0xFF, 0, -1);
                break;
            case 2:
                func_80073CB0(temp_s0, &D_80165C18 + (temp_s0 * 0xE0) + 0xA0, 0x50, 0xC8, 0xFF, 0, -1);
                break;
            case 3:
                func_80073CB0(temp_s0, &D_80165C18 + (temp_s0 * 0xE0) + 0xA0, 0, 0x9B, 0xFF, 0, -1);
                break;
            case 4:
                func_80073CB0(temp_s0, &D_80165C18 + (temp_s0 * 0xE0) + 0xA0, 0x5A, 0x80, 0xFF, 0, -1);
                break;
            }
            temp_s3 = phi_s3 + 1;
            phi_s4 += 4;
            phi_s3 = temp_s3;
        } while (temp_s3 < D_8018D1F0);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80078A44.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
? func_80078170(s32, s32, s32);                     /* extern */
? func_800789AC(s32, s32, ? *);                     /* extern */
? func_80078A44(s32, s32, ? *);                     /* extern */
static ? D_800E6A38;                                /* unable to generate initializer; const */
static ? D_800E6AA8;                                /* unable to generate initializer; const */
static ? D_800E6B00;                                /* unable to generate initializer; const */
static ? D_800E6B38;                                /* unable to generate initializer; const */
static ? D_800E6BA8;                                /* unable to generate initializer; const */
static ? D_800E6C10;                                /* unable to generate initializer; const */
static ? D_800E6C80;                                /* unable to generate initializer; const */
static ? D_800E6DE0;                                /* unable to generate initializer; const */
u16 gCurrentCourseId;                               /* unable to generate initializer */

void func_80078C70(u32 arg0) {
    s32 sp1C;
    s32 sp18;
    s16 temp_v0;
    s32 temp_v1;
    u16 temp_t4;

    if (D_801657C8 == 0) {
        switch (arg0) {                             /* switch 1 */
        case 0:                                     /* switch 1 */
            sp1C = 0;
            sp18 = camera1;
            D_8018D200 = D_80150130[0] + 40.0f;
            break;
        case 1:                                     /* switch 1 */
            sp1C = 0;
            sp18 = camera1;
            D_8018D200 = D_80150130[0] + 40.0f;
            break;
        case 2:                                     /* switch 1 */
            sp18 = camera2;
            sp1C = D_8018D1F0;
            D_8018D200 = D_80150130[1] + 40.0f;
            break;
        case 3:                                     /* switch 1 */
            sp1C = 0;
            sp18 = camera1;
            D_8018D200 = D_80150130[0] + 40.0f;
            break;
        case 4:                                     /* switch 1 */
            sp18 = camera2;
            sp1C = D_8018D1F0;
            D_8018D200 = D_80150130[1] + 40.0f;
            break;
        }
        temp_v0 = D_8018D200;
        temp_t4 = gCurrentCourseId;
        temp_v1 = temp_v0 / 2;
        D_8018D208 = (temp_v1 * 0xB6) + 0x71C;
        D_8018D210 = (-temp_v1 * 0xB6) - 0x71C;
        D_8018D1E8 = 1.7578125 / temp_v0;
        D_8018D218 = 0xA0;
        switch (temp_t4) {                          /* switch 2 */
        case 0:                                     /* switch 2 */
            func_800789AC(sp1C, sp18, &D_800E6A38);
            return;
        case 4:                                     /* switch 2 */
            func_800789AC(sp1C, sp18, &D_800E6AA8);
            return;
        case 5:                                     /* switch 2 */
            func_80078170(sp1C, sp18, 0xB6);
            return;
        case 6:                                     /* switch 2 */
            func_800789AC(sp1C, sp18, &D_800E6B00);
            return;
        case 7:                                     /* switch 2 */
            func_800789AC(sp1C, sp18, &D_800E6B38);
            return;
        case 8:                                     /* switch 2 */
            func_800789AC(sp1C, sp18, &D_800E6A38);
            return;
        case 9:                                     /* switch 2 */
            func_800789AC(sp1C, sp18, &D_800E6AA8);
            return;
        case 10:                                    /* switch 2 */
            func_80078A44(sp1C, sp18, &D_800E6C80);
            return;
        case 11:                                    /* switch 2 */
            func_800789AC(sp1C, sp18, &D_800E6C10);
            return;
        case 12:                                    /* switch 2 */
            func_800789AC(sp1C, sp18, &D_800E6BA8);
            return;
        case 13:                                    /* switch 2 */
            func_80078A44(sp1C, sp18, &D_800E6C80);
            return;
        case 14:                                    /* switch 2 */
            func_80078A44(sp1C, sp18, &D_800E6DE0);
            /* Duplicate return node #22. Try simplifying control flow for better match */
            return;
        }
    } else {
    default:                                        /* switch 2 */
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80078C70.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800723A4(s32, ?); // extern
extern ? D_80183DB8;

void func_80078F64(void) {
    s32 temp_v0;

    temp_v0 = gScreenModeSelection;
    if (temp_v0 != 0) {
        if (temp_v0 != 1) {
            if (temp_v0 != 2) {
                if (temp_v0 != 3) {
                    return;
                }
                func_800723A4(D_80183DB8.unk0, 1);
                func_800723A4(D_80183DB8.unk4, 1);
                func_800723A4(D_80183DB8.unk8, 1);
                func_800723A4(D_80183DB8.unkC, 1);
                return;
            }
            func_800723A4(D_80183DB8.unk0, 1);
            func_800723A4(D_80183DB8.unk4, 1);
            return;
        }
        func_800723A4(D_80183DB8.unk0, 1);
        func_800723A4(D_80183DB8.unk4, 1);
        return;
    }
    func_800723A4(D_80183DB8.unk0, 1);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80078F64.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800723A4(s32, ?); // extern
extern ? D_80183DB8;

void func_80079054(s32 arg0) {
    func_800723A4(*(&D_80183DB8 + (arg0 * 4)), 2);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80079054.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800723A4(s32, ?); // extern
extern ? D_80183DB8;

void func_80079084(s32 arg0) {
    func_800723A4(*(&D_80183DB8 + (arg0 * 4)), 4);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80079084.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800723A4(s32, ?); // extern
extern ? D_80183DB8;

void func_800790B4(s32 arg0) {
    func_800723A4(*(&D_80183DB8 + (arg0 * 4)), 5);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_800790B4.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800723A4(s32, ?); // extern
extern ? D_80183DB8;

void func_800790E4(s32 arg0) {
    func_800723A4(*(&D_80183DB8 + (arg0 * 4)), 6);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_800790E4.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80074894(s32, ? *); // extern
? func_800748C4(s32, ? *); // extern
? func_800748F4(s32, ? *); // extern
extern ? D_80165C18;
extern s32 D_80183DB8;
extern s32 D_8018C028;

void func_80079114(s32 arg0, s32 arg1, s32 arg2) {
    void *temp_v0;
    void *temp_v1;

    temp_v1 = &D_80165C18 + (arg0 * 0xE0);
    if (temp_v1->unkA6 >= 2) {
        if (temp_v1->unkD8 == 1) {
            if (arg1 == 0) {
                func_80074894(D_8018C028, &D_80165C18);
                return;
            }
            temp_v0 = &D_80165C18 + (D_80183DB8 * 0xE0);
            temp_v1->unk60 = temp_v0->unk60;
            temp_v1->unk64 = temp_v0->unk64;
            return;
        }
        if (arg2 != 0) {
            if (arg2 != 1) {
                if (arg2 != 2) {
                    return;
                }
                func_80074894(D_8018C028, &D_80165C18);
                // Duplicate return node #12. Try simplifying control flow for better match
                return;
            }
            func_800748C4(D_8018C028, &D_80165C18);
            return;
        }
        func_800748F4(D_8018C028, &D_80165C18);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80079114.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800722CC(s32, ?); // extern
? func_800C9018(u8, ?); // extern
extern ? D_80165CF0;

void func_800791F0(s32 arg0, u8 arg1) {
    Player *sp1C;
    Player *temp_t8;
    Player *temp_v1;
    s16 temp_v0_2;
    u8 temp_v0;
    s16 phi_v0;
    Player *phi_v1;
    s32 phi_a0;

    temp_v0 = *(&D_80165CF0 + (arg0 * 0xE0));
    temp_t8 = gPlayerOne;
    temp_v1 = &temp_t8[arg1];
    if ((temp_v0 != 3) && (temp_v0 != 7)) {
        sp1C = temp_v1;
        func_800722CC(1);
        temp_v0_2 = gCurrentCourseId;
        phi_v0 = temp_v0_2;
        phi_v1 = temp_v1;
        phi_a0 = arg0;
        if (temp_v0_2 == 0xC) {
            temp_v1->unk_0CA &= 0xFFEF;
            goto block_5;
        }
    } else {
block_5:
        phi_v0 = gCurrentCourseId;
        phi_v1 = &temp_t8[arg1];
        phi_a0 = arg0;
    }
    if (phi_v0 == 0xC) {
        sp1C = phi_v1;
        func_800722CC(phi_a0, 0x10);
        phi_v1->unk_0CA &= 0xFFDF;
    }
    func_800C9018(arg1, 0x100FA28);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_800791F0.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800721E8(s32, ?); // extern
? func_80072488(s32); // extern
? func_80073444(s32, ? *, ? *, ?, s32); // extern
extern ? D_0D005EB0;
extern ? D_0D024ED8;
extern ? D_0F05EB50;
extern f32 D_800EEBF4;
extern s16 D_801656F0;
extern ? D_80165C18;
extern s32 D_8018D168;
extern s32 D_8018D180;

void func_800792D8(s32 arg0, s32 arg1) {
    void *sp24;
    void *temp_v0;

    if (arg1 == 0) {
        D_801656F0 = 0;
        D_8018D168 = 0;
    }
    func_80073444(arg0, &D_0D024ED8, &D_0F05EB50, 0x38, 0x48);
    temp_v0 = (arg0 * 0xE0) + &D_80165C18;
    temp_v0->unk74 = &D_0D005EB0;
    sp24 = temp_v0;
    temp_v0->unk0 = D_800EEBF4;
    func_800721E8(arg0, 0x10);
    func_80072488(arg0);
    temp_v0->unk48 = D_8018D180;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_800792D8.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
? func_800721C0(?);                                 /* extern */
? func_80072428();                                  /* extern */
? func_80072488(s32);                               /* extern */
? func_800729EC();                                  /* extern */
s32 func_80072E54(?, ?, ?, s32, s32);               /* extern */
? func_800792D8(s32);                               /* extern */
? func_80086F10(s32, ?, ? *);                       /* extern */
? play_sound2(?);                                   /* extern */
extern ? D_80165C18;
static ? D_800E67B8;                                /* unable to generate initializer; const */

void func_80079380(s32 arg0, s32 arg1) {
    void *sp20;
    u16 temp_t8;
    void *temp_v1;

    temp_v1 = (arg0 * 0xE0) + &D_80165C18;
    temp_t8 = temp_v1->unkA6;
    switch (temp_t8) {
    case 1:
        func_800792D8(arg1);
        return;
    case 2:
        sp20 = temp_v1;
        func_8007278C(arg0);
        if ((temp_v1->unk50 == 0x55) && (D_8018EDF3 == 3) && (arg1 == 0)) {
            D_8018D168 = 1;
            return;
        }
    default:
        return;
    case 3:
        func_800721C0(0x10);
        func_80086F10(arg0, 1, &D_800E67B8);
        func_80072488(arg0);
        return;
    case 4:
        if ((func_8007278C(arg0) != 0) && (D_8018EDF3 != 3) && (arg1 == 0)) {
            D_8018D168 = 1;
            return;
        }
        /* Duplicate return node #33. Try simplifying control flow for better match */
        return;
    case 5:
        func_8007278C(arg0);
        return;
    case 6:
        func_80072E54(1, 7, 1, 2, 0);
        return;
    case 7:
        sp20 = temp_v1;
        if ((func_8007278C(arg0) != 0) && (temp_v1->unk68 = temp_v1->unk68 + 0x200, (arg1 == 0))) {
            play_sound2(0x49008003);
            return;
        }
        /* Duplicate return node #33. Try simplifying control flow for better match */
        return;
    case 8:
        func_80072E54(8, 0xF, 1, 6, 0);
        return;
    case 9:
        if ((func_8007278C(arg0) != 0) && (arg1 == 0)) {
            play_sound2(0x49008003);
            return;
        }
        /* Duplicate return node #33. Try simplifying control flow for better match */
        return;
    case 10:
        if ((func_80072E54(0x10, 0x17, 1, 6, 0) != 0) && (arg1 == 0)) {
            D_801656F0 = 1;
            return;
        }
        /* Duplicate return node #33. Try simplifying control flow for better match */
        return;
    case 11:
        sp20 = temp_v1;
        if ((func_8007278C(arg0) != 0) && (temp_v1->unk68 = temp_v1->unk68 + 0x200, (arg1 == 0))) {
            play_sound2(0x49008004);
            return;
        }
        /* Duplicate return node #33. Try simplifying control flow for better match */
        return;
    case 12:
        func_80072E54(0x18, 0x1B, 1, 6, 0);
        return;
    case 13:
        if (arg1 == 0) {
            func_800729EC();
            D_8018D160 = 1;
            return;
        }
        func_80072488();
        return;
    case 14:
        func_8007278C(arg0);
        return;
    case 15:
        func_80072428();
        /* Duplicate return node #33. Try simplifying control flow for better match */
        return;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80079380.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800721E8(s32, ?); // extern
? func_80072488(s32); // extern
? func_80073444(s32, ? *, ? *, ?, s32); // extern
? func_800791F0(); // extern
? func_80086F10(s32, ?, ? *); // extern
extern ? D_0D006730;
extern ? D_0D0254D8;
extern ? D_0F07E350;
extern ? D_800E6834;
extern f32 D_800EEC38;
extern f32 D_800EEC3C;
extern ? D_80165C18;
extern s32 D_8018C028;

void func_8007963C(s32 arg0) {
    f32 temp_f0;
    void *temp_v0;

    func_800791F0();
    func_80073444(arg0, &D_0D0254D8, &D_0F07E350, 0x48, 0x38);
    temp_f0 = D_800EEC38;
    temp_v0 = (arg0 * 0xE0) + &D_80165C18;
    temp_v0->unk74 = &D_0D006730;
    temp_v0->unkC = temp_f0;
    temp_v0->unk8 = temp_f0;
    temp_v0->unk4 = temp_f0;
    temp_v0->unk64 = D_8018C028;
    temp_v0->unk0 = D_800EEC3C;
    func_80086F10(arg0, 2, &D_800E6834);
    func_800721E8(arg0, 0x10);
    func_80072488(arg0);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_8007963C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
? func_800721C0(?);                                 /* extern */
? func_80072428();                                  /* extern */
? func_80072488(s32);                               /* extern */
? func_80072E54(?, ?, ?, s32, s32);                 /* extern */
? func_8007963C();                                  /* extern */
extern ? D_80165CBE;

void func_80079700(s32 arg0) {
    u16 temp_t7;

    temp_t7 = *(&D_80165CBE + (arg0 * 0xE0));
    switch (temp_t7) {
    case 1:
        func_8007963C();
        return;
    case 2:
        func_800721C0(0x10);
        func_80072488(arg0);
        return;
    case 3:
        func_80072E54(0, 0x1F, 1, 2, -1);
        return;
    case 4:
        func_80072428();
        /* fallthrough */
    default:
        return;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80079700.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800722A4(s32, ?); // extern
? func_800723A4(s32, ?, s32); // extern
extern ? D_80183DB8;

void func_800797AC(s32 arg0) {
    s32 sp1C;
    Player *sp18;
    Player *temp_v0;
    s32 temp_a2;

    temp_a2 = *(&D_80183DB8 + (arg0 * 4));
    temp_v0 = &gPlayerOne[arg0];
    if ((gCurrentCourseId == 0xC) && ((temp_v0->unk_0CA & 1) != 0)) {
        sp18 = temp_v0;
        sp1C = temp_a2;
        func_800723A4(temp_a2, 7, temp_a2);
        temp_v0->unk_0CA |= 0x10;
    } else {
        sp1C = temp_a2;
        func_800723A4(temp_a2, 3, temp_a2);
    }
    func_800722A4(sp1C, 1);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_800797AC.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 func_80072354(s32, ?, Player *, s32); // extern
? func_800797AC(s32); // extern
? func_80090778(Player *); // extern
s32 func_802ABDF4(u16); // extern
extern ? D_80183DB8;

void func_80079860(s32 arg0) {
    Player *sp18;
    Player *temp_a2;
    s32 temp_a0;
    s32 temp_a3;

    temp_a3 = arg0;
    temp_a2 = &gPlayerOne[temp_a3];
    temp_a0 = *(&D_80183DB8 + (arg0 * 4));
    sp18 = temp_a2;
    arg0 = temp_a3;
    if ((func_80072354(temp_a0, 1, temp_a2, temp_a3) != 0) && (((sp18 = temp_a2, (func_802ABDF4(temp_a2->unk_11A) != 0)) && (temp_a2->unk_124 <= 3.0f)) || ((temp_a2->unk_0CA & 1) != 0) || ((temp_a2->unk_0F8 == 0xFD) && ((temp_a2->unk_0BC & 8) == 0)))) {
        func_80090778(temp_a2);
        func_800797AC(arg0);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80079860.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800722A4(?, void *); // extern
? func_800722CC(?, void *); // extern
extern ? D_80165CB8;

void func_8007993C(s32 arg0, void *arg1) {
    void *temp_a2;

    temp_a2 = arg1;
    if ((arg1->unkCA & 4) != 0) {
        arg1 = temp_a2;
        func_800722A4(2, temp_a2);
        *(&D_80165CB8 + (arg0 * 0xE0)) = arg1->unkC6;
        return;
    }
    func_800722CC(2, temp_a2);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_8007993C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800721E8(s32, ?); // extern
? func_80072488(s32); // extern
? func_80073444(s32, ? *, ? *, ?, s32); // extern
? func_80073720(s32); // extern
? func_800791F0(); // extern
? func_80086E70(s32); // extern
? func_800C8F80(u8, ?); // extern
extern ? D_0D005F30;
extern ? D_0D025CD8;
extern ? D_0F0CCF50;
extern f32 D_800EEC54;
extern ? D_80165C18;

void func_800799A8(s32 arg0, u8 arg1) {
    void *temp_v0;

    func_800791F0();
    func_80073444(arg0, &D_0D025CD8, &D_0F0CCF50, 0x38, 0x48);
    temp_v0 = (arg0 * 0xE0) + &D_80165C18;
    temp_v0->unk74 = &D_0D005F30;
    temp_v0->unk0 = D_800EEC54;
    func_80086E70(arg0);
    func_800721E8(arg0, 0x10);
    func_80073720(arg0);
    func_80072488(arg0);
    func_800C8F80(arg1, 0x100FA28);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_800799A8.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 f32_step_up_towards(void *, ?, ?, s32); // extern
s32 f32_step_down_towards(void *, ?, ?, s32); // extern
? func_80086F60(s32); // extern
? func_80086FD4(s32, s32); // extern
extern ? D_80165C18;

void func_80079A5C(s32 arg0, ? arg1) {
    s16 temp_v1;
    s32 temp_a3;
    void *temp_a0;
    void *temp_v0;

    temp_v0 = (arg0 * 0xE0) + &D_80165C18;
    temp_v1 = temp_v0->unkAE;
    temp_a3 = arg0;
    if (temp_v1 != 0) {
        if (temp_v1 != 1) {
            if (temp_v1 != 2) {
                temp_a0 = temp_v0 + 0x2C;
                if (temp_v1 != 3) {
                    return;
                }
                arg0 = temp_a3;
                if (f32_step_up_towards(temp_a0, 0x42C80000, 0x3F800000, temp_a3) != 0) {
                    func_80086F60(arg0);
                }
                // Duplicate return node #10. Try simplifying control flow for better match
                return;
            }
            arg0 = temp_a3;
            if (f32_step_down_towards(temp_v0 + 0x2C, 0x40A00000, 0x3F800000, temp_a3) != 0) {
                func_80086F60(arg0);
                return;
            }
            // Duplicate return node #10. Try simplifying control flow for better match
            return;
        }
        temp_v0->unk18 = 0.0f;
        temp_v0->unk14 = 0.0f;
        temp_v0->unk10 = 0.0f;
        temp_v0->unk30 = 0.0f;
        temp_v0->unk28 = 0.0f;
        temp_v0->unk2C = 80.0f;
        func_80086FD4(temp_a3, temp_a3);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80079A5C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
? func_800721C0(s32, ?);                            /* extern */
? func_800722CC(s32, ?);                            /* extern */
? func_80072428(s32);                               /* extern */
? func_80072488(s32);                               /* extern */
? func_800730BC(s32, ?, ?, ?, s32, s32);            /* extern */
? func_80073654(s32);                               /* extern */
? func_800736E0(s32);                               /* extern */
? func_80073720(s32);                               /* extern */
? func_8007993C(s32, void *);                       /* extern */
? func_800799A8(s32, s32);                          /* extern */
? func_80079A5C(s32, void *);                       /* extern */
? func_80086EAC(s32, ?, ?);                         /* extern */
? func_80090868(void *);                            /* extern */
? func_800C9018(u8, ?);                             /* extern */
extern ? D_80165C18;

void func_80079B40(s32 arg0, s32 playerId) {
    void *sp34;
    void *sp2C;
    s16 temp_v0;
    u8 temp_t6;
    void *temp_t2;

    temp_t2 = (arg0 * 0xE0) + &D_80165C18;
    sp34 = (playerId * 0xDD8) + gPlayerOne;
    sp2C = temp_t2;
    temp_v0 = temp_t2->unkA6;
    if (temp_v0 != 0) {
        if (temp_v0 != 1) {
            if (temp_v0 != 2) {
                if (temp_v0 != 3) {

                } else {
                    func_800730BC(arg0, 0, 3, 1, 2, -1);
                }
            } else {
                func_800721C0(arg0, 0x10);
                func_800736E0(arg0);
                func_80072488(arg0);
            }
        } else {
            func_800799A8(arg0, playerId);
        }
    }
    temp_t6 = sp2C->unkD6;
    switch (temp_t6) {
    case 1:
        if (func_80086FA4(arg0) != 0) {
            func_80073654(arg0);
        }
        break;
    case 2:
        func_80090868(sp34);
        func_80073654(arg0);
        break;
    case 3:
        if ((sp34->unkCA & 2) == 0) {
            func_80086EAC(arg0, 0, 3);
            func_80073654(arg0);
        }
        break;
    case 4:
        if (func_80086FA4(arg0) != 0) {
            func_80073654(arg0);
        }
        break;
    case 5:
        func_800722CC(arg0, 1);
        func_800C9018(playerId, 0x100FA28);
        func_80072428(arg0);
        func_80073720(arg0);
        break;
    }
    if (sp2C->unkA6 >= 2) {
        func_8007993C(arg0, sp34);
    }
    func_80079A5C(arg0, sp34);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80079B40.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
? func_800721C0(s32, ?);                            /* extern */
? func_800722A4(s32, ?);                            /* extern */
? func_800722CC(s32, ?);                            /* extern */
? func_80072428(s32);                               /* extern */
? func_80072488(s32);                               /* extern */
? func_800730BC(s32, ?, ?, ?, s32, s32);            /* extern */
? func_80073654(s32);                               /* extern */
? func_800736E0(s32);                               /* extern */
? func_80073720(s32);                               /* extern */
s32 func_8007375C(s32, ?);                          /* extern */
? func_8007993C(s32, void *);                       /* extern */
? func_800799A8(s32, s32);                          /* extern */
? func_80079A5C(s32, void *);                       /* extern */
? func_80086EAC(s32, ?, ?);                         /* extern */
? func_80090868(void *);                            /* extern */
? func_800C9018(u8, ?);                             /* extern */
? func_800C9060(u8, ?);                             /* extern */
extern ? D_80165C18;

void func_80079D44(s32 arg0, s32 playerId) {
    void *sp2C;
    s16 temp_v0;
    u8 temp_t7;
    void *temp_s1;
    void *temp_t1;

    temp_t1 = (arg0 * 0xE0) + &D_80165C18;
    sp2C = temp_t1;
    temp_v0 = temp_t1->unkA6;
    temp_s1 = (playerId * 0xDD8) + gPlayerOne;
    if (temp_v0 != 0) {
        if (temp_v0 != 1) {
            if (temp_v0 != 2) {
                if (temp_v0 != 3) {

                } else {
                    func_800730BC(arg0, 0, 3, 1, 2, -1);
                }
            } else {
                func_800721C0(arg0, 0x10);
                func_800736E0(arg0);
                temp_s1->unkCA = temp_s1->unkCA | 0x80;
                func_80072488(arg0);
            }
        } else {
            func_800799A8(arg0, playerId);
        }
    }
    temp_t7 = sp2C->unkD6;
    switch (temp_t7) {
    case 1:
        if (func_80086FA4(arg0) != 0) {
            func_800C9060(playerId, 0x1900A055);
            func_80073654(arg0);
        }
        break;
    case 2:
        func_80090868(temp_s1);
        func_800722A4(arg0, 4);
        func_80073654(arg0);
        break;
    case 3:
        if ((temp_s1->unkF8 == 9) && ((temp_s1->unkCA & 1) == 0) && (temp_s1->unk124 <= 30.0)) {
            func_800722A4(arg0, 8);
        }
        if ((temp_s1->unkCA & 2) == 0) {
            func_80086EAC(arg0, 0, 3);
            func_80073654(arg0);
        }
        break;
    case 4:
        func_8007375C(arg0, 0x1E);
        break;
    case 5:
        temp_s1->unkCA = temp_s1->unkCA & 0xFF7F;
        func_800722A4(arg0, 0x10);
        func_800722A4(arg0, 0x20);
        func_800722CC(arg0, 4);
        func_800722CC(arg0, 8);
        func_80073654(arg0);
        func_800C9060(playerId, 0x1900A056);
        break;
    case 6:
        if (func_8007375C(arg0, 0xA0) != 0) {
            func_800722CC(arg0, 0x10);
            temp_s1->unkCA = temp_s1->unkCA & 0xFFEF;
            temp_s1->unkCA = temp_s1->unkCA | 0x20;
        }
        break;
    case 7:
        func_8007375C(arg0, 0x3C);
        break;
    case 8:
        func_80073720(arg0);
        func_80072428(arg0);
        temp_s1->unkCA = temp_s1->unkCA & 0xFFDF;
        func_800722CC(arg0, 1);
        func_800C9018(playerId, 0x100FA28);
        break;
    }
    if (sp2C->unkA6 >= 2) {
        func_8007993C(arg0, temp_s1);
    }
    func_80079A5C(arg0, temp_s1);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80079D44.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800721E8(s32, ?); // extern
? func_80072488(s32); // extern
? func_80073444(s32, ? *, ? *, ?, s32); // extern
? func_800791F0(); // extern
? func_80086F10(s32, ?, ? *); // extern
extern ? D_0D006730;
extern ? D_0D0256D8;
extern ? D_0F09DB50;
extern ? D_800E694C;
extern f32 D_800EEC90;
extern f32 D_800EEC94;
extern ? D_80165C18;
extern s32 D_8018C028;

void func_8007A060(s32 arg0) {
    f32 temp_f0;
    void *temp_v0;

    func_800791F0();
    func_80073444(arg0, &D_0D0256D8, &D_0F09DB50, 0x48, 0x38);
    temp_f0 = D_800EEC90;
    temp_v0 = (arg0 * 0xE0) + &D_80165C18;
    temp_v0->unk74 = &D_0D006730;
    temp_v0->unkC = temp_f0;
    temp_v0->unk8 = temp_f0;
    temp_v0->unk4 = temp_f0;
    temp_v0->unk64 = D_8018C028;
    temp_v0->unk0 = D_800EEC94;
    func_800721E8(arg0, 0x10);
    func_80086F10(arg0, 5, &D_800E694C);
    func_80072488(arg0);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_8007A060.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
? func_800721C0(?);                                 /* extern */
? func_80072428();                                  /* extern */
? func_80072488(s32);                               /* extern */
? func_8007278C(?);                                 /* extern */
? func_80072E54(?, ?, ?, s32, s32);                 /* extern */
? func_80072F88(?, ?, ?, s32, s32);                 /* extern */
? func_8007A060();                                  /* extern */
extern ? D_80165C18;

void func_8007A124(s32 arg0) {
    u16 temp_t8;
    void *temp_v0;

    temp_v0 = (arg0 * 0xE0) + &D_80165C18;
    temp_t8 = temp_v0->unkA6;
    switch (temp_t8) {
    case 1:
        func_8007A060();
        return;
    case 2:
        func_800721C0(0x10);
        func_80072488(arg0);
        return;
    case 3:
        func_8007278C(0x14);
        return;
    case 4:
        func_80072E54(0, 0xF, 1, 2, 1);
        return;
    case 5:
        func_8007278C(0x3C);
        return;
    case 6:
        func_80072F88(0xF, 0, 1, 2, 1);
        return;
    case 7:
        if (temp_v0->unkAE == 0) {
            func_80072428();
        }
        /* fallthrough */
    default:
        return;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_8007A124.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800721E8(s32, ?); // extern
? func_80072488(s32); // extern
? func_80073444(s32, ? *, ? *, ?, s32); // extern
? func_800791F0(); // extern
? func_80086F10(s32, ?, ? *); // extern
extern ? D_0D006730;
extern ? D_0D0258D8;
extern ? D_0F0AD750;
extern ? D_800E694C;
extern f32 D_800EECB8;
extern f32 D_800EECBC;
extern ? D_80165C18;
extern s32 D_8018C028;

void func_8007A228(s32 arg0) {
    f32 temp_f0;
    void *temp_v0;

    func_800791F0();
    func_80073444(arg0, &D_0D0258D8, &D_0F0AD750, 0x48, 0x38);
    temp_f0 = D_800EECB8;
    temp_v0 = (arg0 * 0xE0) + &D_80165C18;
    temp_v0->unk74 = &D_0D006730;
    temp_v0->unkC = temp_f0;
    temp_v0->unk8 = temp_f0;
    temp_v0->unk4 = temp_f0;
    temp_v0->unk64 = D_8018C028;
    temp_v0->unk0 = D_800EECBC;
    func_800721E8(arg0, 0x10);
    func_80086F10(arg0, 5, &D_800E694C);
    func_80072488(arg0);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_8007A228.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
? func_800721C0(?);                                 /* extern */
? func_80072428();                                  /* extern */
? func_80072488(s32);                               /* extern */
? func_8007278C(?);                                 /* extern */
? func_80072E54(?, ?, ?, s32, s32);                 /* extern */
? func_80072F88(?, ?, ?, s32, s32);                 /* extern */
? func_8007A228();                                  /* extern */
extern ? D_80165C18;

void func_8007A2EC(s32 arg0) {
    u16 temp_t8;
    void *temp_v0;

    temp_v0 = (arg0 * 0xE0) + &D_80165C18;
    temp_t8 = temp_v0->unkA6;
    switch (temp_t8) {
    case 1:
        func_8007A228();
        return;
    case 2:
        func_800721C0(0x10);
        func_80072488(arg0);
        return;
    case 3:
        func_8007278C(0x14);
        return;
    case 4:
        func_80072E54(0, 0xF, 1, 2, 1);
        return;
    case 5:
        func_8007278C(0x3C);
        return;
    case 6:
        func_80072F88(0xF, 0, 1, 2, 1);
        return;
    case 7:
        if (temp_v0->unkAE == 0) {
            func_80072428();
        }
        /* fallthrough */
    default:
        return;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_8007A2EC.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800721E8(s32, ?); // extern
? func_80072488(s32); // extern
? func_80073444(s32, ? *, ? *, ?, s32); // extern
? func_800791F0(); // extern
? func_80086F10(s32, ?, ? *); // extern
? func_800C8F80(u8, ?); // extern
extern ? D_0D006730;
extern ? D_0D025AD8;
extern ? D_0F0BD350;
extern ? D_800E69B0;
extern f32 D_800EECE0;
extern f32 D_800EECE4;
extern ? D_80165C18;
extern s32 D_8018C028;

void func_8007A3F0(s32 arg0, u8 arg1) {
    void *sp28;
    f32 temp_f0;
    void *temp_v0;

    func_800791F0();
    func_80073444(arg0, &D_0D025AD8, &D_0F0BD350, 0x48, 0x38);
    temp_f0 = D_800EECE0;
    temp_v0 = (arg0 * 0xE0) + &D_80165C18;
    temp_v0->unk74 = &D_0D006730;
    temp_v0->unkC = temp_f0;
    temp_v0->unk8 = temp_f0;
    temp_v0->unk4 = temp_f0;
    temp_v0->unk64 = D_8018C028;
    sp28 = temp_v0;
    temp_v0->unk0 = D_800EECE4;
    func_800721E8(arg0, 0x10);
    func_80086F10(arg0, 6, &D_800E69B0);
    temp_v0->unkD6 = 0;
    func_80072488(arg0);
    func_800C8F80(arg1, 0x100FA28);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_8007A3F0.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
? func_800721C0(s32, ?);                            /* extern */
? func_80072428(s32);                               /* extern */
? func_80072488(s32);                               /* extern */
? func_800730BC(s32, ?, ?, ?, s32, s32);            /* extern */
? func_8007A3F0(s32, s32);                          /* extern */
? func_80086F10(s32, ?, ? *);                       /* extern */
? func_800C9018(u8, ?);                             /* extern */
extern ? D_80165C18;
static ? D_800E69F4;                                /* unable to generate initializer; const */

void func_8007A4D4(s32 arg0, s32 playerId) {
    void *sp2C;
    s32 temp_t3;
    u16 temp_t2;
    u8 temp_v0;
    void *temp_s0;

    temp_s0 = (arg0 * 0xE0) + &D_80165C18;
    temp_t2 = temp_s0->unkA6;
    sp2C = (playerId * 0xDD8) + gPlayerOne;
    switch (temp_t2) {
    case 1:
        func_8007A3F0(arg0, playerId);
        break;
    case 2:
        func_800721C0(arg0, 0x10);
        temp_s0->unkD6 = 1;
        func_80072488(arg0);
        break;
    case 3:
        func_800730BC(arg0, 0, 0xF, 1, 2, -1);
        break;
    case 4:
        func_80072428(arg0);
        break;
    }
    temp_v0 = temp_s0->unkD6;
    if (temp_v0 != 1) {
        if (temp_v0 != 2) {
            return;
        }
        temp_t3 = temp_s0->unk4C - 1;
        temp_s0->unk4C = temp_t3;
        if (temp_t3 == 0) {
            func_80072488(arg0);
            temp_s0->unkD6 = 0;
        }
        /* Duplicate return node #14. Try simplifying control flow for better match */
        return;
    }
    if ((temp_s0->unkA6 >= 3) && ((sp2C->unkBC << 9) >= 0)) {
        func_80086F10(arg0, 6, &D_800E69F4);
        temp_s0->unkD6 = 2;
        temp_s0->unk4C = 0x50;
        func_800C9018(playerId, 0x100FA28);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_8007A4D4.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
f32 sins(s32); // extern
f32 coss(s32); // extern
extern ? D_80165C18;

void func_8007A66C(s32 arg0, void *arg1, void *arg2) {
    f32 sp24;
    void *sp20;
    s32 temp_s0;
    s32 temp_t8;
    void *temp_v0;

    temp_t8 = (0x8000 - arg2->unk26) & 0xFFFF;
    temp_s0 = temp_t8;
    sp24 = coss(temp_t8 & 0xFFFF);
    temp_v0 = (arg0 * 0xE0) + &D_80165C18;
    temp_v0->unk4 = (arg1->unk14 + (sp24 * (temp_v0->unk10 + temp_v0->unk28))) - ((temp_v0->unk30 + temp_v0->unk18) * sins(temp_s0 & 0xFFFF));
    sp20 = temp_v0;
    temp_v0->unk8 = temp_v0->unk2C + (arg1->unk74 + temp_v0->unk14);
    sp24 = sins(temp_s0 & 0xFFFF);
    temp_v0->unkC = ((temp_v0->unk30 + temp_v0->unk18) * coss(temp_s0 & 0xFFFF)) + (arg1->unk1C + (sp24 * (temp_v0->unk10 + temp_v0->unk28)));
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_8007A66C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
f32 sins(s32); // extern
f32 coss(s32); // extern
extern ? D_80165C18;

void func_8007A778(s32 arg0, void *arg1, void *arg2) {
    f32 sp24;
    void *sp20;
    s32 temp_s0;
    s32 temp_t8;
    void *temp_v0;

    temp_t8 = (0x8000 - arg2->unk26) & 0xFFFF;
    temp_s0 = temp_t8;
    sp24 = coss(temp_t8 & 0xFFFF);
    temp_v0 = (arg0 * 0xE0) + &D_80165C18;
    temp_v0->unk4 = (arg1->unk14 + (sp24 * (temp_v0->unk10 + temp_v0->unk28))) - ((temp_v0->unk30 + temp_v0->unk18) * sins(temp_s0 & 0xFFFF));
    sp20 = temp_v0;
    temp_v0->unk8 = temp_v0->unk2C + (arg1->unk18 + temp_v0->unk14);
    sp24 = sins(temp_s0 & 0xFFFF);
    temp_v0->unkC = ((temp_v0->unk30 + temp_v0->unk18) * coss(temp_s0 & 0xFFFF)) + (arg1->unk1C + (sp24 * (temp_v0->unk10 + temp_v0->unk28)));
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_8007A778.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800790E4(); // extern
extern ? D_80165CBE;
extern ? D_80183DB8;

void func_8007A88C(s32 arg0) {
    if ((*(&D_80165CBE + (*(&D_80183DB8 + (arg0 * 4)) * 0xE0)) == 0) && (gPlayerOne[arg0].unk_0BC & 0x400000)) {
        func_800790E4();
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_8007A88C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80079860(s32); // extern
? func_8007A88C(); // extern
extern s8 D_801657B4;

void func_8007A910(s32 arg0) {
    if (D_801657B4 == 0) {
        func_8007A88C();
    }
    func_80079860(arg0);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_8007A910.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
? func_80079380(s32, s32);                          /* extern */
? func_80079700(s32, s32);                          /* extern */
? func_80079B40(s32, s32);                          /* extern */
? func_80079D44(s32, s32);                          /* extern */
? func_8007A124(s32, s32);                          /* extern */
? func_8007A2EC(s32, s32);                          /* extern */
? func_8007A4D4(s32, s32);                          /* extern */
? func_8008BFFC(s32);                               /* extern */
extern ? D_80165CF0;
extern ? D_80183DB8;

void func_8007A948(s32 arg0) {
    s32 temp_s0;
    u8 temp_t8;

    temp_s0 = *(&D_80183DB8 + (arg0 * 4));
    temp_t8 = *(&D_80165CF0 + (temp_s0 * 0xE0));
    switch (temp_t8) {
    case 1:
        func_80079380(temp_s0, arg0);
        func_8008BFFC(temp_s0);
        return;
    case 2:
        func_80079700(temp_s0, arg0);
        func_8008BFFC(temp_s0);
        return;
    case 3:
        func_80079B40(temp_s0, arg0);
        return;
    case 4:
        func_8007A124(temp_s0, arg0);
        func_8008BFFC(temp_s0);
        return;
    case 5:
        func_8007A2EC(temp_s0, arg0);
        func_8008BFFC(temp_s0);
        return;
    case 6:
        func_8007A4D4(temp_s0, arg0);
        func_8008BFFC(temp_s0);
        return;
    case 7:
        func_80079D44(temp_s0, arg0);
        /* fallthrough */
    default:
        return;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_8007A948.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
? func_80079114(s32, s32, ?);                       /* extern */
? func_8007A66C(s32, s32, s32);                     /* extern */
? func_8007A778(s32, s32, s32);                     /* extern */
? func_8007A910();                                  /* extern */
extern ? D_80165CF0;
extern ? D_80183DB8;
extern ? D_80183FA8;

void func_8007AA44(s32 arg0) {
    s32 temp_s0;
    u8 temp_t1;

    func_8007A910();
    temp_s0 = *(&D_80183DB8 + (arg0 * 4));
    temp_t1 = *(&D_80165CF0 + (temp_s0 * 0xE0));
    D_8018C028 = (arg0 << 0xD) + &D_80183FA8;
    switch (temp_t1) {
    case 1:
        func_80079114(temp_s0, arg0, 2);
        func_8007A66C(temp_s0, D_8018CF1C, D_8018CF14);
        return;
    case 2:
        func_80079114(temp_s0, arg0, 0);
        func_8007A66C(temp_s0, D_8018CF1C, D_8018CF14);
        return;
    case 3:
        func_80079114(temp_s0, arg0, 0);
        func_8007A778(temp_s0, D_8018CF1C, D_8018CF14);
        return;
    case 4:
        func_80079114(temp_s0, arg0, 0);
        func_8007A66C(temp_s0, D_8018CF1C, D_8018CF14);
        return;
    case 5:
        func_80079114(temp_s0, arg0, 0);
        func_8007A66C(temp_s0, D_8018CF1C, D_8018CF14);
        return;
    case 6:
        func_80079114(temp_s0, arg0, 0);
        func_8007A66C(temp_s0, D_8018CF1C, D_8018CF14);
        return;
    case 7:
        func_80079114(temp_s0, arg0, 0);
        func_8007A778(temp_s0, D_8018CF1C, D_8018CF14);
        /* fallthrough */
    default:
        return;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_8007AA44.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 func_80072354(s32, ?, s32); // extern
? func_800723A4(s32, ?); // extern
? func_800C9060(u8, ?); // extern
extern ? D_80183E88;
extern ? D_8018CA70;

void func_8007ABFC(s32 arg0, s32 arg1) {
    s32 sp1C;
    void *sp18;
    s32 temp_a0;
    s32 temp_a2;
    void *temp_v1;

    temp_v1 = (arg0 * 0x84) + &D_8018CA70;
    temp_a2 = arg0;
    if (temp_v1->unk70 == 0) {
        temp_a0 = *(&D_80183E88 + (arg0 * 4));
        sp18 = temp_v1;
        arg0 = temp_a2;
        sp1C = temp_a0;
        if (func_80072354(temp_a0, 4, temp_a2) != 0) {
            sp18 = temp_v1;
            func_800723A4(temp_a0, 0);
            if (arg1 != 0) {
                temp_v1->unk76 = arg1;
            }
        }
        func_800C9060(arg0, 0x19008406);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_8007ABFC.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800722A4(s32, ?); // extern
? func_800722CC(s32, ?); // extern
s32 func_80072354(s32, ?); // extern
? func_80072388(s32, ?); // extern
? func_800726CC(s32, ?); // extern
extern ? D_80165C18;
extern ? D_80183E88;

void func_8007AC9C(s32 arg0) {
    Player *sp20;
    Player *temp_v0;
    s32 temp_s0;
    void *temp_s1;

    temp_s0 = *(&D_80183E88 + (arg0 * 4));
    temp_s1 = (temp_s0 * 0xE0) + &D_80165C18;
    temp_v0 = &gPlayerOne[arg0];
    if (temp_s1->unkA4 == 0xF) {
        sp20 = temp_v0;
        if (func_80072354(temp_s0, 2) != 0) {
            func_800722A4(temp_s0, 2);
            temp_s1->unk98 = 0x258;
            func_800726CC(temp_s0, 0x32);
        }
        if (temp_s1->unk98 == 0) {
            func_800722CC(temp_s0, 2);
            sp20->unk_010 = 0;
            temp_s1->unkA4 = 0;
            func_80072388(temp_s0, 0);
            func_800726CC(temp_s0, 9);
            return;
        }
        // Duplicate return node #6. Try simplifying control flow for better match
        return;
    }
    temp_v0->unk_010 = 0;
    temp_s1->unkA4 = 0;
    func_80072388(temp_s0, 0);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_8007AC9C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern ? D_0D008150;
extern ? D_0D008790;
extern ? D_0D008B14;
extern u8 D_801658FD;
extern u8 D_801658FF;
extern s32 gRaceFrameCounter;

u8 gen_random_item(s16 arg0, s16 arg1) {
    s32 sp18;
    s32 temp_v0;
    s32 temp_v1;
    u8 phi_v1;
    u8 *phi_a1;
    s32 phi_v0;

    D_801658FD = (random_int(0x64) + (D_801658FD + D_801658FF) + gRaceFrameCounter) % 0x64;
    temp_v1 = gModeSelection;
    phi_a1 = &D_801658FD;
    if (temp_v1 == VERSUS) {
        temp_v0 = gPlayerCountSelection1;
        if (temp_v0 != 2) {
            if (temp_v0 != 3) {
                if (temp_v0 != 4) {

                } else {
                    sp18 = lookup_item(0xD008984);
                    goto block_8;
                }
            } else {
                sp18 = lookup_item(0xD008858);
                goto block_8;
            }
        } else {
            sp18 = lookup_item(&D_0D008790);
block_8:
            phi_a1 = &D_801658FD;
        }
        phi_v1 = *((arg0 * 0x64) + sp18 + *phi_a1);
    } else if (temp_v1 == BATTLE) {
        phi_v1 = *(D_801658FD + lookup_item(&D_0D008B14));
    } else {
        if (arg1 == 0) {
            phi_v0 = lookup_item(&D_0D008150);
        } else {
            phi_v0 = lookup_item(0xD008470);
        }
        phi_v1 = *((arg0 * 0x64) + phi_v0 + D_801658FD);
    }
    return phi_v1;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/gen_random_item.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? gen_random_item(s16, ?); // extern

void func_8007AF40(s32 arg0, s16 arg1) {
    gen_random_item(arg1, 0);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_8007AF40.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? gen_random_item(s16, ?); // extern

void func_8007AF78(s32 arg0, s16 arg1) {
    gen_random_item(arg1, 1);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_8007AF78.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800729B4(s32, s16); // extern
s16 func_8007AF40(s16, s16); // extern
extern ? D_80164392;
extern ? D_801643BA;
extern ? D_8018CA70;

s16 func_8007AFB0(s32 arg0, s32 arg1) {
    s16 sp1A;
    s16 temp_a1;
    s32 temp_v0;
    u8 temp_a0;
    void *temp_v1;
    s16 phi_a1;

    temp_v0 = arg1 * 4;
    temp_v1 = (arg1 * 0x84) + &D_8018CA70;
    temp_a0 = temp_v1->unk76;
    phi_a1 = func_8007AF40(*(&D_80164392 + temp_v0), *(&D_801643BA + temp_v0));
    if (temp_a0 != 0) {
        temp_a1 = temp_a0;
        temp_v1->unk76 = 0;
        phi_a1 = temp_a1;
    }
    sp1A = phi_a1;
    func_800729B4(arg0, phi_a1);
    return sp1A;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_8007AFB0.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800722A4(s32, ?, s32 *, void *); // extern
? func_800722CC(s32, ?, s32); // extern
s32 func_80072320(s32, ?); // extern
s16 func_8007AF40(s16, s16); // extern
? func_800C9060(s32, ?); // extern
extern ? D_80164392;
extern ? D_801643BA;
extern ? D_80165C18;
extern s32 D_80183E88;

? func_8007B040(s32 arg0, s32 arg1) {
    s32 sp64;
    s32 sp60;
    ? sp50;
    ? sp40;
    void *sp38;
    s16 temp_a1;
    s16 temp_t0_2;
    s32 *temp_a2;
    s32 temp_a0;
    s32 temp_t0;
    s32 temp_t3;
    s32 temp_t8;
    s32 temp_v0;
    s32 temp_v0_2;
    s32 temp_v1;
    s32 temp_v1_2;
    void *temp_a3;
    void *temp_a3_2;
    void *temp_s0;
    s16 phi_v1;
    s32 phi_v1_2;
    s32 *phi_a0;
    s32 phi_a3;
    s32 phi_a3_2;
    ? phi_t3;
    s32 phi_a3_3;

    phi_a3 = 0;
    phi_a3_2 = 0;
    phi_t3 = 0;
    if (gModeSelection == GRAND_PRIX) {
        if (random_int(0x64) < 0x51) {
            temp_v0 = arg1 * 4;
            phi_v1 = func_8007AF40(*(&D_80164392 + temp_v0), *(&D_801643BA + temp_v0));
        } else {
            sp60 = 0;
            func_800C9060(arg1 & 0xFF, 0x1900A058);
            phi_v1 = sp60;
        }
        temp_a3 = &D_80165C18 + (arg0 * 0xE0);
        temp_a3->unkA2 = phi_v1;
        temp_a3->unkD2 = phi_v1;
        phi_t3 = 1;
    } else {
        temp_t0 = gPlayerCountSelection1;
        phi_v1_2 = 0;
        if (temp_t0 > 0) {
            phi_a0 = &D_80183E88;
            do {
                phi_a3_3 = phi_a3;
                if (phi_v1_2 != arg1) {
                    temp_v0_2 = phi_a3 * 4;
                    temp_a1 = (&D_80165C18 + (*phi_a0 * 0xE0))->unkA4;
                    if (temp_a1 != 0) {
                        *(&sp50 + temp_v0_2) = phi_v1_2;
                        *(&sp40 + temp_v0_2) = temp_a1;
                        phi_a3_3 = phi_a3 + 1;
                    }
                }
                temp_v1 = phi_v1_2 + 1;
                phi_v1_2 = temp_v1;
                phi_a0 += 4;
                phi_a3 = phi_a3_3;
                phi_a3_2 = phi_a3_3;
            } while (temp_v1 < temp_t0);
        }
        if (phi_a3_2 != 0) {
            temp_t3 = random_int(phi_a3_2 & 0xFFFF) * 4;
            temp_v1_2 = *(&sp50 + temp_t3);
            temp_t0_2 = (&sp40 + temp_t3)->unk2;
            temp_a3_2 = &D_80165C18 + (arg0 * 0xE0);
            temp_t8 = temp_v1_2 * 0x70;
            temp_a3_2->unkD1 = temp_v1_2;
            temp_a3_2->unkA2 = temp_t0_2;
            temp_a3_2->unkD2 = temp_t0_2;
            temp_a2 = &D_80183E88 + (temp_v1_2 * 4);
            temp_a0 = *temp_a2;
            sp38 = ((((temp_t8 - temp_v1_2) * 4) - temp_v1_2) * 8) + gPlayerOne;
            sp64 = temp_a0;
            func_800722A4(temp_a0, 1, temp_a2, temp_a3_2);
            temp_s0 = &D_80165C18 + (temp_a0 * 0xE0);
            temp_s0->unkA4 = 0;
            sp38->unk10 = 0;
            if (func_80072320(temp_a0, 2) != 0) {
                func_800722CC(sp64, 2, sp64);
                temp_s0->unk98 = 0;
            }
            phi_t3 = 1;
        }
    }
    return phi_t3;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_8007B040.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800722A4(s32, ?); // extern
? func_80072428(); // extern
? func_800726CC(s32, ?); // extern
? func_800C8F80(u8, ?); // extern
extern ? D_0D01DED8;
extern ? D_0D01FED8;
extern s8 D_80165888;
extern ? D_80165C18;
extern s16 D_8018CAB8;

void func_8007B254(s32 arg0, u8 arg1) {
    void *sp18;
    s8 temp_v1;
    void *temp_v0;

    func_80072428();
    temp_v0 = (arg0 * 0xE0) + &D_80165C18;
    temp_v0->unkA6 = 2;
    temp_v0->unkA4 = 0;
    temp_v0->unk68 = &D_0D01DED8;
    temp_v0->unk6C = &D_0D01FED8;
    temp_v0->unkD9 = 0x28;
    temp_v0->unkDA = 0x20;
    temp_v0->unk4C = 0x32;
    temp_v0->unkD6 = 1;
    temp_v0->unk98 = 0;
    sp18 = temp_v0;
    func_800722A4(arg0, 4);
    if (D_80165888 != 0) {
        sp18 = temp_v0;
        func_800726CC(arg0, 8);
        temp_v0->unkA4 = 0xE;
        temp_v1 = temp_v0->unkA5;
        temp_v0->unkD6 = 2;
        temp_v0->unkD2 = temp_v1;
        temp_v0->unkA2 = temp_v1;
        D_8018CAB8 = 0;
        D_80165888 = 0;
        return;
    }
    func_800C8F80(arg1, 0x100FE1C);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_8007B254.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 792017ad9d422c2467bd42686f383a5c41f41c75
? s16_step_up_towards(s16 *, ?, ?);                       /* extern */
s32 s16_step_down_towards(s16 *, ?, ?);                     /* extern */
? func_800722CC(s32, ?);                            /* extern */
s32 func_80072320(s32, ?);                          /* extern */
s32 func_80072354(s32, ?);                          /* extern */
? func_800723A4(s32, ?);                            /* extern */
? func_80072428(s32);                               /* extern */
? func_80072488(s32);                               /* extern */
? func_800726CC(s32, ?);                            /* extern */
? func_8007278C(s32, ?);                            /* extern */
? func_800729D0(s32, s16);                          /* extern */
? func_80072D3C(s32, s16, ?, ?, s32);               /* extern */
? func_80072E54(s32, ?, ?, ?, s32, s32);            /* extern */
? func_80073600(s32);                               /* extern */
? func_8007AC9C(s32);                               /* extern */
s8 func_8007AFB0(s32, s32);                         /* extern */
s32 func_8007B040(s32, s32);                        /* extern */
? func_8007B254(s32, s32);                          /* extern */
? func_800C8F80(u8, ?);                             /* extern */
? func_800C9018(u8, ?);                             /* extern */
extern ? D_0D01DED8;
extern ? D_0D01E0D8;
extern ? D_0D01E2D8;
extern ? D_0D01E4D8;
extern ? D_0D01E6D8;
extern ? D_0D01E8D8;
extern ? D_0D01EAD8;
extern ? D_0D01ECD8;
extern ? D_0D01EED8;
extern ? D_0D01F0D8;
extern ? D_0D01F2D8;
extern ? D_0D01F4D8;
extern ? D_0D01F6D8;
extern ? D_0D01F8D8;
extern ? D_0D01FAD8;
extern ? D_0D01FCD8;
extern ? D_0D01FED8;
extern ? D_0D0203D8;
extern ? D_0D0208D8;
extern ? D_0D020DD8;
extern ? D_0D0212D8;
extern ? D_0D0217D8;
extern ? D_0D021CD8;
extern ? D_0D0221D8;
extern ? D_0D0226D8;
extern ? D_0D022BD8;
extern ? D_0D0230D8;
extern ? D_0D0235D8;
extern ? D_0D023AD8;
extern ? D_0D023FD8;
extern ? D_0D0244D8;
extern ? D_0D0249D8;
extern s8 D_80165888;
extern ? D_80165C18;
extern ? D_80183E88;
extern s32 gActiveScreenMode;
extern s32 gControllerOne;
static ? *D_800E44F0[0x10] = {
    &D_0D01DED8,
    &D_0D01E0D8,
    &D_0D01E2D8,
    &D_0D01F0D8,
    &D_0D01F2D8,
    &D_0D01F4D8,
    &D_0D01F6D8,
    &D_0D01ECD8,
    &D_0D01FAD8,
    &D_0D01FCD8,
    &D_0D01F8D8,
    &D_0D01EED8,
    &D_0D01E4D8,
    &D_0D01E6D8,
    &D_0D01E8D8,
    &D_0D01EAD8,
}; /* const */
static ? *D_800E4530[0x10] = {
    &D_0D01FED8,
    &D_0D0203D8,
    &D_0D0208D8,
    &D_0D022BD8,
    &D_0D0230D8,
    &D_0D0235D8,
    &D_0D023AD8,
    &D_0D0221D8,
    &D_0D0244D8,
    &D_0D0249D8,
    &D_0D023FD8,
    &D_0D0226D8,
    &D_0D020DD8,
    &D_0D0212D8,
    &D_0D0217D8,
    &D_0D021CD8,
}; /* const */

void func_8007B34C(s32 playerId) {
    s32 sp40;
    Player *sp38;
    void *sp2C;
    struct_8018CA70_entry *sp28;
    s16 temp_a1;
    s16 temp_a1_2;
    s16 temp_a1_3;
    s16 temp_v0_6;
    s32 temp_s0;
    s32 temp_v0;
    s32 temp_v0_2;
    s32 temp_v0_4;
    s8 temp_v0_7;
    struct_8018CA70_entry *temp_v1;
    struct_8018CA70_entry *temp_v1_2;
    struct_8018CA70_entry *temp_v1_3;
    struct_8018CA70_entry *temp_v1_4;
    struct_8018CA70_entry *temp_v1_5;
    struct_8018CA70_entry *temp_v1_6;
    u16 temp_t6;
    u16 temp_v0_3;
    u8 temp_v0_5;
    void *temp_t0;

    sp38 = &gPlayerOne[playerId];
    sp40 = 0;
    temp_s0 = *(&D_80183E88 + (playerId * 4));
    if ((((playerId * 0x10) + gControllerOne)->unk6 & 0x2000) != 0) {
        sp40 = 1;
    }
    if (D_80165888 != 0) {
        func_800723A4(temp_s0, 0);
    }
    temp_t0 = (temp_s0 * 0xE0) + &D_80165C18;
    sp2C = temp_t0;
    temp_t6 = temp_t0->unkA6;
    switch (temp_t6) {
    case 1:
        func_8007B254(temp_s0, playerId);
        break;
    case 2:
        temp_v0 = gActiveScreenMode;
        if (temp_v0 == 0) {
            temp_v1 = &D_8018CA70[playerId];
            sp28 = temp_v1;
            s16_step_up_towards(&temp_v1->slideItemBoxY, 0x40, 4);
            if (temp_v1->slideItemBoxY == 0x40) {
                func_80072488(temp_s0);
            }
        } else if (temp_v0 == 3) {
            if ((playerId == 0) || (playerId == 2)) {
                temp_v1_2 = &D_8018CA70[playerId];
                sp28 = temp_v1_2;
                s16_step_up_towards(&temp_v1_2->slideItemBoxX, 0x80, 8);
                if (temp_v1_2->slideItemBoxX == 0x80) {
                    func_80072488(temp_s0);
                }
            } else {
                temp_v1_3 = &D_8018CA70[playerId];
                sp28 = temp_v1_3;
                s16_step_down_towards(&temp_v1_3->slideItemBoxX, -0x80, 8);
                if (temp_v1_3->slideItemBoxX == -0x80) {
                    func_80072488(temp_s0);
                }
            }
        } else {
            temp_v1_4 = &D_8018CA70[playerId];
            sp28 = temp_v1_4;
            s16_step_up_towards(&temp_v1_4->slideItemBoxX, 0x80, 8);
            if (temp_v1_4->slideItemBoxX == 0x80) {
                func_80072488(temp_s0);
            }
        }
        break;
    case 3:
        func_80072E54(temp_s0, 1, 0xF, 1, 2, 2);
        break;
    case 4:
        func_80072E54(temp_s0, 1, 6, 1, 8, 1);
        break;
    case 5:
        func_80072E54(temp_s0, 1, 4, 1, 0x10, 1);
        break;
    case 6:
        sp2C->unkD2 = func_8007AFB0(temp_s0, playerId);
        sp2C->unk4C = 8;
        sp2C->unkD6 = 2U;
        func_80072488(temp_s0);
        sp28 = (struct_8018CA70_entry *) (u8) playerId;
        func_800C9018((u8) playerId, 0x0100FE1C);
        func_800C8F80((u8) playerId, 0x0100FE47);
        break;
    case 7:
        func_80072D3C(temp_s0, sp2C->unkA2, 0, 8, 0xA);
        break;
    case 9:
        func_800722CC(temp_s0, 4);
        func_80073600(temp_s0);
        sp2C->unkD2 = 0;
        func_80072488(temp_s0);
        break;
    case 10:
        func_8007278C(temp_s0, 0x14);
        break;
    case 11:
        temp_v0_2 = gActiveScreenMode;
        if (temp_v0_2 == 0) {
            if (s16_step_down_towards((playerId * 0x84) + 0x48 + D_8018CA70, 0, 4) != 0) {
                func_80072488(temp_s0);
            }
        } else if (temp_v0_2 == 3) {
            if ((playerId == 0) || (playerId == 2)) {
                temp_v1_5 = &D_8018CA70[playerId];
                sp28 = temp_v1_5;
                s16_step_down_towards(&temp_v1_5->slideItemBoxX, 0, 8);
                if (temp_v1_5->slideItemBoxX == 0) {
                    func_80072488(temp_s0);
                }
            } else {
                temp_v1_6 = &D_8018CA70[playerId];
                sp28 = temp_v1_6;
                s16_step_up_towards(&temp_v1_6->slideItemBoxX, 0, 8);
                if (temp_v1_6->slideItemBoxX == 0) {
                    func_80072488(temp_s0);
                }
            }
        } else if (s16_step_down_towards((playerId * 0x84) + 0x46 + D_8018CA70, 0, 8) != 0) {
            func_80072488(temp_s0);
        }
        break;
    case 12:
        func_80072428(temp_s0);
        break;
    case 20:
        temp_a1 = sp2C->unkA2;
        if (temp_a1 == 0xB) {
            func_80072D3C(temp_s0, temp_a1, 0, 8, 0xA);
        } else {
            func_80072D3C(temp_s0, temp_a1, 0xB, 8, 0xA);
        }
        break;
    case 21:
        func_800726CC(temp_s0, 8);
        sp2C->unkD6 = 2U;
        break;
    case 30:
        temp_a1_2 = sp2C->unkA2;
        if (temp_a1_2 == 0xB) {
            func_80072D3C(temp_s0, temp_a1_2, 0, 8, 0xA);
        } else {
            func_80072D3C(temp_s0, temp_a1_2, 0xB, 8, 0xA);
        }
        break;
    case 31:
        func_800726CC(temp_s0, 9);
        break;
    case 40:
        temp_a1_3 = sp2C->unkA2;
        if (temp_a1_3 == 0xD) {
            func_80072D3C(temp_s0, temp_a1_3, 0xE, 8, 0xA);
        } else {
            func_80072D3C(temp_s0, temp_a1_3, 0xD, 8, 0xA);
        }
        break;
    case 41:
        func_800726CC(temp_s0, 8);
        break;
    case 50:
        func_80072D3C(temp_s0, sp2C->unkA2, 0, 8, 0x64);
        break;
    }
    if (func_80072320(temp_s0, 2) != 0) {
        temp_v0_3 = sp2C->unk98;
        if (temp_v0_3 == 0) {
            func_8007AC9C(playerId);
        } else {
            sp2C->unk98 = (u16) (temp_v0_3 - 1);
        }
    }
    temp_v0_4 = sp2C->unk4C;
    if (temp_v0_4 >= 0) {
        if (temp_v0_4 > 0) {
            sp2C->unk4C = (s32) (temp_v0_4 - 1);
        } else {
            temp_v0_5 = sp2C->unkD6;
            switch (temp_v0_5) {                    /* switch 1; irregular */
            case 1:                                 /* switch 1 */
                if (sp40 != 0) {
                    func_80073600(temp_s0);
                    func_800726CC(temp_s0, 6);
                }
                break;
            case 2:                                 /* switch 1 */
                func_800729D0(temp_s0, sp2C->unkA2);
                sp2C->unkD6 = 3U;
                break;
            case 3:                                 /* switch 1 */
                if (sp2C->unkA4 == 0) {
                    if (func_80072354(temp_s0, 1) != 0) {
                        temp_v0_6 = sp2C->unkA2;
                        if (temp_v0_6 == 0xB) {
                            if (func_8007B040(temp_s0, playerId) != 0) {
                                func_800726CC(temp_s0, 0x14);
                                sp2C->unkD6 = 0U;
                            } else {
                                func_800726CC(temp_s0, 9);
                            }
                        } else if ((temp_v0_6 == 0xD) || (temp_v0_6 == 0xE)) {
                            sp2C->unkA2 = (s16) (temp_v0_6 - 1);
                            func_800729D0(temp_s0, sp2C->unkA2);
                            sp2C->unkD6 = 3U;
                            func_800726CC(temp_s0, 0x28);
                        } else {
                            func_800726CC(temp_s0, 9);
                        }
                    } else {
                        func_800722CC(temp_s0, 1);
                        func_800726CC(temp_s0, 0x1E);
                        sp2C->unkD6 = 0U;
                    }
                }
                break;
            }
        }
    }
    temp_v0_7 = sp2C->unkD2;
    sp2C->unk60 = (? *) D_800E44F0[temp_v0_7];
    sp2C->unk64 = (? *) D_800E4530[temp_v0_7];
    sp38->unk_010 = sp2C->unkA4;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_8007B34C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_8007B34C(); // extern

void func_8007BB9C(void) {
    func_8007B34C();
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_8007BB9C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s16 func_80041658(f32, f32); // extern
? func_800721C0(s32, ?); // extern
? func_80072428(s32); // extern
? func_8007278C(s32, ?); // extern
? func_800735BC(s32, ? *, ?); // extern
? func_80087E08(s32, ?, ?, ?, s32, s32); // extern
extern ? D_06007BA8;
extern ? D_80165C18;

void func_8007BBBC(s32 arg0) {
    f32 temp_f0;
    s16 temp_v0;
    void *temp_s1;
    f32 phi_f14;

    temp_s1 = (arg0 * 0xE0) + &D_80165C18;
    temp_v0 = temp_s1->unkA6;
    if (temp_v0 != 0) {
        if (temp_v0 != 1) {
            if (temp_v0 != 2) {
                if (temp_v0 != 3) {
                    return;
                }
                func_80072428(arg0);
                // Duplicate return node #14. Try simplifying control flow for better match
                return;
            }
            if (gIsMirrorMode != 0) {
                func_80087E08(arg0, 0x41900000, 0x3F333333, 0x41C80000, -0x5800, 0x12C);
            } else {
                func_80087E08(arg0, 0x41900000, 0x3F333333, 0x41C80000, 0x5800, 0x12C);
            }
            temp_f0 = temp_s1->unk40;
            if (temp_f0 < 0.0f) {
                phi_f14 = -temp_f0;
            } else {
                phi_f14 = temp_f0;
            }
            temp_s1->unkBE = func_80041658(temp_s1->unk3C, phi_f14);
            func_8007278C(arg0, 0x46);
            return;
        }
        func_800735BC(arg0, &D_06007BA8, 0x40000000);
        func_800721C0(arg0, 0x10);
        temp_s1->unkD5 = 0;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_8007BBBC.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800723A4(s32, ?); // extern
? func_8008B7D4(s32, f32, ?, ?); // extern
extern f64 D_800EEE08;
extern ? D_80164438;
extern ? D_80165CBE;
extern s32 D_80183F28;
extern f32 D_8018D01C;

void func_8007BD04(s32 arg0) {
    s32 sp1C;
    s32 temp_t6;
    u16 temp_v0;

    temp_t6 = D_80183F28;
    sp1C = temp_t6;
    if (*(&D_80165CBE + (temp_t6 * 0xE0)) == 0) {
        temp_v0 = *(&D_80164438 + (arg0 * 2));
        if ((temp_v0 >= 0xA0) && (temp_v0 < 0xAB)) {
            func_8008B7D4(temp_t6, D_8018D01C * D_800EEE08, 0xC3480000, 0xC4CE4000);
            func_800723A4(sp1C, 1);
        }
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_8007BD04.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_8007BBBC(s32); // extern
? func_8007BD04(?); // extern
? func_8008BF18(s32); // extern
extern s32 D_80183F28;

void func_8007BDA8(void) {
    s32 sp18;
    s32 temp_a0;

    func_8007BD04(0);
    temp_a0 = D_80183F28;
    sp18 = temp_a0;
    func_8007BBBC(temp_a0);
    func_8008BF18(temp_a0);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_8007BDA8.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80072488(); // extern
? func_8008B7D4(s32, f32, f32, f32); // extern
? func_8008B80C(s32, ?, ?, ?); // extern
? func_8008B888(s32, ?, ?, ?); // extern
extern ? D_06007BA8;
extern ? D_800E634C;
extern f32 D_800EEE10;
extern f64 D_800EEE18;
extern ? D_80165C18;

void func_8007BDE0(s32 arg0) {
    void *temp_v0;

    temp_v0 = (arg0 * 0xE0) + &D_80165C18;
    temp_v0->unkD5 = 1;
    temp_v0->unk54 = 0;
    temp_v0->unk70 = &D_06007BA8;
    temp_v0->unk0 = D_800EEE10;
    func_80072488();
    func_8008B7D4(arg0, D_800E634C.unk0, D_800E634C.unk2 + D_800EEE18, D_800E634C.unk4);
    func_8008B80C(arg0, 0, 0x41F00000, 0);
    func_8008B888(arg0, 0, 0x3800, 0);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_8007BDE0.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
? func_800721C0(s32, ?);                            /* extern */
? func_80072428();                                  /* extern */
? func_80072488();                                  /* extern */
s32 func_8007278C(?);                               /* extern */
? func_8007BDE0();                                  /* extern */
? func_80086E70(s32);                               /* extern */
? func_8008701C(s32, ?);                            /* extern */
extern ? D_80165C18;

void func_8007BEC8(s32 arg0) {
    s32 temp_a0;
    u16 temp_t8;
    void *temp_v0;

    temp_v0 = (arg0 * 0xE0) + &D_80165C18;
    temp_t8 = temp_v0->unkA6;
    switch (temp_t8) {
    case 1:
        func_8007BDE0();
        return;
    case 2:
        temp_a0 = arg0;
        if (func_8007278C(0x3C) != 0) {
            arg0 = temp_a0;
            func_800721C0(temp_a0, 0x10);
            func_80086E70(arg0);
            return;
        }
    default:
        return;
    case 3:
        if (temp_v0->unkAE == 0) {
            func_80072488();
            return;
        }
        /* Duplicate return node #11. Try simplifying control flow for better match */
        return;
    case 4:
        if (func_8007278C(0xA) != 0) {
            func_8008701C(arg0, 2);
            return;
        }
        /* Duplicate return node #11. Try simplifying control flow for better match */
        return;
    case 5:
        if (temp_v0->unkAE == 0) {
            func_80072428();
        }
        /* Duplicate return node #11. Try simplifying control flow for better match */
        return;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_8007BEC8.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
? s16_step_up_towards(void *, ?, ?);                      /* extern */
s32 u16_step_up_towards(void *, ?, u16);                  /* extern */
? func_800721E8(s32, ?);                            /* extern */
? func_80074344(s32, void *, ?, ?, f32, s32, s32);  /* extern */
? func_80086F60(s32);                               /* extern */
? func_80086FD4(s32);                               /* extern */
s32 func_80087060(s32, ?);                          /* extern */
s32 func_800871AC(s32, ?);                          /* extern */
? func_800877C4(s32);                               /* extern */
? func_8008BF18(s32);                               /* extern */
extern ? D_80165C18;

void func_8007BFB0(s32 arg0) {
    f64 temp_f0;
    s16 temp_v0;
    void *temp_s0;

    temp_s0 = (arg0 * 0xE0) + &D_80165C18;
    temp_v0 = temp_s0->unkAE;
    switch (temp_v0) {
    case 1:
        temp_s0->unk3C = -0.2f;
        if (temp_s0->unk2C <= 0.0) {
            temp_s0->unk2C = 0.0f;
            temp_s0->unk3C = 0.0f;
            func_80086F60(arg0);
        }
block_26:
        break;
    case 2:
        if (func_800871AC(arg0, 0x14) != 0) {
            temp_s0->unk92 = 0x40;
        }
        goto block_26;
    case 3:
        temp_s0->unk0 = temp_s0->unk0 - 0.0015;
        if (temp_s0->unkBE >= 0xA01) {
            temp_s0->unk92 = temp_s0->unk92 - 4;
        }
        if (u16_step_up_towards(temp_s0 + 0xBE, 0xC00, temp_s0->unk92) != 0) {
            func_80086FD4(arg0);
        }
        goto block_26;
    case 4:
        temp_s0->unk0 = temp_s0->unk0 - 0.0015;
        temp_s0->unk34 = 0.001f;
        func_80086FD4(arg0);
        temp_s0->unk92 = 0;
        goto block_26;
    case 5:
        temp_f0 = temp_s0->unk34;
        if (temp_f0 <= 0.004) {
            temp_s0->unk34 = temp_f0 + 0.0002;
        }
        temp_s0->unk0 = temp_s0->unk0 + temp_s0->unk34;
        s16_step_up_towards(temp_s0 + 0x92, 0x100, 0x10);
        temp_s0->unkBE = temp_s0->unkBE - temp_s0->unk92;
        if (func_80087060(arg0, 0x35) != 0) {
            func_80086FD4(arg0);
        }
        goto block_26;
    case 6:
        if (func_80087060(arg0, 0xF) != 0) {
            func_80086FD4(arg0);
            D_801658CE = 1;
        }
        goto block_26;
    case 7:
        temp_s0->unk0 = temp_s0->unk0 - 0.05;
        if (temp_s0->unk0 <= 0.01) {
            func_800721E8(arg0, 0x10);
            temp_s0->unk0 = 0.000001f;
            func_80086FD4(arg0);
        }
        goto block_26;
    case 8:
        func_80086F60(arg0);
        goto block_26;
    }
    if (temp_s0->unkAE < 0xA) {
        func_80074344(arg0, temp_s0, 0x3E4CCCCD, 0x3E570A3D, 0.001f, 0, -1);
    }
    func_800877C4(arg0);
    func_8008BF18(arg0);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_8007BFB0.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800723A4(s32, ?); // extern
? func_8007BEC8(s32); // extern
? func_8007BFB0(s32); // extern
extern s8 D_801658BC;
extern ? D_80165CBE;
extern s32 D_80183F28;

void func_8007C280(void) {
    s32 sp1C;
    s32 temp_a0;

    temp_a0 = D_80183F28;
    if (D_801658BC == 1) {
        D_801658BC = 0;
        sp1C = temp_a0;
        func_800723A4(temp_a0, 0);
    }
    if (*(&D_80165CBE + (D_80183F28 * 0xE0)) != 0) {
        sp1C = D_80183F28;
        func_8007BEC8(D_80183F28);
        func_8007BFB0(D_80183F28);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_8007C280.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_8007BDA8(); // extern
? func_8007C280(); // extern

void func_8007C2F8(s32 arg0) {
    if (arg0 != 0) {
        if (arg0 != 1) {
            return;
        }
        func_8007C280();
        return;
    }
    func_8007BDA8();
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_8007C2F8.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_8007CC00(); // extern

void func_8007C340(void) {
    func_8007CC00();
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_8007C340.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800721C0(?, void *, s32); // extern
? func_800721E8(?, void *, s32); // extern
extern ? D_80165C18;

void func_8007C360(s32 arg0, void *arg1) {
    void *sp20;
    s32 sp1C;
    s32 temp_t0;
    s32 temp_t2;
    void *temp_a2;
    s32 phi_t1;

    temp_a2 = (arg0 * 0xE0) + &D_80165C18;
    temp_t0 = (((temp_a2->unkC0 - arg1->unk26) + 0x8000) & 0xFFFF) * 0x24;
    phi_t1 = temp_t0 >> 0x10;
    if (temp_t0 < 0) {
        phi_t1 = (temp_t0 + 0xFFFF) >> 0x10;
    }
    temp_t2 = phi_t1 & 0xFFFF;
    if (temp_t2 < 0x13) {
        sp20 = temp_a2;
        sp1C = temp_t2;
        func_800721E8(0x80, temp_a2, temp_t2);
        temp_a2->unkD2 = sp1C;
        return;
    }
    sp20 = temp_a2;
    sp1C = temp_t2;
    func_800721C0(0x80, temp_a2, temp_t2);
    temp_a2->unkD2 = 0x24 - temp_t2;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_8007C360.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
u16 func_800417B4(u16, s32); // extern
? func_8007C360(s32, s32); // extern
s32 atan2s(f32, f32); // extern
extern ? D_80165C18;

void func_8007C420(s32 arg0, void *arg1, s32 arg2) {
    void *sp18;
    void *temp_v1;

    temp_v1 = (arg0 * 0xE0) + &D_80165C18;
    sp18 = temp_v1;
    temp_v1->unkC0 = func_800417B4(temp_v1->unkC0, atan2s(arg1->unk14 - temp_v1->unk4, arg1->unk1C - temp_v1->unkC) & 0xFFFF);
    func_8007C360(arg0, arg2);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_8007C420.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800721C0(?, s32); // extern
? func_800721E8(?, s32); // extern
extern ? D_80165C18;

void func_8007C4A4(s32 arg0) {
    void *sp20;
    s32 sp1C;
    s32 temp_t0;
    s32 temp_t8;
    void *temp_v1;
    s32 phi_t9;

    temp_v1 = (arg0 * 0xE0) + &D_80165C18;
    temp_t8 = temp_v1->unkC0 * 0x24;
    phi_t9 = temp_t8 >> 0x10;
    if (temp_t8 < 0) {
        phi_t9 = (temp_t8 + 0xFFFF) >> 0x10;
    }
    temp_t0 = phi_t9 & 0xFFFF;
    if (temp_t0 < 0x13) {
        sp20 = temp_v1;
        sp1C = temp_t0;
        func_800721E8(0x80, temp_t0);
        temp_v1->unkD2 = sp1C;
        return;
    }
    sp20 = temp_v1;
    sp1C = temp_t0;
    func_800721C0(0x80, temp_t0);
    temp_v1->unkD2 = 0x24 - temp_t0;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_8007C4A4.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
u16 func_800417B4(u16, s32); // extern
? func_8007C4A4(s32); // extern
s32 atan2s(f32, f32); // extern
extern ? D_80165C18;

void func_8007C550(s32 arg0) {
    void *sp18;
    void *temp_v1;

    temp_v1 = (arg0 * 0xE0) + &D_80165C18;
    sp18 = temp_v1;
    temp_v1->unkC0 = func_800417B4(temp_v1->unkC0, atan2s(temp_v1->unk38, temp_v1->unk40) & 0xFFFF);
    func_8007C4A4(arg0);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_8007C550.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800721C0(s32, ?); // extern
? func_80072488(s32); // extern
? func_80073444(? *, s32, ?, s32); // extern
? func_80073844(s32); // extern
? func_80073FD4(s32); // extern
? func_80086EF0(s32); // extern
extern ? D_06005C80;
extern f32 D_800EEEA0;
extern s32 D_80165880;
extern ? D_80165C18;

void func_8007C5B4(s32 arg0) {
    void *temp_s0;

    func_80073444(&D_06005C80, D_80165880, 0x30, 0x28);
    temp_s0 = (arg0 * 0xE0) + &D_80165C18;
    temp_s0->unk4 = 0.0f;
    temp_s0->unk8 = 0.0f;
    temp_s0->unkC = 0.0f;
    func_800721C0(arg0, 0x20);
    func_80072488(arg0);
    temp_s0->unkA0 = 0;
    func_80073844(arg0);
    temp_s0->unk0 = D_800EEEA0;
    temp_s0->unk34 = 1.0f;
    func_80073FD4(arg0);
    func_80086EF0(arg0);
    func_800721C0(arg0, 0x800);
    temp_s0->unkB2 = 0;
    temp_s0->unkB6 = 0x8000;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_8007C5B4.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
? func_80072428(s32, s32);                          /* extern */
? func_80073514(s32);                               /* extern */
? func_80073884(s32);                               /* extern */
? func_80073998(s32, void *, ?, ?, s32, s32, s32);  /* extern */
? func_80073CB0(s32, void *, ?, ?, s32, s32, s32);  /* extern */
? func_80073DC0(s32, void *, ?, ?);                 /* extern */
? func_8007C5B4(s16);                               /* extern */
? func_80086F60(s32);                               /* extern */
extern ? D_80165C18;

void func_8007C684(s32 arg0) {
    void *sp30;
    s16 temp_a1;
    s32 temp_t6;
    u8 temp_t8;
    void *temp_v0;
    s32 phi_a1;

    temp_t6 = arg0 * 0xE0;
    temp_v0 = temp_t6 + &D_80165C18;
    temp_a1 = temp_v0->unkA6;
    phi_a1 = temp_a1;
    if ((temp_a1 != 0) && (temp_a1 == 1)) {
        sp30 = temp_v0;
        func_8007C5B4(temp_a1);
        phi_a1 = temp_v0->unkA6;
    }
    if (phi_a1 >= 2) {
        temp_t8 = (temp_t6 + &D_80165C18)->unkDC;
        switch (temp_t8) {
        case 1:
            func_80073998(arg0, temp_t6 + &D_80165C18 + 0xA0, 0, 0x50, 2, 1, 0);
            break;
        case 2:
            func_80073CB0(arg0, temp_t6 + &D_80165C18 + 0xA0, 0x50, 0x78, 1, 0, -1);
            break;
        case 3:
            func_80073DC0(arg0, temp_t6 + &D_80165C18 + 0xA0, 0, 2);
            break;
        case 4:
            func_80072428(arg0, phi_a1);
            func_80086F60(arg0);
            func_80073884(arg0);
            break;
        }
        func_80073514(arg0);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_8007C684.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800723A4(s32, ?); // extern
? func_800C9060(s32, ?); // extern
extern s32 D_800E5D9C;
extern ? D_800E5DB0;
extern ? D_80165C18;
extern ? D_8018BFA8;
extern s16 D_8018CFF0;
extern s16 D_8018D048;

void func_8007C7B4(s32 arg0, s8 arg1) {
    s32 *sp40;
    s16 temp_s1_2;
    s16 temp_s4;
    s16 temp_s5;
    s32 *temp_s2;
    s32 *temp_s3;
    s32 temp_s1;
    void *temp_s0;
    s32 *phi_s3;
    s32 *phi_s2;

    temp_s3 = (arg0 * 4) + &D_8018BFA8;
    sp40 = temp_s3;
    phi_s3 = temp_s3;
    phi_s2 = &D_800E5D9C;
    do {
        temp_s1 = *phi_s3;
        func_800723A4(temp_s1, 1);
        temp_s0 = &D_80165C18 + (temp_s1 * 0xE0);
        temp_s0->unkD1 = arg1;
        temp_s1_2 = random_int(0x3C) - 0x1E;
        temp_s4 = random_int(0x14) - 0xA;
        temp_s5 = random_int(0x50) - 0x28;
        random_int(0x1000);
        temp_s2 = phi_s2 + 4;
        temp_s0->unk10 = temp_s1_2;
        temp_s0->unk80 = *phi_s2;
        temp_s0->unk14 = temp_s4;
        temp_s0->unk18 = temp_s5;
        phi_s3 += 4;
        phi_s2 = temp_s2;
    } while (temp_s2 != &D_800E5DB0);
    func_800C9060(arg1 & 0xFF, 0x1900705A);
    if (sp40 == &D_8018BFA8) {
        D_8018CFF0 = 1;
        return;
    }
    D_8018D048 = 1;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_8007C7B4.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern ? D_80165C18;
extern ? D_8018BFA8;
extern s16 D_8018CFF0;
extern s16 D_8018D048;

void func_8007C91C(s32 arg0) {
    s32 *temp_a1;
    void *temp_a0;
    void *temp_a2;
    void *temp_a2_2;
    void *temp_a2_3;
    void *temp_a2_4;
    void *temp_a2_5;

    temp_a1 = (arg0 * 4) + &D_8018BFA8;
    temp_a0 = temp_a1 + (1 * 4);
    temp_a2 = &D_80165C18 + (*temp_a1 * 0xE0);
    temp_a2->unkDC = temp_a2->unkDC + 1;
    temp_a2_2 = &D_80165C18 + (temp_a0->unk0 * 0xE0);
    temp_a2_2->unkDC = temp_a2_2->unkDC + 1;
    temp_a2_3 = &D_80165C18 + (temp_a0->unk4 * 0xE0);
    temp_a2_3->unkDC = temp_a2_3->unkDC + 1;
    temp_a2_4 = &D_80165C18 + (temp_a0->unk8 * 0xE0);
    temp_a2_4->unkDC = temp_a2_4->unkDC + 1;
    temp_a2_5 = &D_80165C18 + (temp_a0->unkC * 0xE0);
    temp_a2_5->unkDC = temp_a2_5->unkDC + 1;
    if (temp_a1 == &D_8018BFA8) {
        D_8018D048 = 0;
        return;
    }
    D_8018CFF0 = 0;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_8007C91C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern s16 D_80164360;

s16 func_8007C9F8(void) {
    s8 temp_v0;

    temp_v0 = D_8018EDF3;
    if (temp_v0 == 1) {
        return 0;
    }
    if (temp_v0 == 2) {
        if (gModeSelection == GRAND_PRIX) {
            if (gPlayerPositions->unk0 < gPlayerPositions->unk4) {
                return 0;
            }
            return 1;
        }
        return D_80164360;
    }
    return D_80164360;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_8007C9F8.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_8007C7B4(?, s16); // extern
? func_8007C91C(?, s16); // extern
s16 func_8007C9F8(); // extern
extern ? D_80164438;
extern s16 D_8018CFF0;
extern s16 D_8018D018;
extern s16 D_8018D048;
extern s16 D_8018D110;

void func_8007CA70(void) {
    u16 *sp1C;
    s16 temp_a1;
    s16 temp_a1_2;
    s16 temp_v0;
    s16 temp_v0_3;
    u16 *temp_v1_2;
    u16 *temp_v1_4;
    u16 temp_v0_2;
    u16 temp_v0_4;
    u16 temp_v1;
    u16 temp_v1_3;
    s32 phi_v0;
    s32 phi_v0_2;

    if (D_8018CFF0 == 0) {
        temp_v0 = func_8007C9F8();
        temp_v1 = *(&D_80164438 + (temp_v0 * 2));
        D_8018D018 = temp_v0;
        if ((temp_v1 >= 0xC9) && (temp_v1 < 0xD2)) {
            func_8007C7B4(0, temp_v0);
        }
    }
    if (D_8018CFF0 != 0) {
        temp_a1 = D_8018D018;
        temp_v1_2 = (temp_a1 * 2) + &D_80164438;
        temp_v0_2 = *temp_v1_2;
        phi_v0 = temp_v0_2;
        if ((temp_v0_2 >= 0xB5) && (temp_v0_2 < 0xBE)) {
            sp1C = temp_v1_2;
            func_8007C91C(0, temp_a1);
            phi_v0 = *temp_v1_2;
        }
        if ((phi_v0 >= 0x119) && (phi_v0 < 0x122)) {
            func_8007C91C(0);
        }
    }
    if (D_8018D048 == 0) {
        temp_v0_3 = func_8007C9F8();
        temp_v1_3 = *(&D_80164438 + (temp_v0_3 * 2));
        D_8018D110 = temp_v0_3;
        if ((temp_v1_3 >= 0x1FF) && (temp_v1_3 < 0x208)) {
            func_8007C7B4(5, temp_v0_3);
        }
    }
    if (D_8018D048 != 0) {
        temp_a1_2 = D_8018D110;
        temp_v1_4 = (temp_a1_2 * 2) + &D_80164438;
        temp_v0_4 = *temp_v1_4;
        phi_v0_2 = temp_v0_4;
        if ((temp_v0_4 >= 0x1EB) && (temp_v0_4 < 0x1F4)) {
            sp1C = temp_v1_4;
            func_8007C91C(5, temp_a1_2);
            phi_v0_2 = *temp_v1_4;
        }
        if ((phi_v0_2 >= 0x26D) && (phi_v0_2 < 0x276)) {
            func_8007C91C(5);
        }
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_8007CA70.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 func_8007223C(s32, ?); // extern
? func_8007C550(s32); // extern
? func_8007C684(s32); // extern
? func_8007CA70(); // extern
? func_8008B78C(s32); // extern
f32 sins(s32); // extern
f32 coss(s32); // extern
extern ? D_800E4470;
extern ? D_800E44B0;
extern ? D_80165C18;
extern s32 D_8018BFA8;
extern ? D_8018BFD0;

void func_8007CC00(void) {
    Player *temp_s3;
    f32 temp_f20;
    f32 temp_f20_2;
    s32 *temp_s4;
    s32 temp_s1;
    s32 temp_s2;
    s32 temp_t4;
    s8 temp_v0;
    void *temp_s0;
    s32 *phi_s4;

    func_8007CA70();
    phi_s4 = &D_8018BFA8;
    do {
        temp_s2 = *phi_s4;
        temp_s0 = &D_80165C18 + (temp_s2 * 0xE0);
        if (temp_s0->unkA6 != 0) {
            func_8007C684(temp_s2);
            func_8008B78C(temp_s2);
            temp_v0 = temp_s0->unkD1;
            temp_t4 = (0x8000 - ((temp_v0 * 0xB8) + camera1)->unk26) & 0xFFFF;
            temp_s1 = temp_t4;
            temp_s3 = &gPlayerOne[temp_v0];
            temp_f20 = coss(temp_t4 & 0xFFFF);
            temp_s0->unk4 = (temp_s3->posX + (temp_f20 * (temp_s0->unk10 + temp_s0->unk28))) - ((temp_s0->unk30 + temp_s0->unk18) * sins(temp_s1 & 0xFFFF));
            temp_s0->unk8 = temp_s0->unk2C + (6.5 + temp_s3->unk_074 + temp_s0->unk14);
            temp_f20_2 = sins(temp_s1 & 0xFFFF);
            temp_s0->unkC = ((temp_s0->unk30 + temp_s0->unk18) * coss(temp_s1 & 0xFFFF)) + (temp_s3->posZ + (temp_f20_2 * (temp_s0->unk10 + temp_s0->unk28)));
            func_8007C550(temp_s2);
            if (func_8007223C(temp_s2, 0x80) != 0) {
                temp_s0->unk74 = &D_800E44B0;
            } else {
                temp_s0->unk74 = &D_800E4470;
            }
        }
        temp_s4 = phi_s4 + 4;
        phi_s4 = temp_s4;
    } while (temp_s4 != &D_8018BFD0);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_8007CC00.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80072488(s32); // extern
? func_80073444(? *, ? *, ?, s32); // extern
? func_80073844(s32); // extern
? func_80086EF0(s32); // extern
s16 atan2s(f32, f32); // extern
extern ? D_06005C80;
extern ? D_0F0D0E50;
extern f32 D_800EEEB8;
extern ? D_80165C18;
extern void *D_8018CF1C;

void func_8007CE0C(s32 arg0) {
    void *temp_s0;
    void *temp_v0;

    func_80073444(&D_06005C80, &D_0F0D0E50, 0x30, 0x28);
    temp_s0 = (arg0 * 0xE0) + &D_80165C18;
    temp_s0->unkD2 = 0x1C;
    temp_s0->unk4 = 0.0f;
    temp_s0->unk8 = 0.0f;
    temp_s0->unkC = 0.0f;
    temp_s0->unk0 = D_800EEEB8;
    func_80072488(arg0);
    temp_s0->unkA0 = 0;
    func_80073844(arg0);
    func_80086EF0(arg0);
    temp_s0->unkC2 = 0x8000;
    temp_v0 = D_8018CF1C;
    temp_s0->unkC0 = atan2s(temp_v0->unk14 - temp_s0->unk10, temp_v0->unk1C - temp_s0->unk18);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_8007CE0C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
? func_80072428(s32);                               /* extern */
? func_8007278C(s32, ?);                            /* extern */
? func_80072950(s32, u8, ?, ?);                     /* extern */
? func_80073514(s32);                               /* extern */
? func_80073884(s32);                               /* extern */
? func_80073998(s32, void *, ?, ?, s32, s32, s32);  /* extern */
? func_80073CB0(s32, void *, ?, ?, s32, s32, s32);  /* extern */
? func_80073DC0(s32, void *, ?, ?);                 /* extern */
? func_8007CE0C(s32);                               /* extern */
extern ? D_80165C18;

void func_8007CEDC(s32 arg0) {
    s16 temp_v0;
    u8 temp_t9;
    void *temp_s0;

    temp_s0 = (arg0 * 0xE0) + &D_80165C18;
    temp_v0 = temp_s0->unkA6;
    switch (temp_v0) {                              /* switch 1 */
    case 1:                                         /* switch 1 */
        func_8007CE0C(arg0);
block_6:
        break;
    case 2:                                         /* switch 1 */
        func_8007278C(arg0, 0x1E);
        goto block_6;
    case 3:                                         /* switch 1 */
        func_8007278C(arg0, 0x3E8);
        goto block_6;
    case 4:                                         /* switch 1 */
        func_80072428(arg0);
        goto block_6;
    }
    if (temp_s0->unkA6 >= 2) {
        func_80072950(arg0, temp_s0->unkDC, 0, 4);
        func_80073514(arg0);
        temp_t9 = temp_s0->unkDC;
        switch (temp_t9) {                          /* switch 2 */
        case 1:                                     /* switch 2 */
            func_80073998(arg0, temp_s0 + 0xA0, 0x28, 0x50, 4, 0, 0);
            return;
        case 2:                                     /* switch 2 */
            func_80073CB0(arg0, temp_s0 + 0xA0, 0x50, 0xB4, 2, 0, -1);
            if ((temp_s0->unkAE == 0) || (temp_s0->unkA6 == 3)) {
                temp_s0->unkDC = temp_s0->unkDC + 1;
                return;
            }
            /* Duplicate return node #16. Try simplifying control flow for better match */
            return;
        case 3:                                     /* switch 2 */
            func_80073DC0(arg0, temp_s0 + 0xA0, 0, 4);
            return;
        case 4:                                     /* switch 2 */
            func_80073884(arg0);
            /* Duplicate return node #16. Try simplifying control flow for better match */
            return;
        }
    } else {
    default:                                        /* switch 2 */
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_8007CEDC.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s16 func_80041770(f32, f32, f32, f32); // extern
? func_8008B80C(s32, ?, ?, ?); // extern
extern f64 D_800EEEE8;
extern f64 D_800EEEF0;
extern f64 D_800EEEF8;
extern f64 D_800EEF00;
extern f64 D_800EEF08;
extern f64 D_800EEF10;
extern ? D_80165C18;
extern f32 D_8018D01C;

void func_8007D360(s32 arg0, s32 arg1) {
    f64 temp_f10;
    f64 temp_f16;
    f64 temp_f16_2;
    f64 temp_f16_3;
    f64 temp_f16_4;
    f64 temp_f18;
    f64 temp_f8;
    s32 temp_v0;
    s32 temp_v0_2;
    s32 temp_v0_3;
    s32 temp_v0_4;
    s32 temp_v0_5;
    s32 temp_v0_6;
    s32 temp_v0_7;
    void *temp_s0;
    void *temp_s0_2;
    f64 phi_f8;
    f64 phi_f18;
    f64 phi_f16;
    f64 phi_f16_2;
    f64 phi_f16_3;
    f32 phi_f6;
    f64 phi_f10;
    f64 phi_f16_4;

    if (arg1 == 1) {
        temp_v0 = random_int(0x1E);
        temp_s0 = (arg0 * 0xE0) + &D_80165C18;
        temp_f8 = temp_v0;
        phi_f8 = temp_f8;
        if (temp_v0 < 0) {
            phi_f8 = temp_f8 + 4294967296.0;
        }
        temp_s0->unk10 = (D_800EEEE8 - phi_f8) * D_8018D01C;
        temp_v0_2 = random_int(0x19);
        temp_f18 = temp_v0_2;
        phi_f18 = temp_f18;
        if (temp_v0_2 < 0) {
            phi_f18 = temp_f18 + 4294967296.0;
        }
        temp_s0->unk14 = phi_f18 + 25.0;
        temp_v0_3 = random_int(0x1E);
        temp_f16 = temp_v0_3;
        phi_f16 = temp_f16;
        if (temp_v0_3 < 0) {
            phi_f16 = temp_f16 + 4294967296.0;
        }
        temp_s0->unk18 = phi_f16 + D_800EEEF0;
        temp_s0->unk20 = 0.0f;
        temp_s0->unk1C = D_8018D01C * D_800EEEF8;
        temp_v0_4 = random_int(0x96);
        temp_f16_2 = temp_v0_4;
        phi_f16_2 = temp_f16_2;
        if (temp_v0_4 < 0) {
            phi_f16_2 = temp_f16_2 + 4294967296.0;
        }
        temp_s0->unkBE = 0xDC00;
        temp_s0->unkC6 = 0x800;
        temp_s0->unk24 = D_800EEF00 - phi_f16_2;
    }
    temp_s0_2 = (arg0 * 0xE0) + &D_80165C18;
    if (arg1 == 2) {
        temp_s0_2->unk10 = (-0x55B - random_int(0x1E)) * D_8018D01C;
        temp_s0_2->unk14 = random_int(0x19) + 0xF;
        temp_s0_2->unk18 = random_int(0x1E) - 0xE8;
        temp_s0_2->unk20 = 0.0f;
        temp_s0_2->unk1C = D_8018D01C * D_800EEF08;
        temp_v0_5 = random_int(0xC8);
        temp_f16_3 = temp_v0_5;
        phi_f16_3 = temp_f16_3;
        if (temp_v0_5 < 0) {
            phi_f16_3 = temp_f16_3 + 4294967296.0;
        }
        temp_s0_2->unkBE = 0;
        temp_s0_2->unkC6 = 0;
        temp_s0_2->unk24 = phi_f16_3 + D_800EEF10;
    }
    temp_s0_2->unkC0 = func_80041770(temp_s0_2->unk10, temp_s0_2->unk1C, temp_s0_2->unk18, temp_s0_2->unk24);
    temp_s0_2->unkC2 = 0;
    func_8008B80C(arg0, 0, 0, 0);
    temp_s0_2->unkB0 = 0;
    if (gCCSelection < CC_150) {
        temp_v0_6 = random_int(4);
        temp_f10 = temp_v0_6;
        phi_f10 = temp_f10;
        if (temp_v0_6 < 0) {
            phi_f10 = temp_f10 + 4294967296.0;
        }
        phi_f6 = phi_f10 + 4.0;
    } else {
        temp_v0_7 = random_int(4);
        temp_f16_4 = temp_v0_7;
        phi_f16_4 = temp_f16_4;
        if (temp_v0_7 < 0) {
            phi_f16_4 = temp_f16_4 + 4294967296.0;
        }
        phi_f6 = phi_f16_4 + 5.0;
    }
    temp_s0_2->unk34 = phi_f6;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_8007D360.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800721C0(s32, ?); // extern
? func_8007D360(); // extern
extern f32 D_800EEF18;
extern ? D_80165C18;

void func_8007D6A8(s32 arg0) {
    void *sp18;
    void *temp_v0;

    temp_v0 = (arg0 * 0xE0) + &D_80165C18;
    temp_v0->unkD5 = 0xD;
    sp18 = temp_v0;
    func_8007D360();
    sp18->unk0 = D_800EEF18;
    func_800721C0(arg0, 0x200);
    sp18->unkC8 = 3;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_8007D6A8.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 func_80072044(? *, ? *, ?); // extern
? func_800723A4(s32, ?); // extern
? func_8007D6A8(s32, s32); // extern
extern ? D_80183E4C;
extern ? D_80183E5C;
extern ? D_8018C3F0;
extern ? D_8018C630;

void func_8007D714(s32 arg0) {
    s32 sp1C;
    s32 phi_v0;

    if (arg0 == 1) {
        phi_v0 = func_80072044(&D_8018C3F0, &D_80183E4C, 0x28);
    } else {
        phi_v0 = func_80072044(&D_8018C630, &D_80183E5C, 0x1E);
    }
    if (phi_v0 != -1) {
        sp1C = phi_v0;
        func_800723A4(phi_v0, 0);
        func_8007D6A8(phi_v0, arg0);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_8007D714.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80089A04(?, ?); // extern

void func_8007D794(void) {
    s32 temp_v0;

    temp_v0 = gCCSelection;
    if (temp_v0 == CC_50) {
        func_80089A04(0x3F000000, 0x3E4CCCCD);
        return;
    }
    if (temp_v0 == CC_100) {
        func_80089A04(0x3ECCCCCD, 0x3E19999A);
        return;
    }
    func_80089A04(0x3E800000, 0x3DCCCCCD);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_8007D794.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 func_8008A140(s32, s32, ?); // extern

s32 func_8007D804(s32 arg0) {
    s32 temp_s1;
    s32 phi_s0;
    s32 phi_s1;
    s32 phi_s2;
    s32 phi_s2_2;
    s32 phi_s2_3;

    phi_s1 = 0;
    phi_s2 = 0;
    phi_s2_3 = 0;
    if (gPlayerCountSelection1 > 0) {
        phi_s0 = 0;
        do {
            phi_s2_2 = phi_s2_3;
            if (func_8008A140(arg0, phi_s0 + camera1, 0x4000) != 0) {
                phi_s2_2 = phi_s2_3 + 1;
            }
            temp_s1 = phi_s1 + 1;
            phi_s0 += 0xB8;
            phi_s1 = temp_s1;
            phi_s2 = phi_s2_2;
            phi_s2_3 = phi_s2_2;
        } while (temp_s1 < gPlayerCountSelection1);
    }
    return phi_s2;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_8007D804.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80072488(); // extern
? func_80086E70(s32); // extern

void func_8007D8AC(s32 arg0) {
    func_80072488();
    func_80086E70(arg0);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_8007D8AC.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80072428(s32); // extern
s32 func_8007D804(); // extern
? func_8007D8AC(); // extern
extern f64 D_800EEF20;
extern f64 D_800EEF28;
extern f64 D_800EEF30;
extern f64 D_800EEF38;
extern ? D_80165C18;

void func_8007D8D4(s32 arg0, s32 arg1) {
    void *sp18;
    s16 temp_v0;
    s32 temp_a0;
    s32 temp_t6;
    void *temp_v1;
    s32 phi_a0;

    temp_t6 = arg0 * 0xE0;
    temp_v1 = temp_t6 + &D_80165C18;
    temp_v0 = temp_v1->unkA6;
    if (temp_v0 != 0) {
        if (temp_v0 != 1) {
            if (temp_v0 != 2) {
                return;
            }
            sp18 = temp_v1;
            temp_a0 = arg0;
            phi_a0 = temp_a0;
            if (func_8007D804() == 0) {
                sp18 = temp_v1;
                arg0 = temp_a0;
                func_80072428(temp_a0);
                phi_a0 = arg0;
            }
            if (arg1 == 1) {
                if (gIsMirrorMode != 0) {
                    if (D_800EEF20 <= (temp_t6 + &D_80165C18)->unk4) {
                        func_80072428(phi_a0);
                        return;
                    }
                    // Duplicate return node #18. Try simplifying control flow for better match
                    return;
                }
                if ((temp_t6 + &D_80165C18)->unk4 <= D_800EEF28) {
                    func_80072428(phi_a0);
                    return;
                }
                // Duplicate return node #18. Try simplifying control flow for better match
                return;
            }
            if (gIsMirrorMode != 0) {
                if (D_800EEF30 <= (temp_t6 + &D_80165C18)->unk4) {
                    func_80072428(phi_a0);
                    return;
                }
                // Duplicate return node #18. Try simplifying control flow for better match
                return;
            }
            if ((temp_t6 + &D_80165C18)->unk4 <= D_800EEF38) {
                func_80072428(phi_a0);
            }
            // Duplicate return node #18. Try simplifying control flow for better match
            return;
        }
        func_8007D8AC();
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_8007D8D4.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_8008781C(); // extern
? func_8008BF18(s32); // extern

void func_8007DA4C(s32 arg0) {
    func_8008781C();
    func_8008BF18(arg0);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_8007DA4C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
u16 func_800417B4(u16, u16); // extern
s32 func_80087060(?); // extern
? func_80087844(s32); // extern
? func_8008BF18(s32); // extern
extern ? D_80165C18;

void func_8007DA74(s32 arg0) {
    void *sp18;
    s16 temp_v0;
    s32 temp_t7;
    void *temp_v1;

    temp_t7 = arg0 * 0xE0;
    temp_v1 = temp_t7 + &D_80165C18;
    temp_v0 = temp_v1->unkAE;
    if ((temp_v0 != 0) && (temp_v0 == 1)) {
        sp18 = temp_v1;
        if (func_80087060(0x1E) != 0) {
            temp_v1->unkC6 = 0;
        }
    }
    sp18 = temp_t7 + &D_80165C18;
    (temp_t7 + &D_80165C18)->unkBE = func_800417B4((temp_t7 + &D_80165C18)->unkBE, (temp_t7 + &D_80165C18)->unkC6);
    func_80087844(arg0);
    func_8008BF18(arg0);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_8007DA74.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_8007DA4C(); // extern
? func_8007DA74(); // extern

void func_8007DAF8(s32 arg1) {
    if (arg1 != 1) {
        if (arg1 != 2) {
            return;
        }
        func_8007DA4C();
        return;
    }
    func_8007DA74();
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_8007DAF8.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
/*
Failed to decompile function func_8007DB44:

Label L8007DCF8 refers to a delay slot; this is currently not supported.
Please modify the assembly to work around it (e.g. copy the instruction
to all jump sources and move the label, or add a nop to the delay slot).
*/
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_8007DB44.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 func_8007223C(s32, ?); // extern
? func_800722A4(s32, ?); // extern
? func_800722CC(?); // extern
s32 func_80072354(s32, ?); // extern
? func_800726CC(s32, ?); // extern
? func_8008A6DC(s32, ?32); // extern
s32 func_8008A8B0(?, ?); // extern
? func_800C9D80(void *, void *, ?); // extern
? func_800C9EF4(void *, ?); // extern
extern ?32 D_800EEF40;
extern ? D_80165C18;

void func_8007DDC0(s32 arg0) {
    ?32 sp2C;
    void *sp20;
    s16 temp_v0_4;
    s32 temp_t1;
    s32 temp_t9;
    s32 temp_v0;
    s32 temp_v0_2;
    s32 temp_v0_3;
    void *temp_s0;

    temp_s0 = (arg0 * 0xE0) + &D_80165C18;
    temp_v0 = temp_s0->unk4C;
    temp_t9 = temp_v0 - 1;
    if (temp_v0 > 0) {
        temp_s0->unk4C = temp_t9;
        if (temp_t9 == 0) {
            func_800722CC(1);
        }
    }
    temp_v0_2 = temp_s0->unk48;
    temp_t1 = temp_v0_2 - 1;
    if (temp_v0_2 > 0) {
        temp_s0->unk48 = temp_t1;
        if (temp_t1 == 0) {
            func_800C9EF4(temp_s0 + 4, 0x51028006);
        }
    }
    if (temp_s0->unk4C == 0) {
        temp_v0_3 = gCCSelection;
        if ((temp_v0_3 == CC_50) || (temp_v0_3 == CC_100) || (temp_v0_3 == CC_150) || (temp_v0_3 == CC_EXTRA)) {
            sp2C = D_800EEF40;
        }
        func_8008A6DC(arg0, sp2C);
        if ((func_8007223C(arg0, 0x40000) != 0) && (func_80072354(arg0, 1) != 0)) {
            sp20 = temp_s0 + 4;
            func_800722A4(arg0, 1);
            func_800C9D80(sp20, temp_s0 + 0x38, 0x51028006);
            func_800726CC(arg0, 3);
            temp_v0_4 = temp_s0->unkA4;
            if (temp_v0_4 > 0) {
                temp_s0->unkA4 = temp_v0_4 - 1;
                temp_s0->unk4C = 0x168;
            } else {
                temp_s0->unk4C = 0x168;
            }
            temp_s0->unk48 = 0x12C;
        }
    }
    if (func_8008A8B0(0xF, 0x12) == 0) {
        temp_s0->unkA4 = 2;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_8007DDC0.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80072488(s32); // extern
? func_8008B8BC(?, ?, ?); // extern
? func_8008B8F0(s32, ?, ?, ?); // extern
extern ? D_0600A9D8;
extern f32 D_800EEF44;
extern f32 D_800EEF48;
extern ? D_80165C18;

void func_8007DF20(s32 arg0) {
    void *sp1C;
    void *temp_v0;

    temp_v0 = (arg0 * 0xE0) + &D_80165C18;
    temp_v0->unk70 = &D_0600A9D8;
    temp_v0->unk4C = 0;
    temp_v0->unk92 = 0;
    sp1C = temp_v0;
    temp_v0->unk0 = 1.0f;
    func_8008B8BC(0, 0, 0);
    if (gIsMirrorMode != 0) {
        temp_v0->unkB4 = 0x8000;
        temp_v0->unk4 = D_800EEF44;
        temp_v0->unkC = 195.0f;
    } else {
        temp_v0->unk4 = D_800EEF48;
        temp_v0->unkC = 70.0f;
    }
    sp1C = temp_v0;
    temp_v0->unk8 = 45.0f;
    func_8008B8F0(arg0, 0, 0, 0);
    temp_v0->unkA4 = 0;
    func_80072488(arg0);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_8007DF20.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
s16 func_800417B4(u16, ?, s32);                     /* extern */
? func_80072488(s32);                               /* extern */
? func_8007278C(s32, ?, s32);                       /* extern */
? func_80073CB0(s32, void *, ?, ?, s32, s32, s32);  /* extern */
? func_8007D714(?);                                 /* extern */
? func_8007DF20(s32);                               /* extern */
? func_800C98B8(void *, void *, ?);                 /* extern */
extern ? D_80165C18;

void func_8007E00C(s32 arg0) {
    s16 temp_v0;
    s16 temp_v1;
    s32 temp_a0;
    s32 temp_a2;
    u16 temp_t8;
    void *temp_s0;

    temp_s0 = (arg0 * 0xE0) + &D_80165C18;
    temp_t8 = temp_s0->unkA6;
    temp_a2 = arg0;
    switch (temp_t8) {
    case 1:
        func_8007DF20(temp_a2);
        return;
    case 3:
        D_8018CFB0 = 1;
        func_80072488(temp_a2);
        return;
    case 4:
        temp_a0 = temp_a2;
        arg0 = temp_a2;
        func_8007278C(temp_a0, 0xD2, temp_a2);
        if (D_80165594 == 0) {
            if (gCCSelection < CC_150) {
                func_8007D714(1);
                func_8007D714(1);
            } else {
                func_8007D714(1);
                func_8007D714(1);
                func_8007D714(1);
                func_8007D714(1);
            }
        }
        func_80073CB0(arg0, temp_s0 + 0xA0, -0x2000, 0, 0x400, 0, -1);
        temp_v1 = temp_s0->unk92;
        temp_s0->unkB6 = temp_s0->unkA0;
        if (temp_v1 == 0) {
            func_800C98B8(temp_s0 + 4, temp_s0 + 0x38, 0x1901904E);
            temp_s0->unk92 = 0x14;
            return;
        }
        temp_s0->unk92 = temp_v1 - 1;
        return;
    case 5:
        arg0 = temp_a2;
        temp_v0 = func_800417B4(temp_s0->unkB6, 0, temp_a2);
        temp_s0->unkB6 = temp_v0;
        if ((temp_v0 & 0xFFFF) == 0) {
            func_80072488(arg0);
            return;
        }
    default:
        return;
    case 6:
        temp_s0->unkB6 = 0;
        temp_s0->unk92 = 0;
        func_80072488(temp_a2);
        D_8018CFB0 = 0;
        /* Duplicate return node #14. Try simplifying control flow for better match */
        return;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_8007E00C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_8007DDC0(s32); // extern
? func_8007E00C(s32); // extern
extern s32 D_80183EA4;

void func_8007E1AC(void) {
    s32 sp1C;
    s32 temp_a0;

    temp_a0 = D_80183EA4;
    sp1C = temp_a0;
    func_8007E00C(temp_a0);
    if (gModeSelection != TIME_TRIALS) {
        func_8007DDC0(temp_a0);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_8007E1AC.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 func_8007223C(s32, ?); // extern
? func_800722A4(s32, ?); // extern
? func_800722CC(?); // extern
s32 func_80072354(s32, ?); // extern
? func_800726CC(s32, ?); // extern
? func_8008A6DC(s32, ?32); // extern
s32 func_8008A8B0(?, ?); // extern
? func_800C9D80(void *, void *, ?); // extern
? func_800C9EF4(void *, ?); // extern
extern ? D_80165C18;

void func_8007E1F4(s32 arg0) {
    ?32 sp2C;
    void *sp20;
    s16 temp_v0_4;
    s32 temp_t1;
    s32 temp_t9;
    s32 temp_v0;
    s32 temp_v0_2;
    s32 temp_v0_3;
    void *temp_s0;

    temp_s0 = (arg0 * 0xE0) + &D_80165C18;
    temp_v0 = temp_s0->unk4C;
    temp_t9 = temp_v0 - 1;
    if (temp_v0 > 0) {
        temp_s0->unk4C = temp_t9;
        if (temp_t9 == 0) {
            func_800722CC(1);
        }
    }
    temp_v0_2 = temp_s0->unk48;
    temp_t1 = temp_v0_2 - 1;
    if (temp_v0_2 > 0) {
        temp_s0->unk48 = temp_t1;
        if (temp_t1 == 0) {
            func_800C9EF4(temp_s0 + 4, 0x51028006);
        }
    }
    if (temp_s0->unk4C == 0) {
        temp_v0_3 = gCCSelection;
        if ((temp_v0_3 == CC_50) || (temp_v0_3 == CC_100) || (temp_v0_3 == CC_150) || (temp_v0_3 == CC_EXTRA)) {
            sp2C = 0x442F0000;
        }
        func_8008A6DC(arg0, sp2C);
        if ((func_8007223C(arg0, 0x40000) != 0) && (func_80072354(arg0, 1) != 0)) {
            sp20 = temp_s0 + 4;
            func_800722A4(arg0, 1);
            func_800C9D80(sp20, temp_s0 + 0x38, 0x51028006);
            func_800726CC(arg0, 3);
            temp_v0_4 = temp_s0->unkA4;
            if (temp_v0_4 > 0) {
                temp_s0->unkA4 = temp_v0_4 - 1;
                temp_s0->unk4C = 0x168;
            } else {
                temp_s0->unk4C = 0x168;
            }
            temp_s0->unk48 = 0x12C;
        }
    }
    if (func_8008A8B0(0xF, 0x13) == 0) {
        temp_s0->unkA4 = 2;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_8007E1F4.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80072488(s32); // extern
? func_8008B8F0(?, ?, ?); // extern
extern f32 D_800EEF68;
extern ? D_80165C18;
extern f32 D_8018D01C;

void func_8007E358(s32 arg0) {
    void *sp1C;
    void *temp_v0;

    temp_v0 = (arg0 * 0xE0) + &D_80165C18;
    temp_v0->unk4 = D_800EEF68 * D_8018D01C;
    sp1C = temp_v0;
    temp_v0->unk8 = 31.0f;
    temp_v0->unkC = -217.0f;
    func_8008B8F0(0, 0, 0);
    temp_v0->unkA4 = 0;
    temp_v0->unk4C = 0;
    temp_v0->unk92 = 0;
    func_80072488(arg0);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_8007E358.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
? func_80072488();                                  /* extern */
? func_8007278C(?);                                 /* extern */
? func_8007D714(?);                                 /* extern */
? func_8007E358();                                  /* extern */
extern ? D_80165CBE;

void func_8007E3EC(s32 arg0) {
    u16 temp_t7;

    temp_t7 = *(&D_80165CBE + (arg0 * 0xE0));
    switch (temp_t7) {
    case 1:
        func_8007E358();
        return;
    case 3:
        D_8018CFE8 = 1;
        func_80072488();
        return;
    case 4:
        func_8007278C(0xD2);
        if (D_80165598 == 0) {
            if (gCCSelection < CC_150) {
                func_8007D714(2);
                return;
            }
            func_8007D714(2);
            func_8007D714(2);
            return;
        }
    default:
        return;
    case 5:
        D_8018CFE8 = 0;
        func_80072488();
        /* Duplicate return node #9. Try simplifying control flow for better match */
        return;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_8007E3EC.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_8007E1F4(s32); // extern
? func_8007E3EC(s32); // extern
extern s32 D_80183EA8;

void func_8007E4C4(void) {
    s32 sp1C;
    s32 temp_a0;

    temp_a0 = D_80183EA8;
    sp1C = temp_a0;
    func_8007E3EC(temp_a0);
    if (gModeSelection != TIME_TRIALS) {
        func_8007E1F4(temp_a0);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_8007E4C4.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800722A4(s32, ?); // extern
s32 func_80072354(?); // extern
s32 func_80088A58(s32, s32, ?); // extern
s32 func_8008A060(s32, s32, ?); // extern
s32 func_8008A0B4(s32, s32, s32, ?); // extern

s32 func_8007E50C(s32 arg0, s32 arg1, s32 arg2) {
    s32 sp24;

    sp24 = 0;
    if ((func_80072354(4) != 0) && (func_80088A58(arg0, arg1, 0x43960000) != 0) && (func_8008A0B4(arg0, arg1, arg2, 0x4000) != 0) && (func_8008A060(arg0, arg2, 0x1555) != 0)) {
        func_800722A4(arg0, 4);
        sp24 = 1;
    }
    return sp24;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_8007E50C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 func_8007E50C(s32, Player *, s32); // extern

s32 func_8007E59C(s32 arg0) {
    s32 temp_s2;
    s32 temp_v0;
    Player *phi_s0;
    s32 phi_s1;
    s32 phi_s2;
    s32 phi_v1;

    phi_s0 = gPlayerOne;
    phi_s1 = camera1;
    phi_s2 = 0;
    phi_v1 = 0;
    if (gPlayerCountSelection1 > 0) {
loop_1:
        temp_v0 = func_8007E50C(arg0, phi_s0, phi_s1);
        phi_s0 += 0xDD8;
        phi_s1 += 0xB8;
        phi_v1 = temp_v0;
        if (temp_v0 == 0) {
            temp_s2 = phi_s2 + 1;
            phi_s2 = temp_s2;
            if (temp_s2 < gPlayerCountSelection1) {
                goto loop_1;
            }
        }
    }
    return phi_v1;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_8007E59C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
s32 f32_step_up_towards(void *, f32, ?);                  /* extern */
s32 f32_step_down_towards(void *, ?, ?);                    /* extern */
? func_800721C0(s32, ?);                            /* extern */
? func_800721E8(s32, ?);                            /* extern */
s32 func_8007223C(s32, ?);                          /* extern */
? func_800722A4(s32, ?);                            /* extern */
? func_800722CC(s32, ?);                            /* extern */
s32 func_80072320(s32, ?);                          /* extern */
? func_80072388(s32, ?);                            /* extern */
? func_80072428(s32);                               /* extern */
? func_80072488(s32);                               /* extern */
? func_8007266C(s32);                               /* extern */
? func_800726CC(s32, ?);                            /* extern */
s32 func_8007278C(s32, ?);                          /* extern */
? func_80072AAC(s32, ?, ?);                         /* extern */
? func_80072E54(s32, ?, ?, ?, s32, s32);            /* extern */
? func_800730BC(s32, ?, ?, ?, s32, s32);            /* extern */
s32 func_8007326C(s32, ?, ?, ?, s32, s32);          /* extern */
s32 func_80073E18(s32, void *, ?, ?);               /* extern */
? func_80080DE4(s32);                               /* extern */
? func_800C98B8(s32, s32, ?);                       /* extern */
extern ? D_80165C18;

void func_8007E63C(s32 arg0) {
    void *sp28;
    f32 temp_f0;
    f32 temp_f0_2;
    f32 temp_f0_3;
    s16 temp_v0;
    s32 temp_t6;
    void *temp_v1;

    temp_t6 = arg0 * 0xE0;
    temp_v1 = temp_t6 + &D_80165C18;
    temp_v0 = temp_v1->unkA6;
    if (temp_v0 >= 0x6D) {
        if (temp_v0 != 0xC8) {
            if (temp_v0 != 0x12C) {
                return;
            }
            if (func_80073E18(arg0, temp_v1 + 0xB4, 0x400, 0x8000) != 0) {
                func_800722CC(arg0, 4);
                func_8007266C(arg0);
            }
            /* Duplicate return node #68. Try simplifying control flow for better match */
            return;
        }
        if (func_8007278C(arg0, 0x12C) != 0) {
            func_80072320(arg0, 0x80);
            func_80072428(arg0);
            func_800726CC(arg0, 1);
            return;
        }
        /* Duplicate return node #68. Try simplifying control flow for better match */
        return;
    }
    if (temp_v0 >= 0x37) {
        switch (temp_v0) {                          /* switch 1 */
        case 0x64:                                  /* switch 1 */
            func_80072E54(arg0, 3, 5, 1, 8, 0);
            return;
        case 0x65:                                  /* switch 1 */
            func_8007278C(arg0, 0x1E);
            return;
        case 0x66:                                  /* switch 1 */
            if (f32_step_up_towards(temp_v1 + 0x2C, 20.0f, 0x3FC00000) != 0) {
                func_80072488(arg0);
                return;
            }
            /* Duplicate return node #68. Try simplifying control flow for better match */
            return;
        case 0x67:                                  /* switch 1 */
            if (f32_step_down_towards(temp_v1 + 0x2C, 0, 0x3FC00000) != 0) {
                if (func_8007223C(arg0, 0x20000) != 0) {
                    func_800722A4(arg0, 0x10);
                    if (func_8007223C(arg0, 0x40000) != 0) {
                        func_800722A4(arg0, 0x20);
                    }
                }
                func_80072488(arg0);
                return;
            }
            /* Duplicate return node #68. Try simplifying control flow for better match */
            return;
        case 0x68:                                  /* switch 1 */
            if (f32_step_up_towards(temp_v1 + 0x2C, 12.0f, 0x3FC00000) != 0) {
                func_80072488(arg0);
                return;
            }
            /* Duplicate return node #68. Try simplifying control flow for better match */
            return;
        case 0x69:                                  /* switch 1 */
            sp28 = temp_v1;
            if (f32_step_down_towards(temp_v1 + 0x2C, 0, 0x3FC00000) != 0) {
                sp28 = temp_v1;
                if (func_8007223C(arg0, 0x20000) != 0) {
                    sp28 = temp_v1;
                    func_800722A4(arg0, 0x10);
                    if (func_8007223C(arg0, 0x40000) != 0) {
                        sp28 = temp_v1;
                        func_800722A4(arg0, 0x20);
                    }
                }
                func_800C98B8(temp_t6 + &D_80165C18 + 4, temp_t6 + &D_80165C18 + 0x38, 0x19018045);
                func_80072488(arg0);
                return;
            }
            /* Duplicate return node #68. Try simplifying control flow for better match */
            return;
        case 0x6A:                                  /* switch 1 */
            if (func_8007326C(arg0, 5, 3, 1, 6, 3) != 0) {
                func_80080DE4(arg0);
                return;
            }
            /* Duplicate return node #68. Try simplifying control flow for better match */
            return;
        case 0x6B:                                  /* switch 1 */
            temp_f0 = temp_v1->unk2C;
            if (temp_f0 >= 22.0f) {
                temp_v1->unkD2 = 0;
            } else if (temp_f0 >= 20.0f) {
                temp_v1->unkD2 = 1;
            } else if (temp_f0 >= 18.0f) {
                temp_v1->unkD2 = 2;
            } else if (temp_f0 >= 16.0f) {
                temp_v1->unkD2 = 3;
            } else if (temp_f0 >= 14.0f) {
                temp_v1->unkD2 = 4;
            } else {
                sp28 = temp_v1;
                func_800730BC(arg0, 3, 5, 1, 6, -1);
            }
            if (f32_step_up_towards(temp_t6 + &D_80165C18 + 0x2C, (temp_t6 + &D_80165C18)->unk20, 0x3F000000) != 0) {
                func_80072388(arg0, 0);
                func_80072488(arg0);
                return;
            }
            /* Duplicate return node #68. Try simplifying control flow for better match */
            return;
        case 0x6C:                                  /* switch 1 */
            if (func_8007278C(arg0, 0x64) != 0) {
                func_800722CC(arg0, 2);
                func_800721E8(arg0, 0x200);
                func_8007266C(arg0);
                return;
            }
            /* Duplicate return node #68. Try simplifying control flow for better match */
            return;
        }
    } else {
        switch (temp_v0) {                          /* switch 2 */
        case 0x32:                                  /* switch 2 */
            if (f32_step_up_towards(temp_v1 + 0x2C, temp_v1->unk20 + 15.0, 0x3FC00000) != 0) {
                func_800721C0(arg0, 0x200);
                func_800722A4(arg0, 1);
                func_800722CC(arg0, 2);
                func_80072488(arg0);
                return;
            }
        default:                                    /* switch 2 */
        default:                                    /* switch 1 */
            return;
        case 0x33:                                  /* switch 2 */
            sp28 = temp_v1;
            if (f32_step_down_towards(temp_v1 + 0x2C, 0, 0x40000000) != 0) {
                temp_f0_2 = temp_v1->unk2C;
                if (temp_f0_2 >= 16.0f) {
                    temp_v1->unkD2 = 0;
                } else if (temp_f0_2 >= 8.0f) {
                    temp_v1->unkD2 = 1;
                } else {
                    temp_v1->unkD2 = 2;
                }
                func_800722CC(arg0, 1);
                if (func_8007223C(arg0, 0x10000) != 0) {
                    func_800722A4(arg0, 0x10);
                    if (func_8007223C(arg0, 0x40000) != 0) {
                        func_800722A4(arg0, 0x20);
                    }
                }
                if (func_80072320(arg0, 2) != 0) {
                    func_800726CC(arg0, 0x64);
                    return;
                }
                func_80072488(arg0);
                return;
            }
            /* Duplicate return node #68. Try simplifying control flow for better match */
            return;
        case 0x34:                                  /* switch 2 */
            func_80072AAC(arg0, 3, 6);
            return;
        case 0x35:                                  /* switch 2 */
            func_80072AAC(arg0, 2, 0x32);
            return;
        case 0x36:                                  /* switch 2 */
            temp_f0_3 = temp_v1->unk2C;
            if (temp_f0_3 >= 20.0f) {
                temp_v1->unkD2 = 0;
            } else if (temp_f0_3 >= 18.0f) {
                temp_v1->unkD2 = 1;
            }
            if (f32_step_up_towards(temp_v1 + 0x2C, temp_v1->unk20, 0x3F000000) != 0) {
                func_800721E8(arg0, 0x200);
                func_8007266C(arg0);
                return;
            }
            /* Duplicate return node #68. Try simplifying control flow for better match */
            return;
        }
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_8007E63C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800721C0(s32, ?); // extern
? func_80072488(s32); // extern
? func_800724DC(s32); // extern
? func_80073444(s32, ? *, ? *, ?, s32); // extern
? func_8008B80C(f32, f32, f32); // extern
? func_8008B888(s32, ?, ?, ?); // extern
? func_8008B8BC(s32, ?, ?, ?); // extern
extern ? D_06006F38;
extern ? D_06007138;
extern ? D_06009088;
extern ? D_80165C18;

void func_8007EC30(s32 arg0) {
    void *temp_s1;

    temp_s1 = (arg0 * 0xE0) + &D_80165C18;
    temp_s1->unk44 = 0.0f;
    temp_s1->unk14 = 0.0f;
    func_8008B80C(0.0f, 0.0f, 0.0f);
    if (gIsMirrorMode != 0) {
        func_8008B888(arg0, 0, 0x4000, 0);
        func_8008B8BC(arg0, 0, 0x4000, 0);
    } else {
        func_8008B888(arg0, 0, 0xC000, 0);
        func_8008B8BC(arg0, 0, 0xC000, 0);
    }
    func_80073444(arg0, &D_06006F38, &D_06007138, 0x10, 0x40);
    temp_s1->unk70 = &D_06009088;
    temp_s1->unkC8 = 0xC;
    temp_s1->unk0 = 1.0f;
    temp_s1->unk20 = 30.0f;
    func_800721C0(arg0, 0x5000220);
    temp_s1->unkA4 = 0;
    temp_s1->unkDF = 6;
    func_800724DC(arg0);
    func_80072488(arg0);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_8007EC30.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
? func_80072568(s32, ?);                            /* extern */
? func_800725E8(s32, ?, ?);                         /* extern */
? func_800726CC(s32, ?);                            /* extern */
? func_8007278C(s32, ?);                            /* extern */
? func_80073514(s32);                               /* extern */
? func_8007E63C(s32);                               /* extern */
? func_8007EC30(s32);                               /* extern */
? func_8008BF18(s32);                               /* extern */
extern ? D_80165C18;

void func_8007ED6C(s32 arg0) {
    void *sp24;
    u16 temp_t9;
    void *temp_t8;

    temp_t8 = (arg0 * 0xE0) + &D_80165C18;
    sp24 = temp_t8;
    temp_t9 = temp_t8->unkA6;
    switch (temp_t9) {
    case 1:
        func_8007EC30(arg0);
        break;
    case 2:
        func_8007278C(arg0, 0x3C);
        break;
    case 3:
        func_80072568(arg0, 0x32);
        break;
    case 4:
        if (func_8007E59C(arg0) != 0) {
            func_800725E8(arg0, 0x12C, 2);
        } else {
            func_800726CC(arg0, 2);
        }
        break;
    }
    func_8007E63C(arg0);
    func_8008BF18(arg0);
    sp24->unkC0 = sp24->unkB4;
    func_80073514(arg0);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_8007ED6C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800721C0(s32, ?); // extern
? func_80072488(s32); // extern
? func_80073444(? *, ? *, ?, s32); // extern
? func_80086E70(s32); // extern
? func_8008B80C(s32, f32, ?, f32); // extern
? func_8008B888(s32, ?, ?, ?); // extern
? func_8008B8BC(s32, ?, ?, ?); // extern
extern ? D_06006F38;
extern ? D_06007138;
extern ? D_06009088;
extern ? D_80165C18;

void func_8007EE5C(s32 arg0) {
    void *temp_s0;

    func_80073444(&D_06006F38, &D_06007138, 0x10, 0x40);
    temp_s0 = (arg0 * 0xE0) + &D_80165C18;
    temp_s0->unk70 = &D_06009088;
    temp_s0->unkC8 = 0xC;
    temp_s0->unk0 = 1.0f;
    func_800721C0(arg0, 0x4000220);
    temp_s0->unkA4 = 0;
    temp_s0->unkDF = 6;
    func_80086E70(arg0);
    temp_s0->unk44 = 0.0f;
    temp_s0->unk14 = 0.0f;
    func_8008B80C(arg0, 0.0f, 0x41A00000, 0.0f);
    temp_s0->unk20 = 20.0f;
    if (gIsMirrorMode != 0) {
        func_8008B888(arg0, 0, 0x4000, 0);
        func_8008B8BC(arg0, 0, 0x4000, 0);
    } else {
        func_8008B888(arg0, 0, 0xC000, 0);
        func_8008B8BC(arg0, 0, 0xC000, 0);
    }
    temp_s0->unkAE = 1;
    if (temp_s0->unkA0 == 0) {
        temp_s0->unkDD = 1;
    } else {
        temp_s0->unkDD = 2;
    }
    func_80072488(arg0);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_8007EE5C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
s32 f32_step_up_towards(void *, ?, ?);                    /* extern */
s32 f32_step_down_towards(void *, ?, ?);                    /* extern */
s32 f32_step_towards(void *, f32, ?);                  /* extern */
? func_800726CC(s32, ?);                            /* extern */
s32 func_80073E18(s32, void *, ?, ?);               /* extern */
? func_80086FD4(s32);                               /* extern */
? func_8008701C(s32, ?);                            /* extern */
extern ? D_80165C18;

void func_8007EFBC(s32 arg0) {
    void *sp24;
    u16 temp_t8;
    void *temp_v1;

    temp_v1 = (arg0 * 0xE0) + &D_80165C18;
    temp_t8 = temp_v1->unkAE;
    switch (temp_t8) {
    case 1:
        sp24 = temp_v1;
        if (func_80073E18(arg0, temp_v1 + 0xB4, 0x800, 0x8000) != 0) {
            temp_v1->unk1C = D_8018D01C * 200.0;
            func_80086FD4(arg0);
            return;
        }
    default:
        return;
    case 2:
        if (f32_step_towards(temp_v1 + 0x28, temp_v1->unk1C, 0x40800000) != 0) {
            func_80086FD4(arg0);
            return;
        }
        /* Duplicate return node #27. Try simplifying control flow for better match */
        return;
    case 3:
        if (func_80073E18(arg0, temp_v1 + 0xB4, 0x400, 0x8000) != 0) {
            func_800726CC(arg0, 3);
            func_80086FD4(arg0);
            return;
        }
        /* Duplicate return node #27. Try simplifying control flow for better match */
        return;
    case 5:
        if (func_80073E18(arg0, temp_v1 + 0xB4, 0x400, 0xC000) != 0) {
            func_80086FD4(arg0);
            return;
        }
        /* Duplicate return node #27. Try simplifying control flow for better match */
        return;
    case 6:
        if (f32_step_down_towards(temp_v1 + 0x30, 0xC2C80000, 0x40000000) != 0) {
            func_80086FD4(arg0);
            return;
        }
        /* Duplicate return node #27. Try simplifying control flow for better match */
        return;
    case 7:
        if (func_80073E18(arg0, temp_v1 + 0xB4, 0x400, 0x4000) != 0) {
            func_80086FD4(arg0);
            func_800726CC(arg0, 3);
            return;
        }
        /* Duplicate return node #27. Try simplifying control flow for better match */
        return;
    case 9:
        if (func_80073E18(arg0, temp_v1 + 0xB4, 0x400, 0x10000) != 0) {
            func_80086FD4(arg0);
            return;
        }
        /* Duplicate return node #27. Try simplifying control flow for better match */
        return;
    case 10:
        if (f32_step_towards(temp_v1 + 0x28, 0.0f, 0x40800000) != 0) {
            func_80086FD4(arg0);
            return;
        }
        /* Duplicate return node #27. Try simplifying control flow for better match */
        return;
    case 11:
        if (func_80073E18(arg0, temp_v1 + 0xB4, 0x400, 0x10000) != 0) {
            func_80086FD4(arg0);
            func_800726CC(arg0, 3);
            return;
        }
        /* Duplicate return node #27. Try simplifying control flow for better match */
        return;
    case 13:
        if (func_80073E18(arg0, temp_v1 + 0xB4, 0x400, 0x14000) != 0) {
            func_80086FD4(arg0);
            return;
        }
        /* Duplicate return node #27. Try simplifying control flow for better match */
        return;
    case 14:
        if (f32_step_up_towards(temp_v1 + 0x30, 0, 0x40000000) != 0) {
            func_80086FD4(arg0);
            return;
        }
        /* Duplicate return node #27. Try simplifying control flow for better match */
        return;
    case 15:
        if (func_80073E18(arg0, temp_v1 + 0xB4, 0x400, 0xC000) != 0) {
            func_80086FD4(arg0);
            func_800726CC(arg0, 3);
            return;
        }
        /* Duplicate return node #27. Try simplifying control flow for better match */
        return;
    case 17:
        func_8008701C(arg0, 1);
        /* Duplicate return node #27. Try simplifying control flow for better match */
        return;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_8007EFBC.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
s32 f32_step_up_towards(void *, ?, ?);                    /* extern */
s32 f32_step_down_towards(void *, ?, ?);                    /* extern */
s32 f32_step_towards(void *, f32, ?);                  /* extern */
? func_800726CC(s32, ?);                            /* extern */
s32 func_80073E18(s32, void *, ?, ?);               /* extern */
? func_80086FD4(s32);                               /* extern */
? func_8008701C(s32, ?);                            /* extern */
extern ? D_80165C18;

void func_8007F280(s32 arg0) {
    void *sp24;
    u16 temp_t8;
    void *temp_v1;

    temp_v1 = (arg0 * 0xE0) + &D_80165C18;
    temp_t8 = temp_v1->unkAE;
    switch (temp_t8) {
    case 1:
        sp24 = temp_v1;
        if (func_80073E18(arg0, temp_v1 + 0xB4, 0x400, 0x10000) != 0) {
            temp_v1->unk1C = D_8018D01C * -200.0;
            func_80086FD4(arg0);
            return;
        }
    default:
        return;
    case 2:
        if (f32_step_towards(temp_v1 + 0x28, temp_v1->unk1C, 0x40800000) != 0) {
            func_80086FD4(arg0);
            return;
        }
        /* Duplicate return node #27. Try simplifying control flow for better match */
        return;
    case 3:
        if (func_80073E18(arg0, temp_v1 + 0xB4, 0x400, 0x10000) != 0) {
            func_800726CC(arg0, 3);
            func_80086FD4(arg0);
            return;
        }
        /* Duplicate return node #27. Try simplifying control flow for better match */
        return;
    case 5:
        if (func_80073E18(arg0, temp_v1 + 0xB4, 0x400, 0x4000) != 0) {
            func_80086FD4(arg0);
            return;
        }
        /* Duplicate return node #27. Try simplifying control flow for better match */
        return;
    case 6:
        if (f32_step_up_towards(temp_v1 + 0x30, 0x42C80000, 0x40000000) != 0) {
            func_80086FD4(arg0);
            return;
        }
        /* Duplicate return node #27. Try simplifying control flow for better match */
        return;
    case 7:
        if (func_80073E18(arg0, temp_v1 + 0xB4, 0x400, 0xC000) != 0) {
            func_80086FD4(arg0);
            func_800726CC(arg0, 3);
            return;
        }
        /* Duplicate return node #27. Try simplifying control flow for better match */
        return;
    case 9:
        if (func_80073E18(arg0, temp_v1 + 0xB4, 0x400, 0x8000) != 0) {
            func_80086FD4(arg0);
            return;
        }
        /* Duplicate return node #27. Try simplifying control flow for better match */
        return;
    case 10:
        if (f32_step_towards(temp_v1 + 0x28, 0.0f, 0x40800000) != 0) {
            func_80086FD4(arg0);
            return;
        }
        /* Duplicate return node #27. Try simplifying control flow for better match */
        return;
    case 11:
        if (func_80073E18(arg0, temp_v1 + 0xB4, 0x400, 0x8000) != 0) {
            func_80086FD4(arg0);
            func_800726CC(arg0, 3);
            return;
        }
        /* Duplicate return node #27. Try simplifying control flow for better match */
        return;
    case 13:
        if (func_80073E18(arg0, temp_v1 + 0xB4, 0x400, 0xC000) != 0) {
            func_80086FD4(arg0);
            return;
        }
        /* Duplicate return node #27. Try simplifying control flow for better match */
        return;
    case 14:
        if (f32_step_down_towards(temp_v1 + 0x30, 0, 0x40000000) != 0) {
            func_80086FD4(arg0);
            return;
        }
        /* Duplicate return node #27. Try simplifying control flow for better match */
        return;
    case 15:
        if (func_80073E18(arg0, temp_v1 + 0xB4, 0x400, 0x14000) != 0) {
            func_80086FD4(arg0);
            func_800726CC(arg0, 3);
            return;
        }
        /* Duplicate return node #27. Try simplifying control flow for better match */
        return;
    case 17:
        func_8008701C(arg0, 1);
        /* Duplicate return node #27. Try simplifying control flow for better match */
        return;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_8007F280.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_8007EFBC(); // extern
? func_8007F280(); // extern
extern ? D_80165CF5;

void func_8007F544(s32 arg0) {
    u8 temp_v0;

    temp_v0 = *(&D_80165CF5 + (arg0 * 0xE0));
    if (temp_v0 != 1) {
        if (temp_v0 != 2) {
            return;
        }
        func_8007F280();
        return;
    }
    func_8007EFBC();
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_8007F544.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80072488(s32); // extern
? func_80072568(s32, ?); // extern
? func_80073514(s32); // extern
? func_8007E63C(s32); // extern
? func_8007EE5C(s32); // extern
? func_8007F544(s32); // extern
? func_80086FD4(s32); // extern
? func_8008BF18(s32); // extern
extern ? D_80165CBE;

void func_8007F5A8(s32 arg0) {
    s16 temp_v0;

    temp_v0 = *(&D_80165CBE + (arg0 * 0xE0));
    if (temp_v0 != 0) {
        if (temp_v0 != 1) {
            if (temp_v0 != 3) {
                if (temp_v0 != 4) {

                } else {
                    func_80086FD4(arg0);
                    func_80072488(arg0);
                }
            } else {
                func_80072568(arg0, 0x32);
            }
        } else {
            func_8007EE5C(arg0);
        }
    }
    func_8007E63C(arg0);
    func_8007F544(arg0);
    func_8008BF18(arg0);
    func_80073514(arg0);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_8007F5A8.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800722A4(?); // extern
? func_80086E70(s32); // extern
extern ? D_80165C18;

void func_8007F660(s32 arg0, s32 arg1, s32 arg2) {
    void *temp_v0;

    func_800722A4(8);
    func_80086E70(arg0);
    temp_v0 = (arg0 * 0xE0) + &D_80165C18;
    temp_v0->unkDD = 1;
    temp_v0->unkD1 = arg1;
    temp_v0->unk48 = arg2;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_8007F660.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800722A4(?); // extern
? func_80086E70(s32); // extern
extern ? D_80165C18;

void func_8007F6C4(s32 arg0, s32 arg1) {
    Player *sp1C;
    void *temp_v0;

    sp1C = &gPlayerOne[arg1];
    func_800722A4(8);
    func_80086E70(arg0);
    temp_v0 = (arg0 * 0xE0) + &D_80165C18;
    temp_v0->unkDD = 2;
    temp_v0->unkD1 = arg1;
    temp_v0->unk1C = sp1C->posX - temp_v0->unk10;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_8007F6C4.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_8007F660(s32, s32, s32); // extern
? func_8007F6C4(s32, s32); // extern
extern ? D_80164438;
extern s16 D_80165750;
extern ? D_80165C18;
extern s32 D_80183EA0;

? func_8007F75C(s32 arg0) {
    s16 temp_v1;
    s16 temp_v1_2;
    s32 temp_a0;
    s32 temp_a0_2;
    s32 temp_s0;
    s32 temp_s0_2;
    u16 temp_v0;
    s32 *phi_s1;
    s32 phi_s0;
    s32 phi_v1;
    s32 *phi_s1_2;
    s32 phi_s0_2;
    s32 phi_v1_2;
    ? phi_s6;
    ? phi_s6_2;
    ? phi_s6_3;

    temp_v0 = *(&D_80164438 + (arg0 * 2));
    phi_s6 = 0;
    phi_s6_2 = 0;
    phi_s6_3 = 0;
    if ((temp_v0 >= 0xAA) && (temp_v0 < 0xB5)) {
        temp_v1 = D_80165750;
        phi_s0 = 0;
        phi_v1 = temp_v1;
        if (temp_v1 > 0) {
            phi_s1 = &D_80183EA0;
            do {
                temp_a0 = *phi_s1;
                if ((&D_80165C18 + (temp_a0 * 0xE0))->unkD5 == 3) {
                    func_8007F660(temp_a0, arg0, random_int(0x32) + 0x32);
                    phi_v1 = D_80165750;
                    phi_s6_2 = 1;
                }
                temp_s0 = phi_s0 + 1;
                phi_s1 += 4;
                phi_s0 = temp_s0;
                phi_s6 = phi_s6_2;
            } while (temp_s0 < phi_v1);
        }
    } else if ((temp_v0 >= 0xD7) && (temp_v0 < 0xE2)) {
        temp_v1_2 = D_80165750;
        phi_s1_2 = &D_80183EA0;
        phi_s0_2 = 0;
        phi_v1_2 = temp_v1_2;
        if (temp_v1_2 > 0) {
            do {
                temp_a0_2 = *phi_s1_2;
                if ((&D_80165C18 + (temp_a0_2 * 0xE0))->unkD5 == 3) {
                    func_8007F6C4(temp_a0_2, arg0);
                    phi_v1_2 = D_80165750;
                    phi_s6_3 = 1;
                }
                temp_s0_2 = phi_s0_2 + 1;
                phi_s1_2 += 4;
                phi_s0_2 = temp_s0_2;
                phi_s6 = phi_s6_3;
            } while (temp_s0_2 < phi_v1_2);
        }
    }
    return phi_s6;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_8007F75C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
/*
Failed to decompile function func_8007F8D8:

Label L8007F9D0 refers to a delay slot; this is currently not supported.
Please modify the assembly to work around it (e.g. copy the instruction
to all jump sources and move the label, or add a nop to the delay slot).
*/
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_8007F8D8.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800721C0(s32, ?); // extern
? func_80072488(s32); // extern
? func_80073444(? *, ? *, ?, s32); // extern
? func_8008B80C(s32, f32, f32, f32); // extern
? func_8008B888(s32, ?, ?, ?); // extern
? func_8008B8BC(s32, ?, ?, ?); // extern
extern ? D_06006F38;
extern ? D_06007138;
extern ? D_06009088;
extern ? D_80165C18;

void func_8007FA08(s32 arg0) {
    void *temp_s0;

    func_80073444(&D_06006F38, &D_06007138, 0x10, 0x40);
    temp_s0 = (arg0 * 0xE0) + &D_80165C18;
    temp_s0->unk70 = &D_06009088;
    temp_s0->unkC8 = 0xC;
    temp_s0->unk0 = 1.0f;
    func_800721C0(arg0, 0x4000220);
    temp_s0->unkA4 = 0;
    temp_s0->unk44 = 0.0f;
    temp_s0->unk14 = 0.0f;
    func_8008B80C(arg0, 0.0f, 0.0f, 0.0f);
    func_8008B888(arg0, 0, 0, 0);
    if (gIsMirrorMode != 0) {
        func_8008B8BC(arg0, 0, 0xC000, 0);
    } else {
        func_8008B8BC(arg0, 0, 0x4000, 0);
    }
    temp_s0->unk38 = 0.0f;
    temp_s0->unkDD = 1;
    temp_s0->unkDF = 8;
    temp_s0->unkC0 = temp_s0->unkB4;
    temp_s0->unk2C = 15.0f;
    temp_s0->unk20 = 15.0f;
    func_80072488(arg0);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_8007FA08.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
? f32_step_towards(void *, ?, ?);                      /* extern */
? func_800722CC(s32, ?);                            /* extern */
? func_800726CC(s32, ?);                            /* extern */
? func_80086FD4(s32, void *);                       /* extern */
? func_8008775C(s32, void *);                       /* extern */
extern ? D_80165C18;

void func_8007FB48(s32 arg0) {
    void *sp18;
    s16 temp_a0;
    s16 temp_a0_2;
    s16 temp_a0_3;
    s32 temp_t1;
    s32 temp_t7;
    s32 temp_v0;
    u16 temp_t2;
    u16 temp_v0_2;
    void *temp_a1;
    void *temp_v1;
    s16 phi_a0;
    s32 phi_v0;

    temp_t7 = arg0 * 0xE0;
    temp_v1 = temp_t7 + &D_80165C18;
    temp_t2 = temp_v1->unkAE;
    temp_a1 = (temp_v1->unkD1 * 0xDD8) + gPlayerOne;
    switch (temp_t2) {
    case 1:
        temp_v1->unkB0 = 0xA0;
        temp_v1->unk28 = 0.0f;
        temp_v1->unk30 = 0.0f;
        temp_v1->unk40 = 0.0f;
        func_80086FD4(arg0, temp_a1);
        return;
    case 2:
        temp_v0 = temp_v1->unk48;
        temp_a0 = temp_v1->unkB0;
        temp_v1->unk38 = (temp_a1->unk94 * D_8018D01C) * 1.25;
        if (temp_v0 >= temp_a0) {
            if (temp_a0 == temp_v0) {
                if ((D_8018D400 & 1) != 0) {
                    temp_v1->unk40 = 1.5f;
                } else {
                    temp_v1->unk40 = -1.5f;
                }
            }
            if (temp_v1->unk40 >= 0.0) {
                if (temp_v1->unk30 >= 40.0) {
                    temp_v1->unk40 = -1.5f;
                }
            } else if (temp_v1->unk30 <= -40.0) {
                temp_v1->unk40 = 1.5f;
            }
        }
        sp18 = temp_v1;
        func_8008775C(arg0, temp_a1);
        temp_a0_2 = temp_v1->unkB0;
        phi_a0 = temp_a0_2;
        if (temp_a0_2 < 0x65) {
            sp18 = temp_v1;
            temp_a0_3 = temp_v1->unkB0;
            temp_v1->unkB4 = func_800417B4(temp_v1->unkB4, (temp_v1->unkC0 + 0x8000) & 0xFFFF);
            phi_a0 = temp_a0_3;
            if (temp_a0_3 == 0x64) {
                temp_v1->unkD2 = 1;
                phi_a0 = temp_v1->unkB0;
            }
        }
        phi_v0 = 0;
        if (gIsMirrorMode != 0) {
            if ((temp_t7 + &D_80165C18)->unk28 <= -1000.0) {
                goto block_20;
            }
        } else if ((temp_t7 + &D_80165C18)->unk28 >= 1000.0) {
block_20:
            phi_v0 = 1;
        }
        (temp_t7 + &D_80165C18)->unkB0 = phi_a0 - 1;
        if (((temp_t7 + &D_80165C18)->unkB0 == 0) || (phi_v0 != 0)) {
            (temp_t7 + &D_80165C18)->unk34 = 0.0f;
            func_800726CC(arg0, 3);
            func_80086FD4(arg0);
            return;
        }
    default:
        return;
    case 4:
        sp18 = temp_v1;
        f32_step_towards(temp_v1 + 0x30, 0, 0x40000000);
        f32_step_towards(temp_v1 + 0x28, 0, 0x40A00000);
        if ((temp_v1->unk30 + temp_v1->unk28) == 0.0) {
            func_80086FD4(arg0);
            return;
        }
        /* Duplicate return node #28. Try simplifying control flow for better match */
        return;
    case 5:
        sp18 = temp_v1;
        temp_v0_2 = func_800417B4(temp_v1->unkB4, temp_v1->unkC0);
        temp_t1 = temp_v0_2 & 0xFFFF;
        temp_v1->unkB4 = temp_v0_2;
        if (temp_t1 == temp_v1->unkC0) {
            sp18 = temp_v1;
            func_800722CC(arg0, 8);
            func_80086FD4(arg0);
            temp_v1->unkD2 = 0;
        }
        /* Duplicate return node #28. Try simplifying control flow for better match */
        return;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_8007FB48.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 f32_step_towards(void *, s32, ?); // extern
? func_800722CC(s32, ?); // extern
? func_800726CC(s32, ?); // extern
? func_80086FD4(s32); // extern
extern ? D_80165C18;

void func_8007FEA4(s32 arg0) {
    s16 temp_v0;
    void *temp_v1;

    temp_v1 = (arg0 * 0xE0) + &D_80165C18;
    temp_v0 = temp_v1->unkAE;
    if (temp_v0 != 0) {
        if (temp_v0 != 1) {
            if (temp_v0 != 2) {
                if (temp_v0 != 3) {
                    return;
                }
                if (f32_step_towards(temp_v1 + 0x28, 0, 0x40A00000) != 0) {
                    func_80086FD4(arg0);
                    func_800722CC(arg0, 8);
                }
                // Duplicate return node #9. Try simplifying control flow for better match
                return;
            }
            // Duplicate return node #9. Try simplifying control flow for better match
            return;
        }
        if (f32_step_towards(temp_v1 + 0x28, temp_v1->unk1C, 0x40A00000) != 0) {
            func_800726CC(arg0, 3);
            func_80086FD4(arg0);
            return;
        }
        // Duplicate return node #9. Try simplifying control flow for better match
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_8007FEA4.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_8007FB48(); // extern
? func_8007FEA4(); // extern
extern ? D_80165CF5;

void func_8007FF5C(s32 arg0) {
    u8 temp_v0;

    temp_v0 = *(&D_80165CF5 + (arg0 * 0xE0));
    if (temp_v0 != 1) {
        if (temp_v0 != 2) {
            return;
        }
        func_8007FEA4();
        return;
    }
    func_8007FB48();
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_8007FF5C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80072488(s32); // extern
? func_80072568(s32, ?); // extern
? func_80073514(s32); // extern
? func_8007E63C(s32); // extern
? func_8007FA08(s32); // extern
? func_8007FF5C(s32); // extern
? func_80086FD4(s32); // extern
? func_8008BF18(s32); // extern
extern ? D_80165CBE;

void func_8007FFC0(s32 arg0) {
    s16 temp_v0;

    temp_v0 = *(&D_80165CBE + (arg0 * 0xE0));
    if (temp_v0 != 0) {
        if (temp_v0 != 1) {
            if (temp_v0 != 3) {
                if (temp_v0 != 4) {

                } else {
                    func_80072488(arg0);
                    func_80086FD4(arg0);
                }
            } else {
                func_80072568(arg0, 0x32);
            }
        } else {
            func_8007FA08(arg0);
        }
    }
    func_8007E63C(arg0);
    func_8007FF5C(arg0);
    func_8008BF18(arg0);
    func_80073514(arg0);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_8007FFC0.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800721C0(s32, ?); // extern
? func_80072488(s32); // extern
? func_800724DC(s32); // extern
? func_80073444(? *, ? *, ?, s32); // extern
? func_8008B80C(s32, f32, f32, f32); // extern
? func_8008B888(s32, ?, ?, ?); // extern
? func_8008B8BC(s32, ?, ?, ?); // extern
extern ? D_06006F38;
extern ? D_06007138;
extern ? D_06009088;
extern ? D_80165C18;

void func_80080078(s32 arg0) {
    s16 temp_v0;
    void *temp_s0;

    func_80073444(&D_06006F38, &D_06007138, 0x10, 0x40);
    temp_s0 = (arg0 * 0xE0) + &D_80165C18;
    temp_s0->unk70 = &D_06009088;
    temp_s0->unkC8 = 0xC;
    temp_s0->unk0 = 1.0f;
    func_800721C0(arg0, 0x4000220);
    temp_s0->unkA4 = 2;
    temp_s0->unkDF = 8;
    func_8008B888(arg0, 0, 0, 0);
    temp_s0->unk44 = 0.0f;
    temp_s0->unk14 = 0.0f;
    func_8008B80C(arg0, 0.0f, 0.0f, 0.0f);
    temp_s0->unk20 = 30.0f;
    if (gIsMirrorMode != 0) {
        func_8008B8BC(arg0, 0, 0x4000, 0);
    } else {
        func_8008B8BC(arg0, 0, 0xC000, 0);
    }
    temp_v0 = temp_s0->unkA0;
    if (temp_v0 != 0) {
        if (temp_v0 != 1) {
            if (temp_v0 != 2) {
                if (temp_v0 != 3) {

                } else {
                    temp_s0->unk50 = 0xB4;
                }
            } else {
                temp_s0->unk50 = 0x78;
            }
        } else {
            temp_s0->unk50 = 0x3C;
        }
    } else {
        temp_s0->unk50 = 2;
    }
    func_800724DC(arg0);
    func_80072488(arg0);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80080078.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
? func_80072568(s32, ?);                            /* extern */
? func_800726CC(s32, ?);                            /* extern */
? func_8007278C(s32, s32);                          /* extern */
? func_80073514(s32);                               /* extern */
? func_8007E63C(s32);                               /* extern */
? func_80080078(s32);                               /* extern */
? func_8008BF18(s32);                               /* extern */
extern ? D_80165C18;

void func_800801FC(s32 arg0) {
    u16 temp_t8;
    void *temp_v0;

    temp_v0 = (arg0 * 0xE0) + &D_80165C18;
    temp_t8 = temp_v0->unkA6;
    switch (temp_t8) {
    case 1:
        func_80080078(arg0);
        break;
    case 2:
        func_8007278C(arg0, temp_v0->unk50);
        break;
    case 3:
        func_80072568(arg0, 0x32);
        break;
    case 4:
        temp_v0->unk50 = 0x3C;
        func_800726CC(arg0, 2);
        break;
    }
    func_8007E63C(arg0);
    func_8008BF18(arg0);
    func_80073514(arg0);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_800801FC.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800721C0(s32, ?); // extern
? func_80072488(s32); // extern
? func_800724DC(s32); // extern
? func_80073444(? *, ? *, ?, s32); // extern
? func_8008B80C(s32, f32, f32, f32); // extern
? func_8008B888(s32, ?, ?, ?); // extern
? func_8008B8BC(s32, ?, ?, ?); // extern
extern ? D_06006F38;
extern ? D_06007138;
extern ? D_06009088;
extern ? D_80165C18;

void func_800802C0(s32 arg0) {
    void *temp_s0;

    temp_s0 = (arg0 * 0xE0) + &D_80165C18;
    temp_s0->unkD8 = 0;
    func_80073444(&D_06006F38, &D_06007138, 0x10, 0x40);
    temp_s0->unk70 = &D_06009088;
    temp_s0->unkD2 = 0;
    temp_s0->unkC8 = 0xC;
    temp_s0->unk0 = 1.5f;
    func_800721C0(arg0, 0x5000220);
    temp_s0->unkA4 = 1;
    temp_s0->unkDF = 6;
    func_8008B80C(arg0, 0.0f, 0.0f, 0.0f);
    func_8008B888(arg0, 0, 0, 0);
    temp_s0->unk44 = 0.0f;
    temp_s0->unk14 = 0.0f;
    temp_s0->unk2C = 10.0f;
    temp_s0->unk20 = 10.0f;
    if (gIsMirrorMode != 0) {
        func_8008B8BC(arg0, 0, 0x4000, 0);
    } else {
        func_8008B8BC(arg0, 0, 0xC000, 0);
    }
    temp_s0->unk28 = 0.0f;
    temp_s0->unk30 = 0.0f;
    func_800724DC(arg0);
    func_80072488(arg0);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_800802C0.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
s32 func_8007223C(s32, ?);                          /* extern */
? func_80072488(s32);                               /* extern */
? func_800726CC(s32, ?);                            /* extern */
s32 func_8007278C(s32, ?);                          /* extern */
s32 func_800730BC(s32, ?, ?, ?, s32, s32);          /* extern */
? func_80073514(s32);                               /* extern */
? func_800802C0(s32);                               /* extern */
? func_8008A6DC(s32, ?);                            /* extern */
? func_8008BF18(s32);                               /* extern */
? func_800C98B8(void *, void *, ?);                 /* extern */
extern ? D_80165C18;

void func_80080408(s32 arg0) {
    void *sp2C;
    u16 temp_t8;
    void *temp_v1;

    temp_v1 = (arg0 * 0xE0) + &D_80165C18;
    temp_t8 = temp_v1->unkA6;
    switch (temp_t8) {
    case 1:
        func_800802C0(arg0);
        break;
    case 2:
        sp2C = temp_v1;
        func_8008A6DC(arg0, 0x42C80000);
        if (func_8007223C(arg0, 0x40000) != 0) {
            func_800C98B8(temp_v1 + 4, temp_v1 + 0x38, 0x19018045);
            func_80072488(arg0);
        }
        break;
    case 3:
        sp2C = temp_v1;
        if (func_800730BC(arg0, 3, 5, 1, 6, 6) != 0) {
            temp_v1->unkD2 = 0;
        }
        break;
    case 4:
        if (func_8007278C(arg0, 0x12C) != 0) {
            func_800726CC(arg0, 2);
        }
        break;
    }
    func_8008BF18(arg0);
    func_80073514(arg0);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80080408.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800721C0(s32, ?); // extern
? func_800722A4(s32, ?); // extern
? func_80072488(s32); // extern
? func_80073444(? *, ? *, ?, s32); // extern
? func_80086E70(s32); // extern
? func_8008B80C(s32, ?, ?, ?); // extern
? func_8008B888(s32, ?, ?, ?); // extern
? func_8008B8BC(s32, ?, ?, ?); // extern
extern ? D_06006F38;
extern ? D_06007138;
extern ? D_06009088;
extern ? D_80165C18;

void func_80080524(s32 arg0) {
    s16 temp_v0;
    void *temp_s0;

    func_80073444(&D_06006F38, &D_06007138, 0x10, 0x40);
    temp_s0 = (arg0 * 0xE0) + &D_80165C18;
    temp_s0->unk70 = &D_06009088;
    temp_s0->unkC8 = 0xC;
    temp_s0->unkD2 = 0;
    temp_s0->unk0 = 1.0f;
    func_800721C0(arg0, 0x4000220);
    temp_s0->unkA4 = 0;
    temp_s0->unkDF = 0xA;
    func_80086E70(arg0);
    func_8008B80C(arg0, 0, 0, 0);
    temp_s0->unk44 = 70.0f;
    temp_s0->unk14 = 70.0f;
    temp_s0->unk20 = 0.0f;
    func_8008B888(arg0, 0, 0, 0);
    if ((gIsMirrorMode != 0) || (D_800DC50C == CREDITS_SEQUENCE)) {
        func_8008B8BC(arg0, 0, 0xC000, 0);
    } else {
        func_8008B8BC(arg0, 0, 0x4000, 0);
    }
    temp_v0 = temp_s0->unkA0;
    if (temp_v0 != 0) {
        if (temp_v0 != 1) {

        } else {
            temp_s0->unkDD = 2;
            temp_s0->unk40 = -1.5f;
        }
    } else {
        temp_s0->unkDD = 2;
        temp_s0->unk40 = -1.0f;
    }
    func_800722A4(arg0, 0x80);
    func_80072488(arg0);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80080524.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 f32_step_towards(void *, ?, f32, s32); // extern
? func_80086FD4(s32); // extern
? func_8008701C(s32, ?); // extern
extern ? D_80165C18;

void func_800806BC(s32 arg0) {
    void *sp18;
    s16 temp_v0;
    s32 temp_a3;
    void *temp_v1;

    temp_v1 = (arg0 * 0xE0) + &D_80165C18;
    temp_v0 = temp_v1->unkAE;
    temp_a3 = arg0;
    if (temp_v0 != 0) {
        if (temp_v0 != 1) {
            if (temp_v0 != 2) {
                return;
            }
            sp18 = temp_v1;
            arg0 = temp_a3;
            if (f32_step_towards(temp_v1 + 0x30, 0, temp_v1->unk40, temp_a3) != 0) {
                temp_v1->unk40 = -temp_v1->unk40;
                func_8008701C(arg0, 1);
            }
            // Duplicate return node #8. Try simplifying control flow for better match
            return;
        }
        sp18 = temp_v1;
        arg0 = temp_a3;
        if (f32_step_towards(temp_v1 + 0x30, 0x437A0000, temp_v1->unk40, temp_a3) != 0) {
            temp_v1->unk40 = -temp_v1->unk40;
            func_80086FD4(arg0);
            return;
        }
        // Duplicate return node #8. Try simplifying control flow for better match
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_800806BC.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 f32_step_towards(void *, ?, f32, s32); // extern
? func_80086FD4(s32); // extern
? func_8008701C(s32, ?); // extern
extern ? D_80165C18;

void func_8008078C(s32 arg0) {
    void *sp18;
    s16 temp_v0;
    s32 temp_a3;
    void *temp_v1;

    temp_v1 = (arg0 * 0xE0) + &D_80165C18;
    temp_v0 = temp_v1->unkAE;
    temp_a3 = arg0;
    if (temp_v0 != 0) {
        if (temp_v0 != 1) {
            if (temp_v0 != 2) {
                return;
            }
            sp18 = temp_v1;
            arg0 = temp_a3;
            if (f32_step_towards(temp_v1 + 0x30, 0, temp_v1->unk40, temp_a3) != 0) {
                temp_v1->unk40 = -temp_v1->unk40;
                func_8008701C(arg0, 1);
            }
            // Duplicate return node #8. Try simplifying control flow for better match
            return;
        }
        sp18 = temp_v1;
        arg0 = temp_a3;
        if (f32_step_towards(temp_v1 + 0x30, 0xC37A0000, temp_v1->unk40, temp_a3) != 0) {
            temp_v1->unk40 = -temp_v1->unk40;
            func_80086FD4(arg0);
            return;
        }
        // Duplicate return node #8. Try simplifying control flow for better match
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_8008078C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800806BC(s32); // extern
? func_8008078C(s32); // extern
? func_8008BF18(s32); // extern
extern ? D_80165CF5;

void func_8008085C(s32 arg0) {
    u8 temp_v0;

    temp_v0 = *(&D_80165CF5 + (arg0 * 0xE0));
    if (temp_v0 != 1) {
        if (temp_v0 != 2) {

        } else {
            func_8008078C(arg0);
        }
    } else {
        func_800806BC(arg0);
    }
    func_8008BF18(arg0);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_8008085C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800730BC(s32, ?, ?, ?, s32, s32); // extern
? func_80073514(s32); // extern
? func_8007E63C(s32); // extern
? func_80080524(s32); // extern
? func_8008085C(s32); // extern
? func_800C98B8(void *, void *, ?); // extern
extern ? D_80165C18;
extern s32 D_8018D40C;
extern s16 D_802876D2;

void func_800808CC(s32 arg0) {
    void *sp20;
    s16 temp_v0;
    s16 temp_v1;
    s32 temp_t7;
    void *temp_t0;
    s32 phi_v1;
    void *phi_t0;

    temp_t7 = arg0 * 0xE0;
    temp_t0 = temp_t7 + &D_80165C18;
    temp_v1 = temp_t0->unkA6;
    phi_v1 = temp_v1;
    phi_t0 = temp_t0;
    if (temp_v1 != 0) {
        if (temp_v1 != 1) {
            if (temp_v1 != 2) {

            } else {
                sp20 = temp_t0;
                func_800730BC(arg0, 3, 5, 1, 6, -1);
                goto block_6;
            }
        } else {
            sp20 = temp_t0;
            func_80080524(arg0);
block_6:
            phi_v1 = (temp_t7 + &D_80165C18)->unkA6;
            phi_t0 = temp_t7 + &D_80165C18;
        }
    }
    if (phi_v1 >= 2) {
        sp20 = phi_t0;
        func_8007E63C(arg0);
        func_8008085C(arg0);
        func_80073514(arg0);
        if (D_800DC50C != CREDITS_SEQUENCE) {
            if ((D_8018D40C == 0) && (phi_t0->unkA6 == 2)) {
                func_800C98B8(phi_t0 + 4, phi_t0 + 0x38, 0x19036045);
                return;
            }
            // Duplicate return node #15. Try simplifying control flow for better match
            return;
        }
        temp_v0 = D_802876D2;
        if ((temp_v0 < 0xBF) && ((temp_v0 % 0x58) == 0x1E)) {
            func_800C98B8(phi_t0 + 4, phi_t0 + 0x38, 0x19036045);
        }
        // Duplicate return node #15. Try simplifying control flow for better match
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_800808CC.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 792017ad9d422c2467bd42686f383a5c41f41c75
s32 func_80088A58(?);                               /* extern */

void func_80080A14(s32 arg0, Player *player) {
    if (func_80088A58(0x41400000) != 0) {
        player->boundingBoxCorners[0].unk_14 |= 3;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80080A14.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_8001CA10(s32); // extern
s32 func_80072320(?, Player *); // extern
s32 func_80088A58(s32, Player *, ?, Player *); // extern
? func_800C98B8(void *, void *, ?); // extern
extern ? D_80165C18;

void func_80080A4C(s32 arg0, s32 arg1) {
    s32 sp1C;
    Player *sp18;
    Player *temp_a3;
    void *temp_v0;

    sp1C = (arg1 * 0xB8) + camera1;

    temp_a3 = &gPlayerOne[arg1];
    if (gScreenModeSelection != 3) {
        sp18 = temp_a3;
        if ((func_80072320(0x10, temp_a3) != 0) && (func_80088A58(arg0, temp_a3, 0x43FA0000, temp_a3) != 0)) {
            func_8001CA10(sp1C);
            temp_v0 = (arg0 * 0xE0) + &D_80165C18;
            func_800C98B8(temp_v0 + 4, temp_v0 + 0x38, 0x1900800F);
        }
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80080A4C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80072180(); // extern
? func_800721E8(s16, ?); // extern
s32 func_8007223C(s16, ?); // extern
? func_800722A4(s16, ?); // extern
s32 func_80072320(s16, ?); // extern
s32 func_80072354(s16, ?, ?); // extern
? func_800726CC(s16, ?); // extern
? func_80075304(void *, ?, ?, s32); // extern
? func_80080DE4(s16); // extern
? func_80086F60(s16); // extern
s32 func_80088A58(s16, Player *, f32); // extern
s32 func_80088D18(s16, Player *); // extern
f32 func_80088F54(s16, Player *); // extern
? func_80088FF0(Player *); // extern
? func_80089474(s16, s32, ?, ?, s32); // extern
? func_800C9060(u8, ?, ?); // extern
? func_800C98B8(f32 *, f32 *, ?); // extern
extern f64 D_800EF0B0;
extern ? D_80165C18;
extern s32 D_8018D3C4;

void func_80080B28(s16 arg0, s32 arg1) {
    f32 sp2C;
    Player *temp_s0;
    f32 temp_f0;
    f32 temp_ret;
    u16 temp_v0;
    u16 temp_v0_2;

    temp_s0 = &gPlayerOne[arg1];
    if (func_8007223C(0x200) != 0) {
        if ((temp_s0->unk_00C & 0x100) == 0) {
            temp_ret = func_80088F54(arg0, temp_s0);
            temp_f0 = temp_ret;
            if ((temp_f0 <= 9.0) && ((temp_s0->unk_0BC << 5) >= 0) && (sp2C = temp_f0, (func_80088D18(arg0, temp_s0) != 0))) {
                temp_v0 = temp_s0->unk_000;
                if (((temp_v0 & 0x8000) != 0) && ((temp_v0 & 0x100) == 0)) {
                    if ((temp_s0->unk_0BC & 0x200) == 0) {
                        func_80089474(arg0, arg1, 0x3FB33333, 0x3F8CCCCD, 0x1900A04C);
                        return;
                    }
                    if (func_80072354(arg0, 0x40, 0x3FB30000) != 0) {
                        if ((temp_s0->unk_000 & 0x1000) != 0) {
                            func_800C98B8(&temp_s0->posX, &temp_s0->unk_034, 0x1901A24A);
                        } else {
                            func_800C9060(arg1, 0x1901A24A, 0x19010000);
                        }
                        func_80080DE4(arg0);
                        func_80075304((arg0 * 0xE0) + 4 + &D_80165C18, 3, 3, D_8018D3C4);
                        func_800721E8(arg0, 0x200);
                        func_800722A4(arg0, 0x40);
                        func_80086F60(arg0);
                        func_800726CC(arg0, 0xC8);
                        return;
                    }
                    // Duplicate return node #23. Try simplifying control flow for better match
                    return;
                }
                // Duplicate return node #23. Try simplifying control flow for better match
                return;
            }
            if ((temp_ret <= D_800EF0B0) && (func_80072320(arg0, 1) != 0) && (func_80088A58(arg0, temp_s0, (temp_s0->unk_094 * 0.5) + 7.0) != 0) && (temp_v0_2 = temp_s0->unk_000, ((temp_v0_2 & 0x8000) != 0)) && ((temp_v0_2 & 0x100) == 0)) {
                if (func_8007223C(arg0, 0x4000000) != 0) {
                    func_80072180();
                }
                func_800722A4(arg0, 2);
                temp_s0->unk_040 = arg0;
                temp_s0->unk_046 = temp_s0->unk_046 | 2;
                temp_s0->unk_00C |= 0x100;
                func_80088FF0(temp_s0);
                return;
            }
            // Duplicate return node #23. Try simplifying control flow for better match
            return;
        }
        func_80088FF0(temp_s0);
        // Duplicate return node #23. Try simplifying control flow for better match
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80080B28.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void func_80080DE4(s32 arg0) {
    s32 temp_v1;
    void *temp_v0;
    void *temp_v0_2;
    void *temp_v0_3;
    Player *phi_v0;
    s32 phi_v1;

    phi_v0 = gPlayerOne;
    phi_v1 = 0;
    do {
        temp_v1 = phi_v1 + 4;
        phi_v1 = temp_v1;
        if (arg0 == phi_v0->unk_040) {
            phi_v0->unk_040 = -1;
            phi_v0->unk_00C &= -0x101;
        }
        temp_v0 = phi_v0 + 0xDD8;
        if (arg0 == phi_v0->unkE18) {
            temp_v0->unk40 = -1;
            temp_v0->unkC = temp_v0->unkC & ~0x100;
        }
        temp_v0_2 = temp_v0 + 0xDD8;
        if (arg0 == temp_v0->unkE18) {
            temp_v0_2->unk40 = -1;
            temp_v0_2->unkC = temp_v0_2->unkC & ~0x100;
        }
        temp_v0_3 = temp_v0_2 + 0xDD8;
        if (arg0 == temp_v0_2->unkE18) {
            temp_v0_3->unk40 = -1;
            temp_v0_3->unkC = temp_v0_3->unkC & ~0x100;
        }
        phi_v0 = temp_v0_3 + 0xDD8;
    } while (temp_v1 != 8);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80080DE4.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
f32 func_800416D8(f32, f32, s32, ? *, u16, s32); // extern
f32 func_80041724(f32, f32, s32); // extern
? func_800723A4(s32); // extern
f32 sins(s32); // extern
f32 coss(s32); // extern
extern ? D_800E594C;
extern ? D_800E597C;
extern f64 D_800EF0B8;
extern f64 D_800EF0C0;
extern ? D_80165C18;

void func_80080E8C(s32 arg0, s32 arg1, s32 arg2) {
    f32 sp38;
    void *sp2C;
    s32 sp28;
    void *sp24;
    s32 temp_s1_2;
    s32 temp_t1;
    s32 temp_t7;
    u16 temp_s1;
    void *temp_s0;
    void *temp_v0;
    void *temp_v1;

    func_800723A4(arg2);
    temp_t1 = arg2 * 2;
    temp_v1 = (temp_t1 * 4) + &D_800E594C;
    temp_s0 = &D_80165C18 + (arg0 * 0xE0);
    temp_s0->unkD5 = 2;
    sp24 = temp_v1;
    sp28 = temp_t1;
    temp_v0 = &D_80165C18 + (arg1 * 0xE0);
    temp_s1 = temp_v0->unkC0;
    sp2C = temp_v0;
    sp38 = func_800416D8(temp_v1->unk4, temp_v1->unk0, temp_t1, &D_80165C18, temp_s1, 0xE0);
    temp_s0->unk10 = temp_v0->unk4 + func_80041724(temp_v1->unk4, temp_v1->unk0, temp_s1 & 0xFFFF);
    temp_s0->unk14 = temp_v0->unk44 - 9.0;
    temp_s0->unk18 = temp_v0->unkC + sp38;
    temp_t7 = (*(&D_800E597C + sp28) + temp_v0->unkC0) & 0xFFFF;
    temp_s1_2 = temp_t7;
    temp_s0->unk38 = sins(temp_t7 & 0xFFFF) * D_800EF0B8;
    temp_s0->unk40 = coss(temp_s1_2 & 0xFFFF) * D_800EF0C0;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80080E8C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 func_80072044(? *, ? *, ?); // extern
? func_80080E8C(s32, s32, s32); // extern
extern ? D_80183E4C;
extern ? D_8018C3F0;

void func_80080FEC(s32 arg0) {
    s32 temp_s0;
    s32 temp_v0;
    s32 phi_s0;

    phi_s0 = 0;
loop_1:
    temp_v0 = func_80072044(&D_8018C3F0, &D_80183E4C, 0x80);
    if (temp_v0 != -1) {
        func_80080E8C(temp_v0, arg0, phi_s0);
        temp_s0 = phi_s0 + 1;
        phi_s0 = temp_s0;
        if (temp_s0 != 6) {
            goto loop_1;
        }
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80080FEC.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80072488(); // extern
extern ? D_80165C18;
extern s32 D_8018D490;

void func_80081080(s32 arg0) {
    s32 temp_v1;
    void *temp_v0;

    temp_v1 = D_8018D490;
    temp_v0 = (arg0 * 0xE0) + &D_80165C18;
    temp_v0->unkA0 = 0xFF;
    temp_v0->unkC0 = 0;
    temp_v0->unkB2 = 0;
    temp_v0->unkB6 = 0;
    temp_v0->unk64 = temp_v1;
    temp_v0->unk6C = temp_v1;
    temp_v0->unk28 = 0.0f;
    temp_v0->unk2C = 0.0f;
    temp_v0->unk30 = 0.0f;
    temp_v0->unk0 = 0.25f;
    func_80072488();
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80081080.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? f32_step_up_towards(void *, ?, ?); // extern
? func_80072428(s32); // extern
? func_80072488(s32); // extern
s32 func_80073B00(s32, void *, ?, ?, s32, s32, s32); // extern
? func_8007415C(s32, void *, ?, ?, f32, s32, s32); // extern
? func_80081080(s32); // extern
? func_8008775C(s32); // extern
? func_8008BF18(s32); // extern
extern f32 D_800EF0C8;
extern ? D_80165C18;

void func_800810F4(s32 arg0) {
    void *sp30;
    s16 temp_v0;
    void *temp_v1;

    temp_v1 = (arg0 * 0xE0) + &D_80165C18;
    temp_v0 = temp_v1->unkA6;
    if (temp_v0 != 0) {
        if (temp_v0 != 1) {
            if (temp_v0 != 2) {
                if (temp_v0 != 3) {

                } else {
                    func_80072428(arg0);
                }
            } else {
                sp30 = temp_v1;
                func_8008775C(arg0);
                f32_step_up_towards(sp30 + 0x2C, 0x41600000, 0x3F000000);
                func_8007415C(arg0, sp30, 0x3E800000, 0x3F400000, D_800EF0C8, 1, 0);
                if (func_80073B00(arg0, sp30 + 0xA0, 0xFF, 0, 4, 0, 0) != 0) {
                    func_80072488(arg0);
                }
            }
        } else {
            func_80081080(arg0);
        }
    }
    func_8008BF18(arg0);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_800810F4.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void func_80081208(void) {

}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80081208.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 792017ad9d422c2467bd42686f383a5c41f41c75
? func_80072100(s32 *);                             /* extern */
s32 func_8007223C(s32, ?);                          /* extern */
? func_800722CC(s32, ?);                            /* extern */
s32 func_80072320(s32, ?);                          /* extern */
? func_8007542C(?);                                 /* extern */
? func_8007ED6C(s32);                               /* extern */
? func_8007F5A8(s32);                               /* extern */
? func_8007F8D8();                                  /* extern */
? func_8007FFC0(s32);                               /* extern */
? func_800801FC(s32);                               /* extern */
? func_80080408(s32);                               /* extern */
? func_800808CC(s32);                               /* extern */
? func_80080A14(s32, Player *);                     /* extern */
? func_80080A4C(s32, s32);                          /* extern */
? func_80080B28(s32, s32);                          /* extern */
? func_80080FEC(s32);                               /* extern */
? func_800810F4(s32);                               /* extern */
? func_8008A4CC(s32);                               /* extern */
extern s16 D_80165750;
extern ? D_80165834;
extern ? D_80165C18;
extern s32 D_80183EA0;
extern s32 D_8018C3F0;
extern ? D_8018C5F0;

void func_80081210(void) {
    s16 temp_v0;
    s32 *temp_s2_2;
    s32 temp_s0;
    s32 temp_s0_2;
    s32 temp_s0_3;
    s32 temp_s0_4;
    s32 temp_s0_5;
    s32 temp_s2;
    s32 temp_s4;
    s32 temp_s4_2;
    s32 temp_s4_3;
    s32 temp_s4_4;
    u8 temp_t5;
    void *temp_s1;
    void *temp_s1_2;
    s32 *phi_s2;
    s32 phi_s4;
    s32 *phi_s2_2;
    s32 phi_s4_2;
    s32 phi_v0;
    Player *phi_s3;
    s32 *phi_s1;
    s32 phi_s4_3;
    s32 phi_s2_3;
    s32 *phi_s2_4;
    s32 phi_s4_4;
    s32 *phi_s2_5;

    D_80165834.unk0 = (u16) (D_80165834.unk0 + 0x100);
    D_80165834.unk2 = (u16) (D_80165834.unk2 + 0x200);
    phi_s4 = 0;
    phi_s4_4 = 0;
    phi_s4_3 = 0;
    if ((s32) D_80165750 > 0) {
        phi_s2 = &D_80183EA0;
        do {
            temp_s0 = *phi_s2;
            func_800722CC(temp_s0, 0x10);
            func_8008A4CC(temp_s0);
            temp_s4 = phi_s4 + 1;
            phi_s2 += 4;
            phi_s4 = temp_s4;
        } while (temp_s4 < (s32) D_80165750);
    }
    func_8007F8D8();
    temp_v0 = D_80165750;
    phi_s2_2 = &D_80183EA0;
    phi_s4_2 = 0;
    phi_v0 = (s32) temp_v0;
    phi_s4_3 = 0;
    if ((s32) temp_v0 > 0) {
        do {
            temp_s0_2 = *phi_s2_2;
            temp_s1 = (temp_s0_2 * 0xE0) + &D_80165C18;
            if (temp_s1->unkA6 != 0) {
                temp_t5 = temp_s1->unkD5;
                switch (temp_t5) {
                case 1:
                    func_8007ED6C(temp_s0_2);
block_14:
                    phi_v0 = (s32) D_80165750;
                    break;
                case 2:
                    func_8007F5A8(temp_s0_2);
                    goto block_14;
                case 3:
                    func_8007FFC0(temp_s0_2);
                    goto block_14;
                case 4:
                    func_800801FC(temp_s0_2);
                    goto block_14;
                case 6:
                    func_80080408(temp_s0_2);
                    goto block_14;
                case 5:
                    func_800808CC(temp_s0_2);
                    goto block_14;
                }
            }
            temp_s4_2 = phi_s4_2 + 1;
            phi_s2_2 += 4;
            phi_s4_2 = temp_s4_2;
        } while (temp_s4_2 < phi_v0);
    }
    phi_s3 = gPlayerOne;
    do {
        phi_s3->boundingBoxCorners[0].unk_14 &= -4;
        phi_s3->unk_046 &= 0xFFF9;
        phi_s1 = &D_80183EA0;
        phi_s2_3 = 0;
        if ((s32) D_80165750 > 0) {
            do {
                temp_s0_3 = *phi_s1;
                if ((phi_s3->unk_0BC & 0x80000000) == 0) {
                    func_80080B28(temp_s0_3, phi_s4_3);
                }
                if (func_8007223C(temp_s0_3, 0x20000) != 0) {
                    func_80080A14(temp_s0_3, phi_s3);
                }
                if (func_8007223C(temp_s0_3, 0x10000) != 0) {
                    func_80080A4C(temp_s0_3, phi_s4_3);
                }
                temp_s2 = phi_s2_3 + 1;
                phi_s1 += 4;
                phi_s2_3 = temp_s2;
            } while (temp_s2 < (s32) D_80165750);
        }
        temp_s4_3 = phi_s4_3 + 1;
        phi_s3 += 0xDD8;
        phi_s4_3 = temp_s4_3;
    } while (temp_s4_3 < 8);
    func_8007542C(3);
    if ((s32) D_80165750 > 0) {
        phi_s2_4 = &D_80183EA0;
        do {
            temp_s0_4 = *phi_s2_4;
            if (func_80072320(temp_s0_4, 0x20) != 0) {
                func_800722CC(temp_s0_4, 0x20);
                func_80080FEC(temp_s0_4);
            }
            temp_s4_4 = phi_s4_4 + 1;
            phi_s2_4 += 4;
            phi_s4_4 = temp_s4_4;
        } while (temp_s4_4 < (s32) D_80165750);
    }
    phi_s2_5 = &D_8018C3F0;
    do {
        temp_s0_5 = *phi_s2_5;
        if (temp_s0_5 != -1) {
            temp_s1_2 = (temp_s0_5 * 0xE0) + &D_80165C18;
            if (temp_s1_2->unkA6 != 0) {
                func_800810F4(temp_s0_5);
                if (temp_s1_2->unkA6 == 0) {
                    func_80072100(phi_s2_5);
                }
            }
        }
        temp_s2_2 = phi_s2_5 + 4;
        phi_s2_5 = temp_s2_2;
    } while (temp_s2_2 != &D_8018C5F0);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80081210.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800723A4(s32, ?); // extern
extern ? D_06013670;
extern f32 D_800EF0E4;
extern f64 D_800EF0E8;
extern f64 D_800EF0F0;
extern f64 D_800EF0F8;
extern f64 D_800EF100;
extern ? D_80165C18;
extern s32 D_8018C3F0;

void func_8008153C(s32 arg0) {
    s32 sp70;
    f32 temp_f30;
    f32 temp_f6;
    f64 temp_f20;
    f64 temp_f22;
    f64 temp_f24;
    f64 temp_f26;
    f64 temp_f4;
    s32 temp_a0;
    s32 temp_s1;
    s32 temp_s7;
    s32 temp_v0;
    void *temp_s0;
    void *temp_s5;
    s32 *phi_v0;
    f32 phi_f6;
    s32 phi_s1;
    s32 phi_s7;

    if (gPlayerCountSelection1 == 1) {
        sp70 = 8;
    } else {
        sp70 = 4;
    }
    phi_s7 = 0;
    if (sp70 > 0) {
        temp_f30 = D_800EF0E4;
        temp_f26 = D_800EF0E8;
        temp_f24 = D_800EF0F0;
        temp_f22 = D_800EF0F8;
        temp_f20 = D_800EF100;
        do {
            phi_v0 = &D_8018C3F0;
            phi_s1 = 0;
loop_6:
            temp_a0 = *phi_v0;
            temp_s0 = &D_80165C18 + (temp_a0 * 0xE0);
            if (temp_s0->unkA6 == 0) {
                temp_s5 = &D_80165C18 + (arg0 * 0xE0);
                func_800723A4(temp_a0, 0);
                temp_s0->unk60 = &D_06013670;
                temp_s0->unk68 = &D_06013670;
                temp_s0->unk0 = temp_f30;
                temp_v0 = random_int(0xA);
                temp_f6 = temp_v0;
                phi_f6 = temp_f6;
                if (temp_v0 < 0) {
                    phi_f6 = temp_f6 + 4294967296.0f;
                }
                temp_s0->unk3C = (phi_f6 * temp_f20) + temp_f22;
                temp_f4 = (random_int(5) * temp_f24) + temp_f26;
                temp_s0->unkB4 = (0x10000 / sp70) * phi_s1;
                temp_s0->unk34 = temp_f4;
                temp_s0->unk10 = temp_s5->unk10;
                temp_s0->unk14 = temp_s5->unk14 - 13.0;
                temp_s0->unk18 = temp_s5->unk18;
            } else {
                temp_s1 = phi_s1 + 1;
                phi_v0 += 4;
                phi_s1 = temp_s1;
                if (temp_s1 != 0x80) {
                    goto loop_6;
                }
            }
            temp_s7 = phi_s7 + 1;
            phi_s7 = temp_s7;
        } while (temp_s7 != sp70);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_8008153C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80072428(s32); // extern
? func_80072488(s32); // extern
? func_80086F60(s32); // extern
s32 func_80087E08(s32, s32, ?, s32, s32, s32); // extern
? func_8008BF18(s32); // extern
extern ? D_80165C18;

void func_80081790(s32 arg0) {
    s16 temp_v1;
    void *temp_v0;

    temp_v0 = (arg0 * 0xE0) + &D_80165C18;
    temp_v1 = temp_v0->unkA6;
    if (temp_v1 != 0) {
        if (temp_v1 != 1) {
            if (temp_v1 != 2) {
                return;
            }
            func_80072428(arg0);
            func_80086F60(arg0);
            // Duplicate return node #8. Try simplifying control flow for better match
            return;
        }
        if (func_80087E08(arg0, temp_v0->unk3C, 0x3E99999A, temp_v0->unk34, temp_v0->unkB4, 0x32) != 0) {
            func_80072488(arg0);
        }
        func_8008BF18(arg0);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80081790.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800721C0(s32, ?); // extern
? func_80072488(s32); // extern
? func_80073444(? *, ? *, ?, s32); // extern
? func_8008B80C(s32, ?, ?, ?); // extern
? func_8008B888(s32, ?, ?, ?); // extern
? func_8008B8BC(s32, ?, ?, ?); // extern
extern ? D_0600FC70;
extern ? D_0600FE70;
extern f32 D_800EF108;
extern ? D_80165C18;

void func_80081848(s32 arg0) {
    void *sp2C;
    void *temp_v0;

    func_80073444(&D_0600FC70, &D_0600FE70, 0x20, 0x40);
    temp_v0 = (arg0 * 0xE0) + &D_80165C18;
    temp_v0->unkD2 = 0;
    sp2C = temp_v0;
    temp_v0->unk0 = D_800EF108;
    func_8008B80C(arg0, 0, 0, 0);
    func_8008B888(arg0, 0, 0, 0);
    func_8008B8BC(arg0, 0, 0, 0x8000);
    temp_v0->unkC8 = 6;
    temp_v0->unk3C = 4.0f;
    func_800721C0(arg0, 0x4000000);
    func_80072488(arg0);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80081848.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
s32 f32_step_up_towards(void *, ?, ?);                    /* extern */
s32 f32_step_down_towards(void *, ?, ?);                    /* extern */
? func_80086F60(s32);                               /* extern */
? func_80086FD4(s32);                               /* extern */
? func_800871AC(s32, ?);                            /* extern */
? func_8008751C(s32);                               /* extern */
? func_80087710(s32);                               /* extern */
? func_80087D24(s32, ?, ?, ?);                      /* extern */
extern ? D_80165C18;

void func_80081924(s32 arg0) {
    void *sp24;
    u16 temp_t8;
    void *temp_v0;

    temp_v0 = (arg0 * 0xE0) + &D_80165C18;
    temp_t8 = temp_v0->unkAE;
    switch (temp_t8) {
    case 1:
        if (f32_step_up_towards(temp_v0 + 0x2C, 0x41100000, 0x3F333333) != 0) {
            func_80086FD4(arg0);
            return;
        }
    default:
        return;
    case 2:
        func_800871AC(arg0, 0xA);
        return;
    case 3:
        if (f32_step_down_towards(temp_v0 + 0x2C, 0x40400000, 0x3F800000) != 0) {
            func_80086F60(arg0);
            return;
        }
        /* Duplicate return node #11. Try simplifying control flow for better match */
        return;
    case 4:
        func_80087D24(arg0, 0x40666666, 0x3E800000, 0);
        return;
    case 5:
        func_80086F60(arg0);
        return;
    case 10:
        temp_v0->unkB6 = temp_v0->unkB6 + 0x1000;
        sp24 = temp_v0;
        temp_v0->unk3C = temp_v0->unk3C - 0.184;
        func_8008751C(arg0);
        func_80087710(arg0);
        if (temp_v0->unk8 <= -10.0) {
            func_80086F60(arg0);
        }
        /* Duplicate return node #11. Try simplifying control flow for better match */
        return;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80081924.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80081924(s32); // extern
? func_8008B724(s32); // extern
? func_8008BF18(s32); // extern
extern ? D_80165CF5;

void func_80081A88(s32 arg0) {
    u8 temp_v0;

    temp_v0 = *(&D_80165CF5 + (arg0 * 0xE0));
    if (temp_v0 != 0) {
        if (temp_v0 != 1) {
            if (temp_v0 != 2) {

            } else {
                func_80081924(arg0);
            }
        } else {
            func_8008B724(arg0);
        }
    }
    func_8008BF18(arg0);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80081A88.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
? func_800721C0(s32, ?);                            /* extern */
? func_800721E8(s32, ?, s32);                       /* extern */
? func_80072428(s32);                               /* extern */
? func_80072488(s32);                               /* extern */
? func_800726CC(s32, ?);                            /* extern */
s32 func_80072E54(s32, ?, ?, ?, s32, s32);          /* extern */
? func_80073514(s32);                               /* extern */
? func_8008153C(s32);                               /* extern */
? func_80081848(s32, s32);                          /* extern */
? func_80086EAC(s32, ?, ?);                         /* extern */
? func_800C98B8(void *, void *, ?);                 /* extern */
extern ? D_80165C18;
extern s8 D_8018D198;
extern s8 D_8018D1A8;
extern s8 D_8018D1B8;

void func_80081AFC(s32 arg0, s32 arg1) {
    s8 *sp2C;
    s16 temp_v1;
    s32 temp_a2;
    s32 temp_v0;
    void *temp_s0;

    temp_s0 = (arg0 * 0xE0) + &D_80165C18;
    temp_v1 = temp_s0->unkA6;
    temp_a2 = arg1;
    if (temp_v1 >= 0xB) {
        if (temp_v1 != 0x64) {

        } else if (temp_s0->unkAE == 0) {
            arg1 = temp_a2;
            func_800721E8(arg0, 0x200, temp_a2);
            func_80072428(arg0);
            if (arg1 != 1) {
                if (arg1 != 2) {
                    if (arg1 != 3) {

                    } else {
                        sp2C = &D_8018D1B8;
                    }
                } else {
                    sp2C = &D_8018D1A8;
                }
            } else {
                sp2C = &D_8018D198;
            }
            sp2C[temp_s0->unkA4] = 0;
            goto block_27;
        }
    } else {
        switch (temp_v1) {
        case 1:
            func_80081848(arg0, temp_a2);
block_27:
            break;
        case 2:
            temp_v0 = temp_s0->unk4C;
            if (temp_v0 == 0) {
                func_80086EAC(arg0, 2, 1);
                func_80072488(arg0);
                func_800721C0(arg0, 0x200);
            } else {
                temp_s0->unk4C = temp_v0 - 1;
            }
            goto block_27;
        case 3:
            if (temp_s0->unkAE == 0) {
                func_80086EAC(arg0, 2, 4);
                func_8008153C(arg0);
                func_80072488(arg0);
                func_800C98B8(temp_s0 + 4, temp_s0 + 0x38, 0x19018007);
                goto block_27;
            }
            break;
        case 4:
            if (func_80072E54(arg0, 1, 6, 1, 2, 0) != 0) {
                func_800726CC(arg0, 0x64);
            }
            goto block_27;
        case 10:
            func_80072E54(arg0, 1, 6, 1, 0, -1);
            if (temp_s0->unkAE == 0) {
                func_800726CC(arg0, 0x64);
            }
            goto block_27;
        }
    }
    if (temp_s0->unkA6 >= 2) {
        func_80073514(arg0);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80081AFC.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80072180(); // extern
? func_800721E8(s32, ?); // extern
s32 func_8007223C(s32, ?); // extern
? func_800726CC(s32, ?); // extern
? func_80086EAC(s32, ?, ?); // extern
? func_80086F60(s32); // extern
s32 func_80088DA4(s32, Player *); // extern
? func_8008B7D4(s32, s32, s32, s32); // extern
? func_8008B80C(s32, ?, ?, ?); // extern
? func_800C9060(s32, ?); // extern
extern ? D_80165C18;
extern s32 D_8018D158;

void func_80081D34(s32 arg0) {
    s32 temp_s2;
    u16 temp_v0;
    void *temp_s0;
    void *temp_s0_2;
    Player *phi_s1;
    s32 phi_s2;
    void *phi_s4;
    s32 phi_s5;
    s32 phi_s5_2;

    phi_s1 = gPlayerOne;
    phi_s2 = 0;
    phi_s4 = camera1;
    phi_s5 = 0;
    phi_s5_2 = 0;
    if (D_8018D158 > 0) {
        do {
            if ((func_8007223C(arg0, 0x200) != 0) && ((phi_s1->unk_0BC & 0x80000000) == 0) && (func_80088DA4(arg0, phi_s1) != 0)) {
                temp_v0 = phi_s1->unk_000;
                if (((temp_v0 & 0x8000) != 0) && ((temp_v0 & 0x100) == 0)) {
                    temp_s0 = (arg0 * 0xE0) + &D_80165C18;
                    phi_s5_2 = 1;
                    if (func_8007223C(arg0, 0x4000000) != 0) {
                        func_80072180();
                    }
                    if ((phi_s1->unk_0BC & 0x200) != 0) {
                        func_800C9060(phi_s2 & 0xFF, 0x1900A046);
                    } else {
                        phi_s1->unk_00C |= 2;
                    }
                    temp_s0->unkC0 = phi_s4->unk26;
                    temp_s0->unk3C = (phi_s1->unk_094 / 2.0f) + 3.0;
                    temp_s0->unk34 = phi_s1->unk_094 + 1.0;
                    if (temp_s0->unk3C >= 5.0) {
                        temp_s0->unk3C = 5.0f;
                    }
                    if (temp_s0->unk34 >= 4.0) {
                        temp_s0->unk3C = 4.0f;
                    }
                }
            }
            temp_s2 = phi_s2 + 1;
            phi_s1 += 0xDD8;
            phi_s2 = temp_s2;
            phi_s4 += 0xB8;
            phi_s5 = phi_s5_2;
        } while (temp_s2 < D_8018D158);
    }
    if (phi_s5 != 0) {
        temp_s0_2 = (arg0 * 0xE0) + &D_80165C18;
        func_800721E8(arg0, 0x200);
        func_80086F60(arg0);
        func_8008B7D4(arg0, temp_s0_2->unk4, temp_s0_2->unk8, temp_s0_2->unkC);
        func_8008B80C(arg0, 0, 0, 0);
        func_80086EAC(arg0, 2, 0xA);
        func_800726CC(arg0, 0xA);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80081D34.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800723A4(?); // extern
extern ? D_800E6360;
extern ? D_80165C18;
extern f32 D_8018D01C;
extern ? D_8018D198;
extern ? D_8018D1A8;
extern ? D_8018D1B8;

void func_80081FF4(s32 arg0, s32 arg1) {
    s32 sp2C;
    s16 sp28;
    ? *sp20;
    void *sp18;
    s16 temp_v0;
    s16 temp_v1;
    s32 temp_a0;
    s8 *temp_v0_2;
    void *temp_a3;
    void *temp_v0_3;
    ? *phi_a2;
    s16 phi_v1;
    s32 phi_a0;
    s16 phi_v1_2;
    s16 phi_v1_3;

    func_800723A4(0);
    temp_a3 = (arg0 * 0xE0) + &D_80165C18;
    temp_a3->unk4C = random_int(0x1E) + 5;
    if (arg1 != 1) {
        if (arg1 != 2) {
            if (arg1 != 3) {

            } else {
                sp28 = 0x39;
                sp2C = 0xC;
                phi_a2 = &D_8018D1B8;
                goto block_7;
            }
        } else {
            sp28 = 0x18;
            sp2C = 0xB;
            phi_a2 = &D_8018D1A8;
            goto block_7;
        }
    } else {
        sp28 = 0;
        sp2C = 8;
        phi_a2 = &D_8018D198;
block_7:
        sp20 = phi_a2;
    }
    sp18 = temp_a3;
    temp_v0 = random_int(sp2C & 0xFFFF);
    phi_v1 = temp_v0;
    phi_a0 = 0;
    phi_v1_2 = temp_v0;
    if (sp2C > 0) {
loop_9:
        temp_v0_2 = phi_v1 + sp20;
        temp_a0 = phi_a0 + 1;
        phi_a0 = temp_a0;
        phi_v1_2 = phi_v1;
        if (*temp_v0_2 != 0) {
            temp_v1 = phi_v1 + 1;
            phi_v1_3 = temp_v1;
            if (temp_v1 == sp2C) {
                phi_v1_3 = 0;
            }
            phi_v1 = phi_v1_3;
            phi_v1_2 = phi_v1_3;
            if (temp_a0 != sp2C) {
                goto loop_9;
            }
        } else {
            *temp_v0_2 = 1;
            temp_a3->unkA4 = phi_v1;
        }
    }
    temp_v0_3 = (sp28 * 2) + (phi_v1_2 * 6) + &D_800E6360;
    temp_a3->unk10 = temp_v0_3->unk0 * D_8018D01C;
    temp_a3->unk14 = temp_v0_3->unk2 - 9.0;
    temp_a3->unk18 = temp_v0_3->unk4;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80081FF4.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80081A88(s32); // extern
? func_80081AFC(); // extern
? func_80081D34(s32); // extern
extern ? D_80165CBE;

void func_800821AC(s32 arg0) {
    if (*(&D_80165CBE + (arg0 * 0xE0)) != 0) {
        func_80081AFC();
        func_80081A88(arg0);
        func_80081D34(arg0);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_800821AC.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80081790(s32); // extern
? func_80081FF4(s32, ?); // extern
? func_800821AC(s32, ?); // extern
s32 func_8008A8B0(?, ?); // extern
extern ? D_80165C18;
extern s32 D_80183EA0;
extern s32 D_80183F28;
extern s32 D_8018BFA8;
extern s32 D_8018C3F0;
extern ? D_8018C5F0;
extern s32 D_8018D1C8;
extern s32 D_8018D1D0;
extern s32 D_8018D1D8;

void func_800821FC(void) {
    s32 *sp30;
    s32 *temp_v0;
    s32 temp_s0;
    s32 temp_s0_2;
    s32 temp_s0_3;
    s32 temp_s0_4;
    s32 temp_s1;
    s32 temp_s1_2;
    s32 temp_s1_3;
    s32 *phi_s2;
    s32 phi_s1;
    s32 *phi_s2_2;
    s32 phi_s1_2;
    s32 *phi_s2_3;
    s32 phi_s1_3;
    s32 *phi_v0;

    phi_s1 = 0;
    phi_s1_3 = 0;
    if (D_8018D1C8 > 0) {
        phi_s2 = &D_80183EA0;
        do {
            temp_s0 = *phi_s2;
            if ((&D_80165C18 + (temp_s0 * 0xE0))->unkA6 == 0) {
                if (func_8008A8B0(8, 9) != 0) {
                    func_80081FF4(temp_s0, 1);
                }
            } else {
                func_800821AC(temp_s0, 1);
            }
            temp_s1 = phi_s1 + 1;
            phi_s2 += 4;
            phi_s1 = temp_s1;
        } while (temp_s1 < D_8018D1C8);
    }
    phi_s1_2 = 0;
    phi_s1_3 = 0;
    if (D_8018D1D0 > 0) {
        phi_s2_2 = &D_80183F28;
        do {
            temp_s0_2 = *phi_s2_2;
            if ((&D_80165C18 + (temp_s0_2 * 0xE0))->unkA6 == 0) {
                if (func_8008A8B0(0x10, 0x13) != 0) {
                    func_80081FF4(temp_s0_2, 2);
                }
            } else {
                func_800821AC(temp_s0_2, 2);
            }
            temp_s1_2 = phi_s1_2 + 1;
            phi_s2_2 += 4;
            phi_s1_2 = temp_s1_2;
        } while (temp_s1_2 < D_8018D1D0);
    }
    phi_s2_3 = &D_8018BFA8;
    if (D_8018D1D8 > 0) {
        do {
            temp_s0_3 = *phi_s2_3;
            if ((&D_80165C18 + (temp_s0_3 * 0xE0))->unkA6 == 0) {
                if (func_8008A8B0(0x11, 0x14) != 0) {
                    func_80081FF4(temp_s0_3, 3);
                }
            } else {
                func_800821AC(temp_s0_3, 3);
            }
            temp_s1_3 = phi_s1_3 + 1;
            phi_s2_3 += 4;
            phi_s1_3 = temp_s1_3;
        } while (temp_s1_3 < D_8018D1D8);
    }
    phi_v0 = &D_8018C3F0;
    do {
        temp_s0_4 = *phi_v0;
        if ((&D_80165C18 + (temp_s0_4 * 0xE0))->unkA6 != 0) {
            sp30 = phi_v0;
            func_80081790(temp_s0_4);
        }
        temp_v0 = phi_v0 + 4;
        phi_v0 = temp_v0;
    } while (temp_v0 != &D_8018C5F0);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_800821FC.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800721C0(s32, ?); // extern
? func_80072488(s32); // extern
? func_80086EF0(s32); // extern
? func_8008B7D4(s32, f32, f32, f32); // extern
? func_8008B888(s32, ?, ?, ?); // extern
extern ? D_060169B0;
extern ? D_06016B60;
extern ? D_800E633C;
extern f32 D_800EF16C;
extern f64 D_800EF170;
extern f64 D_800EF178;
extern f64 D_800EF180;
extern f64 D_800EF188;
extern f64 D_800EF190;
extern f64 D_800EF198;
extern ? D_80165C18;
extern f32 D_8018D01C;

void func_8008241C(s32 arg0, s32 arg1) {
    s16 sp22;
    s16 sp20;
    f64 temp_f10;
    f64 temp_f8;
    s32 temp_f4;
    s32 temp_v0;
    s32 temp_v0_2;
    void *temp_s0;
    f64 phi_f8;
    f64 phi_f10;

    temp_s0 = (arg0 * 0xE0) + &D_80165C18;
    temp_s0->unkD8 = 1;
    temp_s0->unk70 = &D_060169B0;
    temp_s0->unk74 = &D_06016B60;
    temp_s0->unkDD = 1;
    temp_s0->unk0 = D_800EF16C;
    temp_v0 = random_int(0xC8);
    temp_f8 = temp_v0;
    phi_f8 = temp_f8;
    if (temp_v0 < 0) {
        phi_f8 = temp_f8 + 4294967296.0;
    }
    sp22 = phi_f8 + -100.0;
    sp20 = random_int(0x14);
    temp_v0_2 = random_int(0xC8);
    temp_f10 = temp_v0_2;
    phi_f10 = temp_f10;
    if (temp_v0_2 < 0) {
        phi_f10 = temp_f10 + 4294967296.0;
    }
    temp_f4 = phi_f10 + -100.0;
    if (D_800DC50C == CREDITS_SEQUENCE) {
        func_8008B7D4(arg0, sp22 + D_800EF170, sp20 + 60.0, temp_f4 + D_800EF178);
    } else if (temp_s0->unkD5 != 0) {
        func_8008B7D4(arg0, (sp22 + D_800EF180) * D_8018D01C, sp20 + 20.0, temp_f4 + D_800EF188);
    } else {
        func_8008B7D4(arg0, (sp22 + D_800EF190) * D_8018D01C, sp20 + 15.0, temp_f4 + D_800EF198);
    }
    func_8008B888(arg0, 0, 0, 0);
    temp_s0->unk34 = 1.0f;
    func_80086EF0(arg0);
    temp_s0->unk80 = *(&D_800E633C + ((arg1 % 4) * 4));
    func_800721C0(arg0, 0x800);
    func_80072488(arg0);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_8008241C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_8008241C(); // extern
extern ? D_80165CBE;

void func_80082714(s32 arg0) {
    s16 temp_v0;

    temp_v0 = *(&D_80165CBE + (arg0 * 0xE0));
    if ((temp_v0 != 0) && (temp_v0 == 1)) {
        func_8008241C();
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80082714.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_8000D940(void *, void *, s32, ?, s32); // extern
? func_80040EC4(void *, void *); // extern
? func_800873F4(s32); // extern
? func_8008B78C(s32); // extern
? func_8008BF18(s32); // extern
s16 func_802B5224(void *, void *); // extern
extern ? D_80165C18;

void func_8008275C(s32 arg0) {
    void *sp30;
    void *sp2C;
    u8 temp_v0;
    void *temp_a0;
    void *temp_a1;
    void *temp_s0;

    temp_s0 = (arg0 * 0xE0) + &D_80165C18;
    temp_v0 = temp_s0->unkDD;
    if (temp_v0 != 1) {
        if (temp_v0 != 2) {

        } else {
            func_8008B78C(arg0);
            temp_a0 = temp_s0 + 0x1C;
            temp_a1 = temp_s0 + 4;
            sp2C = temp_a1;
            sp30 = temp_a0;
            func_80040EC4(temp_a0, temp_a1);
            func_8000D940(temp_s0 + 0x10, temp_s0 + 0xC6, temp_s0->unk34, 0, 0);
            temp_s0->unk28 = 2.0 * temp_s0->unk28;
            temp_s0->unk2C = temp_s0->unk2C * 2.5;
            temp_s0->unk30 = 2.0 * temp_s0->unk30;
            func_8008BF18(arg0);
            temp_s0->unkC0 = func_802B5224(temp_a0, temp_a1);
        }
    } else {
        func_8008B78C(arg0);
        func_8008BF18(arg0);
    }
    func_800873F4(arg0);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_8008275C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800722CC(s32, ?); // extern
s32 func_80072320(s32, ?); // extern
? func_80082714(s32, s32); // extern
? func_8008275C(s32); // extern
? func_800C98B8(void *, ? *, ?); // extern
extern s16 D_80165900;
extern s8 D_80165908;
extern s8 D_80165A90;
extern ? D_80165C18;
extern ? D_80183E40;
extern s32 D_80183F28;
extern s32 D_80183F2C;
extern s16 D_802876D2;

void func_80082870(void) {
    s16 temp_v0;
    s32 temp_s0;
    s32 temp_s3;
    void *temp_s1;
    s32 *phi_s4;
    s32 phi_s3;

    phi_s4 = &D_80183F28;
    phi_s3 = 0;
    do {
        temp_s0 = *phi_s4;
        temp_s1 = &D_80165C18 + (temp_s0 * 0xE0);
        if (temp_s1->unkA6 != 0) {
            func_80082714(temp_s0, phi_s3);
            func_8008275C(temp_s0);
            if (func_80072320(temp_s0, 2) != 0) {
                func_800722CC(temp_s0, 2);
                if (D_80165A90 != 0) {
                    D_80165A90 = 0;
                    D_80183E40.unk0 = 0.0f;
                    D_80183E40.unk4 = 0.0f;
                    D_80183E40.unk8 = 0.0f;
                    if (D_800DC50C != CREDITS_SEQUENCE) {
                        func_800C98B8(temp_s1 + 4, &D_80183E40, 0x19017043);
                    } else if (D_802876D2 < 0x97) {
                        func_800C98B8(&D_80165C18 + (D_80183F2C * 0xE0) + 4, &D_80183E40, 0x19017043);
                    }
                }
            }
        }
        temp_s3 = phi_s3 + 1;
        phi_s4 += 4;
        phi_s3 = temp_s3;
    } while (temp_s3 != 0xA);
    temp_v0 = D_80165900;
    if (temp_v0 != 0) {
        D_80165900 = temp_v0 - 1;
    } else {
        if (D_800DC50C != CREDITS_SEQUENCE) {
            D_80165900 = 0x3C;
        } else {
            D_80165900 = 0xF;
        }
        if ((D_80165908 != 0) && (D_80165A90 == 0)) {
            D_80165A90 = 1;
        }
    }
    D_80165908 = 0;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80082870.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800721C0(s32, ?); // extern
? func_80072488(s32); // extern
? func_80073444(? *, ? *, ?, s32); // extern
? func_80086EAC(s32, ?, ?); // extern
? func_8008B80C(s32, ?, ?, ?); // extern
? func_8008B8BC(s32, ?, ?, ?); // extern
extern ? D_0600D628;
extern ? D_0600D828;
extern f32 D_800EF1A0;
extern ? D_80165C18;

void func_80082A4C(s32 arg0) {
    void *temp_s1;

    func_80073444(&D_0600D628, &D_0600D828, 0x40, 0x40);
    temp_s1 = (arg0 * 0xE0) + &D_80165C18;
    temp_s1->unkD2 = 0;
    temp_s1->unk0 = D_800EF1A0;
    func_80072488(arg0);
    temp_s1->unkC8 = 1;
    func_800721C0(arg0, 0x4000420);
    func_80086EAC(arg0, 0, 1);
    func_8008B80C(arg0, 0, 0, 0);
    func_8008B8BC(arg0, 0, 0, 0x8000);
    temp_s1->unk34 = 1.5f;
    func_800721C0(arg0, 0x200);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80082A4C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80072E54(s32, ?, ?, ?, s32, s32); // extern
? func_80073514(s32); // extern
? func_80082A4C(s32); // extern
extern ? D_80165C18;

void func_80082B34(s32 arg0, ? arg1) {
    void *sp28;
    s16 temp_v1;
    s32 temp_t6;
    void *temp_t0;
    s32 phi_v1;

    temp_t6 = arg0 * 0xE0;
    temp_t0 = temp_t6 + &D_80165C18;
    temp_v1 = temp_t0->unkA6;
    phi_v1 = temp_v1;
    if (temp_v1 != 0) {
        if (temp_v1 != 1) {
            if (temp_v1 != 2) {
                if (temp_v1 != 3) {

                } else {
                    sp28 = temp_t0;
                    func_80072E54(arg0, 4, 6, 1, 2, -1);
                    goto block_8;
                }
            } else {
                sp28 = temp_t0;
                func_80072E54(arg0, 0, 3, 1, 2, -1);
                goto block_8;
            }
        } else {
            sp28 = temp_t0;
            func_80082A4C(arg0);
block_8:
            phi_v1 = (temp_t6 + &D_80165C18)->unkA6;
        }
    }
    if (phi_v1 >= 2) {
        func_80073514(arg0);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80082B34.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
s32 func_8007223C(s32, ?);                          /* extern */
? func_800726CC(s32, ?);                            /* extern */
? func_80086FD4(s32);                               /* extern */
? func_8008701C(s32, ?);                            /* extern */
s32 func_80087104(s32, ?);                          /* extern */
s32 func_8008789C(s32, ?);                          /* extern */
s32 func_80087954(s32, ?);                          /* extern */
? func_80088538(s32);                               /* extern */
? func_8008BF18(s32);                               /* extern */
extern ? D_80165C18;

void func_80082C30(s32 arg0) {
    void *sp2C;
    s16 temp_t9;
    void *temp_t8;

    temp_t8 = (arg0 * 0xE0) + &D_80165C18;
    sp2C = temp_t8;
    temp_t9 = temp_t8->unkAE;
    switch (temp_t9) {
    case 1:
        if (func_80087A0C(arg0, sp2C->unk10, sp2C->unk1C, sp2C->unk18, sp2C->unk24) != 0) {
            func_800726CC(arg0, 3);
            func_80086FD4(arg0);
        }
        break;
    case 2:
        if (func_80087104(arg0, 0x3C) != 0) {
            sp2C->unk34 = 0.8f;
            func_800726CC(arg0, 2);
            func_80086FD4(arg0);
        }
        break;
    case 3:
        if (func_80087954(arg0, 0x3C) != 0) {
            func_80086FD4(arg0);
            func_800726CC(arg0, 3);
        }
        break;
    case 4:
        if (func_80087104(arg0, 0x3C) != 0) {
            func_800726CC(arg0, 2);
            func_80086FD4(arg0);
        }
        break;
    case 5:
        if (func_8008789C(arg0, 0x3C) != 0) {
            func_800726CC(arg0, 3);
            func_8008701C(arg0, 2);
        }
        break;
    }
    func_8008BF18(arg0);
    if (func_8007223C(arg0, 0x40000) != 0) {
        func_80088538(arg0);
        sp2C->unk8 = sp2C->unk44 + 2.5;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80082C30.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80089F24(); // extern
extern ? D_80165CBE;

void func_80082E18(s32 arg0) {
    if (*(&D_80165CBE + (arg0 * 0xE0)) >= 2) {
        func_80089F24();
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80082E18.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80082B34(s32, s32); // extern
? func_80082C30(s32); // extern
? func_80082E18(s32); // extern
? func_8008A6DC(s32, ?); // extern
extern ? D_80165C18;
extern s32 D_80183EA0;

void func_80082E5C(void) {
    s32 temp_s0;
    s32 temp_s1;
    s32 *phi_s2;
    s32 phi_s1;

    phi_s2 = &D_80183EA0;
    phi_s1 = 0;
    do {
        temp_s0 = *phi_s2;
        if ((&D_80165C18 + (temp_s0 * 0xE0))->unkA6 != 0) {
            func_80082B34(temp_s0, phi_s1);
            func_8008A6DC(temp_s0, 0x43FA0000);
            func_80082C30(temp_s0);
            func_80082E18(temp_s0);
        }
        temp_s1 = phi_s1 + 1;
        phi_s2 += 4;
        phi_s1 = temp_s1;
    } while (temp_s1 != 0xA);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80082E5C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80072488(); // extern
? func_8008B7D4(s32, f32, f32, f32); // extern
? func_8008B80C(s32, ?, ?, ?); // extern
? func_8008B888(s32, ?, u16, ?); // extern
extern ? D_06014794;
extern ? D_06014798;
extern ? D_800E5DF4;
extern f32 D_800EF1BC;
extern ? D_80165C18;
extern f32 D_8018D01C;

void func_80082F1C(s32 arg0, s32 arg1) {
    void *sp24;
    void *temp_v0;
    void *temp_v0_2;

    temp_v0 = (arg0 * 0xE0) + &D_80165C18;
    temp_v0->unk70 = &D_06014798;
    temp_v0->unk74 = &D_06014794;
    temp_v0->unk0 = D_800EF1BC;
    func_80072488();
    temp_v0_2 = (arg1 * 8) + &D_800E5DF4;
    sp24 = temp_v0_2;
    func_8008B7D4(arg0, temp_v0_2->unk0 * D_8018D01C, temp_v0_2->unk2, temp_v0_2->unk4);
    func_8008B80C(arg0, 0, 0, 0);
    func_8008B888(arg0, 0, temp_v0_2->unk6, 0);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80082F1C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80082F1C(); // extern
extern ? D_80165CBE;

void func_80083018(s32 arg0) {
    s16 temp_v0;

    temp_v0 = *(&D_80165CBE + (arg0 * 0xE0));
    if ((temp_v0 != 0) && (temp_v0 == 1)) {
        func_80082F1C();
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80083018.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_8008BF18(); // extern

void func_80083060(void) {
    func_8008BF18();
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80083060.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80083018(s32, s32); // extern
? func_80083060(s32); // extern
extern ? D_80165C18;
extern s32 D_80183EA0;

void func_80083080(void) {
    s32 temp_s0;
    s32 temp_s1;
    s32 *phi_s2;
    s32 phi_s1;

    phi_s2 = &D_80183EA0;
    phi_s1 = 0;
    do {
        temp_s0 = *phi_s2;
        if ((&D_80165C18 + (temp_s0 * 0xE0))->unkA6 != 0) {
            func_80083018(temp_s0, phi_s1);
            func_80083060(temp_s0);
        }
        temp_s1 = phi_s1 + 1;
        phi_s2 += 4;
        phi_s1 = temp_s1;
    } while (temp_s1 != 4);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80083080.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800721C0(s32, ?); // extern
? func_80072488(s32); // extern
? func_80073444(? *, ? *, ?, s32); // extern
? func_80086E70(s32); // extern
? func_8008B80C(s32, ?, ?, ?); // extern
? func_8008B8BC(s32, ?, ?, ?); // extern
extern ? D_06014908;
extern ? D_06014B08;
extern ? D_0D0060B0;
extern f32 D_800EF1C0;
extern f64 D_800EF1C8;
extern ? D_80165C18;

void func_8008311C(s32 arg0, s32 arg1) {
    void *temp_s0;

    func_80073444(&D_06014908, &D_06014B08, 0x40, 0x40);
    temp_s0 = (arg0 * 0xE0) + &D_80165C18;
    temp_s0->unk60 = &D_06014908;
    temp_s0->unk64 = &D_06014B08;
    temp_s0->unk74 = &D_0D0060B0;
    temp_s0->unkD2 = 0;
    temp_s0->unk0 = D_800EF1C0;
    func_80072488(arg0);
    func_8008B80C(arg0, 0, 0, 0);
    func_8008B8BC(arg0, 0, 0, 0x8000);
    temp_s0->unk34 = ((arg1 % 6) * D_800EF1C8) + 0.5;
    func_80086E70(arg0);
    func_800721C0(arg0, 0x4000600);
    temp_s0->unkC8 = 2;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_8008311C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
s32 func_8007223C(s32, ?);                          /* extern */
? func_80086FD4(s32);                               /* extern */
? func_8008701C(s32, ?);                            /* extern */
s32 func_80087060(s32, ?);                          /* extern */
? func_800871AC(s32, ?);                            /* extern */
? func_8008861C(s32);                               /* extern */
? func_8008BF18(s32);                               /* extern */
extern ? D_80165C18;

void func_80083248(s32 arg0) {
    u16 temp_t8;
    void *temp_s1;

    temp_s1 = (arg0 * 0xE0) + &D_80165C18;
    temp_t8 = temp_s1->unkAE;
    switch (temp_t8) {
    case 1:
        if (func_80087A0C(arg0, temp_s1->unk10, temp_s1->unk9C, temp_s1->unk18, temp_s1->unk9E) != 0) {
            func_80086FD4(arg0);
        }
        break;
    case 2:
        func_800871AC(arg0, 0x3C);
        break;
    case 3:
        if (func_80087A0C(arg0, temp_s1->unk9C, temp_s1->unk10, temp_s1->unk9E, temp_s1->unk18) != 0) {
            func_80086FD4(arg0);
        }
        break;
    case 4:
        if (func_80087060(arg0, 0x3C) != 0) {
            func_8008701C(arg0, 1);
        }
        break;
    }
    func_8008BF18(arg0);
    if (func_8007223C(arg0, 0x200000) != 0) {
        if (func_8007223C(arg0, 0x400000) != 0) {
            func_8008861C(arg0);
        }
        temp_s1->unk8 = temp_s1->unk44 + 6.0;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80083248.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80072D3C(?, ?, ?, s32); // extern
? func_8008311C(); // extern
extern ? D_0D0060B0;
extern ? D_0D006130;
extern ? D_80165C18;

void func_800833D0(s32 arg0) {
    void *sp20;
    s16 temp_v0;
    void *temp_v1;
    void *phi_v1;

    temp_v1 = (arg0 * 0xE0) + &D_80165C18;
    temp_v0 = temp_v1->unkA6;
    phi_v1 = temp_v1;
    if (temp_v0 != 0) {
        if (temp_v0 != 1) {
            if (temp_v0 != 2) {

            } else {
                sp20 = temp_v1;
                func_80072D3C(0, 1, 4, -1);
                goto block_6;
            }
        } else {
            sp20 = temp_v1;
            func_8008311C();
block_6:
            phi_v1 = sp20;
        }
    }
    if (phi_v1->unkD2 == 0) {
        phi_v1->unk74 = &D_0D0060B0;
        return;
    }
    phi_v1->unk74 = &D_0D006130;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_800833D0.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80089F24(); // extern
extern ? D_80165CBE;

void func_80083474(s32 arg0) {
    if (*(&D_80165CBE + (arg0 * 0xE0)) >= 2) {
        func_80089F24();
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80083474.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80072120(s32 *, ?); // extern
? func_80083248(s32); // extern
? func_800833D0(s32, s32); // extern
? func_80083474(s32); // extern
extern s32 D_80183F28;

void func_800834B8(void) {
    s32 temp_s0;
    s32 temp_s1;
    s32 *phi_s2;
    s32 phi_s0;

    phi_s2 = &D_80183F28;
    phi_s0 = 0;
    do {
        temp_s1 = *phi_s2;
        func_800833D0(temp_s1, phi_s0);
        func_80083248(temp_s1);
        func_80083474(temp_s1);
        temp_s0 = phi_s0 + 1;
        phi_s2 += 4;
        phi_s0 = temp_s0;
    } while (temp_s0 != 0xF);
    func_80072120(&D_80183F28, 0xF);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_800834B8.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800723A4(?); // extern
extern ? D_06006D20;
extern ? D_06006F20;
extern f64 D_800EF1E8;
extern f64 D_800EF1F0;
extern f64 D_800EF1F8;
extern f64 D_800EF200;
extern ? D_80165C18;

void func_80083538(s32 arg0, void *arg1, s32 arg2, s32 arg3) {
    f32 temp_f6;
    f64 temp_f16;
    s32 temp_v0;
    void *temp_s0;
    f32 phi_f6;

    func_800723A4(0);
    temp_s0 = (arg0 * 0xE0) + &D_80165C18;
    temp_s0->unk64 = &D_06006F20;
    temp_s0->unk6C = &D_06006F20;
    temp_s0->unk60 = &D_06006D20;
    temp_s0->unk68 = &D_06006D20;
    temp_v0 = random_int(0x64);
    temp_f6 = temp_v0;
    phi_f6 = temp_f6;
    if (temp_v0 < 0) {
        phi_f6 = temp_f6 + 4294967296.0f;
    }
    temp_s0->unk0 = (phi_f6 * D_800EF1E8) + D_800EF1F0;
    temp_s0->unk3C = (random_int(0x14) * 0.5) + D_800EF1F8;
    temp_f16 = random_int(0xA) * D_800EF200;
    temp_s0->unkC0 = (arg2 << 0x10) / arg3;
    temp_s0->unk34 = temp_f16 + 4.5;
    temp_s0->unk10 = arg1->unk0;
    temp_s0->unk14 = arg1->unk4;
    temp_s0->unk18 = arg1->unk8;
    temp_s0->unkA0 = random_int(0x4000) + 0x1000;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80083538.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 func_80072044(? *, ? *, ?); // extern
? func_80083538(s32, s32, s32, s32); // extern
extern ? D_80183E4C;
extern ? D_8018C3F0;
extern s32 D_8018D3BC;

void func_800836F0(s32 arg0) {
    s32 temp_s0;
    s32 temp_v0;
    s32 phi_s0;

    phi_s0 = 0;
    if (D_8018D3BC > 0) {
loop_2:
        temp_v0 = func_80072044(&D_8018C3F0, &D_80183E4C, 0x80);
        if (temp_v0 != -1) {
            func_80083538(temp_v0, arg0, phi_s0, D_8018D3BC);
            temp_s0 = phi_s0 + 1;
            phi_s0 = temp_s0;
            if (temp_s0 < D_8018D3BC) {
                goto loop_2;
            }
        }
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_800836F0.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80072428(s32); // extern
? func_80072488(s32); // extern
? func_80086F60(s32); // extern
s32 func_80087E08(s32, s32, ?, s32, s32, s32); // extern
? func_8008BF18(s32); // extern
extern ? D_80165C18;

void func_8008379C(s32 arg0) {
    s16 temp_v0;
    void *temp_s0;

    temp_s0 = (arg0 * 0xE0) + &D_80165C18;
    temp_v0 = temp_s0->unkA6;
    if (temp_v0 != 0) {
        if (temp_v0 != 1) {
            if (temp_v0 != 2) {

            } else {
                func_80086F60(arg0);
                func_80072428(arg0);
            }
        } else if (func_80087E08(arg0, temp_s0->unk3C, 0x3F3D70A4, temp_s0->unk34, temp_s0->unkC0, 0x64) != 0) {
            func_80072488(arg0);
        }
    }
    func_8008BF18(arg0);
    temp_s0->unkB6 = temp_s0->unkB6 + temp_s0->unkA0;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_8008379C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800721C0(s32, ?); // extern
? func_80072488(s32); // extern
? func_80073444(? *, ? *, ?, s32); // extern
? func_80086E70(s32); // extern
? func_8008B80C(s32, ?, ?, ?); // extern
extern ? D_06004B20;
extern ? D_06004D20;
extern ? D_0D0061B0;
extern f32 D_800EF208;
extern ? D_80165C18;

void func_80083868(s32 arg0) {
    void *temp_s0;

    func_80073444(&D_06004B20, &D_06004D20, 0x40, 0x40);
    temp_s0 = (arg0 * 0xE0) + &D_80165C18;
    temp_s0->unk74 = &D_0D0061B0;
    temp_s0->unkD2 = 0;
    temp_s0->unk0 = D_800EF208;
    func_80072488(arg0);
    func_8008B80C(arg0, 0, 0, 0);
    temp_s0->unkB2 = 0;
    temp_s0->unkB4 = 0;
    temp_s0->unkB6 = 0x8000;
    temp_s0->unkA0 = random_int(0x2000) - 0x1000;
    func_80086E70(arg0);
    temp_s0->unk34 = 1.5f;
    func_800721C0(arg0, 0x200);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80083868.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
s32 f32_step_up_towards(void *, ?, ?);                    /* extern */
? func_80073800(s32, ?);                            /* extern */
? func_80073D0C(s32, void *, ?, ?, s32, s32, s32);  /* extern */
? func_80086FD4(s32);                               /* extern */
? func_8008701C(s32, ?);                            /* extern */
? func_800871AC(s32, ?);                            /* extern */
? func_80087C48(s32, ?, ?, ?);                      /* extern */
? func_80087D24(s32, ?, ?, ?);                      /* extern */
? func_8008BF18(s32);                               /* extern */
extern ? D_80165C18;

void func_80083948(s32 arg0) {
    u16 temp_t8;
    void *temp_s1;

    temp_s1 = (arg0 * 0xE0) + &D_80165C18;
    temp_t8 = temp_s1->unkAE;
    switch (temp_t8) {
    case 1:
        func_80086FD4(arg0);
        break;
    case 2:
        func_800871AC(arg0, 0x14);
        break;
    case 3:
        func_8008701C(arg0, 1);
        break;
    case 10:
        func_80087C48(arg0, 0x41200000, 0x3F000000, 0xA);
        break;
    case 11:
        func_80087D24(arg0, 0, 0x3E4CCCCD, 0xC0E00000);
        break;
    case 20:
        if (f32_step_up_towards(temp_s1 + 0x2C, 0, 0x3E4CCCCD) != 0) {
            func_80073800(arg0, 0);
            func_8008701C(arg0, 1);
        }
        break;
    }
    func_8008BF18(arg0);
    func_80073D0C(arg0, temp_s1 + 0xA0, -0x1000, 0x1000, 0x400, 1, -1);
    temp_s1->unkB6 = temp_s1->unkA0 + 0x8000;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80083948.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80073514(s32, s32); // extern
? func_80083868(s16); // extern
? func_80083948(s32); // extern
extern ? D_80165C18;

void func_80083A94(s32 arg0) {
    void *sp18;
    s16 temp_a1;
    void *temp_v1;
    s32 phi_a1;

    temp_v1 = (arg0 * 0xE0) + &D_80165C18;
    temp_a1 = temp_v1->unkA6;
    phi_a1 = temp_a1;
    if ((temp_a1 != 0) && (temp_a1 == 1)) {
        sp18 = temp_v1;
        func_80083868(temp_a1);
        phi_a1 = temp_v1->unkA6;
    }
    if (phi_a1 >= 2) {
        func_80073514(arg0, phi_a1);
    }
    func_80083948(arg0);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80083A94.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800721C0(s32, ?); // extern
? func_80072488(s32); // extern
? func_80073444(? *, ? *, ?, s32); // extern
? func_8008B80C(s32, ?, ?, ?); // extern
extern ? D_06004B20;
extern ? D_06005D20;
extern ? D_0D0060B0;
extern f32 D_800EF260;
extern ? D_80165C18;

void func_80083B0C(s32 arg0) {
    void *sp2C;
    void *temp_v0;

    func_80073444(&D_06004B20, &D_06005D20, 0x40, 0x40);
    temp_v0 = (arg0 * 0xE0) + &D_80165C18;
    temp_v0->unk74 = &D_0D0060B0;
    temp_v0->unkD2 = 0;
    sp2C = temp_v0;
    temp_v0->unk0 = D_800EF260;
    func_80072488(arg0);
    func_8008B80C(arg0, 0, 0, 0);
    temp_v0->unkB2 = 0;
    temp_v0->unkB4 = 0;
    temp_v0->unkB6 = 0x8000;
    temp_v0->unkC8 = 2;
    temp_v0->unk34 = 1.5f;
    func_800721C0(arg0, 0x4000210);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80083B0C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_8008BF18(); // extern

void func_80083BE4(void) {
    func_8008BF18();
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80083BE4.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
? func_800721C0(s32, ?);                            /* extern */
? func_800721E8(s32, ?);                            /* extern */
? func_800722A4(s32, ?);                            /* extern */
? func_80072488(s32);                               /* extern */
? func_800726CC(s32, ?);                            /* extern */
s32 func_8007278C(s32, ?);                          /* extern */
? func_80073514(s32);                               /* extern */
s32 func_80074118(s32, void *, ?, ?, f32, s32, s32); /* extern */
? func_80083B0C(s32);                               /* extern */
? func_80083BE4(s32);                               /* extern */
extern ? D_80165C18;

void func_80083C04(s32 arg0) {
    s16 temp_v1;
    void *temp_s1;

    temp_s1 = (arg0 * 0xE0) + &D_80165C18;
    temp_v1 = temp_s1->unkA6;
    switch (temp_v1) {
    case 1:
        func_80083B0C(arg0);
block_14:
        break;
    case 2:
        func_8007278C(arg0, 0x96);
        goto block_14;
    case 10:
        if (func_8007278C(arg0, 0x12C) != 0) {
            func_800722A4(arg0, 2);
        }
        goto block_14;
    case 11:
        if (func_8007278C(arg0, 0xA) != 0) {
            func_800721C0(arg0, 0x10);
            temp_s1->unk0 = 0.001f;
        }
        goto block_14;
    case 12:
        if (func_80074118(arg0, temp_s1, 0x3A83126F, 0x3DCCCCCD, 0.0025f, 0, 0) != 0) {
            func_80072488(arg0);
        }
        goto block_14;
    case 13:
        func_800726CC(arg0, 2);
        func_800721E8(arg0, 0x1000);
        goto block_14;
    }
    if (temp_s1->unkA6 >= 2) {
        func_80073514(arg0);
    }
    func_80083BE4(arg0);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80083C04.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80072100(s32 *); // extern
? func_800721C0(s32, ?); // extern
? func_800721E8(s32, ?); // extern
s32 func_80072270(s32, ?); // extern
? func_800722CC(s32, ?); // extern
s32 func_80072320(s32, ?); // extern
? func_800726CC(s32, ?); // extern
? func_800836F0(void *); // extern
? func_8008379C(s32); // extern
? func_80083A94(s32); // extern
? func_80083C04(s32); // extern
? func_8008701C(s32, ?); // extern
s32 func_80089B50(s32); // extern
s32 func_8008A8B0(s16, s16); // extern
extern ? D_80165C18;
extern s32 D_80183EA0;
extern s32 D_80183F28;
extern ? D_80183F74;
extern s32 D_8018C3F0;
extern ? D_8018C5F0;

void func_80083D60(void) {
    s32 *temp_s0;
    s32 *temp_s3;
    s32 temp_a0;
    s32 temp_s0_2;
    s32 temp_s2;
    u8 temp_v0;
    void *temp_s1;
    void *temp_s1_2;
    s32 *phi_s0;
    s32 *phi_s3;
    s32 *phi_s4;

    phi_s0 = &D_8018C3F0;
    do {
        temp_a0 = *phi_s0;
        if (temp_a0 != -1) {
            temp_s1 = &D_80165C18 + (temp_a0 * 0xE0);
            if (temp_s1->unkA6 != 0) {
                func_8008379C(temp_a0);
                if (temp_s1->unkA6 == 0) {
                    func_80072100(phi_s0);
                }
            }
        }
        temp_s0 = phi_s0 + 4;
        phi_s0 = temp_s0;
    } while (temp_s0 < &D_8018C5F0);
    phi_s3 = &D_80183F28;
    phi_s4 = &D_80183EA0;
    do {
        temp_s2 = *phi_s3;
        temp_s0_2 = *phi_s4;
        func_80083A94(temp_s2);
        func_80083C04(temp_s0_2);
        if (func_80072270(temp_s0_2, 0x1000) != 0) {
            temp_s1_2 = &D_80165C18 + (temp_s0_2 * 0xE0);
            temp_v0 = temp_s1_2->unkD5;
            if ((func_8008A8B0(temp_v0 - 1, temp_v0 + 1) != 0) && (func_80089B50(temp_s0_2) != 0)) {
                func_800721C0(temp_s0_2, 0x1000);
                func_800721E8(temp_s0_2, 0x10);
                func_800726CC(temp_s0_2, 0xA);
                func_8008701C(temp_s2, 0xA);
                func_800836F0(temp_s1_2 + 4);
            }
        } else if (func_80072320(temp_s0_2, 2) != 0) {
            func_800722CC(temp_s0_2, 2);
            func_8008701C(temp_s2, 0x14);
        }
        temp_s3 = phi_s3 + 4;
        phi_s3 = temp_s3;
        phi_s4 += 4;
    } while (temp_s3 != &D_80183F74);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80083D60.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80072428(s32); // extern
? func_80072488(s32); // extern
? func_80086F60(s32); // extern
s32 func_80087E08(s32, s32, ?, s32, s32, s32); // extern
? func_8008BF18(s32); // extern
extern ? D_80165C18;

void func_80083F18(s32 arg0) {
    s16 temp_v1;
    void *temp_v0;

    temp_v0 = (arg0 * 0xE0) + &D_80165C18;
    temp_v1 = temp_v0->unkA6;
    if (temp_v1 != 0) {
        if (temp_v1 != 1) {
            if (temp_v1 != 2) {
                return;
            }
            func_80086F60(arg0);
            func_80072428(arg0);
            // Duplicate return node #8. Try simplifying control flow for better match
            return;
        }
        if (func_80087E08(arg0, temp_v0->unk3C, 0x3DF5C28F, temp_v0->unk34, temp_v0->unkC0, 0x64) != 0) {
            func_80072488(arg0);
        }
        func_8008BF18(arg0);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80083F18.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800723A4(?); // extern
extern ? D_060068E8;
extern f64 D_800EF2A8;
extern f64 D_800EF2B0;
extern f64 D_800EF2B8;
extern f64 D_800EF2C0;
extern u16 D_801657A2;
extern ? D_80165C18;

void func_80083FD0(s32 arg0, s32 arg1, s16 arg2) {
    Player *sp20;
    f32 temp_f16;
    f32 temp_f8;
    f64 temp_f10;
    s32 temp_v0;
    s32 temp_v0_2;
    s32 temp_v0_3;
    void *temp_s0;
    f32 phi_f16;
    f32 phi_f8;
    f64 phi_f10;

    temp_s0 = (arg0 * 0xE0) + &D_80165C18;
    sp20 = &gPlayerOne[arg2];
    temp_s0->unk92 = arg2;
    func_800723A4(0);
    temp_s0->unk60 = &D_060068E8;
    temp_s0->unk68 = &D_060068E8;
    temp_s0->unk0 = (random_int(0x1F4) * D_800EF2A8) + D_800EF2B0;
    temp_v0 = random_int(0x32);
    temp_f16 = temp_v0;
    phi_f16 = temp_f16;
    if (temp_v0 < 0) {
        phi_f16 = temp_f16 + 4294967296.0f;
    }
    temp_s0->unk3C = (phi_f16 * D_800EF2B8) + 1.0;
    temp_v0_2 = random_int(0xA);
    temp_f8 = temp_v0_2;
    phi_f8 = temp_f8;
    if (temp_v0_2 < 0) {
        phi_f8 = temp_f8 + 4294967296.0f;
    }
    temp_s0->unk34 = (phi_f8 * D_800EF2C0) + 1.0;
    temp_s0->unkC0 = D_801657A2 * arg1;
    temp_s0->unk10 = (random_int(0x14) + sp20->posX) - 10.0f;
    temp_v0_3 = random_int(0xA);
    temp_f10 = temp_v0_3;
    phi_f10 = temp_f10;
    if (temp_v0_3 < 0) {
        phi_f10 = temp_f10 + 4294967296.0;
    }
    temp_s0->unk14 = phi_f10 + (sp20->posY - 10.0);
    temp_s0->unk18 = (random_int(0x14) + sp20->posZ) - 10.0f;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80083FD0.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s32 func_80072044(? *, ? *, ?); // extern
? func_80083FD0(s32, s32, ?); // extern
extern ? D_80183E4C;
extern ? D_8018C3F0;
extern s32 D_8018D3C0;

void func_8008421C(s32 arg0, ? arg1) {
    s32 temp_s0;
    s32 temp_v0;
    s32 phi_s0;

    phi_s0 = 0;
    if (D_8018D3C0 > 0) {
loop_2:
        temp_v0 = func_80072044(&D_8018C3F0, &D_80183E4C, 0x80);
        if (temp_v0 != -1) {
            func_80083FD0(temp_v0, phi_s0, arg1);
            temp_s0 = phi_s0 + 1;
            phi_s0 = temp_s0;
            if (temp_s0 < D_8018D3C0) {
                goto loop_2;
            }
        }
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_8008421C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800419F8(); // extern
? func_80072100(s32 *); // extern
? func_800722CC(s32, ?); // extern
s32 func_80072320(s32, ?); // extern
? func_80083F18(s32); // extern
? func_8008421C(s32, s32); // extern
extern ? D_8016582C;
extern ? D_80165834;
extern ? D_80165C18;
extern s32 D_80183DB8;
extern s32 D_8018C3F0;
extern ? D_8018C5F0;

void func_800842C8(void) {
    s32 *temp_s1_2;
    s32 temp_s0;
    s32 temp_s0_2;
    s32 temp_s1;
    void *temp_s2;
    s32 *phi_s2;
    s32 phi_s1;
    s32 *phi_s1_2;

    D_80165834.unk0 = D_80165834.unk0 + 0x200;
    D_80165834.unk2 = D_80165834.unk2 + 0x400;
    func_800419F8();
    D_8016582C.unk0 = D_8016582C.unk0 + 0x2000;
    D_8016582C.unk2 = D_8016582C.unk2 + 0x1000;
    D_8016582C.unk4 = D_8016582C.unk4 + 0x1800;
    phi_s1 = 0;
    if (gPlayerCountSelection1 > 0) {
        phi_s2 = &D_80183DB8;
        do {
            temp_s0 = *phi_s2;
            if (func_80072320(temp_s0, 0x20) != 0) {
                func_800722CC(temp_s0, 0x20);
                func_8008421C(temp_s0, phi_s1);
            }
            temp_s1 = phi_s1 + 1;
            phi_s2 += 4;
            phi_s1 = temp_s1;
        } while (temp_s1 < gPlayerCountSelection1);
    }
    phi_s1_2 = &D_8018C3F0;
    do {
        temp_s0_2 = *phi_s1_2;
        if (temp_s0_2 != -1) {
            temp_s2 = &D_80165C18 + (temp_s0_2 * 0xE0);
            if (temp_s2->unkA6 != 0) {
                func_80083F18(temp_s0_2);
                if (temp_s2->unkA6 == 0) {
                    func_80072100(phi_s1_2);
                }
            }
        }
        temp_s1_2 = phi_s1_2 + 4;
        phi_s1_2 = temp_s1_2;
    } while (temp_s1_2 != &D_8018C5F0);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_800842C8.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s16 func_80004EAC(? *, ?); // extern
? func_800721C0(s32, ?); // extern
? func_80072488(s32); // extern
? func_80086EF0(s32); // extern
? func_8008B7D4(f32, ?, ?); // extern
? func_8008B888(s32, ?, ?, ?); // extern
extern ? D_06008EB0;
extern ? D_06009AC8;
extern s32 D_800E672C;
extern f32 D_800EF2C8;
extern f64 D_800EF2D0;
extern ? D_80165C18;
extern f32 D_8018D01C;

void func_80084430(s32 arg0, ? arg1) {
    void *temp_s0;

    temp_s0 = (arg0 * 0xE0) + &D_80165C18;
    temp_s0->unkD8 = 0;
    temp_s0->unk70 = &D_06008EB0;
    temp_s0->unk74 = &D_06009AC8;
    temp_s0->unkC8 = 0xC;
    temp_s0->unk9C = 1;
    temp_s0->unk0 = D_800EF2C8;
    func_8008B7D4(D_8018D01C * D_800EF2D0, 0x40000000, 0xC42C8000);
    func_8008B888(arg0, 0, 0, 0);
    temp_s0->unkDD = 1;
    func_80086EF0(arg0);
    temp_s0->unk80 = D_800E672C;
    func_800721C0(arg0, 0x4000800);
    temp_s0->unkA4 = func_80004EAC(&D_06009AC8, 0);
    func_80072488(arg0);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80084430.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80072E54(?, s16, ?, s32, s32); // extern
? func_80084430(s32); // extern
extern ? D_80165C18;

void func_8008453C(s32 arg0) {
    s16 temp_v0;
    void *temp_v1;

    temp_v1 = (arg0 * 0xE0) + &D_80165C18;
    temp_v0 = temp_v1->unkA6;
    if (temp_v0 != 0) {
        if (temp_v0 != 1) {
            if (temp_v0 != 2) {
                return;
            }
            func_80072E54(0, temp_v1->unkA4, 1, 0, -1);
            // Duplicate return node #7. Try simplifying control flow for better match
            return;
        }
        if (gPlayerCountSelection1 == 1) {
            func_80084430(1);
            return;
        }
        // Duplicate return node #7. Try simplifying control flow for better match
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_8008453C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
s16 func_80004EAC(? *, ?);                          /* extern */
? func_800721C0(s32, ?);                            /* extern */
? func_800722A4(s32, ?);                            /* extern */
? func_80072488(s32);                               /* extern */
? func_80086EF0(s32);                               /* extern */
? func_8008B7D4(s32, f32, ?, ?);                    /* extern */
? func_8008B888(s32, ?, s32, ?);                    /* extern */
s32 random_int(?);                                  /* extern */
extern ? D_06008EB0;
extern ? D_06009AC8;
extern ? D_80165C18;

void func_800845C8(s32 arg0, s32 arg1) {
    void *temp_s0;
    f32 phi_f18;
    s32 phi_v1;
    u16 phi_t0;

    temp_s0 = (arg0 * 0xE0) + &D_80165C18;
    temp_s0->unkD8 = 0;
    temp_s0->unk70 = &D_06008EB0;
    temp_s0->unk74 = &D_06009AC8;
    temp_s0->unkC8 = 4;
    temp_s0->unk9C = 2;
    temp_s0->unk4C = random_int(0x12C);
    func_800721C0(arg0, 0x4000220);
    phi_v1 = arg1;
    if ((arg1 > 0) && (arg1 < 9)) {
        if ((arg1 == 1) || (arg1 == 2)) {
            func_8008B7D4(arg0, D_8018D01C * -2960.0, 0xC2A00000, 0x44BE2000);
            temp_s0->unkC6 = 0x150;
            phi_f18 = 100.0f;
            goto block_14;
        }
        if ((arg1 == 3) || (arg1 == 4)) {
            func_8008B7D4(arg0, D_8018D01C * -2490.0, 0xC2A00000, 0x44C98000);
            temp_s0->unkC6 = 0x100;
            phi_f18 = 80.0f;
            goto block_14;
        }
        if ((arg1 == 5) || (arg1 == 6)) {
            func_8008B7D4(arg0, D_8018D01C * -2098.0, 0xC2A00000, 0x44CB0000);
            temp_s0->unkC6 = 0xFF00;
            phi_f18 = 80.0f;
            goto block_14;
        }
        if ((arg1 == 7) || (arg1 == 8)) {
            func_8008B7D4(arg0, D_8018D01C * -2080.0, 0xC2A00000, 0x44926000);
            temp_s0->unkC6 = 0x150;
            phi_f18 = 80.0f;
block_14:
            temp_s0->unk20 = phi_f18;
            phi_v1 = arg1;
        }
        temp_s0->unkC4 = phi_v1 << 0xF;
        temp_s0->unk44 = -80.0f;
        temp_s0->unkDD = 2;
        temp_s0->unk0 = 0.08f;
        func_800722A4(arg0, 8);
    } else if ((arg1 >= 9) && (arg1 < 0xF)) {
        switch (arg1) {
        case 9:
            if (D_800DC50C != CREDITS_SEQUENCE) {
                func_8008B7D4(arg0, D_8018D01C * 146.0, 0, 0xC3BE0000);
            } else {
                func_8008B7D4(arg0, D_8018D01C * 380.0, 0, 0xC405C000);
                temp_s0->unk0 = 0.15f;
            }
            temp_s0->unkC6 = 0x9000;
            if (gIsMirrorMode != 0) {
                temp_s0->unkC6 = 0x5000;
            }
            temp_s0->unkDD = 3;
            break;
        case 10:
            func_8008B7D4(arg0, D_8018D01C * 380.0, 0, 0xC43F8000);
            temp_s0->unkC6 = 0x5000;
            if (gIsMirrorMode != 0) {
                temp_s0->unkC6 = 0xD000;
            }
            temp_s0->unkDD = 4;
            break;
        case 11:
            func_8008B7D4(arg0, D_8018D01C * -2300.0, 0, 0xC3520000);
            temp_s0->unkC6 = 0xC000;
            temp_s0->unkDD = 6;
            if (gIsMirrorMode != 0) {
                temp_s0->unkC6 = 0x14000;
            }
            break;
        case 12:
            func_8008B7D4(arg0, D_8018D01C * -2500.0, 0, 0xC37A0000);
            temp_s0->unkC6 = 0x4000;
            temp_s0->unkDD = 6;
            phi_t0 = 0xC000;
            if (gIsMirrorMode != 0) {
block_36:
                temp_s0->unkC6 = phi_t0;
            }
            break;
        case 13:
            func_8008B7D4(arg0, D_8018D01C * -535.0, 0, 0x445AC000);
            temp_s0->unkC6 = 0x8000;
            temp_s0->unkDD = 6;
            if (gIsMirrorMode != 0) {
                temp_s0->unkC6 = 0x4000;
            }
            break;
        case 14:
            func_8008B7D4(arg0, D_8018D01C * -250.0, 0, 0x446E4000);
            temp_s0->unkC6 = 0x9000;
            temp_s0->unkDD = 6;
            phi_t0 = 0x5000;
            if (gIsMirrorMode != 0) {
                goto block_36;
            }
            break;
        }
        func_8008B888(arg0, 0, (temp_s0->unkC6 + 0x8000) & 0xFFFF, 0);
        temp_s0->unk44 = 5.0f;
        temp_s0->unk0 = 0.04f;
        func_800722A4(arg0, 0x14);
    }
    func_80086EF0(arg0);
    temp_s0->unk34 = 0.0f;
    temp_s0->unkA4 = func_80004EAC(&D_06009AC8, 0);
    func_80072488(arg0);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_800845C8.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
? func_800722A4(s32, ?);                            /* extern */
? func_800722CC(s32, ?);                            /* extern */
s32 func_80072320(s32, ?);                          /* extern */
s32 func_80072354(s32, ?);                          /* extern */
? func_80072488(s32);                               /* extern */
? func_80072E54(s32, ?, s16, s16, s32, s32);        /* extern */
? func_800845C8(s32);                               /* extern */
? func_800C98B8(void *, void *, ?);                 /* extern */
s32 random_int(?);                                  /* extern */
extern ? D_80165C18;

void func_80084B7C(s32 arg0) {
    s16 temp_v0;
    s16 temp_v0_2;
    u16 temp_t8;
    void *temp_s0;

    temp_s0 = (arg0 * 0xE0) + &D_80165C18;
    temp_t8 = temp_s0->unkA6;
    switch (temp_t8) {
    case 1:
        func_800845C8(arg0);
        break;
    case 2:
        func_80072E54(arg0, 0, temp_s0->unkA4, temp_s0->unk9C, 0, -1);
        if (func_80072354(arg0, 0x20) != 0) {
            temp_v0 = temp_s0->unk90;
            if (temp_v0 == 0) {
                temp_s0->unk90 = random_int(0x5A) + 0x5A;
                func_800722A4(arg0, 0x80);
            } else {
                temp_s0->unk90 = temp_v0 - 1;
            }
        }
        break;
    case 3:
        func_80072E54(arg0, 0, temp_s0->unkA4, 1, 0, 0);
        break;
    case 4:
        func_800722CC(arg0, 2);
        func_80072488(arg0);
        break;
    }
    if (func_80072320(arg0, 0x20) != 0) {
        temp_v0_2 = temp_s0->unk90;
        if (temp_v0_2 == 0) {
            func_800722A4(arg0, 0x80);
            temp_s0->unk90 = 0x10;
        } else {
            temp_s0->unk90 = temp_v0_2 - 1;
        }
    }
    if (func_80072320(arg0, 0x80) != 0) {
        func_800722CC(arg0, 0x80);
        if (func_80072320(arg0, 0x10) != 0) {
            func_800C98B8(temp_s0 + 4, temp_s0 + 0x38, 0x19007049);
            return;
        }
        func_800C98B8(temp_s0 + 4, temp_s0 + 0x38, 0x19007017);
        /* Duplicate return node #17. Try simplifying control flow for better match */
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80084B7C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
s16 func_80004EAC(? *, s32);                        /* extern */
? f32_step_towards(void *, f32, ?);                    /* extern */
? func_800722A4(s32, ?);                            /* extern */
? func_800722CC(s32, ?);                            /* extern */
s32 func_80072354(s32, ?);                          /* extern */
? func_800726CC(s32, ?);                            /* extern */
? func_80086FD4(s32);                               /* extern */
? func_8008701C(s32, ?);                            /* extern */
s32 func_80087060(s32, ?);                          /* extern */
? func_8008781C(s32);                               /* extern */
? func_8008BF18(s32);                               /* extern */
extern ? D_06009AC8;
extern ? D_80165C18;

void func_80084D2C(s32 arg0, s32 arg1) {
    f32 sp24;
    s32 temp_t9;
    u16 temp_t8;
    u16 temp_v0;
    void *temp_s0;

    temp_s0 = (arg0 * 0xE0) + &D_80165C18;
    temp_t8 = temp_s0->unkAE;
    switch (temp_t8) {
    case 1:
        temp_v0 = func_800417B4(temp_s0->unkC0, temp_s0->unkC6);
        temp_t9 = temp_v0 & 0xFFFF;
        temp_s0->unkC0 = temp_v0;
        if (temp_t9 == temp_s0->unkC6) {
            temp_s0->unk9C = 4;
            temp_s0->unk34 = 0.4f;
            func_80086FD4(arg0);
        }
        break;
    case 2:
        f32_step_towards(temp_s0 + 0x34, 0.8f, 0x3CA3D70A);
        if (func_80087060(arg0, 0xF) != 0) {
            func_800722A4(arg0, 1);
            func_800722A4(arg0, 2);
            temp_s0->unk9C = 1;
            temp_s0->unkD8 = 1;
            temp_s0->unkD2 = 0;
            temp_s0->unkA4 = func_80004EAC(&D_06009AC8, 1 & 0xFF);
            func_800726CC(arg0, 3);
            func_80086FD4(arg0);
            if (func_80072354(arg0, 0x20) != 0) {
                func_800722A4(arg0, 0x80);
            }
        }
        break;
    case 3:
        if (arg1 != 0) {
            if (arg1 != 1) {
                if (arg1 != 2) {
                    if (arg1 != 3) {

                    } else {
                        sp24 = 2.5f;
                    }
                } else {
                    sp24 = 2.0f;
                }
            } else {
                sp24 = 1.5f;
            }
        } else {
            sp24 = 1.0f;
        }
        f32_step_towards(temp_s0 + 0x34, sp24, 0x3E19999A);
        if ((func_80072354(arg0, 2) != 0) && (sp24 == temp_s0->unk34)) {
            func_80086FD4(arg0);
        }
        break;
    case 4:
        if (func_80087060(arg0, 0x1E) != 0) {
            func_800722CC(arg0, 1);
            func_80086FD4(arg0);
        }
        break;
    case 5:
        f32_step_towards(temp_s0 + 0x34, 0.4f, 0x3E4CCCCD);
        if (func_80087060(arg0, 0xA) != 0) {
            func_800722A4(arg0, 2);
            temp_s0->unkD8 = 2;
            temp_s0->unkD2 = 0;
            temp_s0->unkA4 = func_80004EAC(&D_06009AC8, 2 & 0xFF);
            func_800726CC(arg0, 3);
            func_80086FD4(arg0);
        }
        break;
    case 6:
        if (func_80072354(arg0, 2) != 0) {
            temp_s0->unkD8 = 0;
            temp_s0->unkD2 = 0;
            temp_s0->unkA4 = func_80004EAC(&D_06009AC8, 0 & 0xFF);
            temp_s0->unkC6 = temp_s0->unkC6 + 0x8000;
            func_800726CC(arg0, 2);
            func_8008701C(arg0, 1);
        }
        break;
    }
    func_8008781C(arg0);
    func_8008BF18(arg0);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80084D2C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800873F4(s32); // extern
? func_80088038(s32, u16); // extern
? func_8008BF18(s32); // extern
extern ? D_80165C18;

void func_8008502C(s32 arg0, ? arg1) {
    void *temp_v0;

    temp_v0 = (arg0 * 0xE0) + &D_80165C18;
    func_80088038(temp_v0->unk20, temp_v0->unkC6);
    func_8008BF18(arg0);
    func_800873F4(arg0);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_8008502C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800873F4(s32); // extern
? func_8008B78C(); // extern
? func_8008BF18(s32); // extern

void func_80085080(s32 arg0) {
    func_8008B78C();
    func_8008BF18(arg0);
    func_800873F4(arg0);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80085080.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
? func_800722CC(s32, ?);                            /* extern */
s32 func_80072320(s32, ?);                          /* extern */
? func_80084D2C(s32, ?);                            /* extern */
? func_8008502C(s32);                               /* extern */
? func_80085080(s32);                               /* extern */
extern ? D_80165C18;

void func_800850B0(s32 arg0) {
    s16 temp_v0;
    u8 temp_t8;
    void *temp_s0;

    temp_s0 = (arg0 * 0xE0) + &D_80165C18;
    temp_t8 = temp_s0->unkDD;
    switch (temp_t8) {
    case 1:
        func_80085080(arg0);
        break;
    case 2:
        func_8008502C(arg0);
        break;
    case 3:
        func_80084D2C(arg0, 0);
        break;
    case 4:
        func_80084D2C(arg0, 1);
        break;
    case 5:
        func_80084D2C(arg0, 2);
        break;
    case 6:
        func_80084D2C(arg0, 3);
        break;
    }
    if (func_80072320(arg0, 0x20) != 0) {
        if (func_80072320(arg0, 0x40) != 0) {
            func_800722CC(arg0, 0x40);
            temp_s0->unk90 = 0;
            temp_s0->unk92 = 0x96;
        }
        temp_v0 = temp_s0->unk92;
        if (temp_v0 == 0) {
            func_800722CC(arg0, 0x20);
            return;
        }
        temp_s0->unk92 = temp_v0 - 1;
        temp_s0->unkB4 = temp_s0->unkB4 + 0x2000;
        temp_s0->unkB2 = temp_s0->unkBE;
        temp_s0->unkB6 = temp_s0->unkC2;
        return;
    }
    temp_s0->unkB2 = temp_s0->unkBE;
    temp_s0->unkB4 = temp_s0->unkC0;
    temp_s0->unkB6 = temp_s0->unkC2;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_800850B0.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800721E8(s32, ?); // extern
s32 func_8007223C(s32, ?); // extern
? func_800722A4(s32, ?); // extern
s32 func_80072320(s32, ?); // extern
s32 func_80072354(s32, ?); // extern
? func_8008453C(s32, s32); // extern
? func_80084B7C(s32, s32); // extern
? func_800850B0(s32, s32); // extern
? func_80089820(s32, f32, f32, ?); // extern
extern f32 D_800EF3A8;
extern ? D_80165C18;
extern s32 D_80183EA0;

void func_80085214(void) {
    f32 temp_f24;
    s32 temp_s0;
    s32 temp_s1;
    s32 *phi_s2;
    s32 phi_s1;

    temp_f24 = D_800EF3A8;
    phi_s2 = &D_80183EA0;
    phi_s1 = 0;
    do {
        temp_s0 = *phi_s2;
        if ((&D_80165C18 + (temp_s0 * 0xE0))->unkA6 != 0) {
            if (phi_s1 == 0) {
                func_8008453C(temp_s0, phi_s1);
            } else {
                func_80084B7C(temp_s0, phi_s1);
            }
            func_800850B0(temp_s0, phi_s1);
        }
        if (func_80072320(temp_s0, 1) != 0) {
            func_80089820(temp_s0, 1.75f, 1.5f, 0x1900A046);
        } else if (func_80072320(temp_s0, 8) != 0) {
            func_80089820(temp_s0, temp_f24, 1.0f, 0x1900A046);
        } else {
            func_80089820(temp_s0, 1.5f, 1.25f, 0x1900A046);
        }
        if ((func_8007223C(temp_s0, 0x2000000) != 0) && (func_80072354(temp_s0, 0x20) != 0)) {
            func_800722A4(temp_s0, 0x60);
            func_800721E8(temp_s0, 0x2000000);
        }
        temp_s1 = phi_s1 + 1;
        phi_s2 += 4;
        phi_s1 = temp_s1;
    } while (temp_s1 != 0xF);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80085214.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80072488(s32); // extern
? func_80086EF0(s32); // extern
? func_800886F4(s32); // extern
? func_8008B7D4(f32, f32, f32, ?); // extern
? func_8008B80C(s32, f32, ?, f32); // extern
? func_8008B844(s32); // extern
? func_802A14BC(f32, f32, f32); // extern
extern ? D_0600F960;
extern f64 D_800EF3B0;
extern ? D_80165C18;
extern f32 D_8018D01C;

void func_800853DC(s32 arg0) {
    void *sp2C;
    void *temp_v0;

    temp_v0 = (arg0 * 0xE0) + &D_80165C18;
    temp_v0->unk70 = &D_0600F960;
    temp_v0->unk0 = 1.0f;
    if (D_800DC50C != CREDITS_SEQUENCE) {
        sp2C = temp_v0;
        func_8008B7D4(D_8018D01C * -176.0, 0.0f, -2323.0f);
        func_8008B80C(arg0, 0.0f, 0x43960000, 0.0f);
    } else {
        sp2C = temp_v0;
        func_8008B7D4((bitwise f32) arg0, D_8018D01C * D_800EF3B0, 0.0f, 0x448AC000);
        func_8008B80C(arg0, 0.0f, 0x43960000, 0.0f);
    }
    func_8008B844(arg0);
    func_800886F4(arg0);
    func_80086EF0(arg0);
    sp2C->unk3C = -2.0f;
    func_802A14BC(0.0f, 0.0f, 0.0f);
    func_80072488(arg0);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_800853DC.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
? f32_step_towards(void *, ?, ?);                      /* extern */
? func_80086FD4(s32);                               /* extern */
? func_8008701C(s32, ?);                            /* extern */
s32 func_80087060(s32, ?);                          /* extern */
? func_800871AC(s32, ?);                            /* extern */
? func_800877C4(s32);                               /* extern */
extern ? D_80165C18;

void func_80085534(s32 arg0) {
    s16 temp_t8;
    void *temp_s0;

    temp_s0 = (arg0 * 0xE0) + &D_80165C18;
    temp_t8 = temp_s0->unkAE;
    switch (temp_t8) {
    case 1:
        if (temp_s0->unk2C <= 18.0) {
            func_80086FD4(arg0);
        }
        break;
    case 2:
        f32_step_towards(temp_s0 + 0x3C, 0, 0x3D4CCCCD);
        if (temp_s0->unk3C == 0.0) {
            func_80086FD4(arg0);
        }
        break;
    case 3:
        func_800871AC(arg0, 1);
        break;
    case 4:
        f32_step_towards(temp_s0 + 0x3C, 0x3F800000, 0x3D4CCCCD);
        if (temp_s0->unk3C == 1.0) {
            func_80086FD4(arg0);
        }
        break;
    case 5:
        func_800871AC(arg0, 0x5A);
        break;
    case 6:
        f32_step_towards(temp_s0 + 0x3C, 0, 0x3D4CCCCD);
        if (temp_s0->unk3C == 0.0) {
            func_80086FD4(arg0);
        }
        break;
    case 7:
        f32_step_towards(temp_s0 + 0x3C, 0xBF800000, 0x3D4CCCCD);
        if (temp_s0->unk3C == -1.0) {
            func_80086FD4(arg0);
        }
        break;
    case 8:
        func_800871AC(arg0, 0x5A);
        break;
    case 9:
        f32_step_towards(temp_s0 + 0x3C, 0, 0x3D4CCCCD);
        if (func_80087060(arg0, 0x5A) != 0) {
            func_8008701C(arg0, 3);
        }
        break;
    }
    func_800877C4(arg0);
    temp_s0->unkC0 = temp_s0->unkC0 + 0x100;
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80085534.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800853DC(); // extern
extern ? D_80165CBE;

void func_80085768(s32 arg0) {
    s16 temp_v0;

    temp_v0 = *(&D_80165CBE + (arg0 * 0xE0));
    if (temp_v0 != 0) {
        if (temp_v0 != 1) {
            if (temp_v0 != 2) {
                return;
            }
            // Duplicate return node #5. Try simplifying control flow for better match
            return;
        }
        func_800853DC();
        // Duplicate return node #5. Try simplifying control flow for better match
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80085768.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80085534(s32); // extern
? func_80085768(s32); // extern
? func_8008BF18(s32); // extern
extern ? D_80165C18;
extern s32 D_80183EA0;
extern void *D_802BA05C;

void func_800857C0(void) {
    s32 sp1C;
    void *sp18;
    s32 temp_a0;
    void *temp_v0;

    temp_a0 = D_80183EA0;
    temp_v0 = (temp_a0 * 0xE0) + &D_80165C18;
    if (temp_v0->unkA6 != 0) {
        sp18 = temp_v0;
        sp1C = temp_a0;
        func_80085768(temp_a0);
        func_80085534(temp_a0);
        func_8008BF18(temp_a0);
        if (temp_v0->unkA6 >= 2) {
            D_802BA05C->unk18 = temp_v0->unk4;
            D_802BA05C->unk1C = temp_v0->unk8 - 10.0;
            D_802BA05C->unk20 = temp_v0->unkC;
        }
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_800857C0.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
s16 func_80004EAC(? *, ?); // extern
? func_800721C0(?); // extern
? func_80072488(s32); // extern
? func_8008B7D4(s32, ?, ?, ?); // extern
? func_8008B80C(s32, f32, f32, f32); // extern
? func_8008B888(s32, ?, ?, ?); // extern
extern ? D_0601610C;
extern ? D_06016110;
extern f32 D_800EF3DC;
extern s32 D_80164490;
extern ? D_80165C18;

void func_80085878(s32 arg0, s32 arg1) {
    void *temp_s0;
    void *temp_v0;

    temp_s0 = (arg0 * 0xE0) + &D_80165C18;
    temp_s0->unkD8 = 1;
    temp_s0->unk70 = &D_06016110;
    temp_s0->unk74 = &D_0601610C;
    temp_s0->unkC8 = 0xA;
    temp_s0->unk0 = D_800EF3DC;
    func_800721C0(0x4000200);
    temp_s0->unk94 = (arg1 * 0x12C) + 0x1F4;
    func_8008B7D4(arg0, 0, 0xC1700000, 0);
    temp_v0 = (temp_s0->unk94 * 8) + D_80164490;
    func_8008B80C(arg0, temp_v0->unk0, temp_v0->unk2, temp_v0->unk4);
    func_8008B888(arg0, 0, 0, 0);
    temp_s0->unk34 = 4.0f;
    temp_s0->unkA4 = func_80004EAC(&D_0601610C, 0);
    func_80072488(arg0);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80085878.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80072E54(s32, ?, s16, ?, s32, s32); // extern
? func_80074344(s32, void *, ?, ?, f32, s32, s32); // extern
? func_80085878(s32); // extern
? func_800C98B8(void *, void *, ?); // extern
extern f32 D_800EF3E0;
extern ? D_80165C18;
extern s32 D_8018D40C;

void func_800859C8(s32 arg0) {
    s16 temp_v0;
    void *temp_s0;

    temp_s0 = (arg0 * 0xE0) + &D_80165C18;
    temp_v0 = temp_s0->unkA6;
    if (temp_v0 != 0) {
        if (temp_v0 != 1) {
            if (temp_v0 != 2) {

            } else {
                func_80072E54(arg0, 0, temp_s0->unkA4, 1, 0, -1);
            }
        } else {
            func_80085878(arg0);
        }
    }
    if (D_8018D40C == 0) {
        func_800C98B8(temp_s0 + 4, temp_s0 + 0x38, 0x19018057);
    }
    func_80074344(arg0, temp_s0 + 0x44, 0xBF4CCCCD, 0x3F4CCCCD, D_800EF3E0, 0, -1);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_800859C8.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_8000D940(void *, void *, s32, s32, s32); // extern
? func_80040EC4(void *, void *); // extern
? func_800859C8(s32, s32); // extern
? func_80089CBC(s32, ?); // extern
? func_8008BF18(s32); // extern
s16 func_802B5224(void *, void *); // extern
extern ? D_80165C18;
extern s32 D_80183F28;

void func_80085AA8(void) {
    s32 temp_s2;
    s32 temp_s4;
    void *temp_s0;
    void *temp_s1;
    void *temp_s3;
    s32 *phi_s5;
    s32 phi_s4;

    phi_s5 = &D_80183F28;
    phi_s4 = 0;
    do {
        temp_s2 = *phi_s5;
        temp_s0 = &D_80165C18 + (temp_s2 * 0xE0);
        if (temp_s0->unkA6 != 0) {
            func_800859C8(temp_s2, phi_s4);
            temp_s3 = temp_s0 + 0x1C;
            temp_s1 = temp_s0 + 0x28;
            func_80040EC4(temp_s3, temp_s1);
            func_8000D940(temp_s1, temp_s0 + 0x94, temp_s0->unk34, temp_s0->unk44, 0);
            temp_s0->unkC0 = func_802B5224(temp_s3, temp_s1);
            func_8008BF18(temp_s2);
            func_80089CBC(temp_s2, 0x41F00000);
        }
        temp_s4 = phi_s4 + 1;
        phi_s5 += 4;
        phi_s4 = temp_s4;
    } while (temp_s4 != 3);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80085AA8.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80072488(s32); // extern
? func_8008B80C(?, ?, ?); // extern
? func_8008B8BC(s32, ?, ?, ?); // extern
extern ? D_80165C18;

void func_80085BB4(s32 arg0) {
    *(&D_80165C18 + (arg0 * 0xE0)) = 8.0f;
    func_8008B80C(0, 0, 0);
    func_8008B8BC(arg0, 0, 0, 0x8000);
    func_80072488(arg0);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80085BB4.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80073444(s32, ? *, ? *, ?, s32); // extern
? func_80085BB4(s32); // extern
? func_8008B7D4(f32, ?, ?); // extern
extern ? D_06005400;
extern ? D_06008000;
extern f64 D_800EF3E8;
extern f32 D_8018D01C;

void func_80085C20(s32 arg0) {
    func_8008B7D4(D_8018D01C * D_800EF3E8, 0x444EC000, 0xC538D000);
    func_80073444(arg0, &D_06005400, &D_06008000, 0x40, 0x40);
    func_80085BB4(arg0);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80085C20.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
? func_800726CC(?);                                 /* extern */
? func_8007278C(?);                                 /* extern */
? func_80072D3C(?, ?, ?, s32);                      /* extern */
? func_80072E54(?, ?, ?, s32, s32);                 /* extern */
? func_80085C20();                                  /* extern */
extern ? D_80165CBE;

void func_80085CA0(s32 arg0) {
    u16 temp_t7;

    temp_t7 = *(&D_80165CBE + (arg0 * 0xE0));
    switch (temp_t7) {
    case 1:
        func_80085C20();
        return;
    case 2:
        func_80072E54(0, 4, 1, 0xC, 5);
        return;
    case 3:
        func_80072D3C(3, 4, 4, 0xA);
        return;
    case 4:
        func_8007278C(0x14);
        return;
    case 5:
        func_80072E54(0, 4, 1, 0xC, 5);
        return;
    case 6:
        func_8007278C(0x14);
        return;
    case 7:
        func_80072D3C(3, 4, 0, 0x14);
        return;
    case 8:
        func_800726CC(2);
        /* fallthrough */
    default:
        return;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80085CA0.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80073444(s32, ? *, ? *, ?, s32); // extern
? func_80085BB4(s32); // extern
? func_8008B7D4(f32, ?, ?); // extern
extern ? D_06005E00;
extern ? D_06009000;
extern f64 D_800EF418;
extern f32 D_8018D01C;

void func_80085DB8(s32 arg0) {
    func_8008B7D4(D_8018D01C * D_800EF418, 0x44952000, 0xC5B81800);
    func_80073444(arg0, &D_06005E00, &D_06009000, 0x40, 0x40);
    func_80085BB4(arg0);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80085DB8.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
? func_800726CC(?);                                 /* extern */
? func_80072B48(?);                                 /* extern */
? func_80072D3C(?, ?, ?, s32);                      /* extern */
? func_80072E54(?, ?, ?, s32, s32);                 /* extern */
? func_80085DB8();                                  /* extern */
extern ? D_80165CBE;

void func_80085E38(s32 arg0) {
    u16 temp_t7;

    temp_t7 = *(&D_80165CBE + (arg0 * 0xE0));
    switch (temp_t7) {
    case 1:
        func_80085DB8();
        return;
    case 2:
        func_80072E54(0, 4, 1, 0xC, 1);
        return;
    case 3:
        func_80072D3C(3, 4, 0xC, 1);
        return;
    case 4:
        func_80072B48(0xC);
        return;
    case 5:
        func_800726CC(2);
        /* fallthrough */
    default:
        return;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80085E38.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80073444(s32, ? *, ? *, ?, s32); // extern
? func_80085BB4(s32); // extern
? func_8008B7D4(f32, ?, ?); // extern
extern ? D_06006800;
extern ? D_0600A000;
extern f64 D_800EF438;
extern f32 D_8018D01C;

void func_80085EF8(s32 arg0) {
    func_8008B7D4(D_8018D01C * D_800EF438, 0x440AC000, 0);
    func_80073444(arg0, &D_06006800, &D_0600A000, 0x40, 0x40);
    func_80085BB4(arg0);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80085EF8.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
? func_800726CC(?);                                 /* extern */
? func_8007278C(?);                                 /* extern */
? func_80072B48(?);                                 /* extern */
? func_80072C00(?, ?, ?);                           /* extern */
? func_80072E54(?, ?, ?, s32, s32);                 /* extern */
? func_80072F88(?, ?, ?, s32, s32);                 /* extern */
? func_80085EF8();                                  /* extern */
extern ? D_80165CBE;

void func_80085F74(s32 arg0) {
    u16 temp_t7;

    temp_t7 = *(&D_80165CBE + (arg0 * 0xE0));
    switch (temp_t7) {
    case 1:
        func_80085EF8();
        return;
    case 2:
        func_80072E54(0, 4, 1, 5, 1);
        return;
    case 3:
        func_8007278C(0x1E);
        return;
    case 4:
        func_80072C00(4, 0, 7);
        return;
    case 5:
        func_8007278C(0x1E);
        return;
    case 6:
        func_80072F88(3, 0, 1, 5, 1);
        return;
    case 7:
        func_80072B48(0xF);
        return;
    case 8:
        func_800726CC(2);
        /* fallthrough */
    default:
        return;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80085F74.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80073444(s32, void *, void *, ?, s32); // extern
? func_80085BB4(s32); // extern
? func_8008B7D4(f32, s32, s32); // extern
extern ? D_06007200;
extern ? D_0600B000;
extern ? D_800E6734;
extern f32 D_8018D01C;

void func_80086074(s32 arg0, s32 arg1) {
    void *temp_v0;

    temp_v0 = (arg1 * 0xC) + &D_800E6734;
    func_8008B7D4(temp_v0->unk0 * D_8018D01C, temp_v0->unk4, temp_v0->unk8);
    func_80073444(arg0, (arg1 << 9) + &D_06007200, (arg1 << 0xC) + &D_0600B000, 0x40, 0x40);
    func_80085BB4(arg0);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80086074.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80086074(); // extern
extern ? D_80165CBE;

void func_80086110(s32 arg0) {
    s16 temp_v0;

    temp_v0 = *(&D_80165CBE + (arg0 * 0xE0));
    if ((temp_v0 != 0) && (temp_v0 == 1)) {
        func_80086074();
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80086110.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80085CA0(s32, s32); // extern
? func_80085E38(s32, s32); // extern
? func_80085F74(s32, s32); // extern
? func_80086110(s32, s32, s32); // extern

void func_80086158(s32 arg0, s32 arg1) {
    s32 temp_a2;
    s32 phi_a2;

    temp_a2 = arg1;
    phi_a2 = temp_a2;
    if (arg1 != 0) {
        if (arg1 != 1) {
            if (arg1 != 2) {

            } else {
                arg1 = temp_a2;
                func_80085F74(arg0, temp_a2);
                goto block_7;
            }
        } else {
            arg1 = temp_a2;
            func_80085E38(arg0, temp_a2);
            goto block_7;
        }
    } else {
        arg1 = temp_a2;
        func_80085CA0(arg0, temp_a2);
block_7:
        phi_a2 = arg1;
    }
    if (phi_a2 >= 3) {
        func_80086110(arg0, phi_a2 - 3, phi_a2);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80086158.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800734DC(s32); // extern
? func_80086158(s32, s32); // extern
? func_8008BF18(s32); // extern
extern ? D_80165C18;
extern s32 D_80183EA0;

void func_800861E0(void) {
    s32 temp_s0;
    s32 temp_s2;
    void *temp_s1;
    s32 *phi_s3;
    s32 phi_s2;

    phi_s3 = &D_80183EA0;
    phi_s2 = 0;
    do {
        temp_s0 = *phi_s3;
        temp_s1 = &D_80165C18 + (temp_s0 * 0xE0);
        if (temp_s1->unkA6 != 0) {
            func_80086158(temp_s0, phi_s2);
            if (temp_s1->unkA6 >= 2) {
                func_800734DC(temp_s0);
                func_8008BF18(temp_s0);
            }
        }
        temp_s2 = phi_s2 + 1;
        phi_s3 += 4;
        phi_s2 = temp_s2;
    } while (temp_s2 != 0xA);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_800861E0.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80072488(s32); // extern
? func_8008B7D4(s32, f32, f32, f32); // extern
? func_8008B80C(s32, ?, ?, ?); // extern
? func_8008B888(s32, ?, ?, ?); // extern
extern ? D_0B0075F0;
extern ? D_0B008040;
extern ? D_0B008A90;
extern ? D_800E634C;
extern ? D_80165C18;

void func_8008629C(s32 arg0, s32 arg1) {
    void *sp20;
    void *temp_v0;
    void *temp_v0_2;
    void *temp_v0_3;
    void *phi_v0;

    if (arg1 != 0) {
        if (arg1 != 1) {
            if (arg1 != 2) {
                phi_v0 = (arg0 * 0xE0) + &D_80165C18;
            } else {
                temp_v0 = (arg0 * 0xE0) + &D_80165C18;
                temp_v0->unk70 = &D_0B008A90;
                temp_v0->unk4C = 0x1E;
                phi_v0 = temp_v0;
            }
        } else {
            temp_v0_2 = (arg0 * 0xE0) + &D_80165C18;
            temp_v0_2->unk70 = &D_0B008040;
            temp_v0_2->unk4C = 0x2B;
            phi_v0 = temp_v0_2;
        }
    } else {
        temp_v0_3 = (arg0 * 0xE0) + &D_80165C18;
        temp_v0_3->unk70 = &D_0B0075F0;
        temp_v0_3->unk4C = 0x38;
        phi_v0 = temp_v0_3;
    }
    phi_v0->unk0 = 1.0f;
    sp20 = phi_v0;
    func_8008B7D4(arg0, D_800E634C.unk0 - 1.5, D_800E634C.unk2, D_800E634C.unk4);
    func_8008B80C(arg0, 0, 0xC1200000, 0);
    func_8008B888(arg0, 0, 0xF8E4, 0);
    phi_v0->unk48 = 0;
    func_80072488(arg0);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_8008629C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80086F60(s32); // extern
? func_80086FD4(s32); // extern
? func_800877C4(s32); // extern
? func_8008BF18(s32); // extern
extern f64 D_800EF468;
extern ? D_80165C18;

void func_80086424(s32 arg0) {
    void *sp20;
    s16 temp_v1;
    void *temp_v0;

    temp_v0 = (arg0 * 0xE0) + &D_80165C18;
    temp_v1 = temp_v0->unkAE;
    if (temp_v1 != 0) {
        if (temp_v1 != 1) {
            if (temp_v1 != 2) {

            } else {
                if (temp_v0->unk2C >= -2.0) {
                    temp_v0->unk3C = temp_v0->unk3C - D_800EF468;
                }
                sp20 = temp_v0;
                func_800877C4(arg0);
                if (temp_v0->unk2C >= 0.0) {
                    temp_v0->unk2C = 0.0f;
                    temp_v0->unk3C = 0.0f;
                    func_80086F60(arg0);
                }
            }
        } else {
            temp_v0->unk3C = 0.75f;
            func_80086FD4(arg0);
        }
    }
    func_8008BF18(arg0);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80086424.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80072488(s32, s32, s32, s32); // extern
s32 func_8007278C(s32, s32, s32, s32); // extern
? func_8008629C(s32, s32, s32, s32); // extern
? func_80086E70(s32); // extern
? func_80091440(s8); // extern
extern ? D_80165C18;

void func_80086528(s32 arg0, s32 arg1) {
    s16 temp_v0;
    s32 temp_a0;
    s32 temp_a2;
    s32 temp_a3;
    void *temp_v1;

    temp_v1 = (arg0 * 0xE0) + &D_80165C18;
    temp_v0 = temp_v1->unkA6;
    temp_a2 = arg0;
    temp_a3 = arg1;
    if (temp_v0 != 0) {
        if (temp_v0 != 1) {
            temp_a0 = temp_a2;
            if (temp_v0 != 2) {
                if (temp_v0 != 3) {
                    return;
                }
                if (temp_v1->unkAE == 0) {
                    temp_v1->unk48 = 1;
                    func_80072488(temp_a2, 1, temp_a2, temp_a3);
                }
                // Duplicate return node #10. Try simplifying control flow for better match
                return;
            }
            arg0 = temp_a2;
            arg1 = temp_a3;
            if (func_8007278C(temp_a0, temp_v1->unk4C, temp_a2, temp_a3) != 0) {
                arg0 = arg0;
                func_80091440(arg1);
                func_80086E70(arg0);
                func_80072488(arg0);
                return;
            }
            // Duplicate return node #10. Try simplifying control flow for better match
            return;
        }
        func_8008629C(temp_a2, temp_a3, temp_a2, temp_a3);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80086528.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800723A4(s32, ?); // extern
? func_80086424(s32); // extern
? func_80086528(s32, s32); // extern
extern s16 D_8016347C;
extern s8 D_801658C6;
extern ? D_80165C18;
extern s32 D_80183EA0;
extern ? D_80183EAC;
extern s8 D_802874F5;

void func_80086604(void) {
    s32 *temp_s1;
    s32 temp_s0;
    s32 temp_s2;
    s32 *phi_s1;
    s32 *phi_s1_2;
    s32 phi_s2;

    if ((D_8016347C != 0) && (D_802874F5 < 3)) {
        phi_s1 = &D_80183EA0;
        if (D_801658C6 == 0) {
            do {
                func_800723A4(*phi_s1, 0);
                temp_s1 = phi_s1 + 4;
                phi_s1 = temp_s1;
            } while (temp_s1 != &D_80183EAC);
            D_801658C6 = 1;
        }
    }
    phi_s1_2 = &D_80183EA0;
    phi_s2 = 0;
    do {
        temp_s0 = *phi_s1_2;
        if ((&D_80165C18 + (temp_s0 * 0xE0))->unkA6 != 0) {
            func_80086528(temp_s0, phi_s2);
            func_80086424(temp_s0);
        }
        temp_s2 = phi_s2 + 1;
        phi_s1_2 += 4;
        phi_s2 = temp_s2;
    } while (temp_s2 != 3);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80086604.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80072488(s32); // extern
? func_80086E70(s32); // extern
? func_8008B7D4(s32, s32, f32, s32); // extern
? func_8008B80C(s32, ?, ?, ?); // extern
? func_8008B888(s32, ?, ?, ?); // extern
extern ? D_0B0069D8;
extern ? D_0B006A28;
extern ? D_0B006A78;
extern ? D_0B006AC8;
extern ? D_0B006B18;
extern ? D_0B006B68;
extern f32 D_800EF470;
extern ? D_80165C18;
extern s32 D_80183F28;
extern s8 D_802874F5;

void func_80086700(s32 arg0) {
    void *sp20;
    s8 temp_v0;
    s8 temp_v0_5;
    void *temp_v0_2;
    void *temp_v0_3;
    void *temp_v0_4;
    void *temp_v0_6;
    void *temp_v0_7;
    void *temp_v0_8;
    void *temp_v1;
    void *phi_v0;

    if (gCCSelection < CC_150) {
        temp_v0 = D_802874F5;
        if (temp_v0 != 0) {
            if (temp_v0 != 1) {
                if (temp_v0 != 2) {
                    phi_v0 = (arg0 * 0xE0) + &D_80165C18;
                } else {
                    temp_v0_2 = (arg0 * 0xE0) + &D_80165C18;
                    temp_v0_2->unk70 = &D_0B006B18;
                    phi_v0 = temp_v0_2;
                }
            } else {
                temp_v0_3 = (arg0 * 0xE0) + &D_80165C18;
                temp_v0_3->unk70 = &D_0B006A78;
                phi_v0 = temp_v0_3;
            }
        } else {
            temp_v0_4 = (arg0 * 0xE0) + &D_80165C18;
            temp_v0_4->unk70 = &D_0B0069D8;
            phi_v0 = temp_v0_4;
        }
    } else {
        temp_v0_5 = D_802874F5;
        if (temp_v0_5 != 0) {
            if (temp_v0_5 != 1) {
                if (temp_v0_5 != 2) {
                    phi_v0 = (arg0 * 0xE0) + &D_80165C18;
                } else {
                    temp_v0_6 = (arg0 * 0xE0) + &D_80165C18;
                    temp_v0_6->unk70 = &D_0B006B68;
                    phi_v0 = temp_v0_6;
                }
            } else {
                temp_v0_7 = (arg0 * 0xE0) + &D_80165C18;
                temp_v0_7->unk70 = &D_0B006AC8;
                phi_v0 = temp_v0_7;
            }
        } else {
            temp_v0_8 = (arg0 * 0xE0) + &D_80165C18;
            temp_v0_8->unk70 = &D_0B006A28;
            phi_v0 = temp_v0_8;
        }
    }
    phi_v0->unk0 = D_800EF470;
    temp_v1 = (D_80183F28 * 0xE0) + &D_80165C18;
    sp20 = phi_v0;
    func_8008B7D4(arg0, temp_v1->unk4, temp_v1->unk8 + 16.0, temp_v1->unkC);
    func_8008B80C(arg0, 0, 0, 0);
    func_8008B888(arg0, 0, 0, 0);
    phi_v0->unk86 = 0x200;
    func_80072488(arg0);
    func_80086E70(arg0);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80086700.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
? f32_step_towards(void *, ?, ?);                      /* extern */
? func_80086F60(s32);                               /* extern */
? func_80086FD4(s32);                               /* extern */
? func_8008701C(s32, ?);                            /* extern */
s32 func_800871AC(s32, ?);                          /* extern */
? func_800877C4(s32);                               /* extern */
? func_80087C48(s32, ?, ?, ?);                      /* extern */
? func_8008BF18(s32);                               /* extern */
? func_8009265C();                                  /* extern */
extern ? D_80165C18;

void func_80086940(s32 arg0) {
    s8 temp_v0;
    u16 temp_t8;
    void *temp_s0;

    temp_s0 = (arg0 * 0xE0) + &D_80165C18;
    temp_t8 = temp_s0->unkAE;
    switch (temp_t8) {
    case 1:
        func_80086FD4(arg0);
        break;
    case 2:
        f32_step_towards(temp_s0, 0x3CCCCCCD, 0x3A83126F);
        func_80087C48(arg0, 0x40C00000, 0x3DCCCCCD, 0xC8);
        if (temp_s0->unk3C <= 0.0) {
            func_8008701C(arg0, 3);
        }
        break;
    case 3:
        func_800871AC(arg0, 0x64);
        break;
    case 4:
        D_801658D6 = 1;
        temp_s0->unk3C = -0.4f;
        func_80086FD4(arg0);
        temp_s0->unk14 = 90.0f;
        temp_s0->unk2C = 60.0f;
        temp_v0 = D_802874F5;
        if (temp_v0 != 1) {
            if (temp_v0 != 2) {

            } else {
                temp_s0->unk10 = temp_s0->unk10 - 2.0;
                temp_s0->unk18 = temp_s0->unk18 - 15.0;
            }
        } else {
            temp_s0->unk10 = temp_s0->unk10 - 3.0;
            temp_s0->unk18 = temp_s0->unk18 + 15.0;
        }
        break;
    case 5:
        if (temp_s0->unk2C <= 8.0) {
            f32_step_towards(temp_s0 + 0x3C, 0xBDCCCCCD, 0xBC23D70A);
        }
        func_800877C4(arg0);
        if (temp_s0->unk2C <= 0.0) {
            func_80086FD4(arg0);
        }
        break;
    case 6:
        if (func_800871AC(arg0, 0x41) != 0) {
            D_801658F4 = 1;
        }
        break;
    case 7:
        if (func_800871AC(arg0, 0x64) != 0) {
            func_8009265C();
            func_80086F60(arg0);
        }
        break;
    }
    if (D_801658D6 != 0) {
        temp_s0->unkC0 = 0xE800;
        temp_s0->unkC2 = 0xDA00;
        temp_s0->unkBE = temp_s0->unkBE + 0x400;
    } else {
        temp_s0->unkBE = temp_s0->unkBE + 0x400;
        temp_s0->unkC0 = temp_s0->unkC0 - 0x200;
    }
    func_8008BF18(arg0);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80086940.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80086700(); // extern
extern ? D_80165CBE;

void func_80086C14(s32 arg0) {
    s16 temp_v0;

    temp_v0 = *(&D_80165CBE + (arg0 * 0xE0));
    if (temp_v0 != 0) {
        if (temp_v0 != 1) {
            if (temp_v0 != 2) {
                return;
            }
            // Duplicate return node #5. Try simplifying control flow for better match
            return;
        }
        func_80086700();
        // Duplicate return node #5. Try simplifying control flow for better match
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80086C14.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800773D8(f32 *, s8); // extern
extern s8 D_801658F4;
extern ? D_80165C18;

void func_80086C6C(s32 arg0) {
    f32 sp2C;
    f32 sp28;
    f32 sp24;
    void *sp20;
    f32 temp_f16;
    s32 temp_v0;
    s8 temp_a1;
    void *temp_v1;
    f32 phi_f16;

    temp_v0 = random_int(0xA);
    temp_v1 = (arg0 * 0xE0) + &D_80165C18;
    temp_f16 = temp_v0;
    phi_f16 = temp_f16;
    if (temp_v0 < 0) {
        phi_f16 = temp_f16 + 4294967296.0f;
    }
    sp20 = temp_v1;
    sp24 = phi_f16 + (temp_v1->unk4 - 5.0f);
    temp_a1 = D_801658F4;
    sp2C = random_int(0xA) + (temp_v1->unkC - 5.0f);
    if (temp_a1 != 0) {
        sp28 = temp_v1->unk8 + 14.0;
    } else {
        sp28 = temp_v1->unk8 - 2.0;
    }
    func_800773D8(&sp24, temp_a1);
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80086C6C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800723A4(s32, ?); // extern
? func_80086940(s32); // extern
? func_80086C14(s32); // extern
? func_80086C6C(s32); // extern
extern s32 D_8016559C;
extern s8 D_801658CE;
extern s8 D_801658DC;
extern s8 D_801658F4;
extern ? D_80165CBE;
extern s32 D_80183EAC;

void func_80086D80(void) {
    s32 temp_s0;
    s32 temp_s2;
    s32 phi_s0;

    if ((D_801658CE != 0) && (D_801658DC == 0)) {
        func_800723A4(D_80183EAC, 0);
        D_801658DC = 1;
    }
    temp_s2 = D_80183EAC;
    if (*(&D_80165CBE + (temp_s2 * 0xE0)) != 0) {
        func_80086C14(temp_s2);
        func_80086940(temp_s2);
        phi_s0 = 0;
        if (D_801658F4 != 0) {
            if (D_8016559C == 0) {
                func_80086C6C(temp_s2);
                return;
            }
            // Duplicate return node #8. Try simplifying control flow for better match
            return;
        }
        do {
            func_80086C6C(temp_s2);
            temp_s0 = phi_s0 + 1;
            phi_s0 = temp_s0;
        } while (temp_s0 != 2);
        // Duplicate return node #8. Try simplifying control flow for better match
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_80071F00/func_80086D80.s")
#endif
