#include <ultra64.h>
#include <macros.h>
#include <common_structs.h>
#include <defines.h>
#include "camera.h"

Camera cameras[4];
Camera *camera1 = &cameras[0];
Camera *camera2 = &cameras[1];
Camera *camera3 = &cameras[2];
Camera *camera4 = &cameras[3];

#ifdef MIPS_TO_C
//generated by m2c commit 3b40ab93768f52ac241c5ae84ef58ef6bc4cb1de
? func_80014DE4(s32, s32, s32, Camera *);           /* extern */
extern ? D_80152300;
extern ? D_80164498;
extern ? D_80164678;
extern ? D_801649D8;
extern ? D_801649E8;
extern ? D_801649F8;
extern ? D_80164A08;
extern ? D_80164A18;
extern s32 D_80164A2C;
extern f32 D_80164A30;
extern ? D_80164A38;
extern ? D_80164A48;
extern ? D_80164A78;
extern s8 D_80164A88;
extern s8 D_80164A89;
extern ? D_80164A90;
extern ? D_80164AA0;
static ?32 D_800DDB30[4] = { 0x3ECCCCCD, 0x3F19999A, 0x3E8CCCCD, 0x3E99999A };

void func_8001C4D0(f32 posX, f32 posY, f32 posZ, s16 rot, u32 arg4, s32 cameraId) {
    Camera *sp30;
    s32 sp2C;
    s32 sp28;
    f32 *sp24;
    f32 *sp20;
    ?32 *sp1C;
    ?32 *temp_t3;
    Camera *temp_a3;
    Camera *temp_a3_2;
    Player *temp_v1;
    f32 *temp_t1;
    f32 *temp_t2;
    f32 *temp_v0_2;
    f32 *temp_v0_3;
    s16 *temp_a0;
    s32 temp_t6;
    s32 temp_t6_2;
    s32 temp_v0;

    temp_t6 = cameraId * 2;
    *(&D_80152300 + temp_t6) = (s16) arg4;
    switch (arg4) {
    case 0:
    case 1:
    case 3:
    case 8:
    case 9:
    case 10:
        D_80164A89 = 0;
        temp_a3 = &cameras[cameraId];
        temp_a3->pos[0] = posX;
        temp_a3->pos[1] = posY;
        temp_a3->pos[2] = posZ;
        temp_a3->rotZ = 0;
        temp_a3->lookAt[2] = 150.0f;
        temp_a3->lookAt[1] = (f32) ((f64) posY - 3.0);
        temp_a3->lookAt[0] = 0.0f;
        temp_a3->up[0] = 0.0f;
        temp_a3->up[2] = 0.0f;
        temp_a3->up[1] = 1.0f;
        temp_a3->unk_B0 = 0;
        temp_a3->unk_A0 = 0.0f;
        temp_a3->playerId = (s16) cameraId;
        temp_t6_2 = cameraId * 4;
        *(&D_801649D8 + temp_t6_2) = 20.0f;
        *(&D_801649E8 + temp_t6_2) = 10.0f;
        *(&D_801649F8 + temp_t6_2) = 7.0f;
        D_80164A2C = 0;
        D_80164A30 = 30.0f;
        temp_t1 = temp_t6_2 + &D_80164A38;
        temp_t2 = temp_t6_2 + &D_80164A48;
        *temp_t1 = 0.0f;
        *temp_t2 = 0.0f;
        *(&D_80164A90 + temp_t6_2) = 0.0f;
        *(&D_80164AA0 + temp_t6_2) = 0.0f;
        temp_t3 = temp_t6_2 + &D_80164A78;
        *temp_t3 = D_800DDB30[gActiveScreenMode];
        *(&D_80164A18 + temp_t6_2) = 0;
        *(&D_80164A08 + temp_t6_2) = 0;
        *(&D_80164498 + temp_t6_2) = 0.0f;
        temp_a3->unk_9C = 0;
        temp_a3->unk_94 = 0.0f;
        temp_v1 = &gPlayerOne[cameraId];
        temp_a3->unk2C = (s16) temp_v1->unk_02E;
        temp_a3->unk_AC = temp_v1->unk_02E;
        temp_v0 = gActiveScreenMode;
        switch (temp_v0) {                          /* switch 1; irregular */
        case 0:                                     /* switch 1 */
        case 2:                                     /* switch 1 */
            if (gModeSelection == 3) {
                temp_a3->unk_30[0] = 0.0f;
                temp_a3->unk_3C[0] = 0.0f;
                temp_a3->unk_3C[1] = 0.0f;
                temp_a3->unk_30[1] = 11.6f;
                temp_a3->unk_30[2] = -38.5f;
                temp_a3->unk_3C[2] = 19.2f;
                D_80164A88 = 0;
            } else {
                temp_a3->unk_30[0] = 0.0f;
                temp_a3->unk_3C[0] = 0.0f;
                temp_a3->unk_3C[1] = 0.0f;
                temp_a3->unk_30[1] = 9.5f;
                temp_a3->unk_30[2] = -50.0f;
                temp_a3->unk_3C[2] = 70.0f;
            }
            break;
        case 1:                                     /* switch 1 */
            if (gModeSelection == 3) {
                temp_a3->unk_30[0] = 0.0f;
                temp_a3->unk_3C[0] = 0.0f;
                temp_a3->unk_3C[1] = 0.0f;
                temp_a3->unk_30[1] = 11.6f;
                temp_a3->unk_30[2] = -38.5f;
                temp_a3->unk_3C[2] = 19.2f;
            } else {
                temp_a3->unk_30[0] = 0.0f;
                temp_a3->unk_3C[0] = 0.0f;
                temp_a3->unk_3C[1] = 0.0f;
                temp_a3->unk_3C[2] = 30.0f;
                temp_a3->unk_30[1] = 9.6f;
                temp_a3->unk_30[2] = -35.0f;
            }
            break;
        case 3:                                     /* switch 1 */
            if (gModeSelection == 3) {
                temp_a3->unk_30[0] = 0.0f;
                temp_a3->unk_3C[0] = 0.0f;
                temp_a3->unk_3C[1] = 0.0f;
                temp_a3->unk_30[1] = 11.6f;
                temp_a3->unk_30[2] = -38.5f;
                temp_a3->unk_3C[2] = 19.2f;
            } else {
                temp_a3->unk_30[0] = 0.0f;
                temp_a3->unk_3C[0] = 0.0f;
                temp_a3->unk_3C[1] = 0.0f;
                temp_a3->unk_30[1] = 9.0f;
                temp_a3->unk_30[2] = -40.0f;
                temp_a3->unk_3C[2] = 18.0f;
            }
            break;
        }
        sp28 = temp_t6_2;
        sp2C = temp_t6;
        sp30 = temp_a3;
        sp24 = temp_t1;
        sp20 = temp_t2;
        sp1C = temp_t3;
        func_80014DE4(cameraId, temp_t6_2, temp_t6, temp_a3);
        temp_a0 = temp_t6 + &D_80164678;
        if (*temp_a0 == 0) {
            if (D_80164A28 == 1) {
                D_80150130[cameraId] = 80.0f;
            } else {
                D_80150130[cameraId] = 40.0f;
            }
            temp_a3->unk_B4 = D_80150130[cameraId];
        }
        if (*temp_a0 == (s16) 1) {
            temp_v0_2 = &D_80150130[cameraId];
            if (D_80164A28 == 1) {
                *temp_v0_2 = 100.0f;
            } else {
                *temp_v0_2 = 60.0f;
            }
            temp_a3->unk_B4 = *temp_v0_2;
        }
        if (*temp_a0 == 2) {
            temp_v0_3 = &D_80150130[cameraId];
            if (D_80164A28 == 1) {
                *temp_v0_3 = 100.0f;
            } else {
                *temp_v0_3 = 60.0f;
            }
            temp_a3->unk_B4 = *temp_v0_3;
            *temp_t1 = 20.0f;
            *temp_t2 = 1.5f;
            *temp_t3 = 0x3F800000;
        }
        break;
    }
    temp_a3_2 = &cameras[cameraId];
    func_802B7F7C(temp_a3_2->pos, temp_a3_2->lookAt, temp_a3_2->rot);
}
#else
GLOBAL_ASM("asm/non_matchings/camera/func_8001C4D0.s")
#endif

void func_8001CA10(Camera *camera) {
    camera->unk_9C = 0;
    camera->unk_94 = 6.0f;
}

void func_8001CA24(Player *player, f32 arg1) {
    Camera *camera = &cameras[0];

    if (player == gPlayerTwo) {
        camera += 1;
    }
    if (player == gPlayerThree) {
        camera += 2;
    }
    if (player == gPlayerFour) {
        camera += 3;
    }
    camera->unk_9C = 0;
    camera->unk_94 = arg1;
}

#ifdef MIPS_TO_C
//generated by m2c commit bece1d6db17040749f77dbbd090363cc6fb926f9
? func_802B6540(f32 *, ?, f32, ?, s32);             /* extern */
extern f32 D_80164A30;
s16 gCurrentCourseId;                               /* unable to generate initializer */

void func_8001CA78(s32 arg0, Camera *camera, f32 *arg2, f32 *arg3, f32 *arg4, f32 *arg5) {
    f32 sp74;
    f32 sp70;
    f32 sp6C;
    f32 sp68;
    f32 sp64;
    f32 sp60;
    f32 sp5C;
    f32 sp4C;
    f32 sp48;
    f32 sp44;
    f32 temp_f0;
    f32 temp_f12;
    f32 temp_f16;
    f32 temp_f18;
    f32 temp_f2;
    f32 var_f14;
    f32 var_f14_2;
    struct TrackWayPoint *temp_s2;

    sp68 = camera->unk_30[0];
    sp6C = camera->unk_30[1];
    sp70 = camera->unk_30[2];
    sp5C = camera->unk_3C[0];
    sp60 = camera->unk_3C[1];
    sp64 = camera->unk_3C[2];
    arg2->unk0 = camera->lookAt[0];
    temp_s2 = &(*D_80164550)[*gWaypointCountByPathIndex - 0xA];
    arg2->unk4 = (f32) camera->lookAt[1];
    arg2->unk8 = (f32) camera->lookAt[2];
    func_802B6540(&sp74, 0, 1.0f, 0, -0x00008000);
    func_802B63B8(&sp5C, &sp74);
    if (gCurrentCourseId == 0x000A) {
        var_f14 = sp5C;
    } else {
        var_f14 = sp5C + (f32) temp_s2->wayPointX;
    }
    arg2->unk0 += (var_f14 - camera->lookAt[0]) * 1.0f;
    arg2->unk4 = (f32) (arg2->unk4 + (((sp60 + ((f32) temp_s2->wayPointY + D_80164A30)) - camera->lookAt[1]) * 1.0f));
    arg2->unk8 = (f32) (arg2->unk8 + (((sp64 + (bitwise f32) D_8016524C) - camera->lookAt[2]) * 1.0f));
    func_802B63B8(&sp68, &sp74);
    if (gCurrentCourseId == 0x000A) {
        var_f14_2 = sp68;
    } else {
        var_f14_2 = sp68 + (f32) temp_s2->wayPointX;
    }
    sp4C = var_f14_2;
    temp_f16 = sp70 + (bitwise f32) D_8016524C;
    sp44 = temp_f16;
    temp_f18 = sp6C + ((f32) temp_s2->wayPointY + D_80164A30 + 6.0f);
    sp48 = temp_f18;
    move_f32_towards(&D_80164A30, 0.0f, 0.02f);
    temp_f0 = camera->pos[0];
    *arg3 = ((var_f14_2 - temp_f0) * 1.0f) + temp_f0;
    temp_f2 = camera->pos[1];
    *arg4 = ((temp_f18 - temp_f2) * 1.0f) + temp_f2;
    temp_f12 = camera->pos[2];
    *arg5 = ((temp_f16 - temp_f12) * 1.0f) + temp_f12;
}
#else
GLOBAL_ASM("asm/non_matchings/camera/func_8001CA78.s")
#endif

#ifdef MIPS_TO_C
//generated by m2c commit bece1d6db17040749f77dbbd090363cc6fb926f9
? func_802B6540(f32 *, ?, ?, ?, s32);               /* extern */
extern ? D_80164A38;
extern ? D_80164A48;
extern ? D_80164A78;
extern ? D_80164A90;
extern ? D_80164AA0;
static f32 D_800DDB30[4] = { 0.4f, 0.6f, 0.275f, 0.3f };
s16 gCurrentCourseId;                               /* unable to generate initializer */

void func_8001CCEC(Player *player, Camera *camera, f32 *arg2, f32 *arg3, f32 *arg4, f32 *arg5, s16 arg7, s16 arg8, s16 arg8) {
    f32 sp9C;
    f32 sp98;
    f32 sp94;
    f32 sp90;
    f32 sp8C;
    f32 sp88;
    f32 sp84;
    f32 sp5C;
    f32 sp50;
    f32 *sp44;
    f32 *sp40;
    f32 *sp3C;
    f32 *sp38;
    f32 *sp34;
    f32 *temp_a0;
    f32 *temp_a0_10;
    f32 *temp_a0_11;
    f32 *temp_a0_12;
    f32 *temp_a0_2;
    f32 *temp_a0_3;
    f32 *temp_a0_4;
    f32 *temp_a0_5;
    f32 *temp_a0_6;
    f32 *temp_a0_7;
    f32 *temp_a0_8;
    f32 *temp_a0_9;
    f32 *var_v1_2;
    f32 temp_f0;
    f32 temp_f0_2;
    f32 temp_f0_3;
    f32 temp_f0_4;
    f32 temp_f0_5;
    f32 temp_f12;
    f32 temp_f16;
    f32 temp_f2;
    f32 var_f0;
    f32 var_f16;
    f32 var_f16_2;
    f32 var_f18;
    f32 var_f2;
    s16 var_v0;
    s16 var_v1;
    s32 temp_v0;
    s32 var_s2;

    var_v1 = player->unk_DB4 + 1;
    var_f2 = player->unk_DBC;
    temp_f0 = (f32) ((f64) ((f32) var_v1 * var_f2) - (0.7 * (f64) (var_v1 * var_v1)));
    var_f18 = temp_f0;
    if ((var_v1 != 0) && (temp_f0 < 0.0f)) {
        var_v1 = 0;
        var_f2 = (f32) ((f64) var_f2 * 0.8);
        if ((f64) var_f2 <= 0.1) {
            var_f2 = 0.0f;
        }
    }
    if (var_f18 <= 0.0f) {
        var_f18 = 0.0f;
    }
    player->unk_DB4 = var_v1;
    player->unk_DBC = var_f2;
    var_v0 = camera->unk_9C + 1;
    var_f0 = camera->unk_94;
    var_s2 = arg8 * 4;
    temp_a0 = var_s2 + &D_80164A38;
    temp_f12 = (f32) ((f64) ((f32) var_v0 * var_f0) - (1.25 * (f64) (var_v0 * var_v0)));
    var_f16 = temp_f12;
    if ((var_v0 != 0) && (temp_f12 < 0.0f)) {
        var_v0 = 0;
        var_f0 = (f32) ((f64) var_f0 * 0.9);
        if ((f64) var_f0 <= 0.1) {
            var_f0 = 0.0f;
        }
    }
    if (var_f16 <= 0.0f) {
        var_f16 = 0.0f;
    }
    camera->unk_9C = var_v0;
    camera->unk_94 = var_f0;
    if ((&D_80164A38 + (arg8 * 2))->unk4678 == 2) {
        sp44 = temp_a0;
        sp50 = var_f16;
        sp5C = var_f18;
        move_f32_towards(temp_a0, 20.0f, 0.1f);
        temp_a0_2 = var_s2 + &D_80164A48;
        sp40 = temp_a0_2;
        move_f32_towards(temp_a0_2, 1.5f, 0.1f);
        var_v1_2 = var_s2 + &D_80164A78;
        *var_v1_2 = (f32) ((f64) *var_v1_2 + 0.1);
        if (*var_v1_2 >= 1.0f) {
            *var_v1_2 = 1.0f;
        }
    } else {
        var_s2 = arg8 * 4;
        temp_a0_3 = var_s2 + &D_80164A38;
        sp44 = temp_a0_3;
        sp50 = var_f16;
        sp5C = var_f18;
        move_f32_towards(temp_a0_3, 0.0f, 0.1f);
        temp_a0_4 = var_s2 + &D_80164A48;
        sp40 = temp_a0_4;
        move_f32_towards(temp_a0_4, 0.0f, 0.1f);
        var_v1_2 = var_s2 + &D_80164A78;
        *var_v1_2 = (f32) ((f64) *var_v1_2 - 0.1);
        temp_f0_2 = D_800DDB30[gActiveScreenMode];
        if (*var_v1_2 <= temp_f0_2) {
            *var_v1_2 = temp_f0_2;
        }
    }
    if ((player->unk_0CA & 0x100) == 0x100) {
        temp_v0 = gActiveScreenMode;
        if ((temp_v0 == 1) || (temp_v0 == 2) || (temp_v0 == 3)) {
            temp_a0_5 = var_s2 + &D_80164A90;
            sp38 = temp_a0_5;
            sp3C = var_v1_2;
            move_f32_towards(temp_a0_5, 20.0f, 0.02f);
            temp_a0_6 = var_s2 + &D_80164AA0;
            sp34 = temp_a0_6;
            move_f32_towards(temp_a0_6, 10.0f, 0.02f);
        } else if (gCurrentCourseId == 4) {
            temp_a0_7 = var_s2 + &D_80164A90;
            sp38 = temp_a0_7;
            sp3C = var_v1_2;
            move_f32_towards(temp_a0_7, 50.0f, 0.04f);
            temp_a0_8 = var_s2 + &D_80164AA0;
            sp34 = temp_a0_8;
            move_f32_towards(temp_a0_8, 35.0f, 0.04f);
        } else {
            temp_a0_9 = var_s2 + &D_80164A90;
            sp38 = temp_a0_9;
            sp3C = var_v1_2;
            move_f32_towards(temp_a0_9, 40.0f, 0.02f);
            temp_a0_10 = var_s2 + &D_80164AA0;
            sp34 = temp_a0_10;
            move_f32_towards(temp_a0_10, 20.0f, 0.02f);
        }
    } else {
        temp_a0_11 = var_s2 + &D_80164A90;
        sp38 = temp_a0_11;
        sp3C = var_v1_2;
        move_f32_towards(temp_a0_11, 0.0f, 0.04f);
        temp_a0_12 = var_s2 + &D_80164AA0;
        sp34 = temp_a0_12;
        move_f32_towards(temp_a0_12, 0.0f, 0.04f);
    }
    sp90 = camera->unk_30[0];
    sp94 = (f32) ((f64) *sp34 + (((f64) camera->unk_30[1] + ((f64) player->unk_DD2 * 0.85)) - (f64) *sp40) + (f64) (sp50 / 2.0f));
    sp98 = *sp44 + (camera->unk_30[2] + sp5C);
    sp84 = camera->unk_3C[0];
    sp88 = (f32) ((f64) camera->unk_3C[1] + ((f64) player->unk_DD2 * 0.85) + (f64) sp50);
    sp8C = (camera->unk_3C[2] + sp5C) - *sp38;
    arg2->unk0 = camera->lookAt[0];
    arg2->unk4 = (f32) camera->lookAt[1];
    arg2->unk8 = (f32) camera->lookAt[2];
    if ((player->unk_0BC & 0x01000000) == 0x01000000) {
        sp8C /= 3.0f;
    }
    sp3C = var_v1_2;
    func_802B6540(&sp9C, 0, 0x3F800000, 0, (s32) arg8);
    func_802B63B8(&sp84, &sp9C);
    temp_f16 = sp88 + player->pos[1];
    arg2->unk0 += ((sp84 + player->pos[0]) - camera->lookAt[0]) * *sp3C;
    arg2->unk8 = (f32) (arg2->unk8 + (((sp8C + player->pos[2]) - camera->lookAt[2]) * *sp3C));
    if ((((player->unk_094 / 18.0f) * 216.0f) <= 5.0f) && ((player->unk_0BC & 2) == 2)) {
        arg2->unk4 = (f32) ((f64) arg2->unk4 + ((f64) (temp_f16 - camera->lookAt[1]) * 0.02));
    } else {
        arg2->unk4 = (f32) ((f64) arg2->unk4 + ((f64) (temp_f16 - camera->lookAt[1]) * 0.5));
    }
    sp3C = sp3C;
    func_802B63B8(&sp90, &sp9C);
    if ((player->unk_0BC & 0x01000000) != 0x01000000) {
        var_f16_2 = sp94 + player->pos[1];
    } else {
        var_f16_2 = sp94 + (player->unk_074 + player->boundingBoxSize);
    }
    temp_f0_3 = camera->pos[0];
    *arg3 = (*sp3C * ((sp90 + player->pos[0]) - temp_f0_3)) + temp_f0_3;
    temp_f2 = camera->pos[2];
    *arg5 = (*sp3C * ((sp98 + player->pos[2]) - temp_f2)) + temp_f2;
    if ((((player->unk_094 / 18.0f) * 216.0f) <= 5.0f) && ((player->unk_0BC & 2) == 2)) {
        temp_f0_4 = camera->pos[1];
        *arg4 = (f32) (((f64) (var_f16_2 - temp_f0_4) * 0.01) + (f64) temp_f0_4);
    } else {
        temp_f0_5 = camera->pos[1];
        *arg4 = (f32) (((f64) (var_f16_2 - temp_f0_5) * 0.15) + (f64) temp_f0_5);
    }
    if ((player->unk_0DE & 1) != 0) {
        *arg4 = *(D_801652A0 + var_s2);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/camera/func_8001CCEC.s")
#endif

#ifdef MIPS_TO_C
//generated by m2c commit 3b40ab93768f52ac241c5ae84ef58ef6bc4cb1de
? func_802B6540(f32 *, f32, ?, f32, s32);           /* extern */
extern ? D_80164A90;
extern ? D_80164AA0;

void func_8001D53C(Player *player, Camera *camera, f32 *arg2, f32 *arg3, f32 *arg4, f32 *arg5, s16 arg6, s16 arg7) {
    f32 sp74;
    f32 sp70;
    f32 sp6C;
    f32 sp68;
    f32 sp64;
    f32 sp60;
    f32 sp5C;
    f32 sp3C;
    s32 sp38;
    f32 var_f0;

    if (((u16) player->unk_222 == 0) && (camera->unk_A0 == 0.0f)) {
        camera->unk_A0 = 0.0f;
    }
    if ((u16) player->unk_222 != 4) {
        move_f32_towards(&camera->unk_A0, 20.0f, 0.06f);
    } else {
        move_f32_towards(&camera->unk_A0, 0.0f, 0.06f);
    }
    sp3C = D_801652A0[arg7];
    sp68 = camera->unk_30[0];
    sp6C = camera->unk_30[1];
    sp70 = camera->unk_30[2];
    sp5C = camera->unk_3C[0];
    sp60 = camera->unk_3C[1] + camera->unk_A0;
    sp64 = camera->unk_3C[2];
    arg2->unk0 = camera->lookAt[0];
    arg2->unk4 = (f32) camera->lookAt[1];
    arg2->unk8 = (f32) camera->lookAt[2];
    sp38 = arg7 * 4;
    func_802B6540(&sp74, 0.0f, 0x3F800000, 0.0f, (s32) arg6);
    func_802B63B8(&sp5C, &sp74);
    arg2->unk0 += ((sp5C + player->pos[0]) - camera->lookAt[0]) * 1.0f;
    arg2->unk8 = (f32) (arg2->unk8 + (((sp64 + player->pos[2]) - camera->lookAt[2]) * 1.0f));
    arg2->unk4 = (f32) (arg2->unk4 + (((sp60 + player->pos[1]) - camera->lookAt[1]) * 1.0f));
    func_802B63B8(&sp68, &sp74);
    var_f0 = (f32) ((f64) sp6C + ((f64) player->unk_074 + 1.5));
    if ((player->unk_0CA & 1) == 1) {
        var_f0 = sp6C + (sp3C + 10.0f);
    }
    *arg3 = sp68 + player->pos[0];
    *arg4 = var_f0;
    *arg5 = sp70 + player->pos[2];
    *(&D_80164A90 + sp38) = 0.0f;
    *(&D_80164AA0 + sp38) = 0.0f;
}
#else
GLOBAL_ASM("asm/non_matchings/camera/func_8001D53C.s")
#endif

#ifdef MIPS_TO_C
//generated by m2c commit 3b40ab93768f52ac241c5ae84ef58ef6bc4cb1de
? func_802B6540(f32 *, ?, f32, ?, s32);             /* extern */

void func_8001D794(Player *player, Camera *camera, f32 *arg2, f32 *arg3, f32 *arg4, f32 *arg5, s16 arg6) {
    f32 sp6C;
    f32 sp68;
    f32 sp64;
    f32 sp60;
    f32 sp5C;
    f32 sp58;
    f32 sp54;
    f32 temp_f0;
    f32 temp_f12;
    f32 temp_f2;

    sp60 = camera->unk_30[0];
    sp64 = camera->unk_30[1];
    sp68 = camera->unk_30[2] - 6.0f;
    sp54 = camera->unk_3C[0];
    sp58 = camera->unk_3C[1];
    sp5C = camera->unk_3C[2];
    arg2->unk0 = camera->lookAt[0];
    arg2->unk4 = (f32) camera->lookAt[1];
    arg2->unk8 = (f32) camera->lookAt[2];
    func_802B6540(&sp6C, 0, 1.0f, 0, (s32) arg6);
    func_802B63B8(&sp54, &sp6C);
    arg2->unk0 += ((sp54 + player->pos[0]) - camera->lookAt[0]) * 1.0f;
    arg2->unk4 = (f32) (arg2->unk4 + (((sp58 + player->pos[1]) - camera->lookAt[1]) * 1.0f));
    arg2->unk8 = (f32) (arg2->unk8 + (((sp5C + player->pos[2]) - camera->lookAt[2]) * 1.0f));
    func_802B63B8(&sp60, &sp6C);
    temp_f0 = camera->pos[0];
    *arg3 = (((sp60 + player->pos[0]) - temp_f0) * 1.0f) + temp_f0;
    temp_f2 = camera->pos[1];
    *arg4 = (((sp64 + player->pos[1]) - temp_f2) * 1.0f) + temp_f2;
    temp_f12 = camera->pos[2];
    *arg5 = (((sp68 + player->pos[2]) - temp_f12) * 1.0f) + temp_f12;
}
#else
GLOBAL_ASM("asm/non_matchings/camera/func_8001D794.s")
#endif

#ifdef MIPS_TO_C
//generated by m2c commit 3b40ab93768f52ac241c5ae84ef58ef6bc4cb1de
? func_802B6540(f32 *, ?, ?, ?, s32);               /* extern */
extern ? D_80164A38;
extern ? D_80164A48;
extern ? D_80164A78;
extern ? D_80164A90;
extern ? D_80164AA0;
static f32 D_800DDB30[4] = { 0.4f, 0.6f, 0.275f, 0.3f };

void func_8001D944(Player *player, Camera *camera, f32 *arg2, f32 *arg3, f32 *arg4, f32 *arg5, s16 arg7, s16 arg8, s16 arg8) {
    f32 sp9C;
    f32 sp98;
    f32 sp94;
    f32 sp90;
    f32 sp8C;
    f32 sp88;
    f32 sp84;
    f32 sp5C;
    f32 sp50;
    f32 *sp48;
    f32 *sp44;
    f32 *sp40;
    f32 *sp3C;
    f32 *sp38;
    f32 *temp_a0;
    f32 *temp_a0_2;
    f32 *temp_a0_3;
    f32 *temp_a0_4;
    f32 *temp_a0_5;
    f32 *temp_a0_6;
    f32 *temp_a0_7;
    f32 *temp_a0_8;
    f32 *var_v0_2;
    f32 temp_f0;
    f32 temp_f0_2;
    f32 temp_f0_3;
    f32 temp_f0_4;
    f32 temp_f0_5;
    f32 temp_f0_6;
    f32 temp_f12;
    f32 temp_f16;
    f32 temp_f2;
    f32 var_f0;
    f32 var_f16;
    f32 var_f16_2;
    f32 var_f18;
    f32 var_f2;
    s16 var_v0;
    s16 var_v1;
    s32 var_s2;

    var_v1 = player->unk_DB4 + 1;
    var_f2 = player->unk_DBC;
    temp_f0 = (f32) ((f64) ((f32) var_v1 * var_f2) - (0.7 * (f64) (var_v1 * var_v1)));
    var_f18 = temp_f0;
    if ((var_v1 != 0) && (temp_f0 < 0.0f)) {
        var_v1 = 0;
        var_f2 = (f32) ((f64) var_f2 * 0.8);
        if ((f64) var_f2 <= 0.1) {
            var_f2 = 0.0f;
        }
    }
    if (var_f18 <= 0.0f) {
        var_f18 = 0.0f;
    }
    player->unk_DB4 = var_v1;
    player->unk_DBC = var_f2;
    var_v0 = camera->unk_9C + 1;
    var_f0 = camera->unk_94;
    var_s2 = arg8 * 4;
    temp_a0 = var_s2 + &D_80164A38;
    temp_f12 = (f32) ((f64) ((f32) var_v0 * var_f0) - (1.25 * (f64) (var_v0 * var_v0)));
    var_f16 = temp_f12;
    if ((var_v0 != 0) && (temp_f12 < 0.0f)) {
        var_v0 = 0;
        var_f0 = (f32) ((f64) var_f0 * 0.9);
        if ((f64) var_f0 <= 0.1) {
            var_f0 = 0.0f;
        }
    }
    if (var_f16 <= 0.0f) {
        var_f16 = 0.0f;
    }
    camera->unk_9C = var_v0;
    camera->unk_94 = var_f0;
    if ((&D_80164A38 + (arg8 * 2))->unk4678 == 2) {
        sp48 = temp_a0;
        sp50 = var_f16;
        sp5C = var_f18;
        move_f32_towards(temp_a0, 20.0f, 0.1f);
        temp_a0_2 = var_s2 + &D_80164A48;
        sp44 = temp_a0_2;
        move_f32_towards(temp_a0_2, 1.5f, 0.1f);
        var_v0_2 = var_s2 + &D_80164A78;
        *var_v0_2 = (f32) ((f64) *var_v0_2 + 0.1);
        if (*var_v0_2 >= 1.0f) {
            *var_v0_2 = 1.0f;
        }
    } else {
        var_s2 = arg8 * 4;
        temp_a0_3 = var_s2 + &D_80164A38;
        sp48 = temp_a0_3;
        sp50 = var_f16;
        sp5C = var_f18;
        move_f32_towards(temp_a0_3, 0.0f, 0.1f);
        temp_a0_4 = var_s2 + &D_80164A48;
        sp44 = temp_a0_4;
        move_f32_towards(temp_a0_4, 0.0f, 0.1f);
        var_v0_2 = var_s2 + &D_80164A78;
        *var_v0_2 = (f32) ((f64) *var_v0_2 - 0.1);
        temp_f0_2 = D_800DDB30[gActiveScreenMode];
        if (*var_v0_2 <= temp_f0_2) {
            *var_v0_2 = temp_f0_2;
        }
    }
    if ((player->unk_0CA & 0x100) == 0x100) {
        temp_a0_5 = var_s2 + &D_80164A90;
        sp3C = temp_a0_5;
        sp40 = var_v0_2;
        move_f32_towards(temp_a0_5, 15.0f, 0.02f);
        temp_a0_6 = var_s2 + &D_80164AA0;
        sp38 = temp_a0_6;
        move_f32_towards(temp_a0_6, 20.0f, 0.02f);
    } else {
        temp_a0_7 = var_s2 + &D_80164A90;
        sp3C = temp_a0_7;
        sp40 = var_v0_2;
        move_f32_towards(temp_a0_7, 0.0f, 0.02f);
        temp_a0_8 = var_s2 + &D_80164AA0;
        sp38 = temp_a0_8;
        move_f32_towards(temp_a0_8, 0.0f, 0.02f);
    }
    sp90 = camera->unk_30[0];
    temp_f0_3 = *sp38;
    sp94 = (f32) ((f64) temp_f0_3 + (((f64) camera->unk_30[1] + ((f64) player->unk_DD2 * 0.85)) - (f64) *sp44) + (f64) (sp50 / 2.0f));
    sp98 = temp_f0_3 + (camera->unk_30[2] + sp5C + *sp48);
    sp84 = camera->unk_3C[0];
    sp88 = (f32) ((f64) camera->unk_3C[1] + ((f64) player->unk_DD2 * 0.85) + (f64) sp50);
    sp8C = (camera->unk_3C[2] + sp5C) - *sp3C;
    arg2->unk0 = camera->lookAt[0];
    arg2->unk4 = (f32) camera->lookAt[1];
    arg2->unk8 = (f32) camera->lookAt[2];
    if ((player->unk_0BC & 0x01000000) == 0x01000000) {
        sp8C /= 3.0f;
    }
    sp40 = var_v0_2;
    func_802B6540(&sp9C, 0, 0x3F800000, 0, (s32) arg8);
    func_802B63B8(&sp84, &sp9C);
    temp_f16 = sp88 + player->pos[1];
    arg2->unk0 += ((sp84 + player->pos[0]) - camera->lookAt[0]) * *sp40;
    arg2->unk8 = (f32) (arg2->unk8 + (((sp8C + player->pos[2]) - camera->lookAt[2]) * *sp40));
    if ((((player->unk_094 / 18.0f) * 216.0f) <= 5.0f) && ((player->unk_0BC & 2) == 2)) {
        arg2->unk4 = (f32) ((f64) arg2->unk4 + ((f64) (temp_f16 - camera->lookAt[1]) * 0.02));
    } else {
        arg2->unk4 = (f32) ((f64) arg2->unk4 + ((f64) (temp_f16 - camera->lookAt[1]) * 0.5));
    }
    sp40 = sp40;
    func_802B63B8(&sp90, &sp9C);
    if ((player->unk_0BC & 0x01000000) != 0x01000000) {
        var_f16_2 = sp94 + player->pos[1];
    } else {
        var_f16_2 = sp94 + (player->unk_074 + player->boundingBoxSize);
    }
    temp_f0_4 = camera->pos[0];
    *arg3 = (*sp40 * ((sp90 + player->pos[0]) - temp_f0_4)) + temp_f0_4;
    temp_f2 = camera->pos[2];
    *arg5 = (*sp40 * ((sp98 + player->pos[2]) - temp_f2)) + temp_f2;
    if ((((player->unk_094 / 18.0f) * 216.0f) <= 5.0f) && ((player->unk_0BC & 2) == 2)) {
        temp_f0_5 = camera->pos[1];
        *arg4 = (f32) (((f64) (var_f16_2 - temp_f0_5) * 0.01) + (f64) temp_f0_5);
    } else {
        temp_f0_6 = camera->pos[1];
        *arg4 = (f32) (((f64) (var_f16_2 - temp_f0_6) * 0.15) + (f64) temp_f0_6);
    }
    if (player->unk_0DE & 1) {
        *arg4 = *(D_801652A0 + var_s2);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/camera/func_8001D944.s")
#endif

#ifdef MIPS_TO_C
//generated by m2c commit 3b40ab93768f52ac241c5ae84ef58ef6bc4cb1de
? func_8001CA78(Player *, Camera *, f32 *, f32 *, f32 *, f32 *, s32, s32); /* extern */

void func_8001E0C4(Camera *camera, Player *player, s8 arg2) {
    f32 sp84;
    f32 sp80;
    f32 sp7C;
    f32 sp74;
    f32 sp70;
    f32 sp6C;
    f32 sp60;
    f32 temp_f0;
    f32 temp_f12;
    f32 temp_f14;
    f32 temp_f2;
    f32 temp_f2_2;
    s16 temp_v0;
    s16 var_a2;

    temp_v0 = player->unk_078;
    if (temp_v0 == 0) {
        var_a2 = 0x0064;
    } else if (temp_v0 < 0) {
        var_a2 = 0x87 - (temp_v0 / 3);
    } else {
        var_a2 = (temp_v0 / 3) + 0x87;
    }
    func_800224F0(&camera->unk_2C, player->unk_02C[1], var_a2);
    func_8001CA78(player, camera, &sp60, &sp74, &sp70, &sp6C, (s32) camera->unk_2C, (s32) arg2);
    camera->rotZ = (u16) camera->rotZ & 0xFFFB;
    func_802ADDC8(&camera->unk_54, (f32) 3, sp74, sp70, sp6C);
    temp_f0 = camera->unk_54.unk44;
    if (temp_f0 < 0.0f) {
        sp74 += -camera->unk_54.unk60[0] * temp_f0 * 1.0f;
        sp70 = (f32) ((f64) sp70 + ((f64) (-camera->unk_54.unk60[1] * camera->unk_54.unk44) * 0.5));
        sp6C += -camera->unk_54.unk60[2] * camera->unk_54.unk44 * 1.0f;
    }
    temp_f2 = camera->unk_54.unk3C;
    if (temp_f2 < 0.0f) {
        camera->rotZ = (u16) camera->rotZ | 6;
        sp74 = (f32) ((f64) sp74 + ((f64) (-camera->unk_54.unk48[0] * temp_f2) * 1.5));
        sp70 += -camera->unk_54.unk48[1] * camera->unk_54.unk3C * 1.0f;
        sp6C = (f32) ((f64) sp6C + ((f64) (-camera->unk_54.unk48[2] * camera->unk_54.unk3C) * 1.5));
    }
    temp_f2_2 = camera->unk_54.unk40;
    if (temp_f2_2 < 0.0f) {
        camera->rotZ = (u16) camera->rotZ | 6;
        sp74 = (f32) ((f64) sp74 + ((f64) (-camera->unk_54.unk54[0] * temp_f2_2) * 1.5));
        sp70 += -camera->unk_54.unk54[1] * camera->unk_54.unk40 * 1.0f;
        sp6C = (f32) ((f64) sp6C + ((f64) (-camera->unk_54.unk54[2] * camera->unk_54.unk40) * 1.5));
    }
    if (((s16) M2C_ERROR(Read from unset register $v0) == 0) && (((u16) camera->rotZ & 2) != 2)) {
        camera->unk_AC = camera->unk_2C;
    }
    camera->lookAt[0] = sp60;
    camera->lookAt[1] = sp64;
    camera->lookAt[2] = sp68;
    camera->pos[0] = sp74;
    camera->pos[1] = sp70;
    temp_f12 = camera->lookAt[0] - camera->pos[0];
    camera->pos[2] = sp6C;
    sp80 = camera->lookAt[1] - camera->pos[1];
    sp84 = temp_f12;
    temp_f14 = camera->lookAt[2] - camera->pos[2];
    sp7C = temp_f14;
    camera->rot[1] = atan2s(temp_f12, temp_f14);
    camera->rot[0] = atan2s(sqrtf((sp84 * sp84) + (temp_f14 * temp_f14)), sp80);
    camera->rot[2] = 0;
}
#else
GLOBAL_ASM("asm/non_matchings/camera/func_8001E0C4.s")
#endif

#ifdef MIPS_TO_C
//generated by m2c commit 3b40ab93768f52ac241c5ae84ef58ef6bc4cb1de
? func_8001CCEC(Player *, Camera *, f32 *, f32 *, f32 *, f32 *, ? *, s32, s32); /* extern */

void func_8001E45C(Camera *camera, Player *player, s8 arg2) {
    f32 sp94;
    f32 sp90;
    f32 sp8C;
    f32 sp84;
    f32 sp80;
    f32 sp7C;
    f32 sp64;
    ? sp58;
    s16 sp4E;
    f32 temp_f12;
    f32 temp_f14;
    s16 temp_a3;
    s16 temp_a3_2;
    s16 temp_a3_3;
    s16 temp_v1;
    s16 temp_v1_2;
    s16 var_a3;
    s32 temp_v0;

    temp_v0 = player->unk_0BC;
    if ((temp_v0 & 0x10) == 0x10) {
        temp_v1 = player->unk_078;
        var_a3 = 0x0064;
        if (temp_v1 == 0) {
            camera->unk_B0 = 0;
        } else {
            if (temp_v1 < 0) {
                temp_a3 = 0xA5 - (temp_v1 / 2);
                if ((temp_v0 & 0x20000000) == 0x20000000) {
                    sp4E = temp_a3;
                    move_s16_towards(&camera->unk_B0, -0x0B60, 0.1f);
                } else {
                    sp4E = temp_a3;
                    move_s16_towards(&camera->unk_B0, -0x0888, 0.1f);
                }
            } else {
                temp_a3_2 = (temp_v1 / 2) + 0xA5;
                if ((temp_v0 & 0x20000000) == 0x20000000) {
                    sp4E = temp_a3_2;
                    move_s16_towards(&camera->unk_B0, 0x0B60, 0.1f);
                } else {
                    sp4E = temp_a3_2;
                    move_s16_towards(&camera->unk_B0, 0x0888, 0.1f);
                }
            }
            var_a3 = sp4E;
        }
    } else {
        move_s16_towards(&camera->unk_B0, 0, 0.05f);
        temp_v1_2 = player->unk_078;
        temp_a3_3 = ((s16) camera->unk_2C / 182) - ((s16) player->unk_02C[1] / 182);
        if (temp_v1_2 == 0) {
            if ((player->unk_0BC & 0x20) == 0x20) {
                var_a3 = 0x02D8;
            } else {
                var_a3 = 0x01F4;
            }
        } else if (temp_v1_2 < 0) {
            if ((temp_a3_3 < -0x45) || (temp_a3_3 >= 0x46)) {
                var_a3 = 0xB4 - temp_v1_2;
            } else {
                var_a3 = 0xA5 - (temp_v1_2 / 2);
            }
        } else if ((temp_a3_3 < -0x45) || (temp_a3_3 >= 0x46)) {
            var_a3 = temp_v1_2 + 0xB4;
        } else {
            var_a3 = (temp_v1_2 / 2) + 0xA5;
        }
    }
    if (((player->unk_0BC & 0x80) == 0x80) || ((player->unk_0BC & 0x40) == 0x40) || ((player->unk_0BC & 0x4000) == 0x4000) || ((player->unk_0BC & 0x80000) == 0x80000) || ((player->unk_0BC & 0x800000) == 0x800000) || (((player->unk_0BC & 0x20) == 0x20) && (player->unk_078 != 0)) || (player->unk_110.unk3C <= 0.0f) || (player->unk_110.unk40 <= 0.0f) || ((player->unk_0BC & 0x20000) == 0x20000)) {
        func_8001CCEC(player, camera, &sp64, &sp84, &sp80, &sp7C, &sp58, (s32) camera->unk_2C, (s32) arg2);
    } else {
        func_800224F0(&camera->unk_2C, (s16) (player->unk_02C[1] + camera->unk_B0), var_a3);
        func_8001CCEC(player, camera, &sp64, &sp84, &sp80, &sp7C, &sp58, (s32) camera->unk_2C, (s32) arg2);
    }
    camera->rotZ = (u16) camera->rotZ & 0xFFFB;
    func_802ADDC8(&camera->unk_54, (f32) 3, sp84, sp80, sp7C);
    camera->pos[0] = sp84;
    camera->pos[1] = sp80;
    camera->pos[2] = sp7C;
    camera->lookAt[0] = sp64;
    camera->lookAt[1] = sp68;
    temp_f12 = camera->lookAt[0] - camera->pos[0];
    camera->lookAt[2] = sp6C;
    sp90 = camera->lookAt[1] - camera->pos[1];
    sp94 = temp_f12;
    temp_f14 = camera->lookAt[2] - camera->pos[2];
    sp8C = temp_f14;
    camera->rot[1] = atan2s(temp_f12, temp_f14);
    camera->rot[0] = atan2s(sqrtf((sp94 * sp94) + (temp_f14 * temp_f14)), sp90);
    camera->rot[2] = 0;
}
#else
GLOBAL_ASM("asm/non_matchings/camera/func_8001E45C.s")
#endif

#ifdef MIPS_TO_C
//generated by m2c commit 3b40ab93768f52ac241c5ae84ef58ef6bc4cb1de
? func_8001D53C(Player *, Camera *, f32 *, f32 *, f32 *, f32 *, s32, s32); /* extern */

void func_8001E8E8(Camera *camera, Player *player, s8 arg2) {
    f32 sp8C;
    f32 sp88;
    f32 sp84;
    f32 sp7C;
    f32 sp78;
    f32 sp74;
    f32 sp5C;
    f32 temp_f12;
    f32 temp_f14;

    camera->unk_B0 = 0;
    camera->unk2C = (s16) player->unk_02C[1];
    func_8001D53C(player, camera, &sp5C, &sp7C, &sp78, &sp74, (s32) player->unk_02C[1], (s32) arg2);
    func_802ADDC8(&camera->unk_54, 5.0f, sp7C, sp78, sp74);
    camera->lookAt[0] = sp5C;
    camera->lookAt[1] = sp60;
    camera->lookAt[2] = sp64;
    camera->pos[0] = sp7C;
    camera->pos[1] = sp78;
    temp_f12 = camera->lookAt[0] - camera->pos[0];
    camera->pos[2] = sp74;
    sp88 = camera->lookAt[1] - camera->pos[1];
    sp8C = temp_f12;
    temp_f14 = camera->lookAt[2] - camera->pos[2];
    sp84 = temp_f14;
    camera->rot[1] = atan2s(temp_f12, temp_f14);
    camera->rot[0] = atan2s(sqrtf((sp8C * sp8C) + (temp_f14 * temp_f14)), sp88);
    camera->rot[2] = 0;
}
#else
GLOBAL_ASM("asm/non_matchings/camera/func_8001E8E8.s")
#endif

#ifdef MIPS_TO_C
//generated by m2c commit 3b40ab93768f52ac241c5ae84ef58ef6bc4cb1de
? func_8001D944(Player *, Camera *, f32 *, f32 *, f32 *, f32 *, ? *, s32, s32); /* extern */

void func_8001EA0C(Camera *camera, Player *player, s8 arg2) {
    f32 sp94;
    f32 sp90;
    f32 sp8C;
    f32 sp84;
    f32 sp80;
    f32 sp7C;
    f32 sp64;
    ? sp58;
    s16 sp4E;
    f32 temp_f12;
    f32 temp_f14;
    s16 temp_a3;
    s16 temp_a3_2;
    s16 temp_a3_3;
    s16 temp_v1;
    s16 temp_v1_2;
    s16 var_a3;
    s32 temp_v0;

    temp_v0 = player->unk_0BC;
    if ((temp_v0 & 0x10) == 0x10) {
        temp_v1 = player->unk_078;
        var_a3 = 0x0064;
        if (temp_v1 == 0) {
            camera->unk_B0 = 0;
        } else {
            if (temp_v1 < 0) {
                temp_a3 = 0xA5 - (temp_v1 / 2);
                if ((temp_v0 & 0x20000000) == 0x20000000) {
                    sp4E = temp_a3;
                    move_s16_towards(&camera->unk_B0, -0x0B60, 0.1f);
                } else {
                    sp4E = temp_a3;
                    move_s16_towards(&camera->unk_B0, -0x0888, 0.1f);
                }
            } else {
                temp_a3_2 = (temp_v1 / 2) + 0xA5;
                if ((temp_v0 & 0x20000000) == 0x20000000) {
                    sp4E = temp_a3_2;
                    move_s16_towards(&camera->unk_B0, 0x0B60, 0.1f);
                } else {
                    sp4E = temp_a3_2;
                    move_s16_towards(&camera->unk_B0, 0x0888, 0.1f);
                }
            }
            var_a3 = sp4E;
        }
    } else {
        move_s16_towards(&camera->unk_B0, 0, 0.05f);
        temp_v1_2 = player->unk_078;
        temp_a3_3 = ((s16) camera->unk_2C / 182) - ((s16) player->unk_02C[1] / 182);
        if (temp_v1_2 == 0) {
            if ((player->unk_0BC & 0x20) == 0x20) {
                var_a3 = 0x02D8;
            } else {
                var_a3 = 0x01F4;
            }
        } else if (temp_v1_2 < 0) {
            if ((temp_a3_3 < -0x45) || (temp_a3_3 >= 0x46)) {
                var_a3 = 0xB4 - temp_v1_2;
            } else {
                var_a3 = 0xA5 - (temp_v1_2 / 2);
            }
        } else if ((temp_a3_3 < -0x45) || (temp_a3_3 >= 0x46)) {
            var_a3 = temp_v1_2 + 0xB4;
        } else {
            var_a3 = (temp_v1_2 / 2) + 0xA5;
        }
    }
    if (((player->unk_0BC & 0x80) == 0x80) || ((player->unk_0BC & 0x40) == 0x40) || ((player->unk_0BC & 0x4000) == 0x4000) || ((player->unk_0BC & 0x80000) == 0x80000) || ((player->unk_0BC & 0x800000) == 0x800000) || (((player->unk_0BC & 0x20) == 0x20) && (player->unk_078 != 0)) || (player->unk_110.unk3C <= 0.0f) || (player->unk_110.unk40 <= 0.0f) || ((player->unk_0BC & 0x20000) == 0x20000)) {
        func_8001D944(player, camera, &sp64, &sp84, &sp80, &sp7C, &sp58, (s32) camera->unk_2C, (s32) arg2);
    } else {
        func_800224F0(&camera->unk_2C, (s16) (player->unk_02C[1] + camera->unk_B0), var_a3);
        func_8001D944(player, camera, &sp64, &sp84, &sp80, &sp7C, &sp58, (s32) camera->unk_2C, (s32) arg2);
    }
    camera->rotZ = (u16) camera->rotZ & 0xFFFB;
    func_802ADDC8(&camera->unk_54, (f32) 3, sp84, sp80, sp7C);
    camera->pos[0] = sp84;
    camera->pos[1] = sp80;
    camera->pos[2] = sp7C;
    camera->lookAt[0] = sp64;
    camera->lookAt[1] = sp68;
    temp_f12 = camera->lookAt[0] - camera->pos[0];
    camera->lookAt[2] = sp6C;
    sp90 = camera->lookAt[1] - camera->pos[1];
    sp94 = temp_f12;
    temp_f14 = camera->lookAt[2] - camera->pos[2];
    sp8C = temp_f14;
    camera->rot[1] = atan2s(temp_f12, temp_f14);
    camera->rot[0] = atan2s(sqrtf((sp94 * sp94) + (temp_f14 * temp_f14)), sp90);
    camera->rot[2] = 0;
}
#else
GLOBAL_ASM("asm/non_matchings/camera/func_8001EA0C.s")
#endif

#ifdef MIPS_TO_C
//generated by m2c commit 3b40ab93768f52ac241c5ae84ef58ef6bc4cb1de
? func_80019ED0();                                  /* extern */
? func_8001A0A4(s16 *, Camera *, Player *, s8, s32); /* extern */
? func_8001A0DC(s16 *, Camera *, Player *, s8, s32); /* extern */
? func_8001A588(u16 *, Camera *, Player *, s8, s32); /* extern */
? func_8001E0C4(Camera *, Player *, s8);            /* extern */
? func_8001E45C(Camera *, Player *, s8);            /* extern */
? func_8001E8E8(Camera *, Player *, s8);            /* extern */
? func_8001EA0C(Camera *, Player *, s8);            /* extern */
? func_8001F87C(s32);                               /* extern */
extern ? D_80152300;
extern u16 D_8015F894;
extern s8 D_80164A88;
extern s8 D_80164A89;

void func_8001EE98(Player *player, Camera *camera, s8 arg2) {
    s32 sp34;
    s16 *sp2C;
    s16 *temp_a0;
    s16 *temp_a0_2;
    s16 *temp_a0_3;
    s16 *temp_a0_4;
    s16 *temp_a0_5;
    s16 *temp_a0_6;
    s16 temp_v0_3;
    s16 temp_v0_4;
    s32 temp_v0;
    s32 var_s0;
    u16 *temp_a0_7;
    u16 temp_v0_2;

    if (camera == camera1) {
        sp34 = 0;
    }
    var_s0 = sp34;
    if (camera == camera2) {
        var_s0 = 1;
    }
    if (camera == camera3) {
        var_s0 = 2;
    }
    if (camera == camera4) {
        var_s0 = 3;
    }
    temp_v0 = gModeSelection;
    switch (temp_v0) {                              /* irregular */
    case 0:
        if (((player->unk_000 & 0x800) == 0x800) || (D_800DC51C == 1)) {
            *(&D_80152300 + (var_s0 * 2)) = 3;
        } else if (D_800DC5FC == 1) {
            func_8001A0A4((var_s0 * 2) + &D_80152300, camera, player, arg2, var_s0);
        } else {
            func_8001A0DC((var_s0 * 2) + &D_80152300, camera, player, arg2, var_s0);
        }
        break;
    case 3:
        if ((D_800DC51C == (u16) 1) || ((D_8015F894 == 2) && (D_80164A89 == 1))) {
            if (D_80164A88 == 0) {
                func_80019ED0();
            }
            D_80164A88 = 1;
            D_80152300.unk0 = 3;
            D_80152300.unk2 = 3;
            D_80152300.unk4 = 3;
            D_80152300.unk6 = 3;
        } else {
            D_80164A88 = 0;
            if (D_800DC5FC == (u16) 1) {
                temp_a0 = (var_s0 * 2) + &D_80152300;
                sp2C = temp_a0;
                func_8001A0A4(temp_a0, camera, player, arg2, var_s0);
            } else {
                temp_a0_2 = (var_s0 * 2) + &D_80152300;
                sp2C = temp_a0_2;
                func_8001A0DC(temp_a0_2, camera, player, arg2, var_s0);
            }
            *sp2C = 9;
        }
        break;
    case 1:
        if (((gPlayerOne->unk_000 & 0x800) == 0x800) || (D_800DC51C == (u16) 1)) {
            D_80152300.unk0 = 3;
            *(&D_80152300 + 2) = 3;
            *(&D_80152300 + 4) = 3;
            *(&D_80152300 + 6) = 3;
        } else {
            if (D_800DC5FC == (u16) 1) {
                temp_a0_3 = (var_s0 * 2) + &D_80152300;
                sp2C = temp_a0_3;
                func_8001A0A4(temp_a0_3, camera, player, arg2, var_s0);
            } else {
                temp_a0_4 = (var_s0 * 2) + &D_80152300;
                sp2C = temp_a0_4;
                func_8001A0DC(temp_a0_4, camera, player, arg2, var_s0);
            }
            *sp2C = 1;
        }
        break;
    case 2:
        if (((player->unk_000 & 0x800) == 0x800) || (D_800DC51C == (u16) 1) || (D_8015F894 == 2)) {
            *(&D_80152300 + (var_s0 * 2)) = 3;
        } else {
            if (D_800DC5FC == (u16) 1) {
                temp_a0_5 = (var_s0 * 2) + &D_80152300;
                sp2C = temp_a0_5;
                func_8001A0A4(temp_a0_5, camera, player, arg2, var_s0);
            } else {
                temp_a0_6 = (var_s0 * 2) + &D_80152300;
                sp2C = temp_a0_6;
                func_8001A0DC(temp_a0_6, camera, player, arg2, var_s0);
            }
            *sp2C = 1;
        }
        break;
    }
    if (D_800DC5FC == 0) {
        temp_a0_7 = (var_s0 * 2) + &D_80152300;
        temp_v0_2 = *temp_a0_7;
        switch (temp_v0_2) {                        /* switch 1; irregular */
        case 3:                                     /* switch 1 */
            func_8001A588(temp_a0_7, camera, player, arg2, var_s0);
            return;
        case 1:                                     /* switch 1 */
            temp_v0_3 = player->unk_0CA;
            if (((temp_v0_3 & 1) == 1) || ((temp_v0_3 & 2) == 2)) {
                func_8001E8E8(camera, player, arg2);
                return;
            }
            func_8001E45C(camera, player, arg2);
            return;
        case 8:                                     /* switch 1 */
            func_8001E0C4(camera, player, arg2);
            func_8001F87C(var_s0);
            return;
        case 9:                                     /* switch 1 */
            temp_v0_4 = player->unk_0CA;
            if (((temp_v0_4 & 1) == 1) || ((temp_v0_4 & 2) == 2)) {
                func_8001E8E8(camera, player, arg2);
                return;
            }
            func_8001EA0C(camera, player, arg2);
            break;
        }
    }
}
#else
GLOBAL_ASM("asm/non_matchings/camera/func_8001EE98.s")
#endif

#ifdef MIPS_TO_C
//generated by m2c commit 3b40ab93768f52ac241c5ae84ef58ef6bc4cb1de
f32 func_80014EE4(f32, s32, s32);                   /* extern */
extern ? D_80164498;
extern ? D_80164A08;

void func_8001F394(Player *player, f32 *arg1) {
    s32 sp2C;
    s32 sp1C;
    f32 *temp_a0;
    f32 *var_a0;
    f32 temp_f0;
    f32 temp_f0_2;
    f32 temp_f0_3;
    f32 temp_f0_4;
    f32 temp_f0_5;
    f32 temp_f0_6;
    f32 var_f0;
    f32 var_f2;
    s32 *temp_v1;
    s32 temp_t3;
    s32 temp_v0;
    s32 temp_v0_2;
    s32 temp_v0_3;
    s32 temp_v0_4;
    s32 temp_v0_5;

    if (player == gPlayerOne) {
        sp2C = 0;
    }
    if (player == gPlayerTwo) {
        sp2C = 1;
    }
    if (player == gPlayerThree) {
        sp2C = 2;
    }
    if (player == gPlayerFour) {
        sp2C = 3;
    }
    temp_t3 = sp2C * 4;
    temp_v1 = temp_t3 + &D_80164A08;
    if (*temp_v1 == 0) {
        if (player->unk_00C & 0x40000) {
            *temp_v1 = 1;
        }
        if ((player->unk_0BC & 0x2000) == 0x2000) {
            *temp_v1 = 2;
        }
        if ((player->unk_0BC & 0x100000) == 0x100000) {
            *temp_v1 = 3;
        }
        if ((player->unk_00C & 0x100) == 0x100) {
            *temp_v1 = 4;
        }
        temp_v0 = player->unk_0BC;
        if (((temp_v0 & 0x80) == 0x80) || ((temp_v0 & 0x40) == 0x40)) {
            *temp_v1 = 5;
        }
        *(&D_80164498 + temp_t3) = 0.0f;
    }
    switch (*temp_v1) {
    case 1:
        var_a0 = temp_t3 + &D_80164498;
        if (player->unk_00C & 0x40000) {
            sp1C = temp_t3;
            move_f32_towards(var_a0, 20.0f, 0.2f);
        } else {
            temp_f0 = *var_a0;
            if (temp_f0 > 1.0f) {
                *var_a0 = temp_f0 - 1.0f;
            } else {
                *temp_v1 = 0;
block_51:
                *var_a0 = 0.0f;
            }
        }
        break;
    case 2:
        if ((player->unk_0BC & 0x2000) == 0x2000) {
            if (player->boostTimer != 0) {
                sp1C = temp_t3;
                move_f32_towards(temp_t3 + &D_80164498, 8.0f, 0.2f);
            }
        } else {
            var_a0 = temp_t3 + &D_80164498;
            temp_f0_2 = *var_a0;
            if (temp_f0_2 > 1.0f) {
                *var_a0 = temp_f0_2 - 2.0f;
            } else {
                *temp_v1 = 0;
                goto block_51;
            }
        }
        break;
    case 3:
        temp_v0_2 = player->unk_0BC;
        var_a0 = temp_t3 + &D_80164498;
        if (((temp_v0_2 & 0x100000) == 0x100000) && ((temp_v0_2 & 8) == 8)) {
            sp1C = temp_t3;
            move_f32_towards(var_a0, 20.0f, 0.1f);
        } else {
            temp_f0_3 = *var_a0;
            if (temp_f0_3 > 1.0f) {
                *var_a0 = temp_f0_3 - 1.0f;
            } else {
                *temp_v1 = 0;
                goto block_51;
            }
        }
        break;
    case 4:
        var_a0 = temp_t3 + &D_80164498;
        if ((player->unk_00C & 0x100) == 0x100) {
            sp1C = temp_t3;
            move_f32_towards(var_a0, 25.0f, 1.0f);
        } else {
            temp_f0_4 = *var_a0;
            if (temp_f0_4 > 1.0f) {
                *var_a0 = temp_f0_4 - 2.0f;
            } else {
                *temp_v1 = 0;
                goto block_51;
            }
        }
        break;
    case 5:
        temp_v0_3 = player->unk_0BC;
        var_a0 = temp_t3 + &D_80164498;
        if (((temp_v0_3 & 0x80) == 0x80) || ((temp_v0_3 & 0x40) == 0x40)) {
            sp1C = temp_t3;
            move_f32_towards(var_a0, 18.0f, 0.2f);
        } else {
            temp_f0_5 = *var_a0;
            if (temp_f0_5 > 1.0f) {
                *var_a0 = temp_f0_5 - 2.0f;
            } else {
                *temp_v1 = 0;
                goto block_51;
            }
        }
        break;
    }
    temp_v0_4 = gActiveScreenMode;
    switch (temp_v0_4) {                            /* switch 1; irregular */
    default:                                        /* switch 1 */
        var_f2 = sp34;
        break;
    case 0:                                         /* switch 1 */
        temp_v0_5 = D_80164A28;
        if (temp_v0_5 == 1) {
            *(&D_80164498 + temp_t3) = 40.0f;
        }
        temp_a0 = temp_t3 + &D_80164498;
        if (temp_v0_5 == 2) {
            temp_f0_6 = *temp_a0;
            if (temp_f0_6 >= 0.0f) {
                *temp_a0 = (f32) ((f64) temp_f0_6 - 0.8);
            }
            if (*temp_a0 <= 0.0f) {
                D_80164A28 = 0;
                *temp_a0 = 0.0f;
            }
        }
        var_f0 = func_80014EE4(*arg1, (s32) temp_a0, sp2C);
block_66:
        var_f2 = var_f0;
        break;
    case 1:                                         /* switch 1 */
    case 2:                                         /* switch 1 */
    case 3:                                         /* switch 1 */
        var_f0 = func_80014EE4(*arg1, sp2C);
        goto block_66;
    }
    *arg1 = var_f2;
    cameras[sp2C].unk_B4 = var_f2;
}
#else
GLOBAL_ASM("asm/non_matchings/camera/func_8001F394.s")
#endif

#ifdef MIPS_TO_C
//generated by m2c commit 3b40ab93768f52ac241c5ae84ef58ef6bc4cb1de
extern ? D_80152300;
extern s32 D_80164A2C;

void func_8001F87C(s32 cameraId) {
    Camera *temp_v0_2;
    Player *var_a2;
    s32 var_a1;
    u16 temp_v0;

    if (gActiveScreenMode == 0) {
        var_a1 = 0;
        var_a2 = gPlayerOne;
        if (gModeSelection == 0) {
loop_3:
            temp_v0 = var_a2->unk_000;
            if (!(temp_v0 & 0x200) && !(temp_v0 & 0x80)) {
                if (var_a1 == 0x60E8) {
                    D_80164A2C += 1;
                }
                if ((var_a1 == 0x60E8) && (D_80164A2C == 0x0000003C)) {
                    D_80164A28 = 2;
                    *(&D_80152300 + (cameraId * 2)) = 1;
                    temp_v0_2 = &cameras[cameraId];
                    temp_v0_2->rot[1] = var_a2->unk_02E;
                    temp_v0_2->unk2C = (s16) var_a2->unk_02E;
                }
                var_a1 += 0xDD8;
                var_a2 += 0xDD8;
                if (var_a1 != 0x6EC0) {
                    goto loop_3;
                }
            }
        }
    }
}
#else
GLOBAL_ASM("asm/non_matchings/camera/func_8001F87C.s")
#endif
