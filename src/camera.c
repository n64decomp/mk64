#include <ultra64.h>
#include <macros.h>
#include <common_structs.h>
#include <defines.h>

//f32 D_801646C0;
//f32 D_801646C4;
//f32 D_801646C8;
//f32 D_801646CC;
//s8 D_801646D0[2];

Camera cameras[4];
Camera *camera1 = &cameras[0];
Camera *camera2 = &cameras[1];
Camera *camera3 = &cameras[2];
Camera *camera4 = &cameras[3];


extern Player *gPlayerTwo;
extern Player *gPlayerThree;
extern Player *gPlayerFour;


#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
? func_80014DE4(s32, s32, s32, Camera *);           /* extern */
? func_802B7F7C(Camera *, f32 *, s16 *, Camera *);  /* extern */
extern ? D_80150130;
extern ? D_80152300;
extern ? D_80164498;
extern ? D_80164678;
extern ? D_801649D8;
extern ? D_801649E8;
extern ? D_801649F8;
extern ? D_80164A08;
extern ? D_80164A18;
extern ? D_80164A38;
extern ? D_80164A48;
extern ? D_80164A78;
extern ? D_80164A90;
extern ? D_80164AA0;
static ? D_800DDB30;                                /* unable to generate initializer */
static s32 D_800ED50C = 0x4139999A;                 /* const */
static s32 D_800ED510 = 0x4199999A;                 /* const */
static s32 D_800ED514 = 0x4139999A;                 /* const */
static s32 D_800ED518 = 0x4199999A;                 /* const */
static s32 D_800ED51C = 0x4119999A;                 /* const */
static s32 D_800ED520 = 0x4139999A;                 /* const */
static s32 D_800ED524 = 0x4199999A;                 /* const */

void func_8001C4D0(f32 x, f32 y, f32 z, s16 rot, u32 arg4, s32 cameraId) {
    void *sp30;
    s32 sp2C;
    s32 sp28;
    f32 *sp24;
    f32 *sp20;
    f32 *sp1C;
    f32 *temp_t1;
    f32 *temp_t2;
    f32 *temp_t3;
    f32 *temp_v0_2;
    f32 *temp_v0_3;
    f32 *temp_v0_4;
    f32 *temp_v0_5;
    s16 *temp_a0;
    s32 temp_t6;
    s32 temp_t6_2;
    s32 temp_v0;
    void *temp_v1;
    f32 *phi_v0;
    s16 phi_v1;

    temp_t6 = cameraId * 2;
    *(&D_80152300 + temp_t6) = arg4;
    switch (arg4) {
    case 0:
    case 1:
    case 3:
    case 8:
    case 9:
    case 10:
        D_80164A89 = 0;
        cameras[cameraId].posX = x;
        cameras[cameraId].posY = y;
        cameras[cameraId].posZ = z;
        cameras[cameraId].rotZ = 0;
        cameras[cameraId].unk2 = 150.0f;
        cameras[cameraId].unk1 = y - 3.0;
        cameras[cameraId].unk = 0.0f;
        cameras[cameraId].angleX = 0.0f;
        cameras[cameraId].angleZ = 0.0f;
        cameras[cameraId].angleY = 1.0f;
        cameras[cameraId].unkB0 = 0;
        cameras[cameraId].unk25 = (bitwise s32) 0.0f;
        cameras[cameraId].unkAE = cameraId;
        temp_t6_2 = cameraId * 4;
        *(&D_801649D8 + temp_t6_2) = 20.0f;
        *(&D_801649E8 + temp_t6_2) = 10.0f;
        *(&D_801649F8 + temp_t6_2) = 7.0f;
        D_80164A2C = 0;
        D_80164A30 = 30.0f;
        temp_t1 = temp_t6_2 + &D_80164A38;
        temp_t2 = temp_t6_2 + &D_80164A48;
        *temp_t1 = 0.0f;
        *temp_t2 = 0.0f;
        *(&D_80164A90 + temp_t6_2) = 0.0f;
        *(&D_80164AA0 + temp_t6_2) = 0.0f;
        temp_t3 = temp_t6_2 + &D_80164A78;
        *temp_t3 = *(&D_800DDB30 + (gActiveScreenMode * 4));
        *(&D_80164A18 + temp_t6_2) = 0;
        *(&D_80164A08 + temp_t6_2) = 0;
        *(&D_80164498 + temp_t6_2) = 0.0f;
        cameras[cameraId].unk24_and_a_half = 0;
        cameras[cameraId].unk22 = 0.0f;
        temp_v1 = gPlayerOne + (cameraId * 0xDD8);
        cameras[cameraId].unk2C = temp_v1->unk2E;
        cameras[cameraId].unk28 = temp_v1->unk2E;
        temp_v0 = gActiveScreenMode;
        if (temp_v0 != 0) {
            if (temp_v0 != 1) {
                if (temp_v0 != 2) {
                    if (temp_v0 != 3) {

                    } else if (gModeSelection == BATTLE) {
                        cameras[cameraId].unk4 = (bitwise s32) 0.0f;
                        cameras[cameraId].unk7 = (bitwise s32) 0.0f;
                        cameras[cameraId].unk8 = (bitwise s32) 0.0f;
                        cameras[cameraId].unk5 = 0x4139999A;
                        cameras[cameraId].unk6 = -0x3DE60000;
                        cameras[cameraId].unk9 = 0x4199999A;
                    } else {
                        cameras[cameraId].unk4 = (bitwise s32) 0.0f;
                        cameras[cameraId].unk7 = (bitwise s32) 0.0f;
                        cameras[cameraId].unk8 = (bitwise s32) 0.0f;
                        cameras[cameraId].unk5 = 0x41100000;
                        cameras[cameraId].unk6 = -0x3DE00000;
                        cameras[cameraId].unk9 = 0x41900000;
                    }
                } else {
                    goto block_7;
                }
            } else if (gModeSelection == BATTLE) {
                cameras[cameraId].unk4 = (bitwise s32) 0.0f;
                cameras[cameraId].unk7 = (bitwise s32) 0.0f;
                cameras[cameraId].unk8 = (bitwise s32) 0.0f;
                cameras[cameraId].unk5 = 0x4139999A;
                cameras[cameraId].unk6 = -0x3DE60000;
                cameras[cameraId].unk9 = 0x4199999A;
            } else {
                cameras[cameraId].unk4 = (bitwise s32) 0.0f;
                cameras[cameraId].unk7 = (bitwise s32) 0.0f;
                cameras[cameraId].unk8 = (bitwise s32) 0.0f;
                cameras[cameraId].unk9 = (bitwise s32) 30.0f;
                cameras[cameraId].unk5 = 0x4119999A;
                cameras[cameraId].unk6 = -0x3DF40000;
            }
        } else {
block_7:
            if (gModeSelection == BATTLE) {
                cameras[cameraId].unk4 = (bitwise s32) 0.0f;
                cameras[cameraId].unk7 = (bitwise s32) 0.0f;
                cameras[cameraId].unk8 = (bitwise s32) 0.0f;
                cameras[cameraId].unk5 = 0x4139999A;
                cameras[cameraId].unk6 = -0x3DE60000;
                cameras[cameraId].unk9 = 0x4199999A;
                D_80164A88 = 0;
            } else {
                cameras[cameraId].unk4 = (bitwise s32) 0.0f;
                cameras[cameraId].unk7 = (bitwise s32) 0.0f;
                cameras[cameraId].unk8 = (bitwise s32) 0.0f;
                cameras[cameraId].unk5 = 0x41180000;
                cameras[cameraId].unk6 = -0x3DB80000;
                cameras[cameraId].unk9 = 0x428C0000;
            }
        }
        sp28 = temp_t6_2;
        sp2C = temp_t6;
        sp30 = &cameras[cameraId];
        sp24 = temp_t1;
        sp20 = temp_t2;
        sp1C = temp_t3;
        func_80014DE4(cameraId, temp_t6_2, temp_t6, &cameras[cameraId]);
        temp_a0 = temp_t6 + &D_80164678;
        if (*temp_a0 == 0) {
            if (D_80164A28 == 1) {
                temp_v0_2 = temp_t6_2 + &D_80150130;
                *temp_v0_2 = 80.0f;
                phi_v0 = temp_v0_2;
            } else {
                temp_v0_3 = temp_t6_2 + &D_80150130;
                *temp_v0_3 = 40.0f;
                phi_v0 = temp_v0_3;
            }
            cameras[cameraId].unk30 = *phi_v0;
        }
        phi_v1 = *temp_a0;
        if (*temp_a0 == 1) {
            temp_v0_4 = temp_t6_2 + &D_80150130;
            if (D_80164A28 == 1) {
                *temp_v0_4 = 100.0f;
            } else {
                *temp_v0_4 = 60.0f;
            }
            cameras[cameraId].unk30 = *temp_v0_4;
            phi_v1 = *temp_a0;
        }
        if (phi_v1 == 2) {
            temp_v0_5 = temp_t6_2 + &D_80150130;
            if (D_80164A28 == 1) {
                *temp_v0_5 = 100.0f;
            } else {
                *temp_v0_5 = 60.0f;
            }
            cameras[cameraId].unk30 = *temp_v0_5;
            *temp_t1 = 20.0f;
            *temp_t2 = 1.5f;
            *temp_t3 = 1.0f;
        }
        break;
    }
    func_802B7F7C(&cameras[cameraId], &cameras[cameraId].unk, &cameras[cameraId].rotX, &cameras[cameraId]);
}
#else
GLOBAL_ASM("asm/non_matchings/camera/func_8001C4D0.s")
#endif

void func_8001CA10(Camera *camera) {
    camera->unk24_and_a_half = 0;
    camera->unk22 = 6.0f;
}

void func_8001CA24(Player *arg0, f32 arg1) {
    Camera *camera = &cameras[0];

    if (arg0 == gPlayerTwo) {
        camera += 1;
    }
    if (arg0 == gPlayerThree) {
        camera += 2;
    }
    if (arg0 == gPlayerFour) {
        camera += 3;
    }
    camera->unk24_and_a_half = 0;
    camera->unk22 = arg1;
}

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
//? move_f32_towards(f32 *, ?, ?); // extern
//? func_802B63B8(f32 *, f32 *); // extern
extern u16 gWaypointCountByPathIndex;
extern f32 D_80164A30;

void func_8001CA78(s32 arg0, void *arg1, void *arg2, f32 *arg3, f32 *arg4, f32 *arg5) {
    f32 sp74;
    f32 sp70;
    f32 sp6C;
    f32 sp68;
    f32 sp64;
    f32 sp60;
    f32 sp5C;
    f32 sp4C;
    f32 sp48;
    f32 sp44;
    f32 temp_f0;
    f32 temp_f12;
    f32 temp_f16;
    f32 temp_f18;
    f32 temp_f2;
    void *temp_s2;
    f32 phi_f14;
    f32 phi_f14_2;

    sp68 = arg1->unk30;
    sp6C = arg1->unk34;
    sp70 = arg1->unk38;
    sp5C = arg1->unk3C;
    sp60 = arg1->unk40;
    sp64 = arg1->unk44;
    arg2->unk0 = arg1->unkC;
    temp_s2 = ((gWaypointCountByPathIndex - 0xA) * 8) + D_80164550;
    arg2->unk4 = arg1->unk10;
    arg2->unk8 = arg1->unk14;
    func_802B6540(&sp74, 0.0f, 1.0f, 0.0f, -0x8000);
    func_802B63B8(&sp5C, &sp74);
    if (gCurrentCourseId == 0xA) {
        phi_f14 = sp5C;
    } else {
        phi_f14 = sp5C + temp_s2->unk0;
    }
    arg2->unk0 = arg2->unk0 + ((phi_f14 - arg1->unkC) * 1.0f);
    arg2->unk4 = arg2->unk4 + (((sp60 + (temp_s2->unk2 + D_80164A30)) - arg1->unk10) * 1.0f);
    arg2->unk8 = arg2->unk8 + (((sp64 + (bitwise f32) D_8016524C) - arg1->unk14) * 1.0f);
    func_802B63B8(&sp68, &sp74);
    if (gCurrentCourseId == COURSE_TOADS_TURNPIKE) {
        phi_f14_2 = sp68;
    } else {
        phi_f14_2 = sp68 + temp_s2->unk0;
    }
    sp4C = phi_f14_2;
    temp_f16 = sp70 + (bitwise f32) D_8016524C;
    sp44 = temp_f16;
    temp_f18 = sp6C + (temp_s2->unk2 + D_80164A30 + 6.0f);
    sp48 = temp_f18;
    move_f32_towards(&D_80164A30, 0, 0x3CA3D70A);
    temp_f0 = arg1->unk0;
    *arg3 = ((phi_f14_2 - temp_f0) * 1.0f) + temp_f0;
    temp_f2 = arg1->unk4;
    *arg4 = ((temp_f18 - temp_f2) * 1.0f) + temp_f2;
    temp_f12 = arg1->unk8;
    *arg5 = ((temp_f16 - temp_f12) * 1.0f) + temp_f12;
}
#else
GLOBAL_ASM("asm/non_matchings/camera/func_8001CA78.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? move_f32_towards(f32, f32, f32 *, f32, ?); // extern
? func_802B63B8(f32 *, f32 *, f32 *, f32 *); // extern
extern ? D_800DDB30;
extern f64 D_800ED528;
extern f64 D_800ED530;
extern f64 D_800ED538;
extern f64 D_800ED540;
extern f64 D_800ED548;
extern f64 D_800ED550;
extern f64 D_800ED558;
extern f64 D_800ED560;
extern f64 D_800ED568;
extern f64 D_800ED570;
extern f64 D_800ED578;
extern ? D_80164A38;
extern ? D_80164A48;
extern ? D_80164A78;
extern ? D_80164A90;
extern ? D_80164AA0;

void func_8001CCEC(void *arg0, void *arg1, void *arg2, f32 *arg3, f32 *arg4, f32 *arg5, s16 arg7, s16 arg8) {
    f32 sp9C;
    f32 sp98;
    f32 sp94;
    f32 sp90;
    f32 sp8C;
    f32 sp88;
    f32 sp84;
    f32 sp5C;
    f32 sp50;
    f32 *sp44;
    f32 *sp40;
    f32 *sp3C;
    f32 *sp38;
    f32 *sp34;
    f32 *temp_a0;
    f32 *temp_a0_10;
    f32 *temp_a0_11;
    f32 *temp_a0_12;
    f32 *temp_a0_2;
    f32 *temp_a0_3;
    f32 *temp_a0_4;
    f32 *temp_a0_5;
    f32 *temp_a0_6;
    f32 *temp_a0_7;
    f32 *temp_a0_8;
    f32 *temp_a0_9;
    f32 *temp_v1_2;
    f32 *temp_v1_3;
    f32 temp_f0;
    f32 temp_f0_2;
    f32 temp_f0_3;
    f32 temp_f0_4;
    f32 temp_f0_6;
    f32 temp_f0_7;
    f32 temp_f0_8;
    f32 temp_f12;
    f32 temp_f12_2;
    f32 temp_f14;
    f32 temp_f16;
    f32 temp_f2;
    f32 temp_f2_2;
    f32 temp_f2_3;
    f64 temp_f0_5;
    s16 temp_v0;
    s16 temp_v1;
    s32 temp_s2;
    s32 temp_s2_2;
    s32 temp_v0_2;
    s16 phi_v1;
    f32 phi_f2;
    s16 phi_v0;
    f32 phi_f0;
    f32 phi_f16;
    f32 phi_f18;
    s32 phi_s2;
    f32 *phi_v1_2;
    f32 phi_f16_2;

    temp_v1 = arg0->unkDB4 + 1;
    temp_f2 = arg0->unkDBC;
    temp_f0 = (temp_v1 * temp_f2) - (D_800ED528 * (temp_v1 * temp_v1));
    phi_v1 = temp_v1;
    phi_f2 = temp_f2;
    phi_f18 = temp_f0;
    if ((temp_v1 != 0) && (temp_f0 < 0.0f)) {
        temp_f2_2 = temp_f2 * D_800ED530;
        phi_v1 = 0;
        phi_f2 = temp_f2_2;
        if (temp_f2_2 <= D_800ED538) {
            phi_f2 = 0.0f;
        }
    }
    if (temp_f0 <= 0.0f) {
        phi_f18 = 0.0f;
    }
    arg0->unkDB4 = phi_v1;
    arg0->unkDBC = phi_f2;
    temp_v0 = arg1->unk9C + 1;
    temp_f0_2 = arg1->unk94;
    temp_s2 = arg8 * 4;
    temp_a0 = temp_s2 + &D_80164A38;
    temp_f12 = (temp_v0 * temp_f0_2) - (1.25 * (temp_v0 * temp_v0));
    phi_v0 = temp_v0;
    phi_f0 = temp_f0_2;
    phi_f16 = temp_f12;
    phi_s2 = temp_s2;
    if ((temp_v0 != 0) && (temp_f12 < 0.0f)) {
        temp_f0_3 = temp_f0_2 * D_800ED540;
        phi_v0 = 0;
        phi_f0 = temp_f0_3;
        if (temp_f0_3 <= D_800ED548) {
            phi_f0 = 0.0f;
        }
    }
    if (temp_f12 <= 0.0f) {
        phi_f16 = 0.0f;
    }
    arg1->unk9C = phi_v0;
    arg1->unk94 = phi_f0;
    if ((&D_80164A38 + (arg8 * 2))->unk4678 == 2) {
        sp44 = temp_a0;
        sp50 = phi_f16;
        sp5C = phi_f18;
        move_f32_towards(temp_f12, 0.0f, temp_a0, 20.0f, 0x3DCCCCCD);
        temp_a0_2 = temp_s2 + &D_80164A48;
        sp40 = temp_a0_2;
        move_f32_towards((bitwise f32) temp_a0_2, 1.5f, 0x3DCCCCCD);
        temp_v1_2 = temp_s2 + &D_80164A78;
        *temp_v1_2 = *temp_v1_2 + D_800ED550;
        phi_v1_2 = temp_v1_2;
        if (*temp_v1_2 >= 1.0f) {
            *temp_v1_2 = 1.0f;
        }
    } else {
        temp_s2_2 = arg8 * 4;
        temp_a0_3 = temp_s2_2 + &D_80164A38;
        sp44 = temp_a0_3;
        sp50 = phi_f16;
        sp5C = phi_f18;
        move_f32_towards(temp_f12, 0.0f, temp_a0_3, 0.0f, 0x3DCCCCCD);
        temp_a0_4 = temp_s2_2 + &D_80164A48;
        sp40 = temp_a0_4;
        move_f32_towards((bitwise f32) temp_a0_4, 0.0f, 0x3DCCCCCD);
        temp_v1_3 = temp_s2_2 + &D_80164A78;
        *temp_v1_3 = *temp_v1_3 - D_800ED558;
        temp_f0_4 = *(&D_800DDB30 + (gActiveScreenMode * 4));
        phi_s2 = temp_s2_2;
        phi_v1_2 = temp_v1_3;
        if (*temp_v1_3 <= temp_f0_4) {
            *temp_v1_3 = temp_f0_4;
        }
    }
    if ((arg0->unkCA & 0x100) == 0x100) {
        temp_v0_2 = gActiveScreenMode;
        if ((temp_v0_2 == 1) || (temp_v0_2 == 2) || (temp_v0_2 == 3)) {
            temp_a0_9 = phi_s2 + &D_80164A90;
            sp38 = temp_a0_9;
            sp3C = phi_v1_2;
            move_f32_towards((bitwise f32) temp_a0_9, 20.0f, 0x3CA3D70A);
            temp_a0_10 = phi_s2 + &D_80164AA0;
            sp34 = temp_a0_10;
            move_f32_towards((bitwise f32) temp_a0_10, 10.0f, 0x3CA3D70A);
        } else if (gCurrentCourseId == 4) {
            temp_a0_5 = phi_s2 + &D_80164A90;
            sp38 = temp_a0_5;
            sp3C = phi_v1_2;
            move_f32_towards((bitwise f32) temp_a0_5, 50.0f, 0x3D23D70A);
            temp_a0_6 = phi_s2 + &D_80164AA0;
            sp34 = temp_a0_6;
            move_f32_towards((bitwise f32) temp_a0_6, 35.0f, 0x3D23D70A);
        } else {
            temp_a0_7 = phi_s2 + &D_80164A90;
            sp38 = temp_a0_7;
            sp3C = phi_v1_2;
            move_f32_towards((bitwise f32) temp_a0_7, 40.0f, 0x3CA3D70A);
            temp_a0_8 = phi_s2 + &D_80164AA0;
            sp34 = temp_a0_8;
            move_f32_towards((bitwise f32) temp_a0_8, 20.0f, 0x3CA3D70A);
        }
    } else {
        temp_a0_11 = phi_s2 + &D_80164A90;
        sp38 = temp_a0_11;
        sp3C = phi_v1_2;
        move_f32_towards((bitwise f32) temp_a0_11, 0.0f, 0x3D23D70A);
        temp_a0_12 = phi_s2 + &D_80164AA0;
        sp34 = temp_a0_12;
        move_f32_towards((bitwise f32) temp_a0_12, 0.0f, 0x3D23D70A);
    }
    temp_f0_5 = D_800ED560;
    sp90 = arg1->unk30;
    sp94 = *sp34 + ((arg1->unk34 + (arg0->unkDD2 * temp_f0_5)) - *sp40) + (sp50 / 2.0f);
    sp98 = *sp44 + (arg1->unk38 + sp5C);
    sp84 = arg1->unk3C;
    sp88 = arg1->unk40 + (arg0->unkDD2 * temp_f0_5) + sp50;
    sp8C = (arg1->unk44 + sp5C) - *sp38;
    arg2->unk0 = arg1->unkC;
    arg2->unk4 = arg1->unk10;
    arg2->unk8 = arg1->unk14;
    if ((arg0->unkBC & 0x1000000) == 0x1000000) {
        sp8C /= 3.0f;
    }
    sp3C = phi_v1_2;
    func_802B6540(&sp9C, 0.0f, 1.0f, 0.0f, arg7);
    func_802B63B8(&sp84, &sp9C);
    temp_f12_2 = sp84 + arg0->unk14;
    temp_f14 = sp8C + arg0->unk1C;
    temp_f16 = sp88 + arg0->unk18;
    arg2->unk0 = arg2->unk0 + ((temp_f12_2 - arg1->unkC) * *phi_v1_2);
    arg2->unk8 = arg2->unk8 + ((temp_f14 - arg1->unk14) * *phi_v1_2);
    if ((((arg0->unk94 / 18.0f) * 216.0f) <= 5.0f) && ((arg0->unkBC & 2) == 2)) {
        arg2->unk4 = arg2->unk4 + ((temp_f16 - arg1->unk10) * D_800ED568);
    } else {
        arg2->unk4 = arg2->unk4 + ((temp_f16 - arg1->unk10) * 0.5);
    }
    sp3C = phi_v1_2;
    func_802B63B8((bitwise f32 *) temp_f12_2, (bitwise f32 *) temp_f14, &sp90, &sp9C);
    if ((arg0->unkBC & 0x1000000) != 0x1000000) {
        phi_f16_2 = sp94 + arg0->unk18;
    } else {
        phi_f16_2 = sp94 + (arg0->unk74 + arg0->unk70);
    }
    temp_f0_6 = arg1->unk0;
    *arg3 = (*phi_v1_2 * ((sp90 + arg0->unk14) - temp_f0_6)) + temp_f0_6;
    temp_f2_3 = arg1->unk8;
    *arg5 = (*phi_v1_2 * ((sp98 + arg0->unk1C) - temp_f2_3)) + temp_f2_3;
    if ((((arg0->unk94 / 18.0f) * 216.0f) <= 5.0f) && ((arg0->unkBC & 2) == 2)) {
        temp_f0_7 = arg1->unk4;
        *arg4 = ((phi_f16_2 - temp_f0_7) * D_800ED570) + temp_f0_7;
    } else {
        temp_f0_8 = arg1->unk4;
        *arg4 = ((phi_f16_2 - temp_f0_8) * D_800ED578) + temp_f0_8;
    }
    if ((arg0->unkDE & 1) != 0) {
        *arg4 = *(D_801652A0 + phi_s2);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/camera/func_8001CCEC.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? move_f32_towards(void *, f32, ?); // extern
? func_802B63B8(f32 *, f32 *, f32 *, f32 *); // extern
extern ? D_80164A90;
extern ? D_80164AA0;

void func_8001D53C(void *arg0, void *arg1, void *arg2, f32 *arg3, f32 *arg4, f32 *arg5, s16 arg6, s16 arg7) {
    f32 sp74;
    f32 sp70;
    f32 sp6C;
    f32 sp68;
    f32 sp64;
    f32 sp60;
    f32 sp5C;
    f32 sp3C;
    s32 sp38;
    f32 temp_f10;
    f32 temp_f10_2;
    f32 temp_f12;
    f32 temp_f6;
    f32 phi_f0;

    if ((arg0->unk222 == 0) && (arg1->unkA0 == 0.0f)) {
        arg1->unkA0 = 0.0f;
    }
    if (arg0->unk222 != 4) {
        move_f32_towards(arg1 + 0xA0, 20.0f, 0x3D75C28F);
    } else {
        move_f32_towards(arg1 + 0xA0, 0.0f, 0x3D75C28F);
    }
    temp_f6 = D_801652A0[arg7];
    sp3C = temp_f6;
    sp68 = arg1->unk30;
    temp_f10 = arg1->unk34;
    sp6C = temp_f10;
    sp70 = arg1->unk38;
    sp5C = arg1->unk3C;
    sp60 = arg1->unk40 + arg1->unkA0;
    temp_f10_2 = arg1->unk44;
    sp64 = temp_f10_2;
    arg2->unk0 = arg1->unkC;
    arg2->unk4 = arg1->unk10;
    arg2->unk8 = arg1->unk14;
    sp38 = arg7 * 4;
    func_802B6540(&sp74, 0.0f, 1.0f, 0.0f, arg6);
    func_802B63B8(&sp5C, &sp74);
    temp_f12 = temp_f10_2 + arg0->unk1C;
    arg2->unk0 = arg2->unk0 + (((sp5C + arg0->unk14) - arg1->unkC) * 1.0f);
    arg2->unk8 = arg2->unk8 + ((temp_f12 - arg1->unk14) * 1.0f);
    arg2->unk4 = arg2->unk4 + (((sp60 + arg0->unk18) - arg1->unk10) * 1.0f);
    func_802B63B8((bitwise f32 *) temp_f12, (bitwise f32 *) 1.0f, &sp68, &sp74);
    phi_f0 = temp_f10 + (arg0->unk74 + 1.5);
    if ((arg0->unkCA & 1) == 1) {
        phi_f0 = temp_f10 + (temp_f6 + 10.0f);
    }
    *arg3 = sp68 + arg0->unk14;
    *arg4 = phi_f0;
    *arg5 = sp70 + arg0->unk1C;
    *(&D_80164A90 + sp38) = 0.0f;
    *(&D_80164AA0 + sp38) = 0.0f;
}
#else
GLOBAL_ASM("asm/non_matchings/camera/func_8001D53C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_802B63B8(f32 *, f32 *); // extern

void func_8001D794(void *arg0, void *arg1, void *arg2, f32 *arg3, f32 *arg4, f32 *arg5, s16 arg6) {
    f32 sp6C;
    f32 sp68;
    f32 sp64;
    f32 sp60;
    f32 sp5C;
    f32 sp58;
    f32 sp54;
    f32 temp_f0;
    f32 temp_f12;
    f32 temp_f2;

    sp60 = arg1->unk30;
    sp64 = arg1->unk34;
    sp68 = arg1->unk38 - 6.0f;
    sp54 = arg1->unk3C;
    sp58 = arg1->unk40;
    sp5C = arg1->unk44;
    arg2->unk0 = arg1->unkC;
    arg2->unk4 = arg1->unk10;
    arg2->unk8 = arg1->unk14;
    func_802B6540(&sp6C, 0.0f, 1.0f, 0.0f, arg6);
    func_802B63B8(&sp54, &sp6C);
    arg2->unk0 = arg2->unk0 + (((sp54 + arg0->unk14) - arg1->unkC) * 1.0f);
    arg2->unk4 = arg2->unk4 + (((sp58 + arg0->unk18) - arg1->unk10) * 1.0f);
    arg2->unk8 = arg2->unk8 + (((sp5C + arg0->unk1C) - arg1->unk14) * 1.0f);
    func_802B63B8(&sp60, &sp6C);
    temp_f0 = arg1->unk0;
    *arg3 = (((sp60 + arg0->unk14) - temp_f0) * 1.0f) + temp_f0;
    temp_f2 = arg1->unk4;
    *arg4 = (((sp64 + arg0->unk18) - temp_f2) * 1.0f) + temp_f2;
    temp_f12 = arg1->unk8;
    *arg5 = (((sp68 + arg0->unk1C) - temp_f12) * 1.0f) + temp_f12;
}
#else
GLOBAL_ASM("asm/non_matchings/camera/func_8001D794.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? move_f32_towards(f32, f32, f32 *, f32, ?); // extern
? func_802B63B8(f32 *, f32 *, f32 *, f32 *); // extern
extern ? D_800DDB30;
extern f64 D_800ED580;
extern f64 D_800ED588;
extern f64 D_800ED590;
extern f64 D_800ED598;
extern f64 D_800ED5A0;
extern f64 D_800ED5A8;
extern f64 D_800ED5B0;
extern f64 D_800ED5B8;
extern f64 D_800ED5C0;
extern f64 D_800ED5C8;
extern f64 D_800ED5D0;
extern ? D_80164A38;
extern ? D_80164A48;
extern ? D_80164A78;
extern ? D_80164A90;
extern ? D_80164AA0;

void func_8001D944(void *arg0, void *arg1, void *arg2, f32 *arg3, f32 *arg4, f32 *arg5, s16 arg7, s16 arg8) {
    f32 sp9C;
    f32 sp98;
    f32 sp94;
    f32 sp90;
    f32 sp8C;
    f32 sp88;
    f32 sp84;
    f32 sp5C;
    f32 sp50;
    f32 *sp48;
    f32 *sp44;
    f32 *sp40;
    f32 *sp3C;
    f32 *sp38;
    f32 *temp_a0;
    f32 *temp_a0_2;
    f32 *temp_a0_3;
    f32 *temp_a0_4;
    f32 *temp_a0_5;
    f32 *temp_a0_6;
    f32 *temp_a0_7;
    f32 *temp_a0_8;
    f32 *temp_v0_2;
    f32 *temp_v0_3;
    f32 temp_f0;
    f32 temp_f0_2;
    f32 temp_f0_3;
    f32 temp_f0_4;
    f32 temp_f0_5;
    f32 temp_f0_6;
    f32 temp_f0_7;
    f32 temp_f0_8;
    f32 temp_f12;
    f32 temp_f12_2;
    f32 temp_f14;
    f32 temp_f16;
    f32 temp_f2;
    f32 temp_f2_2;
    f32 temp_f2_4;
    f64 temp_f2_3;
    s16 temp_v0;
    s16 temp_v1;
    s32 temp_s2;
    s32 temp_s2_2;
    s16 phi_v1;
    f32 phi_f2;
    s16 phi_v0;
    f32 phi_f0;
    f32 phi_f16;
    f32 phi_f18;
    s32 phi_s2;
    f32 *phi_v0_2;
    f32 phi_f16_2;

    temp_v1 = arg0->unkDB4 + 1;
    temp_f2 = arg0->unkDBC;
    temp_f0 = (temp_v1 * temp_f2) - (D_800ED580 * (temp_v1 * temp_v1));
    phi_v1 = temp_v1;
    phi_f2 = temp_f2;
    phi_f18 = temp_f0;
    if ((temp_v1 != 0) && (temp_f0 < 0.0f)) {
        temp_f2_2 = temp_f2 * D_800ED588;
        phi_v1 = 0;
        phi_f2 = temp_f2_2;
        if (temp_f2_2 <= D_800ED590) {
            phi_f2 = 0.0f;
        }
    }
    if (temp_f0 <= 0.0f) {
        phi_f18 = 0.0f;
    }
    arg0->unkDB4 = phi_v1;
    arg0->unkDBC = phi_f2;
    temp_v0 = arg1->unk9C + 1;
    temp_f0_2 = arg1->unk94;
    temp_s2 = arg8 * 4;
    temp_a0 = temp_s2 + &D_80164A38;
    temp_f12 = (temp_v0 * temp_f0_2) - (1.25 * (temp_v0 * temp_v0));
    phi_v0 = temp_v0;
    phi_f0 = temp_f0_2;
    phi_f16 = temp_f12;
    phi_s2 = temp_s2;
    if ((temp_v0 != 0) && (temp_f12 < 0.0f)) {
        temp_f0_3 = temp_f0_2 * D_800ED598;
        phi_v0 = 0;
        phi_f0 = temp_f0_3;
        if (temp_f0_3 <= D_800ED5A0) {
            phi_f0 = 0.0f;
        }
    }
    if (temp_f12 <= 0.0f) {
        phi_f16 = 0.0f;
    }
    arg1->unk9C = phi_v0;
    arg1->unk94 = phi_f0;
    if ((&D_80164A38 + (arg8 * 2))->unk4678 == 2) {
        sp48 = temp_a0;
        sp50 = phi_f16;
        sp5C = phi_f18;
        move_f32_towards(temp_f12, 0.0f, temp_a0, 20.0f, 0x3DCCCCCD);
        temp_a0_2 = temp_s2 + &D_80164A48;
        sp44 = temp_a0_2;
        move_f32_towards((bitwise f32) temp_a0_2, 1.5f, 0x3DCCCCCD);
        temp_v0_2 = temp_s2 + &D_80164A78;
        *temp_v0_2 = *temp_v0_2 + D_800ED5A8;
        phi_v0_2 = temp_v0_2;
        if (*temp_v0_2 >= 1.0f) {
            *temp_v0_2 = 1.0f;
        }
    } else {
        temp_s2_2 = arg8 * 4;
        temp_a0_3 = temp_s2_2 + &D_80164A38;
        sp48 = temp_a0_3;
        sp50 = phi_f16;
        sp5C = phi_f18;
        move_f32_towards(temp_f12, 0.0f, temp_a0_3, 0.0f, 0x3DCCCCCD);
        temp_a0_4 = temp_s2_2 + &D_80164A48;
        sp44 = temp_a0_4;
        move_f32_towards((bitwise f32) temp_a0_4, 0.0f, 0x3DCCCCCD);
        temp_v0_3 = temp_s2_2 + &D_80164A78;
        *temp_v0_3 = *temp_v0_3 - D_800ED5B0;
        temp_f0_4 = *(&D_800DDB30 + (gActiveScreenMode * 4));
        phi_s2 = temp_s2_2;
        phi_v0_2 = temp_v0_3;
        if (*temp_v0_3 <= temp_f0_4) {
            *temp_v0_3 = temp_f0_4;
        }
    }
    if ((arg0->unkCA & 0x100) == 0x100) {
        temp_a0_5 = phi_s2 + &D_80164A90;
        sp3C = temp_a0_5;
        sp40 = phi_v0_2;
        move_f32_towards((bitwise f32) temp_a0_5, 15.0f, 0x3CA3D70A);
        temp_a0_6 = phi_s2 + &D_80164AA0;
        sp38 = temp_a0_6;
        move_f32_towards((bitwise f32) temp_a0_6, 20.0f, 0x3CA3D70A);
    } else {
        temp_a0_7 = phi_s2 + &D_80164A90;
        sp3C = temp_a0_7;
        sp40 = phi_v0_2;
        move_f32_towards((bitwise f32) temp_a0_7, 0.0f, 0x3CA3D70A);
        temp_a0_8 = phi_s2 + &D_80164AA0;
        sp38 = temp_a0_8;
        move_f32_towards((bitwise f32) temp_a0_8, 0.0f, 0x3CA3D70A);
    }
    temp_f2_3 = D_800ED5B8;
    sp90 = arg1->unk30;
    temp_f0_5 = *sp38;
    sp94 = temp_f0_5 + ((arg1->unk34 + (arg0->unkDD2 * temp_f2_3)) - *sp44) + (sp50 / 2.0f);
    sp98 = temp_f0_5 + (arg1->unk38 + sp5C + *sp48);
    sp84 = arg1->unk3C;
    sp88 = arg1->unk40 + (arg0->unkDD2 * temp_f2_3) + sp50;
    sp8C = (arg1->unk44 + sp5C) - *sp3C;
    arg2->unk0 = arg1->unkC;
    arg2->unk4 = arg1->unk10;
    arg2->unk8 = arg1->unk14;
    if ((arg0->unkBC & 0x1000000) == 0x1000000) {
        sp8C /= 3.0f;
    }
    sp40 = phi_v0_2;
    func_802B6540(&sp9C, 0.0f, 1.0f, 0.0f, arg7);
    func_802B63B8(&sp84, &sp9C);
    temp_f12_2 = sp84 + arg0->unk14;
    temp_f14 = sp8C + arg0->unk1C;
    temp_f16 = sp88 + arg0->unk18;
    arg2->unk0 = arg2->unk0 + ((temp_f12_2 - arg1->unkC) * *phi_v0_2);
    arg2->unk8 = arg2->unk8 + ((temp_f14 - arg1->unk14) * *phi_v0_2);
    if ((((arg0->unk94 / 18.0f) * 216.0f) <= 5.0f) && ((arg0->unkBC & 2) == 2)) {
        arg2->unk4 = arg2->unk4 + ((temp_f16 - arg1->unk10) * D_800ED5C0);
    } else {
        arg2->unk4 = arg2->unk4 + ((temp_f16 - arg1->unk10) * 0.5);
    }
    sp40 = phi_v0_2;
    func_802B63B8((bitwise f32 *) temp_f12_2, (bitwise f32 *) temp_f14, &sp90, &sp9C);
    if ((arg0->unkBC & 0x1000000) != 0x1000000) {
        phi_f16_2 = sp94 + arg0->unk18;
    } else {
        phi_f16_2 = sp94 + (arg0->unk74 + arg0->unk70);
    }
    temp_f0_6 = arg1->unk0;
    *arg3 = (*phi_v0_2 * ((sp90 + arg0->unk14) - temp_f0_6)) + temp_f0_6;
    temp_f2_4 = arg1->unk8;
    *arg5 = (*phi_v0_2 * ((sp98 + arg0->unk1C) - temp_f2_4)) + temp_f2_4;
    if ((((arg0->unk94 / 18.0f) * 216.0f) <= 5.0f) && ((arg0->unkBC & 2) == 2)) {
        temp_f0_7 = arg1->unk4;
        *arg4 = ((phi_f16_2 - temp_f0_7) * D_800ED5C8) + temp_f0_7;
    } else {
        temp_f0_8 = arg1->unk4;
        *arg4 = ((phi_f16_2 - temp_f0_8) * D_800ED5D0) + temp_f0_8;
    }
    if ((arg0->unkDE & 1) != 0) {
        *arg4 = *(D_801652A0 + phi_s2);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/camera/func_8001D944.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_8001CA78(void *, void *, f32 *, f32 *, f32 *, f32 *, s32, s32); // extern
? func_800224F0(s32, s16, s16, void *); // extern
s16 func_802ADDC8(void *, f32, f32, f32, f32); // extern
s16 atan2s(f32, f32); // extern

void func_8001E0C4(void *arg0, void *arg1, s8 arg2) {
    f32 sp84;
    f32 sp80;
    f32 sp7C;
    f32 sp74;
    f32 sp70;
    f32 sp6C;
    f32 sp60;
    f32 temp_f0;
    f32 temp_f12;
    f32 temp_f14;
    f32 temp_f2;
    f32 temp_f2_2;
    s16 temp_a1;
    s16 temp_v0;
    void *temp_a3;
    s16 phi_a2;

    temp_v0 = arg1->unk78;
    temp_a3 = arg1;
    if (temp_v0 == 0) {
        phi_a2 = 0x64;
    } else if (temp_v0 < 0) {
        phi_a2 = 0x87 - (temp_v0 / 3);
    } else {
        phi_a2 = (temp_v0 / 3) + 0x87;
    }
    temp_a1 = temp_a3->unk2E;
    arg1 = temp_a3;
    func_800224F0(arg0 + 0x2C, temp_a1, phi_a2, temp_a3);
    func_8001CA78(arg1, arg0, &sp60, &sp74, &sp70, &sp6C, arg0->unk2C, arg2);
    arg0->unk2A = arg0->unk2A & 0xFFFB;
    temp_f0 = arg0->unk68;
    if (temp_f0 < 0.0f) {
        sp74 += -arg0->unk84 * temp_f0 * 1.0f;
        sp70 = sp70 + ((-arg0->unk88 * arg0->unk68) * 0.5);
        sp6C += -arg0->unk8C * arg0->unk68 * 1.0f;
    }
    temp_f2 = arg0->unk60;
    if (temp_f2 < 0.0f) {
        arg0->unk2A = arg0->unk2A | 6;
        sp74 = sp74 + ((-arg0->unk6C * temp_f2) * 1.5);
        sp70 += -arg0->unk70 * arg0->unk60 * 1.0f;
        sp6C = sp6C + ((-arg0->unk74 * arg0->unk60) * 1.5);
    }
    temp_f2_2 = arg0->unk64;
    if (temp_f2_2 < 0.0f) {
        arg0->unk2A = arg0->unk2A | 6;
        sp74 = sp74 + ((-arg0->unk78 * temp_f2_2) * 1.5);
        sp70 += -arg0->unk7C * arg0->unk64 * 1.0f;
        sp6C = sp6C + ((-arg0->unk80 * arg0->unk64) * 1.5);
    }
    if ((func_802ADDC8(arg0 + 0x54, 3, sp74, sp70, sp6C) == 0) && ((arg0->unk2A & 2) != 2)) {
        arg0->unkAC = arg0->unk2C;
    }
    arg0->unkC = sp60;
    arg0->unk10 = sp64;
    arg0->unk14 = sp68;
    arg0->unk0 = sp74;
    arg0->unk4 = sp70;
    temp_f12 = arg0->unkC - arg0->unk0;
    arg0->unk8 = sp6C;
    sp80 = arg0->unk10 - arg0->unk4;
    sp84 = temp_f12;
    temp_f14 = arg0->unk14 - arg0->unk8;
    sp7C = temp_f14;
    arg0->unk26 = atan2s(temp_f12, temp_f14);
    arg0->unk24 = atan2s(sqrtf((sp84 * sp84) + (temp_f14 * temp_f14)), sp80);
    arg0->unk28 = 0;
}
#else
GLOBAL_ASM("asm/non_matchings/camera/func_8001E0C4.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_8001CCEC(void *, void *, f32 *, f32 *, f32 *, f32 *, ? *, s32, s32); // extern
? func_800224F0(void *, s16, s16, s16); // extern
? move_s16_towards(void *, ?, ?, s16); // extern
? func_802ADDC8(void *, f32, f32, f32, f32); // extern
s16 atan2s(f32, f32); // extern

void func_8001E45C(void *arg0, void *arg1, s8 arg2) {
    f32 sp94;
    f32 sp90;
    f32 sp8C;
    f32 sp84;
    f32 sp80;
    f32 sp7C;
    f32 sp64;
    ? sp58;
    s16 sp4E;
    f32 temp_f12;
    f32 temp_f14;
    s16 temp_a3;
    s16 temp_a3_2;
    s16 temp_a3_3;
    s16 temp_v1;
    s16 temp_v1_2;
    s32 temp_v0;
    s16 phi_a3;

    temp_v0 = arg1->unkBC;
    if ((temp_v0 & 0x10) == 0x10) {
        temp_v1 = arg1->unk78;
        phi_a3 = 0x64;
        if (temp_v1 == 0) {
            arg0->unkB0 = 0;
        } else {
            if (temp_v1 < 0) {
                temp_a3 = 0xA5 - (temp_v1 / 2);
                if ((temp_v0 & 0x20000000) == 0x20000000) {
                    sp4E = temp_a3;
                    move_s16_towards(arg0 + 0xB0, -0xB60, 0x3DCCCCCD, temp_a3);
                } else {
                    sp4E = temp_a3;
                    move_s16_towards(arg0 + 0xB0, -0x888, 0x3DCCCCCD, temp_a3);
                }
            } else {
                temp_a3_2 = (temp_v1 / 2) + 0xA5;
                if ((temp_v0 & 0x20000000) == 0x20000000) {
                    sp4E = temp_a3_2;
                    move_s16_towards(arg0 + 0xB0, 0xB60, 0x3DCCCCCD, temp_a3_2);
                } else {
                    sp4E = temp_a3_2;
                    move_s16_towards(arg0 + 0xB0, 0x888, 0x3DCCCCCD, temp_a3_2);
                }
            }
            phi_a3 = sp4E;
        }
        goto block_26;
    }
    move_s16_towards(arg0 + 0xB0, 0, 0x3D4CCCCD);
    temp_v1_2 = arg1->unk78;
    temp_a3_3 = (arg0->unk2C / 0xB6) - (arg1->unk2E / 0xB6);
    if (temp_v1_2 == 0) {
        if ((arg1->unkBC & 0x20) == 0x20) {
            phi_a3 = 0x2D8;
        } else {
            phi_a3 = 0x1F4;
        }
    } else {
        if (temp_v1_2 < 0) {
            if ((temp_a3_3 < -0x45) || (temp_a3_3 >= 0x46)) {
                phi_a3 = 0xB4 - temp_v1_2;
            } else {
                phi_a3 = 0xA5 - (temp_v1_2 / 2);
            }
        } else if ((temp_a3_3 < -0x45) || (temp_a3_3 >= 0x46)) {
            phi_a3 = temp_v1_2 + 0xB4;
        } else {
            phi_a3 = (temp_v1_2 / 2) + 0xA5;
        }
block_26:
    }
    if (((arg1->unkBC & 0x80) == 0x80) || ((arg1->unkBC & 0x40) == 0x40) || ((arg1->unkBC & 0x4000) == 0x4000) || ((arg1->unkBC & 0x80000) == 0x80000) || ((arg1->unkBC & 0x800000) == 0x800000) || (((arg1->unkBC & 0x20) == 0x20) && (arg1->unk78 != 0)) || (arg1->unk11C <= 0.0f) || (arg1->unk120 <= 0.0f) || ((arg1->unkBC & 0x20000) == 0x20000)) {
        func_8001CCEC(arg1, arg0, &sp64, &sp84, &sp80, &sp7C, &sp58, arg0->unk2C, arg2);
    } else {
        func_800224F0(arg0 + 0x2C, arg1->unk2E + arg0->unkB0, phi_a3, phi_a3);
        func_8001CCEC(arg1, arg0, &sp64, &sp84, &sp80, &sp7C, &sp58, arg0->unk2C, arg2);
    }
    arg0->unk2A = arg0->unk2A & 0xFFFB;
    func_802ADDC8(arg0 + 0x54, 3, sp84, sp80, sp7C);
    arg0->unk0 = sp84;
    arg0->unk4 = sp80;
    arg0->unk8 = sp7C;
    arg0->unkC = sp64;
    arg0->unk10 = sp68;
    temp_f12 = arg0->unkC - arg0->unk0;
    arg0->unk14 = sp6C;
    sp90 = arg0->unk10 - arg0->unk4;
    sp94 = temp_f12;
    temp_f14 = arg0->unk14 - arg0->unk8;
    sp8C = temp_f14;
    arg0->unk26 = atan2s(temp_f12, temp_f14);
    arg0->unk24 = atan2s(sqrtf((sp94 * sp94) + (temp_f14 * temp_f14)), sp90);
    arg0->unk28 = 0;
}
#else
GLOBAL_ASM("asm/non_matchings/camera/func_8001E45C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_8001D53C(void *, void *, f32 *, f32 *, f32 *, f32 *, s32, s32); // extern
? func_802ADDC8(void *, ?, f32, f32, f32); // extern
s16 atan2s(f32, f32); // extern

void func_8001E8E8(void *arg0, void *arg1, s8 arg2) {
    f32 sp8C;
    f32 sp88;
    f32 sp84;
    f32 sp7C;
    f32 sp78;
    f32 sp74;
    f32 sp5C;
    f32 temp_f12;
    f32 temp_f14;

    arg0->unkB0 = 0;
    arg0->unk2C = arg1->unk2E;
    func_8001D53C(arg1, arg0, &sp5C, &sp7C, &sp78, &sp74, arg1->unk2E, arg2);
    func_802ADDC8(arg0 + 0x54, 0x40A00000, sp7C, sp78, sp74);
    arg0->unkC = sp5C;
    arg0->unk10 = sp60;
    arg0->unk14 = sp64;
    arg0->unk0 = sp7C;
    arg0->unk4 = sp78;
    temp_f12 = arg0->unkC - arg0->unk0;
    arg0->unk8 = sp74;
    sp88 = arg0->unk10 - arg0->unk4;
    sp8C = temp_f12;
    temp_f14 = arg0->unk14 - arg0->unk8;
    sp84 = temp_f14;
    arg0->unk26 = atan2s(temp_f12, temp_f14);
    arg0->unk24 = atan2s(sqrtf((sp8C * sp8C) + (temp_f14 * temp_f14)), sp88);
    arg0->unk28 = 0;
}
#else
GLOBAL_ASM("asm/non_matchings/camera/func_8001E8E8.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_8001D944(void *, void *, f32 *, f32 *, f32 *, f32 *, ? *, s32, s32); // extern
? func_800224F0(void *, s16, s16, s16); // extern
? move_s16_towards(void *, ?, ?, s16); // extern
? func_802ADDC8(void *, f32, f32, f32, f32); // extern
s16 atan2s(f32, f32); // extern

void func_8001EA0C(void *arg0, void *arg1, s8 arg2) {
    f32 sp94;
    f32 sp90;
    f32 sp8C;
    f32 sp84;
    f32 sp80;
    f32 sp7C;
    f32 sp64;
    ? sp58;
    s16 sp4E;
    f32 temp_f12;
    f32 temp_f14;
    s16 temp_a3;
    s16 temp_a3_2;
    s16 temp_a3_3;
    s16 temp_v1;
    s16 temp_v1_2;
    s32 temp_v0;
    s16 phi_a3;

    temp_v0 = arg1->unkBC;
    if ((temp_v0 & 0x10) == 0x10) {
        temp_v1 = arg1->unk78;
        phi_a3 = 0x64;
        if (temp_v1 == 0) {
            arg0->unkB0 = 0;
        } else {
            if (temp_v1 < 0) {
                temp_a3 = 0xA5 - (temp_v1 / 2);
                if ((temp_v0 & 0x20000000) == 0x20000000) {
                    sp4E = temp_a3;
                    move_s16_towards(arg0 + 0xB0, -0xB60, 0x3DCCCCCD, temp_a3);
                } else {
                    sp4E = temp_a3;
                    move_s16_towards(arg0 + 0xB0, -0x888, 0x3DCCCCCD, temp_a3);
                }
            } else {
                temp_a3_2 = (temp_v1 / 2) + 0xA5;
                if ((temp_v0 & 0x20000000) == 0x20000000) {
                    sp4E = temp_a3_2;
                    move_s16_towards(arg0 + 0xB0, 0xB60, 0x3DCCCCCD, temp_a3_2);
                } else {
                    sp4E = temp_a3_2;
                    move_s16_towards(arg0 + 0xB0, 0x888, 0x3DCCCCCD, temp_a3_2);
                }
            }
            phi_a3 = sp4E;
        }
        goto block_26;
    }
    move_s16_towards(arg0 + 0xB0, 0, 0x3D4CCCCD);
    temp_v1_2 = arg1->unk78;
    temp_a3_3 = (arg0->unk2C / 0xB6) - (arg1->unk2E / 0xB6);
    if (temp_v1_2 == 0) {
        if ((arg1->unkBC & 0x20) == 0x20) {
            phi_a3 = 0x2D8;
        } else {
            phi_a3 = 0x1F4;
        }
    } else {
        if (temp_v1_2 < 0) {
            if ((temp_a3_3 < -0x45) || (temp_a3_3 >= 0x46)) {
                phi_a3 = 0xB4 - temp_v1_2;
            } else {
                phi_a3 = 0xA5 - (temp_v1_2 / 2);
            }
        } else if ((temp_a3_3 < -0x45) || (temp_a3_3 >= 0x46)) {
            phi_a3 = temp_v1_2 + 0xB4;
        } else {
            phi_a3 = (temp_v1_2 / 2) + 0xA5;
        }
block_26:
    }
    if (((arg1->unkBC & 0x80) == 0x80) || ((arg1->unkBC & 0x40) == 0x40) || ((arg1->unkBC & 0x4000) == 0x4000) || ((arg1->unkBC & 0x80000) == 0x80000) || ((arg1->unkBC & 0x800000) == 0x800000) || (((arg1->unkBC & 0x20) == 0x20) && (arg1->unk78 != 0)) || (arg1->unk11C <= 0.0f) || (arg1->unk120 <= 0.0f) || ((arg1->unkBC & 0x20000) == 0x20000)) {
        func_8001D944(arg1, arg0, &sp64, &sp84, &sp80, &sp7C, &sp58, arg0->unk2C, arg2);
    } else {
        func_800224F0(arg0 + 0x2C, arg1->unk2E + arg0->unkB0, phi_a3, phi_a3);
        func_8001D944(arg1, arg0, &sp64, &sp84, &sp80, &sp7C, &sp58, arg0->unk2C, arg2);
    }
    arg0->unk2A = arg0->unk2A & 0xFFFB;
    func_802ADDC8(arg0 + 0x54, 3, sp84, sp80, sp7C);
    arg0->unk0 = sp84;
    arg0->unk4 = sp80;
    arg0->unk8 = sp7C;
    arg0->unkC = sp64;
    arg0->unk10 = sp68;
    temp_f12 = arg0->unkC - arg0->unk0;
    arg0->unk14 = sp6C;
    sp90 = arg0->unk10 - arg0->unk4;
    sp94 = temp_f12;
    temp_f14 = arg0->unk14 - arg0->unk8;
    sp8C = temp_f14;
    arg0->unk26 = atan2s(temp_f12, temp_f14);
    arg0->unk24 = atan2s(sqrtf((sp94 * sp94) + (temp_f14 * temp_f14)), sp90);
    arg0->unk28 = 0;
}
#else
GLOBAL_ASM("asm/non_matchings/camera/func_8001EA0C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80019ED0(); // extern
? func_8001A0A4(s16 *, s32, void *, s8, s32); // extern
? func_8001A0DC(s16 *, s32, void *, s8, s32); // extern
? func_8001A588(u16 *, s32, void *, s8, s32); // extern
? func_8001E0C4(s32, void *, s8); // extern
? func_8001E45C(s32, void *, s8); // extern
? func_8001E8E8(s32, void *, s8); // extern
? func_8001EA0C(s32, void *, s8); // extern
? func_8001F87C(s32); // extern
extern u16 D_800DC5FC;
extern ? D_80152300;
extern u16 D_8015F894;
extern s8 D_80164A88;
extern s8 D_80164A89;

void func_8001EE98(void *arg0, s32 arg1, s8 arg2) {
    s32 sp34;
    s16 *sp2C;
    s16 *temp_a0;
    s16 *temp_a0_2;
    s16 *temp_a0_3;
    s16 *temp_a0_4;
    s16 *temp_a0_5;
    s16 *temp_a0_6;
    s16 temp_v0_3;
    s16 temp_v0_4;
    s32 temp_v0;
    u16 *temp_a0_7;
    u16 temp_v0_2;
    s32 phi_s0;
    s8 phi_v1;

    if (arg1 == camera1) {
        sp34 = 0;
    }
    phi_s0 = sp34;
    if (arg1 == camera2) {
        phi_s0 = 1;
    }
    if (arg1 == camera3) {
        phi_s0 = 2;
    }
    phi_v1 = 1;
    if (arg1 == camera4) {
        phi_s0 = 3;
    }
    temp_v0 = gModeSelection;
    if (temp_v0 != GRAND_PRIX) {
        if (temp_v0 != TIME_TRIALS) {
            if (temp_v0 != VERSUS) {
                if (temp_v0 != BATTLE) {

                } else if ((D_800DC51C == 1) || ((D_8015F894 == 2) && (D_80164A89 == 1))) {
                    if (D_80164A88 == 0) {
                        func_80019ED0();
                    }
                    D_80164A88 = 1;
                    D_80152300.unk0 = 3;
                    D_80152300.unk2 = 3;
                    D_80152300.unk4 = 3;
                    D_80152300.unk6 = 3;
                    phi_v1 = 1;
                } else {
                    D_80164A88 = 0;
                    if (D_800DC5FC == 1) {
                        temp_a0 = (phi_s0 * 2) + &D_80152300;
                        sp2C = temp_a0;
                        func_8001A0A4(temp_a0, arg1, arg0, arg2, phi_s0);
                    } else {
                        temp_a0_2 = (phi_s0 * 2) + &D_80152300;
                        sp2C = temp_a0_2;
                        func_8001A0DC(temp_a0_2, arg1, arg0, arg2, phi_s0);
                    }
                    *sp2C = 9;
                    phi_v1 = 1;
                }
            } else if (((arg0->unk0 & 0x800) == 0x800) || (D_800DC51C == 1) || (D_8015F894 == 2)) {
                *(&D_80152300 + (phi_s0 * 2)) = 3;
            } else {
                if (D_800DC5FC == 1) {
                    temp_a0_3 = (phi_s0 * 2) + &D_80152300;
                    sp2C = temp_a0_3;
                    func_8001A0A4(temp_a0_3, arg1, arg0, arg2, phi_s0);
                } else {
                    temp_a0_4 = (phi_s0 * 2) + &D_80152300;
                    sp2C = temp_a0_4;
                    func_8001A0DC(temp_a0_4, arg1, arg0, arg2, phi_s0);
                }
                *sp2C = 1;
                phi_v1 = 1;
            }
        } else if (((gPlayerOne->unk_000 & PLAYER_CINEMATIC_MODE) == PLAYER_CINEMATIC_MODE) || (D_800DC51C == 1)) {
            D_80152300.unk0 = 3;
            *(&D_80152300 + 2) = 3;
            *(&D_80152300 + 4) = 3;
            *(&D_80152300 + 6) = 3;
        } else {
            if (D_800DC5FC == 1) {
                temp_a0_5 = (phi_s0 * 2) + &D_80152300;
                sp2C = temp_a0_5;
                func_8001A0A4(temp_a0_5, arg1, arg0, arg2, phi_s0);
            } else {
                temp_a0_6 = (phi_s0 * 2) + &D_80152300;
                sp2C = temp_a0_6;
                func_8001A0DC(temp_a0_6, arg1, arg0, arg2, phi_s0);
            }
            *sp2C = 1;
            phi_v1 = 1;
        }
    } else if (((arg0->unk0 & 0x800) == 0x800) || (D_800DC51C == 1)) {
        *(&D_80152300 + (phi_s0 * 2)) = 3;
    } else if (D_800DC5FC == 1) {
        func_8001A0A4((phi_s0 * 2) + &D_80152300, arg1, arg0, arg2, phi_s0);
    } else {
        func_8001A0DC((phi_s0 * 2) + &D_80152300, arg1, arg0, arg2, phi_s0);
    }
    if (D_800DC5FC == 0) {
        temp_a0_7 = (phi_s0 * 2) + &D_80152300;
        temp_v0_2 = *temp_a0_7;
        if (temp_v0_2 != phi_v1) {
            if (temp_v0_2 != 3) {
                if (temp_v0_2 != 8) {
                    if (temp_v0_2 != 9) {
                        return;
                    }
                    temp_v0_3 = arg0->unkCA;
                    if ((phi_v1 == (temp_v0_3 & 1)) || ((temp_v0_3 & 2) == 2)) {
                        func_8001E8E8(arg1, arg0, arg2);
                        return;
                    }
                    func_8001EA0C(arg1, arg0, arg2);
                    // Duplicate return node #60. Try simplifying control flow for better match
                    return;
                }
                func_8001E0C4(arg1, arg0, arg2);
                func_8001F87C(phi_s0);
                return;
            }
            func_8001A588(temp_a0_7, arg1, arg0, arg2, phi_s0);
            return;
        }
        temp_v0_4 = arg0->unkCA;
        if ((phi_v1 == (temp_v0_4 & 1)) || ((temp_v0_4 & 2) == 2)) {
            func_8001E8E8(arg1, arg0, arg2);
            return;
        }
        func_8001E45C(arg1, arg0, arg2);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/camera/func_8001EE98.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit bd0364fa19633bd6201f8007e2d0a7ed87825909
? move_f32_towards(f32, f32 *, ?, ?, s32);             /* extern */
extern ? D_80164498;
extern ? D_80164A08;

void func_8001F394(Player *player, f32 *arg1) {
    s32 playerId;
    s32 sp1C;
    f32 *temp_a0;
    f32 *temp_a0_2;
    f32 *temp_a0_3;
    f32 *temp_a0_4;
    f32 *temp_a0_5;
    f32 *temp_a0_6;
    f32 temp_f0;
    f32 temp_f0_2;
    f32 temp_f0_3;
    f32 temp_f0_4;
    f32 temp_f0_5;
    f32 temp_f0_6;
    s32 *temp_v1;
    s32 temp_t3;
    s32 temp_v0;
    s32 temp_v0_2;
    s32 temp_v0_3;
    s32 temp_v0_4;
    s32 temp_v0_5;
    f32 *phi_a0;
    f32 phi_f2;
    f32 phi_f0;

    if (player == gPlayerOne) {
        playerId = 0;
    }
    if (player == gPlayerTwo) {
        playerId = 1;
    }
    if (player == gPlayerThree) {
        playerId = 2;
    }
    if (player == gPlayerFour) {
        playerId = 3;
    }
    temp_t3 = playerId * 4;
    temp_v1 = temp_t3 + &D_80164A08;
    if (*temp_v1 == 0) {
        if (player->unk_00C & 0x40000) {
            *temp_v1 = 1;
        }
        if ((player->unk_0BC & 0x2000) == 0x2000) {
            *temp_v1 = 2;
        }
        if ((player->unk_0BC & 0x100000) == 0x100000) {
            *temp_v1 = 3;
        }
        if ((player->unk_00C & 0x100) == 0x100) {
            *temp_v1 = 4;
        }
        temp_v0 = player->unk_0BC;
        if (((temp_v0 & 0x80) == 0x80) || ((temp_v0 & 0x40) == 0x40)) {
            *temp_v1 = 5;
        }
        *(&D_80164498 + temp_t3) = 0.0f;
    }
    switch (*temp_v1) {
    case 1:
        temp_a0 = temp_t3 + &D_80164498;
        phi_a0 = temp_a0;
        if (player->unk_00C & 0x40000) {
            sp1C = temp_t3;
            move_f32_towards(0.0f, temp_a0, 0x41A00000, 0x3E4CCCCD, temp_t3);
        } else {
            temp_f0 = *temp_a0;
            if (temp_f0 > 1.0f) {
                *temp_a0 = temp_f0 - 1.0f;
            } else {
                *temp_v1 = 0;
block_51:
                *phi_a0 = 0.0f;
            }
        }
        break;
    case 2:
        if ((player->unk_0BC & 0x2000) == 0x2000) {
            if (player->unk_0DC != 0) {
                sp1C = temp_t3;
                move_f32_towards(0.0f, temp_t3 + &D_80164498, 0x41000000, 0x3E4CCCCD, temp_t3);
            }
        } else {
            temp_a0_2 = temp_t3 + &D_80164498;
            temp_f0_2 = *temp_a0_2;
            phi_a0 = temp_a0_2;
            if (temp_f0_2 > 1.0f) {
                *temp_a0_2 = temp_f0_2 - 2.0f;
            } else {
                *temp_v1 = 0;
                goto block_51;
            }
        }
        break;
    case 3:
        temp_v0_2 = player->unk_0BC;
        temp_a0_3 = temp_t3 + &D_80164498;
        phi_a0 = temp_a0_3;
        if (((temp_v0_2 & 0x100000) == 0x100000) && ((temp_v0_2 & 8) == 8)) {
            sp1C = temp_t3;
            move_f32_towards(0.0f, temp_a0_3, 0x41A00000, 0x3DCCCCCD, temp_t3);
        } else {
            temp_f0_3 = *temp_a0_3;
            if (temp_f0_3 > 1.0f) {
                *temp_a0_3 = temp_f0_3 - 1.0f;
            } else {
                *temp_v1 = 0;
                goto block_51;
            }
        }
        break;
    case 4:
        temp_a0_4 = temp_t3 + &D_80164498;
        phi_a0 = temp_a0_4;
        if ((player->unk_00C & 0x100) == 0x100) {
            sp1C = temp_t3;
            move_f32_towards(0.0f, temp_a0_4, 0x41C80000, 0x3F800000, temp_t3);
        } else {
            temp_f0_4 = *temp_a0_4;
            if (temp_f0_4 > 1.0f) {
                *temp_a0_4 = temp_f0_4 - 2.0f;
            } else {
                *temp_v1 = 0;
                goto block_51;
            }
        }
        break;
    case 5:
        temp_v0_3 = player->unk_0BC;
        temp_a0_5 = temp_t3 + &D_80164498;
        phi_a0 = temp_a0_5;
        if (((temp_v0_3 & 0x80) == 0x80) || ((temp_v0_3 & 0x40) == 0x40)) {
            sp1C = temp_t3;
            move_f32_towards(0.0f, temp_a0_5, 0x41900000, 0x3E4CCCCD, temp_t3);
        } else {
            temp_f0_5 = *temp_a0_5;
            if (temp_f0_5 > 1.0f) {
                *temp_a0_5 = temp_f0_5 - 2.0f;
            } else {
                *temp_v1 = 0;
                goto block_51;
            }
        }
        break;
    }
    temp_v0_4 = gActiveScreenMode;
    if (temp_v0_4 != 0) {
        if ((temp_v0_4 != 1) && (temp_v0_4 != 2) && (temp_v0_4 != 3)) {
            phi_f2 = sp34;
        } else {
            phi_f0 = func_80014EE4(*arg1, playerId, MIPS2C_ERROR(Read from unset register $a2));
            goto block_66;
        }
    } else {
        temp_v0_5 = D_80164A28;
        if (temp_v0_5 == 1) {
            *(&D_80164498 + (playerId * 4)) = 40.0f;
        }
        temp_a0_6 = (playerId * 4) + &D_80164498;
        if (temp_v0_5 == 2) {
            temp_f0_6 = *temp_a0_6;
            if (temp_f0_6 >= 0.0f) {
                *temp_a0_6 = temp_f0_6 - 0.8;
            }
            if (*temp_a0_6 <= 0.0f) {
                D_80164A28 = 0;
                *temp_a0_6 = 0.0f;
            }
        }
        phi_f0 = func_80014EE4(*arg1, playerId, MIPS2C_ERROR(Read from unset register $a2));
block_66:
        phi_f2 = phi_f0;
    }
    *arg1 = phi_f2;
    cameras[playerId].unk30 = phi_f2;
}
#else
GLOBAL_ASM("asm/non_matchings/camera/func_8001F394.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern ? D_80152300;
extern ? cameras;
extern s32 D_80164A2C;

void func_8001F87C(s32 arg0) {
    s32 temp_a1;
    u16 temp_v0;
    void *temp_v0_2;
    Player *phi_a2;
    s32 phi_a1;

    if (gActiveScreenMode == 0) {
        phi_a2 = gPlayerOne;
        phi_a1 = 0;
        if (gModeSelection == GRAND_PRIX) {
loop_3:
            temp_v0 = phi_a2->unk_000;
            if (((temp_v0 & 0x200) == 0) && ((temp_v0 & 0x80) == 0)) {
                if (phi_a1 == 0x60E8) {
                    D_80164A2C = D_80164A2C + 1;
                }
                if ((phi_a1 == 0x60E8) && (D_80164A2C == 0x3C)) {
                    D_80164A28 = 2;
                    *(&D_80152300 + (arg0 * 2)) = 1;
                    temp_v0_2 = &cameras + (arg0 * 0xB8);
                    temp_v0_2->unk26 = phi_a2->unk_02E;
                    temp_v0_2->unk2C = phi_a2->unk_02E;
                }
                temp_a1 = phi_a1 + 0xDD8;
                phi_a2 += 0xDD8;
                phi_a1 = temp_a1;
                if (temp_a1 != 0x6EC0) {
                    goto loop_3;
                }
            }
        }
    }
}
#else
GLOBAL_ASM("asm/non_matchings/camera/func_8001F87C.s")
#endif
