#include <ultra64.h>
#include <macros.h>
#include <common_structs.h>
#include <defines.h>
#include "framebuffers.h"

extern s32 D_800ED600, D_800ED608, D_800ED610, D_800ED618, D_800ED620, D_800ED628, D_800ED630;
extern s32 D_800DC52C;
extern s32 D_800ED638;
extern s32 D_80164A28;
extern u16 D_800DC51C;
extern u16 D_8015F894;
extern Player *gPlayerOne;
extern Player *gPlayerTwo;
extern Player *gPlayerThree;
extern Player *gPlayerFour;
extern Player *gPlayerFive;
extern Player *gPlayerSix;
extern Player *gPlayerSeven;
extern Player *gPlayerEight;
extern Player *gPlayerOneCopy;

extern void func_8006E848(Player *, u8, u8);
extern void func_8006E8C4(Player *, u8, u8);


// Not yet implemented. Needs more work to match.
// Remove ifdef when matching.
#ifdef NON_MATCHING
s8 D_800DDB50[] = {
    0x00, 0x02, 0x00, 0x01, 0x00, 0x01, 0x00, 0x02
};

s32 D_800DDB58[] = {
    0x00000000, gFramebuffer0, gFramebuffer1, gFramebuffer2
};
#endif

void func_8001F980(s32 *arg0, s32 *arg1) {
    if ((D_800DC51C == 1) || (D_80164A28 != 0) || (D_8015F894 != 0)) {
        *arg0 = 0xAA;
    } else {
        *arg0 = 0;
    }
    if (D_80164A28 != 0) {
        *arg1 = 0xAA;
        return;
    }
    *arg1 = 0;
}

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_8001F980(s32 *, s32 *); // extern
s32 func_8001FB0C(void *, s32, f32, f32); // extern
? get_player_index_for_player(); // extern

void func_8001F9E4(void *arg0, s32 arg1, s8 arg2) {
    s32 sp30;
    s32 sp2C;
    s32 sp24;
    s32 sp20;
    s32 temp_t0;
    s32 temp_t6;
    s32 temp_v1;
    u16 temp_t3;

    get_player_index_for_player();
    func_8001F980(&sp30, &sp2C);
    temp_t6 = arg2 * 4;
    temp_v1 = 2 << temp_t6;
    temp_t0 = 8 << temp_t6;
    temp_t3 = arg0->unk2 & ~temp_v1;
    arg0->unk2 = temp_t3;
    arg0->unk2 = temp_t3 & ~temp_t0;
    sp20 = temp_t0;
    sp24 = temp_v1;
    if (func_8001FB0C(arg0, arg1, D_80165578 + sp30, D_8016557A + sp2C) == 1) {
        arg0->unk2 = arg0->unk2 | temp_v1;
    }
    if (func_8001FB0C(arg0, arg1, D_80165580, D_80165582) == 1) {
        arg0->unk2 = arg0->unk2 | sp20;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_8001F980/func_8001F9E4.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
f32 sins(s32); // extern
f32 coss(s32); // extern

u16 func_8001FB0C(void *arg0, void *arg1, f32 arg2, f32 arg3) {
    f32 sp64;
    f32 sp60;
    f32 sp5C;
    f32 sp58;
    f32 sp54;
    f32 sp50;
    f32 sp4C;
    f32 sp48;
    f32 sp44;
    s16 sp42;
    u16 sp40;
    f32 sp34;
    f32 sp2C;
    f32 sp20;
    f32 temp_f10;
    f32 temp_f10_2;
    f32 temp_f12;
    f32 temp_f14;
    f32 temp_f16;
    f32 temp_f18;
    f32 temp_f2;
    f32 temp_f4;
    f32 temp_f6;
    f32 temp_f8;
    s32 temp_v0;
    s16 phi_v0;

    temp_v0 = D_800DC52C;
    sp40 = 0;
    if (temp_v0 != 0) {
        if ((temp_v0 != 1) && (temp_v0 != 2)) {
            if (temp_v0 != 3) {
                phi_v0 = 0x1FFE;
            } else {
                phi_v0 = 0x1FFE;
            }
        } else {
            phi_v0 = 0x3058;
        }
    } else {
        phi_v0 = 0x293C;
    }
    sp42 = phi_v0;
    sp4C = arg1->unk8 + (arg2 * coss((arg1->unk26 - phi_v0) & 0xFFFF));
    sp58 = arg1->unk0 + (arg2 * sins((arg1->unk26 - phi_v0) & 0xFFFF));
    temp_f10 = arg1->unk8 + (arg2 * coss((arg1->unk26 + phi_v0) & 0xFFFF));
    sp48 = temp_f10;
    sp54 = arg1->unk0 + (arg2 * sins((arg1->unk26 + phi_v0) & 0xFFFF));
    sp44 = arg1->unk8 + (arg3 * coss((arg1->unk26 + 0x5FFA) & 0xFFFF));
    sp50 = arg1->unk0 + (arg3 * sins((arg1->unk26 + 0x5FFA) & 0xFFFF));
    temp_f12 = arg0->unk14;
    temp_f2 = arg0->unk1C;
    temp_f16 = sp54 - temp_f12;
    temp_f14 = sp4C - temp_f2;
    temp_f18 = sp58 - temp_f12;
    temp_f4 = temp_f10 - temp_f2;
    sp20 = temp_f4;
    temp_f10_2 = (temp_f14 * temp_f16) - (temp_f18 * temp_f4);
    temp_f8 = sp50 - temp_f12;
    sp64 = temp_f10_2;
    sp2C = temp_f8;
    sp34 = sp44 - temp_f2;
    temp_f6 = (temp_f4 * temp_f8) - (temp_f16 * sp34);
    sp60 = temp_f6;
    sp5C = (sp34 * temp_f18) - (temp_f8 * temp_f14);
    if (((temp_f10_2 >= 0.0f) && (temp_f6 >= 0.0f) && (sp5C >= 0.0f)) || ((sp64 <= 0.0f) && (sp60 <= 0.0f) && (sp5C <= 0.0f))) {
        sp40 = 1;
    }
    return sp40;
}
#else
GLOBAL_ASM("asm/non_matchings/code_8001F980/func_8001FB0C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
f32 sins(s32); // extern
f32 coss(s32); // extern

u16 func_8001FD78(void *arg0, f32 arg1, ? arg2, f32 arg3) {
    f32 sp64;
    f32 sp60;
    f32 sp5C;
    f32 sp58;
    f32 sp54;
    f32 sp50;
    u16 sp42;
    f32 sp30;
    f32 sp2C;
    f32 sp24;
    f32 sp20;
    f32 temp_f0;
    f32 temp_f0_2;
    f32 temp_f14;
    f32 temp_f16;
    f32 temp_f18;
    f32 temp_f2;
    f32 temp_f2_2;
    f32 temp_f4;
    f32 temp_f6;
    f32 temp_f8;

    sp42 = 0;
    sp58 = arg0->unk1C + (70.0f * coss(((arg0->unkC0 - arg0->unk2E) - 0x71C) & 0xFFFF));
    sp64 = arg0->unk14 + (70.0f * sins(((arg0->unkC0 - arg0->unk2E) - 0x71C) & 0xFFFF));
    sp54 = arg0->unk1C + (70.0f * coss(((arg0->unkC0 - arg0->unk2E) + 0x71C) & 0xFFFF));
    sp60 = arg0->unk14 + (70.0f * sins(((arg0->unkC0 - arg0->unk2E) + 0x71C) & 0xFFFF));
    sp50 = arg0->unk1C + (10.0f * coss(((arg0->unkC0 - arg0->unk2E) + 0x1C70) & 0xFFFF));
    temp_f8 = arg0->unk14 + (10.0f * sins(((arg0->unkC0 - arg0->unk2E) + 0x1C70) & 0xFFFF));
    sp5C = temp_f8;
    temp_f16 = sp58 - arg3;
    sp20 = arg3;
    temp_f18 = sp60 - arg1;
    sp24 = arg1;
    temp_f6 = sp54 - arg3;
    temp_f4 = sp64 - arg1;
    sp30 = temp_f6;
    sp2C = temp_f4;
    temp_f14 = (temp_f16 * temp_f18) - (temp_f6 * temp_f4);
    if (((temp_f14 >= 0.0f) && (temp_f0 = temp_f8 - sp24, temp_f2 = sp50 - sp20, (((temp_f6 * temp_f0) - (temp_f2 * temp_f18)) >= 0.0f)) && (((temp_f2 * temp_f4) - (temp_f16 * temp_f0)) >= 0.0f)) || ((temp_f14 <= 0.0f) && (temp_f0_2 = sp5C - arg1, temp_f2_2 = sp50 - arg3, (((sp30 * temp_f0_2) - (temp_f2_2 * temp_f18)) <= 0.0f)) && (((temp_f2_2 * sp2C) - (temp_f16 * temp_f0_2)) <= 0.0f))) {
        sp42 = 1;
    }
    return sp42;
}
#else
GLOBAL_ASM("asm/non_matchings/code_8001F980/func_8001FD78.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_8001F980(s32 *, s32 *); // extern
? func_8001F9E4(s8); // extern
s32 func_8001FB0C(Player *, s32, f32, f32); // extern
extern ? D_800DDB50;
extern s32 D_800DDB58;
extern ? D_80164AB0;
extern ? D_80164AC0;
extern ? D_80164AD0;
extern u16 sRenderingFramebuffer;

void func_80020000(Player *arg0, s32 arg1, s8 arg2, s8 arg3) {
    s32 sp4C;
    s32 sp48;
    s32 sp38;
    s32 sp34;
    s16 *temp_a0;
    s16 *temp_a0_2;
    s16 *temp_a0_3;
    s16 *temp_a2;
    s32 temp_a1;
    s32 temp_a1_2;
    s32 temp_a1_3;
    s32 temp_t3;
    s32 temp_t5;
    s32 temp_t6;
    s32 temp_v0;
    s32 temp_v0_2;
    s32 temp_v0_3;
    s32 temp_v0_4;
    s32 temp_v0_5;
    s32 temp_v0_6;
    s32 temp_v0_7;
    s32 temp_v1_2;
    s32 temp_v1_3;
    s32 temp_v1_4;
    s32 temp_v1_5;
    u16 temp_v1;
    void *temp_t0;
    s16 *phi_a0;

    if ((arg0->unk_000 & PLAYER_EXISTS) == 0x8000) {
        func_8001F9E4(arg3);
        temp_t3 = arg3 * 4;
        sp38 = temp_t3;
        temp_v0 = 2 << temp_t3;
        if (temp_v0 == (arg0->unk_002 & temp_v0)) {
            if ((arg0->unk_000 & PLAYER_START_SEQUENCE) == 0) {
                sp34 = temp_v0;
                func_8002934C(arg0, arg1, arg3, arg2);
            } else {
                sp34 = temp_v0;
                func_8002934C(arg0, arg1, arg3, arg2);
                arg0->unk_0C4 = 0;
                arg0->unk_206 = 0;
                (arg0 + (arg3 * 2))->unk50 = 0;
            }
        }
        sp34 = 2 << temp_t3;
        func_8001F980(&sp4C, &sp48);
        temp_v1 = arg0->unk_002;
        temp_v0_2 = 1 << sp38;
        if (((2 << temp_t3) == (temp_v1 & (2 << temp_t3))) && (temp_v0_2 == (temp_v1 & temp_v0_2))) {
            temp_t0 = arg0 + (arg3 * 2);
            sp38 = temp_t0;
            if (((func_8001FB0C(arg0, arg1, D_80165570 + sp4C, D_80165572 + sp48) == 1) & 0xFFFF) != 0) {
                temp_v0_3 = D_800DDB58;
                temp_v1_2 = arg2 * 2;
                temp_a1 = temp_v0_3 * 2;
                *(&D_80164AB0 + temp_a1) = arg2;
                *(&D_80164AC0 + temp_a1) = arg3;
                *(&D_80164AD0 + (temp_v0_3 * 4)) = arg0;
                D_800DDB58 = temp_v0_3 + 1;
                *(D_80165190 + ((arg3 * 0x10) + temp_v1_2)) = 0;
                *(D_801650D0 + ((arg3 * 0x10) + temp_v1_2)) = arg0->unk_244[arg3];
                *(D_80165110 + ((arg3 * 0x10) + temp_v1_2)) = arg0->unk_24C[arg3];
                temp_a0 = (arg3 * 0x10) + temp_v1_2 + D_801651D0;
                *(D_80165150 + ((arg3 * 0x10) + temp_v1_2)) = arg0->unk_0A8;
                *temp_a0 = *temp_a0 + 1;
                phi_a0 = temp_a0;
                if (*temp_a0 == 2) {
                    goto block_21;
                }
            } else {
                sp38 = temp_t0;
                if (((func_8001FB0C(arg0, arg1, D_80165574 + sp4C, D_80165576) == 1) & 0xFFFF) != 0) {
                    temp_v1_3 = arg2 * 2;
                    if ((sRenderingFramebuffer == *(&D_800DDB50 + arg2)) || (temp_v0_4 = *(D_801650D0 + ((arg3 * 0x10) + temp_v1_3)) - arg0->unk_244[arg3], ((temp_v0_4 < 0x14) == 0)) || (temp_v0_4 < -0x13) || (*(D_80165190 + ((arg3 * 0x10) + temp_v1_3)) == 1)) {
                        temp_v0_5 = D_800DDB58;
                        temp_v1_4 = arg2 * 2;
                        temp_a1_2 = temp_v0_5 * 2;
                        *(&D_80164AB0 + temp_a1_2) = arg2;
                        *(&D_80164AC0 + temp_a1_2) = arg3;
                        *(&D_80164AD0 + (temp_v0_5 * 4)) = arg0;
                        D_800DDB58 = temp_v0_5 + 1;
                        *(D_801650D0 + ((arg3 * 0x10) + temp_v1_4)) = arg0->unk_244[arg3];
                        temp_t5 = arg3 * 0x10;
                        *(D_80165110 + (temp_t5 + temp_v1_4)) = arg0->unk_24C[arg3];
                        *(D_80165150 + ((arg3 * 0x10) + temp_v1_4)) = arg0->unk_0A8;
                        *(D_80165190 + ((arg3 * 0x10) + temp_v1_4)) = 0;
                        temp_a0_2 = temp_t5 + temp_v1_4 + D_801651D0;
                        *temp_a0_2 = *temp_a0_2 + 1;
                        phi_a0 = temp_a0_2;
                        if (*temp_a0_2 == 2) {
                            goto block_21;
                        }
                    }
                } else {
                    temp_v1_5 = arg2 * 2;
                    temp_a2 = (arg3 * 0x10) + temp_v1_5 + D_801650D0;
                    temp_v0_6 = *temp_a2 - arg0->unk_244[arg3];
                    temp_t6 = arg3 * 0x10;
                    if ((temp_v0_6 >= 0x14) || (temp_v0_6 < -0x13) || (*(D_80165190 + ((arg3 * 0x10) + temp_v1_5)) == 1)) {
                        temp_v0_7 = D_800DDB58;
                        temp_a1_3 = temp_v0_7 * 2;
                        *(&D_80164AB0 + temp_a1_3) = arg2;
                        *(&D_80164AC0 + temp_a1_3) = arg3;
                        *(&D_80164AD0 + (temp_v0_7 * 4)) = arg0;
                        D_800DDB58 = temp_v0_7 + 1;
                        *temp_a2 = arg0->unk_244[arg3];
                        *(D_80165110 + (temp_t6 + temp_v1_5)) = arg0->unk_24C[arg3];
                        *(D_80165150 + ((arg3 * 0x10) + temp_v1_5)) = arg0->unk_0A8;
                        *(D_80165190 + ((arg3 * 0x10) + temp_v1_5)) = 0;
                        temp_a0_3 = temp_t6 + temp_v1_5 + D_801651D0;
                        *temp_a0_3 = *temp_a0_3 + 1;
                        phi_a0 = temp_a0_3;
                        if (*temp_a0_3 == 2) {
block_21:
                            *phi_a0 = 0;
                        }
                    }
                }
            }
        }
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_8001F980/func_80020000.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80027560(s32, s8, s8, s8, s32); // extern
? func_8006E5AC(Player *, ?, ?); // extern
extern s32 D_800DDB58;
extern OSMesgQueue gDmaMesgQueue;
extern void *gMainReceivedMesg;
extern ? D_80164AAE;
extern s16 D_80164AB0;
extern ? D_80164ABE;
extern s16 D_80164AC0;
extern s32 D_80164AD0;

void func_80020524(void) {
    s16 temp_a2;
    s16 temp_a2_2;
    s16 temp_s0;
    s16 temp_t0;
    s16 temp_t0_2;
    s16 temp_v0;
    s16 temp_v0_3;
    s16 temp_v1;
    s16 temp_v1_2;
    s16 temp_v1_3;
    s16 temp_v1_4;
    s32 temp_a3;
    s32 temp_v0_2;
    void *temp_s1;
    void *temp_s2;
    s16 phi_s0;

    temp_v1 = D_80164AC0;
    temp_v0 = D_80164AB0;
    func_80027560(D_80164AD0, temp_v0, temp_v1, temp_v1, *(&D_801651D0[temp_v1] + (temp_v0 * 2)));
    func_8006E5AC(gPlayerOneCopy, 0, 0);
    func_8006E5AC(gPlayerTwo, 1, 0);
    func_8006E5AC(gPlayerThree, 2, 0);
    func_8006E5AC(gPlayerFour, 3, 0);
    if (D_800DC52C != 3) {
        func_8006E5AC(gPlayerFive, 4, 0);
        func_8006E5AC(gPlayerSix, 5, 0);
        func_8006E5AC(gPlayerSeven, 6, 0);
        func_8006E5AC(gPlayerEight, 7, 0);
    }
    osRecvMesg(&gDmaMesgQueue, &gMainReceivedMesg, 1);
    phi_s0 = 1;
    if (D_800DDB58 >= 2) {
        do {
            temp_v0_2 = phi_s0 * 2;
            temp_s2 = temp_v0_2 + &D_80164AC0;
            temp_t0 = temp_s2->unk0;
            temp_s1 = temp_v0_2 + &D_80164AB0;
            temp_v1_2 = temp_s1->unk0;
            func_80027560(*(&D_80164AD0 + (phi_s0 * 4)), temp_v1_2, temp_t0, temp_t0, *(&D_801651D0[temp_t0] + (temp_v1_2 * 2)));
            temp_v0_3 = temp_s2->unk-2;
            temp_v1_3 = temp_s1->unk-2;
            temp_a2 = *(&D_801651D0[temp_v0_3] + (temp_v1_3 * 2));
            mio0decode(D_802DFB80 + (temp_a2 * 0x9200) + (temp_v0_3 * 0x4900) + (temp_v1_3 * 0x920), &D_802BFB80[(temp_a2 << 0x10) + (temp_v0_3 << 0xF) + (temp_v1_3 << 0xC)]);
            osRecvMesg(&gDmaMesgQueue, &gMainReceivedMesg, 1);
            temp_s0 = phi_s0 + 1;
            phi_s0 = temp_s0;
        } while (temp_s0 < D_800DDB58);
    }
    temp_a3 = D_800DDB58 * 2;
    temp_v1_4 = *(&D_80164ABE + temp_a3);
    temp_a2_2 = *(&D_80164AAE + temp_a3);
    temp_t0_2 = *(&D_801651D0[temp_v1_4] + (temp_a2_2 * 2));
    mio0decode(D_802DFB80 + (temp_t0_2 * 0x9200) + (temp_v1_4 * 0x4900) + (temp_a2_2 * 0x920), &D_802BFB80[(temp_t0_2 << 0x10) + (temp_v1_4 << 0xF) + (temp_a2_2 << 0xC)]);
}
#else
GLOBAL_ASM("asm/non_matchings/code_8001F980/func_80020524.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80027560(s32, s8, s8, s8, s32); // extern
? func_8006E634(Player *, ?, ?); // extern
extern s32 D_800DDB58;
extern OSMesgQueue gDmaMesgQueue;
extern void *gMainReceivedMesg;
extern ? D_80164AAE;
extern s16 D_80164AB0;
extern ? D_80164ABE;
extern s16 D_80164AC0;
extern s32 D_80164AD0;

void func_8002088C(void) {
    s16 temp_a2;
    s16 temp_a2_2;
    s16 temp_s0;
    s16 temp_t0;
    s16 temp_t0_2;
    s16 temp_v0;
    s16 temp_v0_3;
    s16 temp_v1;
    s16 temp_v1_2;
    s16 temp_v1_3;
    s16 temp_v1_4;
    s32 temp_a3;
    s32 temp_v0_2;
    void *temp_s1;
    void *temp_s2;
    s16 phi_s0;

    temp_v1 = D_80164AC0;
    temp_v0 = D_80164AB0;
    func_80027560(D_80164AD0, temp_v0, temp_v1, temp_v1, *(&D_801651D0[temp_v1] + (temp_v0 * 2)));
    func_8006E634(gPlayerOneCopy, 0, 1);
    func_8006E634(gPlayerTwo, 1, 1);
    func_8006E634(gPlayerThree, 2, 1);
    func_8006E634(gPlayerFour, 3, 1);
    if (D_800DC52C != 3) {
        func_8006E634(gPlayerFive, 4, 1);
        func_8006E634(gPlayerSix, 5, 1);
        func_8006E634(gPlayerSeven, 6, 1);
        func_8006E634(gPlayerEight, 7, 1);
    }
    osRecvMesg(&gDmaMesgQueue, &gMainReceivedMesg, 1);
    phi_s0 = 1;
    if (D_800DDB58 >= 2) {
        do {
            temp_v0_2 = phi_s0 * 2;
            temp_s2 = temp_v0_2 + &D_80164AC0;
            temp_t0 = temp_s2->unk0;
            temp_s1 = temp_v0_2 + &D_80164AB0;
            temp_v1_2 = temp_s1->unk0;
            func_80027560(*(&D_80164AD0 + (phi_s0 * 4)), temp_v1_2, temp_t0, temp_t0, *(&D_801651D0[temp_t0] + (temp_v1_2 * 2)));
            temp_v0_3 = temp_s2->unk-2;
            temp_v1_3 = temp_s1->unk-2;
            temp_a2 = *(&D_801651D0[temp_v0_3] + (temp_v1_3 * 2));
            mio0decode(D_802DFB80 + (temp_a2 * 0x9200) + (temp_v0_3 * 0x4900) + (temp_v1_3 * 0x920), &D_802BFB80[(temp_a2 << 0x10) + (temp_v0_3 << 0xF) + (temp_v1_3 << 0xC)]);
            osRecvMesg(&gDmaMesgQueue, &gMainReceivedMesg, 1);
            temp_s0 = phi_s0 + 1;
            phi_s0 = temp_s0;
        } while (temp_s0 < D_800DDB58);
    }
    temp_a3 = D_800DDB58 * 2;
    temp_v1_4 = *(&D_80164ABE + temp_a3);
    temp_a2_2 = *(&D_80164AAE + temp_a3);
    temp_t0_2 = *(&D_801651D0[temp_v1_4] + (temp_a2_2 * 2));
    mio0decode(D_802DFB80 + (temp_t0_2 * 0x9200) + (temp_v1_4 * 0x4900) + (temp_a2_2 * 0x920), &D_802BFB80[(temp_t0_2 << 0x10) + (temp_v1_4 << 0xF) + (temp_a2_2 << 0xC)]);
}
#else
GLOBAL_ASM("asm/non_matchings/code_8001F980/func_8002088C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80027560(s32, s8, s8, s8, s32); // extern
? func_8006E6BC(Player *, ?, ?); // extern
extern s32 D_800DDB58;
extern OSMesgQueue gDmaMesgQueue;
extern void *gMainReceivedMesg;
extern ? D_80164AAE;
extern s16 D_80164AB0;
extern ? D_80164ABE;
extern s16 D_80164AC0;
extern s32 D_80164AD0;

void func_80020BF4(void) {
    s16 temp_a2;
    s16 temp_a2_2;
    s16 temp_s0;
    s16 temp_t0;
    s16 temp_t0_2;
    s16 temp_v0;
    s16 temp_v0_2;
    s16 temp_v0_3;
    s16 temp_v1;
    s16 temp_v1_3;
    s16 temp_v1_4;
    s32 temp_a3;
    s32 temp_v1_2;
    void *temp_s1;
    void *temp_s2;
    s16 phi_s0;

    temp_v0 = D_80164AC0;
    temp_v1 = D_80164AB0;
    func_80027560(D_80164AD0, temp_v1 + 4, temp_v0, temp_v0 - 2, *(&D_801651D0[temp_v0] + (temp_v1 * 2)));
    func_8006E6BC(gPlayerOneCopy, 0, 2);
    func_8006E6BC(gPlayerTwo, 1, 2);
    func_8006E6BC(gPlayerThree, 2, 2);
    func_8006E6BC(gPlayerFour, 3, 2);
    osRecvMesg(&gDmaMesgQueue, &gMainReceivedMesg, 1);
    phi_s0 = 1;
    if (D_800DDB58 >= 2) {
        do {
            temp_v1_2 = phi_s0 * 2;
            temp_s1 = temp_v1_2 + &D_80164AB0;
            temp_t0 = temp_s1->unk0;
            temp_s2 = temp_v1_2 + &D_80164AC0;
            temp_v0_2 = temp_s2->unk0;
            func_80027560(*(&D_80164AD0 + (phi_s0 * 4)), temp_t0 + 4, temp_v0_2, temp_v0_2 - 2, *(&D_801651D0[temp_v0_2] + (temp_t0 * 2)));
            temp_v0_3 = temp_s2->unk-2;
            temp_v1_3 = temp_s1->unk-2;
            temp_a2 = *(&D_801651D0[temp_v0_3] + (temp_v1_3 * 2));
            mio0decode((D_802DFB80 + (temp_a2 * 0x9200) + (temp_v0_3 * 0x4900) + (temp_v1_3 * 0x920)) - 0x6D80, &D_802BFB80[(temp_a2 << 0x10) + (temp_v0_3 << 0xF) + (temp_v1_3 << 0xC) + 0xFFFF4000]);
            osRecvMesg(&gDmaMesgQueue, &gMainReceivedMesg, 1);
            temp_s0 = phi_s0 + 1;
            phi_s0 = temp_s0;
        } while (temp_s0 < D_800DDB58);
    }
    temp_a3 = D_800DDB58 * 2;
    temp_v1_4 = *(&D_80164ABE + temp_a3);
    temp_a2_2 = *(&D_80164AAE + temp_a3);
    temp_t0_2 = *(&D_801651D0[temp_v1_4] + (temp_a2_2 * 2));
    mio0decode((D_802DFB80 + (temp_t0_2 * 0x9200) + (temp_v1_4 * 0x4900) + (temp_a2_2 * 0x920)) - 0x6D80, &D_802BFB80[(temp_t0_2 << 0x10) + (temp_v1_4 << 0xF) + (temp_a2_2 << 0xC) + 0xFFFF4000]);
}
#else
GLOBAL_ASM("asm/non_matchings/code_8001F980/func_80020BF4.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80027560(s32, s8, s8, s8, s32); // extern
? func_8006E744(Player *, ?, ?); // extern
extern s32 D_800DDB58;
extern OSMesgQueue gDmaMesgQueue;
extern void *gMainReceivedMesg;
extern ? D_80164AAE;
extern s16 D_80164AB0;
extern ? D_80164ABE;
extern s16 D_80164AC0;
extern s32 D_80164AD0;

void func_80020F1C(void) {
    s16 temp_a2;
    s16 temp_a2_2;
    s16 temp_s0;
    s16 temp_t0;
    s16 temp_t0_2;
    s16 temp_v0;
    s16 temp_v0_2;
    s16 temp_v0_3;
    s16 temp_v1;
    s16 temp_v1_3;
    s16 temp_v1_4;
    s32 temp_a3;
    s32 temp_v1_2;
    void *temp_s1;
    void *temp_s2;
    s16 phi_s0;

    temp_v0 = D_80164AC0;
    temp_v1 = D_80164AB0;
    func_80027560(D_80164AD0, temp_v1 + 4, temp_v0, temp_v0 - 2, *(&D_801651D0[temp_v0] + (temp_v1 * 2)));
    func_8006E744(gPlayerOneCopy, 0, 3);
    func_8006E744(gPlayerTwo, 1, 3);
    func_8006E744(gPlayerThree, 2, 3);
    func_8006E744(gPlayerFour, 3, 3);
    osRecvMesg(&gDmaMesgQueue, &gMainReceivedMesg, 1);
    phi_s0 = 1;
    if (D_800DDB58 >= 2) {
        do {
            temp_v1_2 = phi_s0 * 2;
            temp_s1 = temp_v1_2 + &D_80164AB0;
            temp_t0 = temp_s1->unk0;
            temp_s2 = temp_v1_2 + &D_80164AC0;
            temp_v0_2 = temp_s2->unk0;
            func_80027560(*(&D_80164AD0 + (phi_s0 * 4)), temp_t0 + 4, temp_v0_2, temp_v0_2 - 2, *(&D_801651D0[temp_v0_2] + (temp_t0 * 2)));
            temp_v0_3 = temp_s2->unk-2;
            temp_v1_3 = temp_s1->unk-2;
            temp_a2 = *(&D_801651D0[temp_v0_3] + (temp_v1_3 * 2));
            mio0decode((D_802DFB80 + (temp_a2 * 0x9200) + (temp_v0_3 * 0x4900) + (temp_v1_3 * 0x920)) - 0x6D80, &D_802BFB80[(temp_a2 << 0x10) + (temp_v0_3 << 0xF) + (temp_v1_3 << 0xC) + 0xFFFF4000]);
            osRecvMesg(&gDmaMesgQueue, &gMainReceivedMesg, 1);
            temp_s0 = phi_s0 + 1;
            phi_s0 = temp_s0;
        } while (temp_s0 < D_800DDB58);
    }
    temp_a3 = D_800DDB58 * 2;
    temp_v1_4 = *(&D_80164ABE + temp_a3);
    temp_a2_2 = *(&D_80164AAE + temp_a3);
    temp_t0_2 = *(&D_801651D0[temp_v1_4] + (temp_a2_2 * 2));
    mio0decode((D_802DFB80 + (temp_t0_2 * 0x9200) + (temp_v1_4 * 0x4900) + (temp_a2_2 * 0x920)) - 0x6D80, &D_802BFB80[(temp_t0_2 << 0x10) + (temp_v1_4 << 0xF) + (temp_a2_2 << 0xC) + 0xFFFF4000]);
}
#else
GLOBAL_ASM("asm/non_matchings/code_8001F980/func_80020F1C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void func_80021244(Player *arg0, s8 arg1, s8 arg2) {
    s32 temp_v0_2;
    u16 temp_v0;

    temp_v0 = arg0->unk_000;
    if (((temp_v0 & PLAYER_EXISTS) == PLAYER_EXISTS) && ((temp_v0 & 0x40) == 0)) {
        temp_v0_2 = 2 << (arg2 * 4);
        if (temp_v0_2 == (arg0->unk_002 & temp_v0_2)) {
            func_800267AC(arg0, arg1, arg2);
        }
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_8001F980/func_80021244.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80020000(Player *, s32, ?, ?); // extern
? func_80020524(Player **, ?, ?); // extern
? func_80021244(Player *, ?, ?); // extern
? func_8006E5AC(Player *, ?, ?); // extern
extern s32 D_800DDB58;
extern ? D_800DDB68;
extern ? D_800DDB88;

void func_800212B4(void) {
    ? sp3C;
    ? sp1C;

    sp3C.unk0 = D_800DDB68.unk0;
    sp3C.unk4 = D_800DDB68.unk4;
    sp3C.unkC = D_800DDB68.unkC;
    sp3C.unk8 = D_800DDB68.unk8;
    sp3C.unk10 = D_800DDB68.unk10;
    sp3C.unk14 = D_800DDB68.unk14;
    sp3C.unk1C = D_800DDB68.unk1C;
    sp3C.unk18 = D_800DDB68.unk18;
    sp1C.unk0 = D_800DDB88.unk0;
    sp1C.unk4 = D_800DDB88.unk4;
    sp1C.unk8 = D_800DDB88.unk8;
    sp1C.unkC = D_800DDB88.unkC;
    sp1C.unk10 = D_800DDB88.unk10;
    sp1C.unk14 = D_800DDB88.unk14;
    sp1C.unk18 = D_800DDB88.unk18;
    sp1C.unk1C = D_800DDB88.unk1C;
    D_800DDB58 = 0;
    func_80020000(gPlayerOneCopy, camera1, 0, 0);
    func_80020000(gPlayerTwo, camera1, 1, 0);
    func_80020000(gPlayerThree, camera1, 2, 0);
    func_80020000(gPlayerFour, camera1, 3, 0);
    if (D_800DC52C != 3) {
        func_80020000(gPlayerFive, camera1, 4, 0);
        func_80020000(gPlayerSix, camera1, 5, 0);
        func_80020000(gPlayerSeven, camera1, 6, 0);
        func_80020000(gPlayerEight, camera1, 7, 0);
    }
    func_80021244(gPlayerOne, 0, 0);
    func_80021244(gPlayerTwo, 1, 0);
    func_80021244(gPlayerThree, 2, 0);
    func_80021244(gPlayerFour, 3, 0);
    if (D_800DC52C != 3) {
        func_80021244(gPlayerFive, 4, 0);
        func_80021244(gPlayerSix, 5, 0);
        func_80021244(gPlayerSeven, 6, 0);
        func_80021244(gPlayerEight, 7, 0);
    }
    if (D_800DDB58 != 0) {
        func_80020524(&gPlayerOneCopy, 0, 0);
    } else {
        func_8006E5AC(gPlayerOneCopy, 0, 0);
        func_8006E5AC(gPlayerTwo, 1, 0);
        func_8006E5AC(gPlayerThree, 2, 0);
        func_8006E5AC(gPlayerFour, 3, 0);
        if (D_800DC52C != 3) {
            func_8006E5AC(gPlayerFive, 4, 0);
            func_8006E5AC(gPlayerSix, 5, 0);
            func_8006E5AC(gPlayerSeven, 6, 0);
            func_8006E5AC(gPlayerEight, 7, 0);
        }
    }
    D_800DDB58 = 0;
}
#else
GLOBAL_ASM("asm/non_matchings/code_8001F980/func_800212B4.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80020000(Player *, s32, ?, ?); // extern
? func_8002088C(Player **, ?, ?); // extern
? func_80021244(Player *, ?, ?); // extern
? func_8006E634(Player *, ?, ?); // extern
extern s32 D_800DDB58;

void func_800215DC(void) {
    D_800DDB58 = 0;
    func_80020000(gPlayerOneCopy, camera2, 0, 1);
    func_80020000(gPlayerTwo, camera2, 1, 1);
    func_80020000(gPlayerThree, camera2, 2, 1);
    func_80020000(gPlayerFour, camera2, 3, 1);
    if (D_800DC52C != 3) {
        func_80020000(gPlayerFive, camera2, 4, 1);
        func_80020000(gPlayerSix, camera2, 5, 1);
        func_80020000(gPlayerSeven, camera2, 6, 1);
        func_80020000(gPlayerEight, camera2, 7, 1);
    }
    func_80021244(gPlayerOne, 0, 1);
    func_80021244(gPlayerTwo, 1, 1);
    func_80021244(gPlayerThree, 2, 1);
    func_80021244(gPlayerFour, 3, 1);
    if (D_800DC52C != 3) {
        func_80021244(gPlayerFive, 4, 1);
        func_80021244(gPlayerSix, 5, 1);
        func_80021244(gPlayerSeven, 6, 1);
        func_80021244(gPlayerEight, 7, 1);
    }
    if (D_800DDB58 != 0) {
        func_8002088C(&gPlayerOneCopy, 0, 1);
    } else {
        func_8006E634(gPlayerOneCopy, 0, 1);
        func_8006E634(gPlayerTwo, 1, 1);
        func_8006E634(gPlayerThree, 2, 1);
        func_8006E634(gPlayerFour, 3, 1);
        if (D_800DC52C != 3) {
            func_8006E634(gPlayerFive, 4, 1);
            func_8006E634(gPlayerSix, 5, 1);
            func_8006E634(gPlayerSeven, 6, 1);
            func_8006E634(gPlayerEight, 7, 1);
        }
    }
    D_800DDB58 = 0;
}
#else
GLOBAL_ASM("asm/non_matchings/code_8001F980/func_800215DC.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80020000(Player *, s32, ?, ?); // extern
? func_80020BF4(Player **, ?, ?); // extern
? func_80021244(Player *, ?, ?); // extern
? func_8006E6BC(Player *, ?, ?); // extern
extern s32 D_800DDB58;

void func_8002186C(void) {
    D_800DDB58 = 0;
    func_80020000(gPlayerOneCopy, camera3, 0, 2);
    func_80020000(gPlayerTwo, camera3, 1, 2);
    func_80020000(gPlayerThree, camera3, 2, 2);
    func_80020000(gPlayerFour, camera3, 3, 2);
    func_80021244(gPlayerOne, 0, 2);
    func_80021244(gPlayerTwo, 1, 2);
    func_80021244(gPlayerThree, 2, 2);
    func_80021244(gPlayerFour, 3, 2);
    if (D_800DDB58 != 0) {
        func_80020BF4(&gPlayerOneCopy, 0, 2);
    } else {
        func_8006E6BC(gPlayerOneCopy, 0, 2);
        func_8006E6BC(gPlayerTwo, 1, 2);
        func_8006E6BC(gPlayerThree, 2, 2);
        func_8006E6BC(gPlayerFour, 3, 2);
    }
    D_800DDB58 = 0;
}
#else
GLOBAL_ASM("asm/non_matchings/code_8001F980/func_8002186C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80020000(Player *, s32, ?, ?); // extern
? func_80020F1C(Player **, ?, ?); // extern
? func_80021244(Player *, ?, ?); // extern
? func_8006E744(Player *, ?, ?); // extern
extern s32 D_800DDB58;

void func_800219BC(void) {
    D_800DDB58 = 0;
    func_80020000(gPlayerOneCopy, camera4, 0, 3);
    func_80020000(gPlayerTwo, camera4, 1, 3);
    func_80020000(gPlayerThree, camera4, 2, 3);
    func_80020000(gPlayerFour, camera4, 3, 3);
    func_80021244(gPlayerOne, 0, 3);
    func_80021244(gPlayerTwo, 1, 3);
    func_80021244(gPlayerThree, 2, 3);
    func_80021244(gPlayerFour, 3, 3);
    if (D_800DDB58 != 0) {
        func_80020F1C(&gPlayerOneCopy, 0, 3);
    } else {
        func_8006E744(gPlayerOneCopy, 0, 3);
        func_8006E744(gPlayerTwo, 1, 3);
        func_8006E744(gPlayerThree, 2, 3);
        func_8006E744(gPlayerFour, 3, 3);
    }
    D_800DDB58 = 0;
}
#else
GLOBAL_ASM("asm/non_matchings/code_8001F980/func_800219BC.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80024374(Player *, ?, ?); // extern
? func_8006E7CC(Player *, ?, ?); // extern

void func_80021B0C(void) {
    Player *temp_a0;
    Player *temp_a0_2;
    Player *temp_a0_3;
    Player *temp_a0_4;

    func_8006E7CC(gPlayerOneCopy, 0, 0);
    func_8006E7CC(gPlayerTwo, 1, 0);
    func_8006E7CC(gPlayerThree, 2, 0);
    func_8006E7CC(gPlayerFour, 3, 0);
    if (D_800DC52C != 3) {
        func_8006E7CC(gPlayerFive, 4, 0);
        func_8006E7CC(gPlayerSix, 5, 0);
        func_8006E7CC(gPlayerSeven, 6, 0);
        func_8006E7CC(gPlayerEight, 7, 0);
    }
    if (D_800DC50C == ENDING_SEQUENCE) {
        temp_a0 = gPlayerOne;
        if ((temp_a0->unk_044 & 0x2000) != 0) {
            func_80024374(temp_a0, 0, 0);
        }
        temp_a0_2 = gPlayerTwo;
        if ((temp_a0_2->unk_044 & 0x2000) != 0) {
            func_80024374(temp_a0_2, 1, 0);
        }
        temp_a0_3 = gPlayerThree;
        if ((temp_a0_3->unk_044 & 0x2000) != 0) {
            func_80024374(temp_a0_3, 2, 0);
        }
        temp_a0_4 = gPlayerFour;
        if ((temp_a0_4->unk_044 & 0x2000) != 0) {
            func_80024374(temp_a0_4, 3, 0);
        }
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_8001F980/func_80021B0C.s")
#endif

void func_80021C78(void) {
    func_8006E848(gPlayerOneCopy, 0, 1);
    func_8006E848(gPlayerTwo, 1, 1);
    func_8006E848(gPlayerThree, 2, 1);
    func_8006E848(gPlayerFour, 3, 1);
    if (D_800DC52C != 3) {
        func_8006E848(gPlayerFive, 4, 1);
        func_8006E848(gPlayerSix, 5, 1);
        func_8006E848(gPlayerSeven, 6, 1);
        func_8006E848(gPlayerEight, 7, 1);
    }
}

void func_80021D40(void) {
    func_8006E8C4(gPlayerOneCopy, 0, 2);
    func_8006E8C4(gPlayerTwo, 1, 2);
    func_8006E8C4(gPlayerThree, 2, 2);
    func_8006E8C4(gPlayerFour, 3, 2);
}

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_8006E940(Player *, ?, ?); // extern

void func_80021DA8(void) {
    func_8006E940(gPlayerOneCopy, 0, 3);
    func_8006E940(gPlayerTwo, 1, 3);
    func_8006E940(gPlayerThree, 2, 3);
    func_8006E940(gPlayerFour, 3, 3);
}
#else
GLOBAL_ASM("asm/non_matchings/code_8001F980/func_80021DA8.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
f32 sins(u16); // extern
f32 coss(u16); // extern

void func_80021E10(void *arg0, void *arg1, void *arg2) {
    f32 sp38;
    f32 sp30;
    f32 sp2C;
    f32 sp28;
    f32 temp_f0;
    f32 temp_f12;
    f32 temp_f12_2;
    f32 temp_f20;
    f32 temp_f6;

    sp38 = sins(arg2->unk0);
    temp_f20 = coss(arg2->unk0);
    sp30 = sins(arg2->unk2);
    sp2C = coss(arg2->unk2);
    sp28 = sins(arg2->unk4);
    temp_f0 = coss(arg2->unk4);
    temp_f12 = sp38 * sp30;
    temp_f6 = temp_f12 * temp_f0;
    arg0->unk0 = (sp2C * temp_f0) + (temp_f12 * sp28);
    arg0->unk20 = temp_f20 * sp30;
    arg0->unk10 = (-sp2C * sp28) + temp_f6;
    arg0->unk24 = -sp38;
    temp_f12_2 = sp38 * sp2C;
    arg0->unk4 = temp_f20 * sp28;
    arg0->unk30 = arg1->unk0;
    arg0->unk14 = temp_f20 * temp_f0;
    arg0->unk34 = arg1->unk4;
    arg0->unk8 = (-sp30 * temp_f0) + (temp_f12_2 * sp28);
    arg0->unk28 = temp_f20 * sp2C;
    arg0->unk18 = (sp30 * sp28) + (temp_f12_2 * temp_f0);
    arg0->unkC = 0.0f;
    arg0->unk1C = 0.0f;
    arg0->unk2C = 0.0f;
    arg0->unk3C = 1.0f;
    arg0->unk38 = arg1->unk8;
}
#else
GLOBAL_ASM("asm/non_matchings/code_8001F980/func_80021E10.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void func_80021F84(void *arg0, f32 arg1) {
    arg0->unk0 = arg0->unk0 * arg1;
    arg0->unk10 = arg0->unk10 * arg1;
    arg0->unk20 = arg0->unk20 * arg1;
    arg0->unk4 = arg0->unk4 * arg1;
    arg0->unk14 = arg0->unk14 * arg1;
    arg0->unk24 = arg0->unk24 * arg1;
    arg0->unk8 = arg0->unk8 * arg1;
    arg0->unk18 = arg0->unk18 * arg1;
    arg0->unk28 = arg0->unk28 * arg1;
}
#else
GLOBAL_ASM("asm/non_matchings/code_8001F980/func_80021F84.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
void func_80022180(void *arg0, void *arg1) {
    arg0->unk0 = (((arg1->unk4 * 65536.0f) >> 0x10) & 0xFFFF) | ((arg1->unk0 * 65536.0f) & 0xFFFF0000);
    arg0->unk4 = (((arg1->unkC * 65536.0f) >> 0x10) & 0xFFFF) | ((arg1->unk8 * 65536.0f) & 0xFFFF0000);
    arg0->unk8 = (((arg1->unk14 * 65536.0f) >> 0x10) & 0xFFFF) | ((arg1->unk10 * 65536.0f) & 0xFFFF0000);
    arg0->unkC = (((arg1->unk1C * 65536.0f) >> 0x10) & 0xFFFF) | ((arg1->unk18 * 65536.0f) & 0xFFFF0000);
    arg0->unk10 = (((arg1->unk24 * 65536.0f) >> 0x10) & 0xFFFF) | ((arg1->unk20 * 65536.0f) & 0xFFFF0000);
    arg0->unk14 = (((arg1->unk2C * 65536.0f) >> 0x10) & 0xFFFF) | ((arg1->unk28 * 65536.0f) & 0xFFFF0000);
    arg0->unk18 = (((arg1->unk34 * 65536.0f) >> 0x10) & 0xFFFF) | ((arg1->unk30 * 65536.0f) & 0xFFFF0000);
    arg0->unk1C = (((arg1->unk3C * 65536.0f) >> 0x10) & 0xFFFF) | ((arg1->unk38 * 65536.0f) & 0xFFFF0000);
    arg0->unk20 = ((arg1->unk4 * 65536.0f) & 0xFFFF) | ((arg1->unk0 * 65536.0f) << 0x10);
    arg0->unk24 = ((arg1->unkC * 65536.0f) & 0xFFFF) | ((arg1->unk8 * 65536.0f) << 0x10);
    arg0->unk28 = ((arg1->unk14 * 65536.0f) & 0xFFFF) | ((arg1->unk10 * 65536.0f) << 0x10);
    arg0->unk2C = ((arg1->unk1C * 65536.0f) & 0xFFFF) | ((arg1->unk18 * 65536.0f) << 0x10);
    arg0->unk30 = ((arg1->unk24 * 65536.0f) & 0xFFFF) | ((arg1->unk20 * 65536.0f) << 0x10);
    arg0->unk34 = ((arg1->unk2C * 65536.0f) & 0xFFFF) | ((arg1->unk28 * 65536.0f) << 0x10);
    arg0->unk38 = ((arg1->unk34 * 65536.0f) & 0xFFFF) | ((arg1->unk30 * 65536.0f) << 0x10);
    arg0->unk3C = ((arg1->unk3C * 65536.0f) & 0xFFFF) | ((arg1->unk38 * 65536.0f) << 0x10);
}
#else
GLOBAL_ASM("asm/non_matchings/code_8001F980/func_80022180.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_800224F0(s16 *arg0, s16 arg1, s16 arg2) {
    s16 temp_v0;
    s16 temp_v0_2;
    s16 temp_v0_3;
    s16 phi_a2;

    temp_v0 = arg1 - *arg0;
    phi_a2 = arg2;
    if (arg2 < 0) {
        phi_a2 = arg2 * -1;
    }
    if (temp_v0 > 0) {
        temp_v0_2 = temp_v0 - phi_a2;
        if (temp_v0_2 >= 0) {
            *arg0 = arg1 - temp_v0_2;
        } else {
            goto block_8;
        }
    } else {
        temp_v0_3 = temp_v0 + phi_a2;
        if (temp_v0_3 <= 0) {
            *arg0 = arg1 - temp_v0_3;
        } else {
block_8:
            *arg0 = arg1;
        }
    }
    if (arg1 == *arg0) {
        return 0;
    }
    return 1;
}
#else
GLOBAL_ASM("asm/non_matchings/code_8001F980/func_800224F0.s")
#endif

void move_s32_towards(s32 *startingValue, s32 targetValue, f32 somePercent) {
    *startingValue -= ((*startingValue - targetValue) * somePercent);
}

extern f64 D_800ED680;
extern f64 D_800ED688;

/**
  * Function: move_f32_towards

  * Parameters:
  *     f32 *startingValue - Pointer to the float that will be modified
  *     f32 targetValue    - Float value to move startingValue towards
  *     f32 somePercent    - The percent of the difference between startingValue
                            and targetValue to actually move

  * Moves a given startingValue the given somePercent towards the targetValue

  * f32 *thing = 2500;
  * move_f32_towards(thing, 500, 0.75f);
  * thing now has a value of 1000

  * If after the move startingValue is inside of the range [D_800ED688, D_800ED680],
  * force it to exactly 0.0f
  * [D_800ED688, D_800ED680] = [-0.001, 0.001], based on data_0DD0A0_3.s

  * This is probably a precision thing. The scaling with somePercent likely
  * can't hit exactly 0 with any reliability, so they force it to 0 if you're
  * in a small range around it. Why they only do this for 0 is anyone's guess though
**/
void move_f32_towards(f32 *startingValue, f32 targetValue, f32 somePercent) {
    *startingValue -= ((*startingValue - targetValue) * somePercent);
    if ((*startingValue < D_800ED680) && (D_800ED688 < *startingValue)) {
        *startingValue = 0.0f;
    }
}

void move_s16_towards(s16 *startingValue, s16 targetValue, f32 somePercent) {
    *startingValue -= ((*startingValue - targetValue) * somePercent);
}

void move_u16_towards(u16 *startingValue, s16 targetValue, f32 somePercent) {
    *startingValue -= ((*startingValue - targetValue) * somePercent);
}

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_8002276C(); // extern
? func_8006E058(); // extern

void func_80022744(void) {
    func_8006E058();
    func_8002276C();
}
#else
GLOBAL_ASM("asm/non_matchings/code_8001F980/func_80022744.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80022A98(Player *, ?); // extern

void func_8002276C(void) {
    Player *temp_a0;
    Player *temp_a0_2;
    s32 temp_v0;
    s32 temp_v0_2;
    s32 temp_v0_3;
    s32 temp_v0_4;
    s32 temp_v0_5;
    s32 phi_v0;

    temp_v0 = D_800DC52C;
    if (temp_v0 != 0) {
        if ((temp_v0 != 1) && (temp_v0 != 2)) {
            if (temp_v0 != 3) {
                return;
            }
            temp_v0_2 = gModeSelection;
            if ((temp_v0_2 == VERSUS) || (temp_v0_2 == BATTLE)) {
                func_80022A98(gPlayerOne, 0);
                func_80022A98(gPlayerTwo, 1);
                func_80022A98(gPlayerThree, 2);
                if (gPlayerCountSelection1 == 4) {
                    func_80022A98(gPlayerFour, 3);
                }
            }
            // Duplicate return node #31. Try simplifying control flow for better match
            return;
        }
        temp_v0_3 = gModeSelection;
        if (temp_v0_3 != GRAND_PRIX) {
            if (temp_v0_3 != TIME_TRIALS) {
                if ((temp_v0_3 != VERSUS) && (temp_v0_3 != BATTLE)) {
                    return;
                }
                func_80022A98(gPlayerOne, 0);
                func_80022A98(gPlayerTwo, 1);
                return;
            }
            func_80022A98(gPlayerOne, 0);
            return;
        }
        func_80022A98(gPlayerOne, 0);
        func_80022A98(gPlayerTwo, 1);
        func_80022A98(gPlayerThree, 2);
        func_80022A98(gPlayerFour, 3);
        func_80022A98(gPlayerFive, 4);
        func_80022A98(gPlayerSix, 5);
        func_80022A98(gPlayerSeven, 6);
        func_80022A98(gPlayerEight, 7);
        return;
    }
    temp_v0_4 = gModeSelection;
    if (temp_v0_4 != GRAND_PRIX) {
        if (temp_v0_4 != TIME_TRIALS) {
            if ((temp_v0_4 != VERSUS) && (temp_v0_4 != BATTLE)) {
                return;
            }
            func_80022A98(gPlayerOne, 0);
            func_80022A98(gPlayerTwo, 1);
            temp_v0_5 = gPlayerCountSelection1;
            phi_v0 = temp_v0_5;
            if (temp_v0_5 >= 3) {
                func_80022A98(gPlayerThree, 2);
                phi_v0 = gPlayerCountSelection1;
            }
            if (phi_v0 == 4) {
                func_80022A98(gPlayerFour, 3);
                return;
            }
            // Duplicate return node #31. Try simplifying control flow for better match
            return;
        }
        func_80022A98(gPlayerOne, 0);
        temp_a0 = gPlayerTwo;
        if ((temp_a0->unk_000 & PLAYER_INVISIBLE_OR_BOMB) == PLAYER_INVISIBLE_OR_BOMB) {
            func_80022A98(temp_a0, 1);
        }
        temp_a0_2 = gPlayerThree;
        if ((temp_a0_2->unk_000 & PLAYER_INVISIBLE_OR_BOMB) == PLAYER_INVISIBLE_OR_BOMB) {
            func_80022A98(temp_a0_2, 2);
            return;
        }
        return;
    }
    func_80022A98(gPlayerOne, 0);
    func_80022A98(gPlayerTwo, 1);
    func_80022A98(gPlayerThree, 2);
    func_80022A98(gPlayerFour, 3);
    func_80022A98(gPlayerFive, 4);
    func_80022A98(gPlayerSix, 5);
    func_80022A98(gPlayerSeven, 6);
    func_80022A98(gPlayerEight, 7);
}
#else
GLOBAL_ASM("asm/non_matchings/code_8001F980/func_8002276C.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80022B50(void *, s8, s32); // extern
? func_80022BC4(void *, s8, s32); // extern
? func_80022DB4(void *, s8, s32); // extern
? func_800235AC(void *, s8); // extern
? func_80026A48(s8); // extern
? func_80030A34(void *); // extern

void func_80022A98(void *arg0, s8 arg1) {
    s32 temp_v0;
    s32 temp_v1;

    if ((arg0->unk0 & 0x8000) == 0x8000) {
        func_80026A48(arg1);
        func_800235AC(arg0, arg1);
        temp_v0 = arg0->unkBC;
        temp_v1 = temp_v0 & 0x4000000;
        if ((temp_v1 == 0x4000000) || ((temp_v0 & 0x8000000) == 0x8000000)) {
            if (temp_v1 == 0x4000000) {
                func_80022B50(arg0, arg1, 0x8000000);
            }
            if ((arg0->unkBC & 0x8000000) == 0x8000000) {
                func_80022BC4(arg0, arg1, 0x8000000);
            }
        } else {
            func_80022DB4(arg0, arg1, 0x8000000);
        }
        func_80030A34(arg0);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_8001F980/func_80022A98.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern f64 D_800ED690;

void func_80022B50(void *arg0, ? arg1) {
    f32 temp_f0;
    s16 temp_v0;
    s16 phi_v0;

    temp_v0 = arg0->unkDB6;
    temp_f0 = arg0->unkDC4;
    phi_v0 = temp_v0;
    if (temp_v0 < 5) {
        phi_v0 = temp_v0 + 1;
    }
    arg0->unkDC4 = temp_f0;
    arg0->unkDB6 = phi_v0;
    arg0->unkDA4 = (phi_v0 * temp_f0) - (D_800ED690 * (phi_v0 * phi_v0));
}
#else
GLOBAL_ASM("asm/non_matchings/code_8001F980/func_80022B50.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern f64 D_800ED698;
extern f64 D_800ED6A0;

void func_80022BC4(void *arg0, ? arg1) {
    f32 temp_f0;
    f32 temp_f0_2;
    s16 temp_v0;
    s32 temp_f16;
    s16 phi_v1;
    f32 phi_f0;
    s16 phi_v0;

    temp_v0 = arg0->unkDB6 + 1;
    temp_f0 = arg0->unkDC4;
    temp_f16 = (temp_v0 * temp_f0) - (0.5 * (temp_v0 * temp_v0));
    phi_v1 = temp_f16;
    phi_f0 = temp_f0;
    phi_v0 = temp_v0;
    if ((temp_v0 != 0) && (temp_f16 < 0)) {
        temp_f0_2 = temp_f0 * D_800ED698;
        phi_f0 = temp_f0_2;
        phi_v0 = 0;
        if (temp_f0_2 <= D_800ED6A0) {
            arg0->unkBC = arg0->unkBC & 0xF7FFFFFF;
            phi_f0 = 0.0f;
        }
    }
    if (temp_f16 <= 0) {
        phi_v1 = 0;
    }
    arg0->unkDA4 = phi_v1;
    arg0->unkDC4 = phi_f0;
    arg0->unkDB6 = phi_v0;
}
#else
GLOBAL_ASM("asm/non_matchings/code_8001F980/func_80022BC4.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern ? D_800DDBB4;
extern f64 D_800ED6A8;

void func_80022CA8(void *arg0, s8 arg1, ? arg2, s8 arg3) {
    s16 temp_t1;
    s16 temp_v0;
    s32 *temp_v1;
    s32 temp_a2;
    s32 temp_f4;

    temp_v0 = arg0->unkDA4;
    temp_v1 = (arg1 * 4) + &D_800DDBB4;
    temp_a2 = arg3 * 0x10;
    temp_t1 = 9 - temp_v0;
    temp_f4 = 18.0 - (temp_v0 * D_800ED6A8);
    (*temp_v1 + temp_a2)->unk2 = temp_f4;
    (*temp_v1 + temp_a2)->unk12 = temp_t1;
    (*temp_v1 + temp_a2)->unk22 = temp_t1;
    (*temp_v1 + temp_a2)->unk32 = temp_f4;
    (*temp_v1 + temp_a2)->unk42 = temp_t1;
    (*temp_v1 + temp_a2)->unk72 = temp_t1;
}
#else
GLOBAL_ASM("asm/non_matchings/code_8001F980/func_80022CA8.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern ? D_800DDBB4;

void func_80022D60(s32 arg0, s8 arg1, ? arg2, s8 arg3) {
    s32 *temp_v0;
    s32 temp_v1;

    temp_v0 = (arg1 * 4) + &D_800DDBB4;
    temp_v1 = arg3 * 0x10;
    (*temp_v0 + temp_v1)->unk2 = 0x15;
    (*temp_v0 + temp_v1)->unk32 = 0x15;
}
#else
GLOBAL_ASM("asm/non_matchings/code_8001F980/func_80022D60.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern f64 D_800ED6B0;
extern f64 D_800ED6B8;
extern f64 D_800ED6C0;

void func_80022DB4(void *arg0, ? arg1) {
    f32 temp_f0;
    f32 temp_f0_2;
    s16 temp_v0;
    s32 temp_f16;
    s16 phi_v1;
    f32 phi_f0;
    s16 phi_v0;

    temp_v0 = arg0->unkDCC + 1;
    temp_f0 = arg0->unkDC0;
    temp_f16 = (temp_v0 * temp_f0) - (D_800ED6B0 * (temp_v0 * temp_v0));
    phi_v1 = temp_f16;
    phi_f0 = temp_f0;
    phi_v0 = temp_v0;
    if ((temp_v0 != 0) && (temp_f16 < 0)) {
        temp_f0_2 = temp_f0 * D_800ED6B8;
        phi_f0 = temp_f0_2;
        phi_v0 = 0;
        if (temp_f0_2 <= D_800ED6C0) {
            phi_f0 = 0.0f;
        }
    }
    if (temp_f16 <= 0) {
        phi_v1 = 0;
    }
    arg0->unkDD2 = phi_v1;
    arg0->unkDC0 = phi_f0;
    arg0->unkDCC = phi_v0;
}
#else
GLOBAL_ASM("asm/non_matchings/code_8001F980/func_80022DB4.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern ? D_800DDBB4;

void func_80022E84(void *arg0, s8 arg1, ? arg2, s8 arg3) {
    s16 temp_t0;
    s16 temp_t1;
    s16 temp_v0;
    s32 *temp_v1;
    s32 temp_a2;

    temp_v1 = (arg1 * 4) + &D_800DDBB4;
    temp_v0 = arg0->unkDD2;
    temp_a2 = arg3 * 0x10;
    temp_t0 = 0x12 - temp_v0;
    (*temp_v1 + temp_a2)->unk2 = temp_t0;
    temp_t1 = 9 - temp_v0;
    (*temp_v1 + temp_a2)->unk12 = temp_t1;
    (*temp_v1 + temp_a2)->unk22 = temp_t1;
    (*temp_v1 + temp_a2)->unk32 = temp_t0;
    (*temp_v1 + temp_a2)->unk42 = temp_t1;
    (*temp_v1 + temp_a2)->unk72 = temp_t1;
}
#else
GLOBAL_ASM("asm/non_matchings/code_8001F980/func_80022E84.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern ? D_80164B10;
extern ? D_80164B20;
extern ? D_80164B30;

void func_80022F14(s32 arg0, s8 arg1, s32 arg2, f32 arg3) {
    f32 temp_f16;
    f32 temp_f4;
    s32 temp_v0;
    u16 *temp_a3;
    u16 *temp_t1;
    u16 *temp_v1;
    u16 temp_a0;
    u16 temp_t0;
    u16 temp_t2;
    f32 phi_f16;
    f32 phi_f4;

    temp_v0 = arg1 * 2;
    temp_v1 = temp_v0 + &D_80164B10;
    temp_a0 = *temp_v1;
    temp_a3 = temp_v0 + &D_80164B20;
    temp_t0 = *temp_a3;
    temp_f16 = temp_t0;
    *temp_v1 = temp_a0 - ((temp_a0 - ((arg2 >> 0x10) & 0xFF)) * arg3);
    phi_f16 = temp_f16;
    if (temp_t0 < 0) {
        phi_f16 = temp_f16 + 4294967296.0f;
    }
    temp_t1 = temp_v0 + &D_80164B30;
    temp_t2 = *temp_t1;
    *temp_a3 = phi_f16 - ((temp_t0 - ((arg2 >> 8) & 0xFF)) * arg3);
    temp_f4 = temp_t2;
    phi_f4 = temp_f4;
    if (temp_t2 < 0) {
        phi_f4 = temp_f4 + 4294967296.0f;
    }
    *temp_t1 = phi_f4 - ((temp_t2 - (arg2 & 0xFF)) * arg3);
}
#else
GLOBAL_ASM("asm/non_matchings/code_8001F980/func_80022F14.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? move_u16_towards(void *, s16, s32, s8); // extern
extern ? D_80164B40;
extern ? D_80164B50;
extern ? D_80164B60;

void func_80023038(s32 arg0, s8 arg1, s32 arg2, s32 arg3) {
    s32 sp1C;
    s32 temp_v0;

    temp_v0 = arg1 * 2;
    sp1C = temp_v0;
    move_u16_towards(temp_v0 + &D_80164B40, (arg2 >> 0x10) & 0xFF, arg3, arg1);
    move_u16_towards(sp1C + &D_80164B50, (arg2 >> 8) & 0xFF, arg3);
    move_u16_towards(sp1C + &D_80164B60, arg2 & 0xFF, arg3);
}
#else
GLOBAL_ASM("asm/non_matchings/code_8001F980/func_80023038.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80022F14(s32, s8, ?, ?); // extern
? func_80023038(s32, s8, ?, ?); // extern
extern ? D_80164438;
extern ? D_80164B80;

? func_800230E4(s32 arg0, s8 arg1) {
    s8 temp_a1;
    u16 temp_v0;

    temp_a1 = arg1;
    if (gCurrentCourseId == 8) {
        temp_v0 = *(&D_80164438 + (arg1 * 2));
        if (((temp_v0 >= 0x14F) && (temp_v0 < 0x158)) || ((temp_v0 >= 0x15E) && (temp_v0 < 0x164)) || ((temp_v0 >= 0x169) && (temp_v0 < 0x170)) || ((temp_v0 >= 0x174) && (temp_v0 < 0x17A)) || ((temp_v0 >= 0x17E) && (temp_v0 < 0x184))) {
            arg1 = temp_a1;
            func_80022F14(arg0, temp_a1, 0x1C0000, 0x3E99999A);
            func_80023038(arg0, arg1, 0xE0, 0x3E99999A);
            *(&D_80164B80 + (arg1 * 4)) = 0;
            return 1;
        }
        goto block_13;
    }
block_13:
    return 0;
}
#else
GLOBAL_ASM("asm/non_matchings/code_8001F980/func_800230E4.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80022F14(s8, ?, ?); // extern
? func_80023038(void *, s8, ?, ?); // extern
extern ? D_80164438;
extern ? D_80164B80;

void func_800231D8(void *arg0, s8 arg1) {
    s16 temp_v0;
    s8 temp_a1;
    u16 temp_v0_2;
    u16 temp_v0_3;
    s32 *phi_at;

    temp_v0 = gCurrentCourseId;
    temp_a1 = arg1;
    if (temp_v0 != 2) {
        if (temp_v0 != 3) {
            arg1 = temp_a1;
            func_80022F14(temp_a1, 0, 0x3E99999A);
            func_80023038(arg0, arg1, 0, 0x3E99999A);
            phi_at = &D_80164B80 + (arg1 * 4);
        } else {
            temp_v0_2 = *(&D_80164438 + (temp_a1 * 2));
            if (((temp_v0_2 >= 0xD) && (temp_v0_2 < 0x15)) || ((temp_v0_2 >= 0x29) && (temp_v0_2 < 0x39)) || ((temp_v0_2 >= 0x46) && (temp_v0_2 < 0x4E)) || ((temp_v0_2 >= 0x5F) && (temp_v0_2 < 0x67)) || ((temp_v0_2 >= 0x7B) && (temp_v0_2 < 0x86)) || ((temp_v0_2 >= 0x9D) && (temp_v0_2 < 0xA6)) || ((temp_v0_2 >= 0xB9) && (temp_v0_2 < 0xC3)) || ((temp_v0_2 >= 0xB9) && (temp_v0_2 < 0xC3)) || ((temp_v0_2 >= 0xD7) && (temp_v0_2 < 0xE1)) || ((temp_v0_2 >= 0x10E) && (temp_v0_2 < 0x119)) || ((temp_v0_2 >= 0x154) && (temp_v0_2 < 0x15F)) || ((temp_v0_2 >= 0x1EF) && (temp_v0_2 < 0x1F7)) || ((temp_v0_2 >= 0x202) && (temp_v0_2 < 0x209)) || ((temp_v0_2 >= 0x216) && (temp_v0_2 < 0x21D)) || ((temp_v0_2 >= 0x230) && (temp_v0_2 < 0x23A)) || ((temp_v0_2 >= 0x24C) && (temp_v0_2 < 0x256)) || ((temp_v0_2 >= 0x288) && (temp_v0_2 < 0x269)) || ((temp_v0_2 >= 0x274) && (temp_v0_2 < 0x27E))) {
                arg1 = temp_a1;
                func_80022F14(temp_a1, 0x1C0000, 0x3E99999A);
                func_80023038(arg0, arg1, 0xE0, 0x3E99999A);
                phi_at = &D_80164B80 + (arg1 * 4);
            } else {
                arg1 = temp_a1;
                func_80022F14(temp_a1, 0, 0x3E99999A);
                func_80023038(arg0, arg1, 0, 0x3E99999A);
                phi_at = &D_80164B80 + (arg1 * 4);
            }
        }
    } else {
        temp_v0_3 = *(&D_80164438 + (temp_a1 * 2));
        if (((temp_v0_3 >= 0x15) && (temp_v0_3 < 0x2A)) || ((temp_v0_3 >= 0x14D) && (temp_v0_3 < 0x15C)) || ((temp_v0_3 >= 0x1D1) && (temp_v0_3 < 0x1E4)) || (arg0->unk124 >= 500.0f)) {
            arg1 = temp_a1;
            func_80022F14(temp_a1, 0x340000, 0x3E99999A);
            func_80023038(arg0, arg1, 0x4040, 0x3E99999A);
            phi_at = &D_80164B80 + (arg1 * 4);
        } else if (((temp_v0_3 >= 0xF1) && (temp_v0_3 < 0xF5)) || ((temp_v0_3 >= 0xFB) && (temp_v0_3 < 0xFF)) || ((temp_v0_3 >= 0x105) && (temp_v0_3 < 0x109)) || ((temp_v0_3 >= 0x10F) && (temp_v0_3 < 0x113)) || ((temp_v0_3 >= 0x145) && (temp_v0_3 < 0x14A)) || ((temp_v0_3 >= 0x15E) && (temp_v0_3 < 0x163))) {
            arg1 = temp_a1;
            func_80022F14(temp_a1, 0x1C0000, 0x3E99999A);
            func_80023038(arg0, arg1, 0xE0, 0x3E99999A);
            phi_at = &D_80164B80 + (arg1 * 4);
        } else {
            arg1 = temp_a1;
            func_80022F14(temp_a1, 0, 0x3E99999A);
            func_80023038(arg0, arg1, 0, 0x3E99999A);
            phi_at = &D_80164B80 + (arg1 * 4);
        }
    }
    *phi_at = 0;
}
#else
GLOBAL_ASM("asm/non_matchings/code_8001F980/func_800231D8.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80022F14(s8, s8, ?, ?); // extern
? func_80023038(void *, s8, ?, ?); // extern
s32 func_800230E4(void *, s8); // extern
? func_800231D8(void *, s8); // extern
extern ? D_80164B80;
extern ? D_8018D930;
extern f32 gCourseTimer;

void func_800235AC(void *arg0, s8 arg1) {
    s32 *sp24;
    s16 temp_v0;
    s32 *temp_v1_2;
    s32 *temp_v1_4;
    s32 *temp_v1_5;
    s32 temp_t6;
    s32 temp_v0_2;
    s32 temp_v0_3;
    s32 temp_v0_4;
    s32 temp_v0_5;
    s32 temp_v0_6;
    s32 temp_v1;
    s32 temp_v1_3;
    s32 phi_v0;
    s32 phi_v0_2;
    s32 phi_v0_3;
    s32 *phi_v1;
    s32 phi_v0_4;
    s32 phi_v0_5;
    s32 phi_v0_6;
    s32 phi_v0_7;

    if (((arg0->unk0 & 0x100) == 0x100) && (arg0 == gPlayerThree)) {
        func_80022F14(arg1, 0x1C0000, 0x3E99999A);
        func_80023038(arg0, arg1, 0xE0, 0x3E99999A);
        *(&D_80164B80 + (arg1 * 4)) = 0;
        return;
    }
    temp_v0 = arg0->unkCA;
    temp_v1 = temp_v0 & 0x10;
    if ((temp_v1 == 0x10) && ((temp_v0 & 4) == 4)) {
        func_80022F14(arg0, arg1, 0x646464, 0x3F000000);
        func_80023038(arg0, arg1, 0xFF0000, 0x3DCCCCCD);
        return;
    }
    if ((temp_v0 & 4) == 4) {
        func_80022F14(arg0, arg1, 0, 0x3F800000);
        func_80023038(arg0, arg1, 0, 0x3F800000);
        return;
    }
    if (temp_v1 == 0x10) {
        func_80022F14(arg0, arg1, 0x646464, 0x3F000000);
        func_80023038(arg0, arg1, 0xFF0000, 0x3DCCCCCD);
        return;
    }
    if ((temp_v0 & 0x20) == 0x20) {
        func_80022F14(arg0, arg1, 0, 0x3DCCCCCD);
        func_80023038(arg0, arg1, 0, 0x3DCCCCCD);
        return;
    }
    temp_v0_2 = arg0->unkBC;
    if (((temp_v0_2 & 0x40000000) == 0x40000000) && (arg0->unkB0 < 0x78)) {
        temp_t6 = arg1 * 4;
        temp_v1_2 = temp_t6 + &D_80164B80;
        temp_v0_3 = *temp_v1_2 + 5;
        *temp_v1_2 = temp_v0_3;
        phi_v0 = temp_v0_3;
        if (temp_v0_3 >= 0x1E) {
            *temp_v1_2 = 0;
            phi_v0 = 0;
        }
        phi_v0_2 = phi_v0;
        if ((phi_v0 >= 0) && (phi_v0 < 0xB)) {
            sp24 = temp_v1_2;
            func_80022F14(arg0, arg1, 0x808080, 0x3F4CCCCD);
            func_80023038(arg0, arg1, 0, 0x3F4CCCCD);
            phi_v0_2 = *temp_v1_2;
        }
        phi_v0_3 = phi_v0_2;
        if ((phi_v0_2 >= 0xB) && (phi_v0_2 < 0x15)) {
            sp24 = temp_t6 + &D_80164B80;
            func_80022F14(arg0, arg1, 0x70, 0x3F4CCCCD);
            func_80023038(arg0, arg1, 0, 0x3F4CCCCD);
            phi_v0_3 = *(temp_t6 + &D_80164B80);
        }
        if ((phi_v0_3 >= 0x15) && (phi_v0_3 < 0x1F)) {
            func_80022F14(arg0, arg1, 0x8F8F00, 0x3F4CCCCD);
            func_80023038(arg0, arg1, 0, 0x3F4CCCCD);
            return;
        }
        // Duplicate return node #50. Try simplifying control flow for better match
        return;
    }
    if (((temp_v0_2 & 0x200) != 0) && (temp_v0_4 = arg1 * 4, temp_v1_3 = gCourseTimer - *(&D_8018D930 + temp_v0_4), ((temp_v1_3 < 9) != 0))) {
        if (temp_v1_3 >= 7) {
            temp_v1_4 = temp_v0_4 + &D_80164B80;
            *temp_v1_4 = *temp_v1_4 + 0xA;
            phi_v1 = temp_v1_4;
        } else {
            temp_v1_5 = temp_v0_4 + &D_80164B80;
            *temp_v1_5 = *temp_v1_5 + 5;
            phi_v1 = temp_v1_5;
        }
        temp_v0_5 = *phi_v1;
        phi_v0_4 = temp_v0_5;
        if (temp_v0_5 >= 0x28) {
            *phi_v1 = 0;
            phi_v0_4 = 0;
        }
        phi_v0_5 = phi_v0_4;
        if ((phi_v0_4 >= 0) && (phi_v0_4 < 0xB)) {
            sp24 = phi_v1;
            func_80022F14(arg0, arg1, 0x70, 0x3F4CCCCD);
            func_80023038(arg0, arg1, 0, 0x3F4CCCCD);
            phi_v0_5 = *phi_v1;
        }
        phi_v0_6 = phi_v0_5;
        if ((phi_v0_5 >= 0xB) && (phi_v0_5 < 0x15)) {
            sp24 = phi_v1;
            func_80022F14(arg0, arg1, 0x707000, 0x3F4CCCCD);
            func_80023038(arg0, arg1, 0, 0x3F4CCCCD);
            phi_v0_6 = *phi_v1;
        }
        phi_v0_7 = phi_v0_6;
        if ((phi_v0_6 >= 0x15) && (phi_v0_6 < 0x1F)) {
            sp24 = phi_v1;
            func_80022F14(arg0, arg1, 0x700000, 0x3F4CCCCD);
            func_80023038(arg0, arg1, 0, 0x3F4CCCCD);
            phi_v0_7 = *phi_v1;
        }
        if (phi_v0_7 >= 0x1F) {
            func_80022F14(arg0, arg1, 0x7000, 0x3F4CCCCD);
            func_80023038(arg0, arg1, 0, 0x3F4CCCCD);
            return;
        }
        // Duplicate return node #50. Try simplifying control flow for better match
        return;
    }
    if (func_800230E4(arg0, arg1) != 1) {
        temp_v0_6 = arg0->unk1F4;
        if (((temp_v0_6 & 1) == 1) || ((temp_v0_6 & 2) == 2) || ((arg0->unk1AC & 3) == 3)) {
            func_80022F14(arg0, arg1, 0, 0x3E99999A);
            func_80023038(arg0, arg1, 0x6F6F6F, 0x3E99999A);
            return;
        }
        func_800231D8(arg0, arg1);
        if ((arg0->unkCA & 0x1000) == 0x1000) {
            func_80022F14(arg0, arg1, 0, 0x3E99999A);
            func_80023038(arg0, arg1, 0xF0F0F0, 0x3E99999A);
        }
        // Duplicate return node #50. Try simplifying control flow for better match
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_8001F980/func_800235AC.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80022CA8(s8, s8, s8); // extern
? func_80022D60(void *, s8, s8, s8); // extern
? func_80022E84(s8, s8, s8); // extern

void func_80023BF0(void *arg0, s8 arg1, s8 arg2, s8 arg3) {
    s32 temp_v0;

    temp_v0 = arg0->unkBC;
    if (((temp_v0 & 0x4000000) == 0x4000000) || ((temp_v0 & 0x8000000) == 0x8000000)) {
        func_80022CA8(arg1, arg2, arg3);
    } else {
        func_80022E84(arg1, arg2, arg3);
    }
    if ((arg0->unkCA & 2) == 2) {
        func_80022D60(arg0, arg1, arg2, arg3);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_8001F980/func_80023BF0.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80021E10(? *, f32 *, s16 *); // extern
? func_80021F84(? *, f32); // extern
? func_80022180(void *, ? *); // extern
? func_80042A20(? *, f32 *, f32 *, s32, f32); // extern
? func_8004B414(?, ?, ?, ?); // extern
f32 sins(u16, s32); // extern
f32 coss(s32, s32); // extern
extern ? D_0D008C78;
extern ? D_0D008D58;
extern ? D_800DDBD4;
extern ? D_800E51D0;
extern ? D_800E5210;
extern f64 D_800ED6C8;
extern s32 D_8018D474;
extern void *gDisplayListHead;

void func_80023C84(void *arg0, s8 arg1, s8 arg2) {
    ? sp118;
    f32 spD4;
    f32 spD0;
    f32 spCC;
    s16 spC8;
    s16 spC6;
    s16 spC4;
    s16 spC0;
    f32 spBC;
    f32 spB8;
    f32 spB4;
    f32 spB0;
    f32 spAC;
    f32 sp9C;
    f32 sp38;
    f32 temp_f2;
    s16 temp_v0;
    s16 temp_v1;
    s32 temp_s0;
    s32 temp_t7;
    s32 temp_t9;
    s32 temp_v0_2;
    s32 temp_v1_2;
    void *temp_v0_10;
    void *temp_v0_11;
    void *temp_v0_12;
    void *temp_v0_13;
    void *temp_v0_14;
    void *temp_v0_15;
    void *temp_v0_16;
    void *temp_v0_17;
    void *temp_v0_18;
    void *temp_v0_19;
    void *temp_v0_20;
    void *temp_v0_21;
    void *temp_v0_22;
    void *temp_v0_23;
    void *temp_v0_24;
    void *temp_v0_25;
    void *temp_v0_26;
    void *temp_v0_3;
    void *temp_v0_4;
    void *temp_v0_5;
    void *temp_v0_6;
    void *temp_v0_7;
    void *temp_v0_8;
    void *temp_v0_9;
    f32 phi_f2;
    f32 phi_f2_2;

    temp_v0 = arg0->unk2E;
    temp_v1 = arg0->unkC0;
    temp_t7 = (temp_v0 + (arg0 + (arg2 * 2))->unk48 + temp_v1) & 0xFFFF;
    temp_t9 = ((temp_t7 / 0x80) << 7) & 0xFFFF;
    spC0 = -temp_v0 - temp_v1;
    spB0 = -coss(temp_t9 & 0xFFFF, temp_t7) * 2.0f;
    spAC = -sins(temp_t9 & 0xFFFF) * 2.0f;
    temp_v0_2 = arg0->unkBC;
    temp_v1_2 = temp_v0_2 & 0x400;
    if (((temp_v0_2 & 0x1000000) == 0x1000000) || (temp_v1_2 == 0x400) || ((temp_v0_2 & 0x80000) == 0x80000) || ((temp_v0_2 & 0x800000) == 0x800000) || (temp_v1_2 == 0x400) || ((arg0->unkCA & 2) == 2) || ((temp_v0_2 & 0x2000000) == 0x2000000) || ((temp_v0_2 & 0x10000) == 0x10000) || ((temp_v0_2 & 8) == 8)) {
        temp_f2 = 1.0 - (arg0->unk124 * D_800ED6C8);
        phi_f2 = temp_f2;
        if (temp_f2 < 0.0f) {
            phi_f2 = 0.0f;
        }
        phi_f2_2 = phi_f2;
        if (phi_f2 > 1.0f) {
            phi_f2_2 = 1.0f;
        }
        spB4 = arg0->unk140;
        spBC = arg0->unk148;
        sp9C = phi_f2_2;
        spB8 = arg0->unk144;
        sp38 = sins(spC0, 0x400);
        spCC = (coss(spC0 & 0xFFFF) * spAC) + (spB0 * sp38) + arg0->unk14;
        spD0 = arg0->unk74 + 1.0f;
        sp38 = coss(spC0 & 0xFFFF);
        spD4 = ((spB0 * sp38) - (sins(spC0 & 0xFFFF) * spAC)) + arg0->unk1C;
        func_80042A20(&sp118, &spB4, &spCC, (spC0 + arg0->unk42) & 0xFFFF, *(&D_800DDBD4 + (arg0->unk254 * 4)) * arg0->unk224 * phi_f2_2);
    } else {
        spC4 = arg0->unkC4;
        spC6 = spC0;
        spC8 = arg0->unk206 * 2;
        sp38 = sins(spC0, 0x400);
        spCC = (coss(spC0 & 0xFFFF) * spAC) + (spB0 * sp38) + arg0->unk14;
        spD0 = arg0->unk74 + 1.0f;
        sp38 = coss(spC0 & 0xFFFF);
        spD4 = ((spB0 * sp38) - (sins(spC0 & 0xFFFF) * spAC)) + arg0->unk1C;
        func_80021E10(&sp118, &spCC, &spC4);
        func_80021F84(&sp118, *(&D_800DDBD4 + (arg0->unk254 * 4)) * arg0->unk224);
    }
    temp_s0 = arg2 << 9;
    func_80022180(gGfxPool + (arg1 << 6) + temp_s0 + 0xEAC0, &sp118);
    temp_v0_3 = gDisplayListHead;
    gDisplayListHead = temp_v0_3 + 8;
    temp_v0_3->unk0 = 0x1020040;
    temp_v0_3->unk4 = (gGfxPool + (arg1 << 6) + temp_s0 + 0xEAC0) & 0x1FFFFFFF;
    temp_v0_4 = gDisplayListHead;
    gDisplayListHead = temp_v0_4 + 8;
    temp_v0_4->unk4 = &D_0D008D58;
    temp_v0_4->unk0 = 0x6000000;
    temp_v0_5 = gDisplayListHead;
    gDisplayListHead = temp_v0_5 + 8;
    temp_v0_5->unk4 = 0;
    temp_v0_5->unk0 = 0xBA000E02;
    temp_v0_6 = gDisplayListHead;
    gDisplayListHead = temp_v0_6 + 8;
    temp_v0_6->unk0 = 0xFD900000;
    temp_v0_6->unk4 = D_8018D474;
    temp_v0_7 = gDisplayListHead;
    gDisplayListHead = temp_v0_7 + 8;
    temp_v0_7->unk4 = 0x7080200;
    temp_v0_7->unk0 = 0xF5900000;
    temp_v0_8 = gDisplayListHead;
    gDisplayListHead = temp_v0_8 + 8;
    temp_v0_8->unk4 = 0;
    temp_v0_8->unk0 = 0xE6000000;
    temp_v0_9 = gDisplayListHead;
    gDisplayListHead = temp_v0_9 + 8;
    temp_v0_9->unk4 = 0x73FF100;
    temp_v0_9->unk0 = 0xF3000000;
    temp_v0_10 = gDisplayListHead;
    gDisplayListHead = temp_v0_10 + 8;
    temp_v0_10->unk4 = 0;
    temp_v0_10->unk0 = 0xE7000000;
    temp_v0_11 = gDisplayListHead;
    gDisplayListHead = temp_v0_11 + 8;
    temp_v0_11->unk0 = 0xF5881000;
    temp_v0_11->unk4 = 0x80200;
    temp_v0_12 = gDisplayListHead;
    gDisplayListHead = temp_v0_12 + 8;
    temp_v0_12->unk0 = 0xF2000000;
    temp_v0_12->unk4 = 0xFC07C;
    func_8004B414(0, 0, 0, 0xFF);
    temp_v0_13 = gDisplayListHead;
    gDisplayListHead = temp_v0_13 + 8;
    temp_v0_13->unk0 = 0xB900031D;
    temp_v0_13->unk4 = 0x504B50;
    temp_v0_14 = gDisplayListHead;
    gDisplayListHead = temp_v0_14 + 8;
    temp_v0_14->unk4 = &D_800E51D0;
    temp_v0_14->unk0 = 0x400103F;
    temp_v0_15 = gDisplayListHead;
    gDisplayListHead = temp_v0_15 + 8;
    temp_v0_15->unk4 = &D_0D008C78;
    temp_v0_15->unk0 = 0x6000000;
    temp_v0_16 = gDisplayListHead;
    gDisplayListHead = temp_v0_16 + 8;
    temp_v0_16->unk0 = 0xFD900000;
    temp_v0_16->unk4 = D_8018D474 + 0x800;
    temp_v0_17 = gDisplayListHead;
    gDisplayListHead = temp_v0_17 + 8;
    temp_v0_17->unk4 = 0x7080200;
    temp_v0_17->unk0 = 0xF5900000;
    temp_v0_18 = gDisplayListHead;
    gDisplayListHead = temp_v0_18 + 8;
    temp_v0_18->unk4 = 0;
    temp_v0_18->unk0 = 0xE6000000;
    temp_v0_19 = gDisplayListHead;
    gDisplayListHead = temp_v0_19 + 8;
    temp_v0_19->unk4 = 0x73FF100;
    temp_v0_19->unk0 = 0xF3000000;
    temp_v0_20 = gDisplayListHead;
    gDisplayListHead = temp_v0_20 + 8;
    temp_v0_20->unk4 = 0;
    temp_v0_20->unk0 = 0xE7000000;
    temp_v0_21 = gDisplayListHead;
    gDisplayListHead = temp_v0_21 + 8;
    temp_v0_21->unk0 = 0xF5881000;
    temp_v0_21->unk4 = 0x80200;
    temp_v0_22 = gDisplayListHead;
    gDisplayListHead = temp_v0_22 + 8;
    temp_v0_22->unk0 = 0xF2000000;
    temp_v0_22->unk4 = 0xFC07C;
    func_8004B414(0, 0, 0, 0xFF);
    temp_v0_23 = gDisplayListHead;
    gDisplayListHead = temp_v0_23 + 8;
    temp_v0_23->unk0 = 0xB900031D;
    temp_v0_23->unk4 = 0x504B50;
    temp_v0_24 = gDisplayListHead;
    gDisplayListHead = temp_v0_24 + 8;
    temp_v0_24->unk4 = &D_800E5210;
    temp_v0_24->unk0 = 0x400103F;
    temp_v0_25 = gDisplayListHead;
    gDisplayListHead = temp_v0_25 + 8;
    temp_v0_25->unk4 = &D_0D008C78;
    temp_v0_25->unk0 = 0x6000000;
    temp_v0_26 = gDisplayListHead;
    gDisplayListHead = temp_v0_26 + 8;
    temp_v0_26->unk4 = 0x10001;
    temp_v0_26->unk0 = 0xBB000000;
}
#else
GLOBAL_ASM("asm/non_matchings/code_8001F980/func_80023C84.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80021E10(? *, f32 *, s16 *); // extern
? func_80021F84(? *, f32); // extern
? func_80022180(void *, ? *); // extern
? func_8004B414(?, ?, ?, ?); // extern
f32 sins(s32); // extern
f32 coss(s32, s32); // extern
extern ? D_0D008C78;
extern ? D_0D008D58;
extern ? D_800DDBD4;
extern ? D_800DDE9C;
extern ? D_800E51D0;
extern ? D_800E5210;
extern ? D_80165C20;
extern ? D_80183EA0;
extern s32 D_8018D474;
extern void *gDisplayListHead;

void func_80024374(void *arg0, s8 arg1, s8 arg2) {
    ? sp118;
    f32 spD4;
    f32 spD0;
    f32 spCC;
    s16 spC8;
    s16 spC6;
    s16 spC4;
    s16 spC0;
    f32 spB0;
    f32 spAC;
    ? sp94;
    f32 sp30;
    f32 temp_f18;
    s16 temp_v0;
    s16 temp_v1;
    s32 temp_s0;
    s32 temp_s0_2;
    s32 temp_t6;
    s32 temp_t8;
    s32 temp_t9;
    void *temp_v0_10;
    void *temp_v0_11;
    void *temp_v0_12;
    void *temp_v0_13;
    void *temp_v0_14;
    void *temp_v0_15;
    void *temp_v0_16;
    void *temp_v0_17;
    void *temp_v0_18;
    void *temp_v0_19;
    void *temp_v0_20;
    void *temp_v0_21;
    void *temp_v0_22;
    void *temp_v0_23;
    void *temp_v0_24;
    void *temp_v0_25;
    void *temp_v0_2;
    void *temp_v0_3;
    void *temp_v0_4;
    void *temp_v0_5;
    void *temp_v0_6;
    void *temp_v0_7;
    void *temp_v0_8;
    void *temp_v0_9;

    sp94.unk0 = D_800DDE9C.unk0;
    sp94.unk4 = D_800DDE9C.unk4;
    sp94.unk8 = D_800DDE9C.unk8;
    temp_v0 = arg0->unk2E;
    temp_v1 = arg0->unkC0;
    temp_t6 = (temp_v0 + (arg0 + (arg2 * 2))->unk48 + temp_v1) & 0xFFFF;
    temp_t9 = ((temp_t6 / 0x80) << 7) & 0xFFFF;
    spC0 = -temp_v0 - temp_v1;
    spB0 = -coss(temp_t9 & 0xFFFF, temp_t6) * 3.0f;
    temp_f18 = -sins(temp_t9 & 0xFFFF) * 3.0f;
    spC4 = 0;
    temp_s0 = spC0 & 0xFFFF;
    spC8 = 0;
    spC6 = spC0;
    spAC = temp_f18;
    sp30 = sins(temp_s0 & 0xFFFF);
    spCC = (coss(temp_s0 & 0xFFFF) * spAC) + (spB0 * sp30) + arg0->unk14;
    sp30 = coss(temp_s0 & 0xFFFF);
    temp_t8 = arg1 * 4;
    spD4 = ((spB0 * sp30) - (sins(temp_s0 & 0xFFFF) * temp_f18)) + arg0->unk1C;
    spD0 = (sp + temp_t8)->unk94 + *(&D_80165C20 + (*(&D_80183EA0 + temp_t8) * 0xE0));
    func_80021E10(&sp118, &spCC, &spC4);
    func_80021F84(&sp118, *(&D_800DDBD4 + (arg0->unk254 * 4)) * arg0->unk224);
    temp_s0_2 = arg2 << 9;
    func_80022180(gGfxPool + (arg1 << 6) + temp_s0_2 + 0xEAC0, &sp118);
    temp_v0_2 = gDisplayListHead;
    gDisplayListHead = temp_v0_2 + 8;
    temp_v0_2->unk0 = 0x1020040;
    temp_v0_2->unk4 = (gGfxPool + (arg1 << 6) + temp_s0_2 + 0xEAC0) & 0x1FFFFFFF;
    temp_v0_3 = gDisplayListHead;
    gDisplayListHead = temp_v0_3 + 8;
    temp_v0_3->unk4 = &D_0D008D58;
    temp_v0_3->unk0 = 0x6000000;
    temp_v0_4 = gDisplayListHead;
    gDisplayListHead = temp_v0_4 + 8;
    temp_v0_4->unk4 = 0;
    temp_v0_4->unk0 = 0xBA000E02;
    temp_v0_5 = gDisplayListHead;
    gDisplayListHead = temp_v0_5 + 8;
    temp_v0_5->unk0 = 0xFD900000;
    temp_v0_5->unk4 = D_8018D474;
    temp_v0_6 = gDisplayListHead;
    gDisplayListHead = temp_v0_6 + 8;
    temp_v0_6->unk4 = 0x7080200;
    temp_v0_6->unk0 = 0xF5900000;
    temp_v0_7 = gDisplayListHead;
    gDisplayListHead = temp_v0_7 + 8;
    temp_v0_7->unk4 = 0;
    temp_v0_7->unk0 = 0xE6000000;
    temp_v0_8 = gDisplayListHead;
    gDisplayListHead = temp_v0_8 + 8;
    temp_v0_8->unk4 = 0x73FF100;
    temp_v0_8->unk0 = 0xF3000000;
    temp_v0_9 = gDisplayListHead;
    gDisplayListHead = temp_v0_9 + 8;
    temp_v0_9->unk4 = 0;
    temp_v0_9->unk0 = 0xE7000000;
    temp_v0_10 = gDisplayListHead;
    gDisplayListHead = temp_v0_10 + 8;
    temp_v0_10->unk0 = 0xF5881000;
    temp_v0_10->unk4 = 0x80200;
    temp_v0_11 = gDisplayListHead;
    gDisplayListHead = temp_v0_11 + 8;
    temp_v0_11->unk0 = 0xF2000000;
    temp_v0_11->unk4 = 0xFC07C;
    func_8004B414(0, 0, 0, 0xD0);
    temp_v0_12 = gDisplayListHead;
    gDisplayListHead = temp_v0_12 + 8;
    temp_v0_12->unk0 = 0xB900031D;
    temp_v0_12->unk4 = 0x504B50;
    temp_v0_13 = gDisplayListHead;
    gDisplayListHead = temp_v0_13 + 8;
    temp_v0_13->unk4 = &D_800E51D0;
    temp_v0_13->unk0 = 0x400103F;
    temp_v0_14 = gDisplayListHead;
    gDisplayListHead = temp_v0_14 + 8;
    temp_v0_14->unk4 = &D_0D008C78;
    temp_v0_14->unk0 = 0x6000000;
    temp_v0_15 = gDisplayListHead;
    gDisplayListHead = temp_v0_15 + 8;
    temp_v0_15->unk0 = 0xFD900000;
    temp_v0_15->unk4 = D_8018D474 + 0x800;
    temp_v0_16 = gDisplayListHead;
    gDisplayListHead = temp_v0_16 + 8;
    temp_v0_16->unk4 = 0x7080200;
    temp_v0_16->unk0 = 0xF5900000;
    temp_v0_17 = gDisplayListHead;
    gDisplayListHead = temp_v0_17 + 8;
    temp_v0_17->unk4 = 0;
    temp_v0_17->unk0 = 0xE6000000;
    temp_v0_18 = gDisplayListHead;
    gDisplayListHead = temp_v0_18 + 8;
    temp_v0_18->unk4 = 0x73FF100;
    temp_v0_18->unk0 = 0xF3000000;
    temp_v0_19 = gDisplayListHead;
    gDisplayListHead = temp_v0_19 + 8;
    temp_v0_19->unk4 = 0;
    temp_v0_19->unk0 = 0xE7000000;
    temp_v0_20 = gDisplayListHead;
    gDisplayListHead = temp_v0_20 + 8;
    temp_v0_20->unk0 = 0xF5881000;
    temp_v0_20->unk4 = 0x80200;
    temp_v0_21 = gDisplayListHead;
    gDisplayListHead = temp_v0_21 + 8;
    temp_v0_21->unk0 = 0xF2000000;
    temp_v0_21->unk4 = 0xFC07C;
    func_8004B414(0, 0, 0, 0xD0);
    temp_v0_22 = gDisplayListHead;
    gDisplayListHead = temp_v0_22 + 8;
    temp_v0_22->unk0 = 0xB900031D;
    temp_v0_22->unk4 = 0x504B50;
    temp_v0_23 = gDisplayListHead;
    gDisplayListHead = temp_v0_23 + 8;
    temp_v0_23->unk4 = &D_800E5210;
    temp_v0_23->unk0 = 0x400103F;
    temp_v0_24 = gDisplayListHead;
    gDisplayListHead = temp_v0_24 + 8;
    temp_v0_24->unk4 = &D_0D008C78;
    temp_v0_24->unk0 = 0x6000000;
    temp_v0_25 = gDisplayListHead;
    gDisplayListHead = temp_v0_25 + 8;
    temp_v0_25->unk4 = 0x10001;
    temp_v0_25->unk0 = 0xBB000000;
}
#else
GLOBAL_ASM("asm/non_matchings/code_8001F980/func_80024374.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80021E10(? *, f32 *, s16 *); // extern
? func_80021F84(? *, f32); // extern
? func_80022180(void *, ? *); // extern
? func_8004B614(u16, u16, u16, u16, s32, s32, s32); // extern
? func_80062B18(f32 *, f32 *, f32 *, f32, f32, f32, s32, s32); // extern
f32 sins(s32); // extern
extern ? D_0D008C78;
extern ? D_0D008CD8;
extern ? D_800DDBB4;
extern ? D_800DDBD4;
extern f64 D_800ED6D0;
extern ? D_80164714;
extern void *D_80164B04;
extern u8 *D_80164B08;
extern u8 *D_80164B0C;
extern ? D_80164B10;
extern ? D_80164B20;
extern ? D_80164B30;
extern ? D_80164B40;
extern ? D_80164B50;
extern ? D_80164B60;
extern ? D_8018D970;
extern s32 *gDisplayListHead;

void func_800248D0(void *arg0, s8 arg1, s8 arg2, s8 arg3) {
    ? sp1A4;
    f32 sp15C;
    f32 sp158;
    f32 sp154;
    s16 sp150;
    s16 sp14E;
    s16 sp14C;
    f32 sp148;
    f32 sp144;
    f32 sp140;
    void *sp44;
    s32 sp40;
    s16 temp_v1;
    s32 *temp_t5;
    s32 *temp_v0_10;
    s32 *temp_v0_11;
    s32 *temp_v0_12;
    s32 *temp_v0_13;
    s32 *temp_v0_14;
    s32 *temp_v0_15;
    s32 *temp_v0_16;
    s32 *temp_v0_17;
    s32 *temp_v0_18;
    s32 *temp_v0_19;
    s32 *temp_v0_20;
    s32 *temp_v0_21;
    s32 *temp_v0_22;
    s32 *temp_v0_23;
    s32 *temp_v0_24;
    s32 *temp_v0_26;
    s32 *temp_v0_27;
    s32 *temp_v0_28;
    s32 *temp_v0_29;
    s32 *temp_v0_30;
    s32 *temp_v0_31;
    s32 *temp_v0_32;
    s32 *temp_v0_33;
    s32 *temp_v0_34;
    s32 *temp_v0_35;
    s32 *temp_v0_36;
    s32 *temp_v0_37;
    s32 *temp_v0_38;
    s32 *temp_v0_39;
    s32 *temp_v0_40;
    s32 *temp_v0_41;
    s32 *temp_v0_42;
    s32 *temp_v0_43;
    s32 *temp_v0_44;
    s32 *temp_v0_45;
    s32 *temp_v0_46;
    s32 *temp_v0_47;
    s32 *temp_v0_48;
    s32 *temp_v0_49;
    s32 *temp_v0_50;
    s32 *temp_v0_51;
    s32 *temp_v0_52;
    s32 *temp_v0_53;
    s32 *temp_v0_54;
    s32 *temp_v0_55;
    s32 *temp_v0_56;
    s32 *temp_v0_57;
    s32 *temp_v0_58;
    s32 *temp_v0_59;
    s32 *temp_v0_5;
    s32 *temp_v0_60;
    s32 *temp_v0_61;
    s32 *temp_v0_62;
    s32 *temp_v0_63;
    s32 *temp_v0_64;
    s32 *temp_v0_65;
    s32 *temp_v0_66;
    s32 *temp_v0_6;
    s32 *temp_v0_7;
    s32 *temp_v0_8;
    s32 *temp_v0_9;
    s32 temp_s0;
    s32 temp_t0;
    s32 temp_t7;
    s32 temp_v0_25;
    u8 *temp_v0_3;
    u8 *temp_v0_4;
    void *temp_v0;
    void *temp_v0_2;
    u8 *phi_t9;
    s32 phi_t7;
    s32 *phi_v0;
    s32 **phi_v1;
    s32 phi_s0;

    if ((arg0->unk44 & 0x2000) != 0) {
        sp14C = 0;
        temp_v0 = arg0 + (arg2 * 2);
        sp150 = 0;
        sp14E = temp_v0->unk48;
        func_80062B18(&sp148, &sp144, &sp140, 0.0f, 1.5f, 0.0f, -temp_v0->unk48, temp_v0->unk50);
        sp158 = (arg0->unk18 - arg0->unk70) + (sp144 - 2.0);
        sp154 = arg0->unk14 + sp148;
        sp15C = arg0->unk1C + sp140;
    } else {
        temp_v0_2 = arg0 + (arg2 * 2);
        sp44 = temp_v0_2;
        if ((arg0->unkBC & 8) == 8) {
            sp14C = *(&D_80164714 + (arg2 * 0xB8)) - 0x4000;
        } else {
            sp14C = -(sins((arg0->unk2E + temp_v0_2->unk48 + arg0->unkC0) & 0xFFFF) * temp_v0_2->unkCC) * D_800ED6D0;
        }
        sp14E = temp_v0_2->unk48;
        sp150 = temp_v0_2->unk50;
        if ((arg0->unkBC & 0x4000000) == 0x4000000) {
            func_80062B18(&sp148, &sp144, &sp140, 0.0f, 8.0f, 0.0f, -temp_v0_2->unk48, temp_v0_2->unk50);
            sp158 = (arg0->unk18 - arg0->unk70) + arg0->unk108;
            sp154 = arg0->unk14 + sp148;
            sp15C = arg0->unk1C + sp140;
        } else {
            func_80062B18(&sp148, &sp144, &sp140, 0.0f, 1.5f, 0.0f, -temp_v0_2->unk48, temp_v0_2->unk50);
            sp158 = ((arg0->unk18 - arg0->unk70) + arg0->unk108) + (sp144 - 2.0);
            sp154 = arg0->unk14 + sp148;
            sp15C = arg0->unk1C + sp140;
        }
    }
    temp_t0 = arg1 * 2;
    temp_v1 = *(D_801651D0 + ((arg2 * 0x10) + temp_t0));
    D_80164B04 = (temp_v1 << 0xE) + (arg2 << 0xC) + (arg1 << 9) + D_802F1F80;
    if ((arg2 == 0) || (arg2 == 1)) {
        temp_v0_4 = &D_802BFB80[(temp_v1 << 0x10) + (arg2 << 0xF) + (arg1 << 0xC)];
        D_80164B08 = temp_v0_4;
        phi_t9 = temp_v0_4 + 0x7C0;
    } else {
        temp_v0_3 = &D_802BFB80[(temp_v1 << 0x10) + (arg2 << 0xF) + (arg1 << 0xC)];
        D_80164B08 = temp_v0_3 + 0xFFFF4000;
        phi_t9 = temp_v0_3 + 0xFFFF47C0;
    }
    D_80164B0C = phi_t9;
    sp44 = temp_t0;
    func_80021E10(&sp1A4, &sp154, &sp14C);
    func_80021F84(&sp1A4, *(&D_800DDBD4 + (arg0->unk254 * 4)) * arg0->unk224);
    temp_t7 = arg2 << 9;
    sp40 = temp_t7;
    func_80022180(gGfxPool + (arg1 << 6) + temp_t7 + 0xF2C0, &sp1A4);
    if ((arg0->unkBC & 0x80000000) == 0x80000000) {
        if (arg2 == arg1) {
            temp_v0_5 = gDisplayListHead;
            gDisplayListHead = temp_v0_5 + 8;
            temp_v0_5->unk0 = 0x1020040;
            temp_v0_5->unk4 = (gGfxPool + (arg1 << 6) + sp40 + 0xF2C0) & 0x1FFFFFFF;
            temp_v0_6 = gDisplayListHead;
            gDisplayListHead = temp_v0_6 + 8;
            temp_v0_6->unk0 = 0x6000000;
            temp_v0_6->unk4 = &D_0D008CD8;
            temp_v0_7 = gDisplayListHead;
            gDisplayListHead = temp_v0_7 + 8;
            temp_v0_7->unk0 = 0xFD100000;
            temp_v0_7->unk4 = D_80164B04;
            temp_v0_8 = gDisplayListHead;
            gDisplayListHead = temp_v0_8 + 8;
            temp_v0_8->unk4 = 0;
            temp_v0_8->unk0 = 0xE8000000;
            temp_v0_9 = gDisplayListHead;
            gDisplayListHead = temp_v0_9 + 8;
            temp_v0_9->unk4 = 0x7000000;
            temp_v0_9->unk0 = 0xF5000100;
            temp_v0_10 = gDisplayListHead;
            gDisplayListHead = temp_v0_10 + 8;
            temp_v0_10->unk4 = 0;
            temp_v0_10->unk0 = 0xE6000000;
            temp_v0_11 = gDisplayListHead;
            gDisplayListHead = temp_v0_11 + 8;
            temp_v0_11->unk4 = 0x73FC000;
            temp_v0_11->unk0 = 0xF0000000;
            temp_v0_12 = gDisplayListHead;
            gDisplayListHead = temp_v0_12 + 8;
            temp_v0_12->unk4 = 0;
            temp_v0_12->unk0 = 0xE7000000;
            temp_v0_13 = gDisplayListHead;
            gDisplayListHead = temp_v0_13 + 8;
            temp_v0_13->unk4 = 0x8000;
            temp_v0_13->unk0 = 0xBA000E02;
            func_8004B614(*(&D_80164B10 + temp_t0), *(&D_80164B20 + temp_t0), *(&D_80164B30 + temp_t0), *(&D_80164B40 + temp_t0), *(&D_80164B50 + temp_t0), *(&D_80164B60 + temp_t0), arg0->unkC6);
            temp_v0_14 = gDisplayListHead;
            gDisplayListHead = temp_v0_14 + 8;
            *temp_v0_14 = 0xB900031D;
            phi_t7 = 0x505978;
            phi_v0 = temp_v0_14;
            phi_s0 = arg1 * 4;
            goto block_21;
        }
        temp_v0_15 = gDisplayListHead;
        gDisplayListHead = temp_v0_15 + 8;
        temp_v0_15->unk0 = 0x1020040;
        temp_v0_15->unk4 = (gGfxPool + (arg1 << 6) + sp40 + 0xF2C0) & 0x1FFFFFFF;
        temp_v0_16 = gDisplayListHead;
        gDisplayListHead = temp_v0_16 + 8;
        temp_v0_16->unk0 = 0x6000000;
        temp_v0_16->unk4 = &D_0D008CD8;
        temp_v0_17 = gDisplayListHead;
        gDisplayListHead = temp_v0_17 + 8;
        temp_v0_17->unk0 = 0xFD100000;
        temp_s0 = arg1 * 4;
        temp_v0_17->unk4 = D_80164B04;
        temp_v0_18 = gDisplayListHead;
        gDisplayListHead = temp_v0_18 + 8;
        temp_v0_18->unk4 = 0;
        temp_v0_18->unk0 = 0xE8000000;
        temp_v0_19 = gDisplayListHead;
        gDisplayListHead = temp_v0_19 + 8;
        temp_v0_19->unk4 = 0x7000000;
        temp_v0_19->unk0 = 0xF5000100;
        temp_v0_20 = gDisplayListHead;
        gDisplayListHead = temp_v0_20 + 8;
        temp_v0_20->unk4 = 0;
        temp_v0_20->unk0 = 0xE6000000;
        temp_v0_21 = gDisplayListHead;
        gDisplayListHead = temp_v0_21 + 8;
        temp_v0_21->unk4 = 0x73FC000;
        temp_v0_21->unk0 = 0xF0000000;
        temp_v0_22 = gDisplayListHead;
        gDisplayListHead = temp_v0_22 + 8;
        temp_v0_22->unk4 = 0;
        temp_v0_22->unk0 = 0xE7000000;
        temp_v0_23 = gDisplayListHead;
        gDisplayListHead = temp_v0_23 + 8;
        temp_v0_23->unk0 = 0xBA000E02;
        temp_v0_23->unk4 = 0x8000;
        func_8004B614(*(&D_80164B10 + temp_t0), *(&D_80164B20 + temp_t0), *(&D_80164B30 + temp_t0), *(&D_80164B40 + temp_t0), *(&D_80164B50 + temp_t0), *(&D_80164B60 + temp_t0), *(&D_8018D970 + temp_s0));
        temp_v0_24 = gDisplayListHead;
        gDisplayListHead = temp_v0_24 + 8;
        temp_v0_24->unk0 = 0xB900031D;
        temp_v0_24->unk4 = 0x505978;
        phi_v1 = &gDisplayListHead;
        phi_s0 = temp_s0;
    } else if (((arg0->unkCA & 4) == 4) || (temp_v0_25 = arg0->unkC, ((temp_v0_25 * 0x10) < 0)) || (temp_v0_25 & 0x4000000)) {
        temp_v0_36 = gDisplayListHead;
        gDisplayListHead = temp_v0_36 + 8;
        temp_v0_36->unk0 = 0x1020040;
        temp_v0_36->unk4 = (gGfxPool + (arg1 << 6) + sp40 + 0xF2C0) & 0x1FFFFFFF;
        temp_v0_37 = gDisplayListHead;
        gDisplayListHead = temp_v0_37 + 8;
        temp_v0_37->unk0 = 0x6000000;
        temp_v0_37->unk4 = &D_0D008CD8;
        temp_v0_38 = gDisplayListHead;
        gDisplayListHead = temp_v0_38 + 8;
        temp_v0_38->unk0 = 0xFD100000;
        temp_v0_38->unk4 = D_80164B04;
        temp_v0_39 = gDisplayListHead;
        gDisplayListHead = temp_v0_39 + 8;
        temp_v0_39->unk4 = 0;
        temp_v0_39->unk0 = 0xE8000000;
        temp_v0_40 = gDisplayListHead;
        gDisplayListHead = temp_v0_40 + 8;
        temp_v0_40->unk4 = 0x7000000;
        temp_v0_40->unk0 = 0xF5000100;
        temp_v0_41 = gDisplayListHead;
        gDisplayListHead = temp_v0_41 + 8;
        temp_v0_41->unk4 = 0;
        temp_v0_41->unk0 = 0xE6000000;
        temp_v0_42 = gDisplayListHead;
        gDisplayListHead = temp_v0_42 + 8;
        temp_v0_42->unk4 = 0x73FC000;
        temp_v0_42->unk0 = 0xF0000000;
        temp_v0_43 = gDisplayListHead;
        gDisplayListHead = temp_v0_43 + 8;
        temp_v0_43->unk4 = 0;
        temp_v0_43->unk0 = 0xE7000000;
        temp_v0_44 = gDisplayListHead;
        gDisplayListHead = temp_v0_44 + 8;
        temp_v0_44->unk4 = 0x8000;
        temp_v0_44->unk0 = 0xBA000E02;
        func_8004B614(*(&D_80164B10 + temp_t0), *(&D_80164B20 + temp_t0), *(&D_80164B30 + temp_t0), *(&D_80164B40 + temp_t0), *(&D_80164B50 + temp_t0), *(&D_80164B60 + temp_t0), arg0->unkC6);
        temp_v0_45 = gDisplayListHead;
        gDisplayListHead = temp_v0_45 + 8;
        temp_v0_45->unk4 = 3;
        temp_v0_45->unk0 = 0xB9000002;
        temp_v0_46 = gDisplayListHead;
        gDisplayListHead = temp_v0_46 + 8;
        temp_v0_46->unk4 = 0x504A50;
        temp_v0_46->unk0 = 0xB900031D;
        phi_v1 = &gDisplayListHead;
        phi_s0 = arg1 * 4;
    } else {
        temp_v0_26 = gDisplayListHead;
        gDisplayListHead = temp_v0_26 + 8;
        temp_v0_26->unk0 = 0x1020040;
        temp_v0_26->unk4 = (gGfxPool + (arg1 << 6) + sp40 + 0xF2C0) & 0x1FFFFFFF;
        temp_v0_27 = gDisplayListHead;
        gDisplayListHead = temp_v0_27 + 8;
        temp_v0_27->unk0 = 0x6000000;
        temp_v0_27->unk4 = &D_0D008CD8;
        temp_v0_28 = gDisplayListHead;
        gDisplayListHead = temp_v0_28 + 8;
        temp_v0_28->unk0 = 0xFD100000;
        temp_v0_28->unk4 = D_80164B04;
        temp_v0_29 = gDisplayListHead;
        gDisplayListHead = temp_v0_29 + 8;
        temp_v0_29->unk4 = 0;
        temp_v0_29->unk0 = 0xE8000000;
        temp_v0_30 = gDisplayListHead;
        gDisplayListHead = temp_v0_30 + 8;
        temp_v0_30->unk4 = 0x7000000;
        temp_v0_30->unk0 = 0xF5000100;
        temp_v0_31 = gDisplayListHead;
        gDisplayListHead = temp_v0_31 + 8;
        temp_v0_31->unk4 = 0;
        temp_v0_31->unk0 = 0xE6000000;
        temp_v0_32 = gDisplayListHead;
        gDisplayListHead = temp_v0_32 + 8;
        temp_v0_32->unk4 = 0x73FC000;
        temp_v0_32->unk0 = 0xF0000000;
        temp_v0_33 = gDisplayListHead;
        gDisplayListHead = temp_v0_33 + 8;
        temp_v0_33->unk4 = 0;
        temp_v0_33->unk0 = 0xE7000000;
        temp_v0_34 = gDisplayListHead;
        gDisplayListHead = temp_v0_34 + 8;
        temp_v0_34->unk4 = 0x8000;
        temp_v0_34->unk0 = 0xBA000E02;
        func_8004B614(*(&D_80164B10 + temp_t0), *(&D_80164B20 + temp_t0), *(&D_80164B30 + temp_t0), *(&D_80164B40 + temp_t0), *(&D_80164B50 + temp_t0), *(&D_80164B60 + temp_t0), arg0->unkC6);
        temp_v0_35 = gDisplayListHead;
        gDisplayListHead = temp_v0_35 + 8;
        *temp_v0_35 = 0xB900031D;
        phi_t7 = 0x553078;
        phi_v0 = temp_v0_35;
        phi_s0 = arg1 * 4;
block_21:
        phi_v0->unk4 = phi_t7;
        phi_v1 = &gDisplayListHead;
    }
    temp_v0_47 = *phi_v1;
    *phi_v1 = temp_v0_47 + 8;
    temp_v0_47->unk0 = 0xFD500000;
    temp_v0_47->unk4 = D_80164B08;
    temp_v0_48 = *phi_v1;
    *phi_v1 = temp_v0_48 + 8;
    temp_v0_48->unk4 = 0x7080200;
    temp_v0_48->unk0 = 0xF5500000;
    temp_v0_49 = *phi_v1;
    *phi_v1 = temp_v0_49 + 8;
    temp_v0_49->unk4 = 0;
    temp_v0_49->unk0 = 0xE6000000;
    temp_v0_50 = *phi_v1;
    *phi_v1 = temp_v0_50 + 8;
    temp_v0_50->unk4 = 0x73FF100;
    temp_v0_50->unk0 = 0xF3000000;
    temp_v0_51 = *phi_v1;
    *phi_v1 = temp_v0_51 + 8;
    temp_v0_51->unk4 = 0;
    temp_v0_51->unk0 = 0xE7000000;
    temp_v0_52 = *phi_v1;
    *phi_v1 = temp_v0_52 + 8;
    temp_v0_52->unk0 = 0xF5481000;
    temp_v0_52->unk4 = 0x80200;
    temp_v0_53 = *phi_v1;
    *phi_v1 = temp_v0_53 + 8;
    temp_v0_53->unk0 = 0xF2000000;
    temp_v0_53->unk4 = 0xFC07C;
    temp_v0_54 = *phi_v1;
    *phi_v1 = temp_v0_54 + 8;
    temp_v0_54->unk0 = 0x400103F;
    temp_t5 = phi_s0 + &D_800DDBB4;
    temp_v0_54->unk4 = *temp_t5 + (arg3 * 0x10);
    temp_v0_55 = *phi_v1;
    *phi_v1 = temp_v0_55 + 8;
    temp_v0_55->unk4 = &D_0D008C78;
    temp_v0_55->unk0 = 0x6000000;
    temp_v0_56 = *phi_v1;
    *phi_v1 = temp_v0_56 + 8;
    temp_v0_56->unk0 = 0xFD500000;
    temp_v0_56->unk4 = D_80164B0C;
    temp_v0_57 = *phi_v1;
    *phi_v1 = temp_v0_57 + 8;
    temp_v0_57->unk4 = 0x7080200;
    temp_v0_57->unk0 = 0xF5500000;
    temp_v0_58 = *phi_v1;
    *phi_v1 = temp_v0_58 + 8;
    temp_v0_58->unk4 = 0;
    temp_v0_58->unk0 = 0xE6000000;
    temp_v0_59 = *phi_v1;
    *phi_v1 = temp_v0_59 + 8;
    temp_v0_59->unk4 = 0x73FF100;
    temp_v0_59->unk0 = 0xF3000000;
    temp_v0_60 = *phi_v1;
    *phi_v1 = temp_v0_60 + 8;
    temp_v0_60->unk4 = 0;
    temp_v0_60->unk0 = 0xE7000000;
    temp_v0_61 = *phi_v1;
    *phi_v1 = temp_v0_61 + 8;
    temp_v0_61->unk0 = 0xF5481000;
    temp_v0_61->unk4 = 0x80200;
    temp_v0_62 = *phi_v1;
    *phi_v1 = temp_v0_62 + 8;
    temp_v0_62->unk0 = 0xF2000000;
    temp_v0_62->unk4 = 0xFC07C;
    temp_v0_63 = *phi_v1;
    *phi_v1 = temp_v0_63 + 8;
    temp_v0_63->unk0 = 0x400103F;
    temp_v0_63->unk4 = *temp_t5 + ((arg3 + 4) * 0x10);
    temp_v0_64 = *phi_v1;
    *phi_v1 = temp_v0_64 + 8;
    temp_v0_64->unk4 = &D_0D008C78;
    temp_v0_64->unk0 = 0x6000000;
    temp_v0_65 = *phi_v1;
    *phi_v1 = temp_v0_65 + 8;
    temp_v0_65->unk4 = 0x10001;
    temp_v0_65->unk0 = 0xBB000000;
    temp_v0_66 = *phi_v1;
    *phi_v1 = temp_v0_66 + 8;
    temp_v0_66->unk4 = 0;
    temp_v0_66->unk0 = 0xB9000002;
}
#else
GLOBAL_ASM("asm/non_matchings/code_8001F980/func_800248D0.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80021E10(? *, f32 *, s16 *); // extern
? func_80021F84(? *, f32); // extern
? func_80022180(void *, ? *); // extern
? func_8004B614(u16, u16, u16, u16, s32, s32, s32); // extern
? func_80062B18(f32 *, f32 *, f32 *, f32, f32, f32, s32, s32); // extern
f32 sins(s32); // extern
extern ? D_0D008C78;
extern ? D_0D008CD8;
extern ? D_800DDBB4;
extern ? D_800DDBD4;
extern f64 D_800ED6D8;
extern void *D_80164B04;
extern u8 *D_80164B08;
extern u8 *D_80164B0C;
extern ? D_80164B10;
extern ? D_80164B20;
extern ? D_80164B30;
extern ? D_80164B40;
extern ? D_80164B50;
extern ? D_80164B60;
extern void *gDisplayListHead;

void func_800256F4(void *arg0, s8 arg1, s8 arg2, s8 arg3) {
    ? sp12C;
    f32 spE4;
    f32 spE0;
    f32 spDC;
    s16 spD8;
    s16 spD6;
    s16 spD4;
    f32 spD0;
    f32 spCC;
    f32 spC8;
    s16 spC2;
    void *sp44;
    s16 temp_v1;
    s32 *temp_t5_2;
    s32 temp_t5;
    s32 temp_t7;
    u8 *temp_v0_2;
    u8 *temp_v0_3;
    void *temp_v0;
    void *temp_v0_10;
    void *temp_v0_11;
    void *temp_v0_12;
    void *temp_v0_13;
    void *temp_v0_14;
    void *temp_v0_15;
    void *temp_v0_16;
    void *temp_v0_17;
    void *temp_v0_18;
    void *temp_v0_19;
    void *temp_v0_20;
    void *temp_v0_21;
    void *temp_v0_22;
    void *temp_v0_23;
    void *temp_v0_24;
    void *temp_v0_25;
    void *temp_v0_26;
    void *temp_v0_27;
    void *temp_v0_28;
    void *temp_v0_29;
    void *temp_v0_30;
    void *temp_v0_31;
    void *temp_v0_32;
    void *temp_v0_33;
    void *temp_v0_4;
    void *temp_v0_5;
    void *temp_v0_6;
    void *temp_v0_7;
    void *temp_v0_8;
    void *temp_v0_9;
    u8 *phi_t9;

    if (D_8015F890 == 1) {
        spC2 = 0xFF;
    } else {
        spC2 = 0x70;
    }
    temp_v0 = arg0 + (arg2 * 2);
    sp44 = temp_v0;
    spD4 = -(sins((temp_v0->unk48 - arg0->unk2E) & 0xFFFF) * 0.0f) * D_800ED6D8;
    spD6 = temp_v0->unk48;
    spD8 = temp_v0->unk50;
    func_80062B18(&spD0, &spCC, &spC8, 0.0f, 1.5f, 0.0f, -temp_v0->unk48, temp_v0->unk50);
    temp_t5 = arg1 * 2;
    temp_v1 = *(D_801651D0 + ((arg2 * 0x10) + temp_t5));
    spE0 = (arg0->unk18 - arg0->unk70) + (spCC - 2.0);
    spDC = arg0->unk14 + spD0;
    D_80164B04 = (temp_v1 << 0xE) + (arg2 << 0xC) + (arg1 << 9) + D_802F1F80;
    spE4 = arg0->unk1C + spC8;
    if ((arg2 == 0) || (arg2 == 1)) {
        temp_v0_3 = &D_802BFB80[(temp_v1 << 0x10) + (arg2 << 0xF) + (arg1 << 0xC)];
        D_80164B08 = temp_v0_3;
        phi_t9 = temp_v0_3 + 0x7C0;
    } else {
        temp_v0_2 = &D_802BFB80[(temp_v1 << 0x10) + (arg2 << 0xF) + (arg1 << 0xC)];
        D_80164B08 = temp_v0_2 + 0xFFFF4000;
        phi_t9 = temp_v0_2 + 0xFFFF47C0;
    }
    D_80164B0C = phi_t9;
    sp44 = temp_t5;
    func_80021E10(&sp12C, &spDC, &spD4);
    func_80021F84(&sp12C, *(&D_800DDBD4 + (arg0->unk254 * 4)) * arg0->unk224);
    temp_t7 = arg2 << 9;
    func_80022180(gGfxPool + (arg1 << 6) + temp_t7 + 0xF2C0, &sp12C);
    temp_v0_4 = gDisplayListHead;
    gDisplayListHead = temp_v0_4 + 8;
    temp_v0_4->unk0 = 0x1020040;
    temp_v0_4->unk4 = (gGfxPool + (arg1 << 6) + temp_t7 + 0xF2C0) & 0x1FFFFFFF;
    temp_v0_5 = gDisplayListHead;
    gDisplayListHead = temp_v0_5 + 8;
    temp_v0_5->unk4 = &D_0D008CD8;
    temp_v0_5->unk0 = 0x6000000;
    temp_v0_6 = gDisplayListHead;
    gDisplayListHead = temp_v0_6 + 8;
    temp_v0_6->unk0 = 0xFD100000;
    temp_v0_6->unk4 = D_80164B04;
    temp_v0_7 = gDisplayListHead;
    gDisplayListHead = temp_v0_7 + 8;
    temp_v0_7->unk4 = 0;
    temp_v0_7->unk0 = 0xE8000000;
    temp_v0_8 = gDisplayListHead;
    gDisplayListHead = temp_v0_8 + 8;
    temp_v0_8->unk4 = 0x7000000;
    temp_v0_8->unk0 = 0xF5000100;
    temp_v0_9 = gDisplayListHead;
    gDisplayListHead = temp_v0_9 + 8;
    temp_v0_9->unk4 = 0;
    temp_v0_9->unk0 = 0xE6000000;
    temp_v0_10 = gDisplayListHead;
    gDisplayListHead = temp_v0_10 + 8;
    temp_v0_10->unk4 = 0x73FC000;
    temp_v0_10->unk0 = 0xF0000000;
    temp_v0_11 = gDisplayListHead;
    gDisplayListHead = temp_v0_11 + 8;
    temp_v0_11->unk4 = 0;
    temp_v0_11->unk0 = 0xE7000000;
    temp_v0_12 = gDisplayListHead;
    gDisplayListHead = temp_v0_12 + 8;
    temp_v0_12->unk4 = 0x8000;
    temp_v0_12->unk0 = 0xBA000E02;
    func_8004B614(*(&D_80164B10 + temp_t5), *(&D_80164B20 + temp_t5), *(&D_80164B30 + temp_t5), *(&D_80164B40 + temp_t5), *(&D_80164B50 + temp_t5), *(&D_80164B60 + temp_t5), spC2);
    temp_v0_13 = gDisplayListHead;
    gDisplayListHead = temp_v0_13 + 8;
    temp_v0_13->unk0 = 0xB900031D;
    temp_v0_13->unk4 = 0x505978;
    temp_v0_14 = gDisplayListHead;
    gDisplayListHead = temp_v0_14 + 8;
    temp_v0_14->unk0 = 0xFD500000;
    temp_v0_14->unk4 = D_80164B08;
    temp_v0_15 = gDisplayListHead;
    gDisplayListHead = temp_v0_15 + 8;
    temp_v0_15->unk4 = 0x7080200;
    temp_v0_15->unk0 = 0xF5500000;
    temp_v0_16 = gDisplayListHead;
    gDisplayListHead = temp_v0_16 + 8;
    temp_v0_16->unk4 = 0;
    temp_v0_16->unk0 = 0xE6000000;
    temp_v0_17 = gDisplayListHead;
    gDisplayListHead = temp_v0_17 + 8;
    temp_v0_17->unk4 = 0x73FF100;
    temp_v0_17->unk0 = 0xF3000000;
    temp_v0_18 = gDisplayListHead;
    gDisplayListHead = temp_v0_18 + 8;
    temp_v0_18->unk4 = 0;
    temp_v0_18->unk0 = 0xE7000000;
    temp_v0_19 = gDisplayListHead;
    gDisplayListHead = temp_v0_19 + 8;
    temp_v0_19->unk0 = 0xF5481000;
    temp_v0_19->unk4 = 0x80200;
    temp_v0_20 = gDisplayListHead;
    gDisplayListHead = temp_v0_20 + 8;
    temp_v0_20->unk0 = 0xF2000000;
    temp_v0_20->unk4 = 0xFC07C;
    temp_v0_21 = gDisplayListHead;
    gDisplayListHead = temp_v0_21 + 8;
    temp_v0_21->unk0 = 0x400103F;
    temp_t5_2 = (arg1 * 4) + &D_800DDBB4;
    temp_v0_21->unk4 = *temp_t5_2 + (arg3 * 0x10);
    temp_v0_22 = gDisplayListHead;
    gDisplayListHead = temp_v0_22 + 8;
    temp_v0_22->unk4 = &D_0D008C78;
    temp_v0_22->unk0 = 0x6000000;
    temp_v0_23 = gDisplayListHead;
    gDisplayListHead = temp_v0_23 + 8;
    temp_v0_23->unk0 = 0xFD500000;
    temp_v0_23->unk4 = D_80164B0C;
    temp_v0_24 = gDisplayListHead;
    gDisplayListHead = temp_v0_24 + 8;
    temp_v0_24->unk4 = 0x7080200;
    temp_v0_24->unk0 = 0xF5500000;
    temp_v0_25 = gDisplayListHead;
    gDisplayListHead = temp_v0_25 + 8;
    temp_v0_25->unk4 = 0;
    temp_v0_25->unk0 = 0xE6000000;
    temp_v0_26 = gDisplayListHead;
    gDisplayListHead = temp_v0_26 + 8;
    temp_v0_26->unk4 = 0x73FF100;
    temp_v0_26->unk0 = 0xF3000000;
    temp_v0_27 = gDisplayListHead;
    gDisplayListHead = temp_v0_27 + 8;
    temp_v0_27->unk4 = 0;
    temp_v0_27->unk0 = 0xE7000000;
    temp_v0_28 = gDisplayListHead;
    gDisplayListHead = temp_v0_28 + 8;
    temp_v0_28->unk0 = 0xF5481000;
    temp_v0_28->unk4 = 0x80200;
    temp_v0_29 = gDisplayListHead;
    gDisplayListHead = temp_v0_29 + 8;
    temp_v0_29->unk0 = 0xF2000000;
    temp_v0_29->unk4 = 0xFC07C;
    temp_v0_30 = gDisplayListHead;
    gDisplayListHead = temp_v0_30 + 8;
    temp_v0_30->unk0 = 0x400103F;
    temp_v0_30->unk4 = *temp_t5_2 + ((arg3 + 4) * 0x10);
    temp_v0_31 = gDisplayListHead;
    gDisplayListHead = temp_v0_31 + 8;
    temp_v0_31->unk4 = &D_0D008C78;
    temp_v0_31->unk0 = 0x6000000;
    temp_v0_32 = gDisplayListHead;
    gDisplayListHead = temp_v0_32 + 8;
    temp_v0_32->unk4 = 0x10001;
    temp_v0_32->unk0 = 0xBB000000;
    temp_v0_33 = gDisplayListHead;
    gDisplayListHead = temp_v0_33 + 8;
    temp_v0_33->unk4 = 0;
    temp_v0_33->unk0 = 0xB9000002;
}
#else
GLOBAL_ASM("asm/non_matchings/code_8001F980/func_800256F4.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80021E10(? *, f32 *, s16 *); // extern
? func_80021F84(? *, f32); // extern
? func_80022180(void *, ? *); // extern
? func_8004B614(u16, u16, u16, u16, s32, s32, s32); // extern
f32 sins(s32); // extern
f32 coss(s32); // extern
extern ? D_0D008C78;
extern ? D_0D008D10;
extern ? D_800DDBB4;
extern ? D_800DDBD4;
extern f64 D_800ED6E0;
extern s16 D_80164AF0;
extern s32 D_80164B08;
extern s32 D_80164B0C;
extern ? D_80164B10;
extern ? D_80164B20;
extern ? D_80164B30;
extern ? D_80164B40;
extern ? D_80164B50;
extern ? D_80164B60;
extern void *gDisplayListHead;

void func_80025DE8(void *arg0, s8 arg1, s8 arg2, s8 arg3) {
    ? spA8;
    f32 spA4;
    f32 spA0;
    f32 sp9C;
    s16 sp98;
    s16 sp96;
    s16 sp94;
    f64 temp_f4;
    s32 *temp_t5;
    s32 temp_t9;
    void *temp_v0;
    void *temp_v0_10;
    void *temp_v0_11;
    void *temp_v0_12;
    void *temp_v0_13;
    void *temp_v0_14;
    void *temp_v0_15;
    void *temp_v0_16;
    void *temp_v0_17;
    void *temp_v0_18;
    void *temp_v0_19;
    void *temp_v0_20;
    void *temp_v0_21;
    void *temp_v0_22;
    void *temp_v0_23;
    void *temp_v0_24;
    void *temp_v0_2;
    void *temp_v0_3;
    void *temp_v0_4;
    void *temp_v0_5;
    void *temp_v0_6;
    void *temp_v0_7;
    void *temp_v0_8;
    void *temp_v0_9;

    sp9C = (sins(-arg0->unk2E & 0xFFFF) * -1.5) + arg0->unk14;
    spA0 = ((arg0->unk18 - arg0->unk70) + arg0->unk108) + D_800ED6E0;
    temp_f4 = coss(-arg0->unk2E & 0xFFFF) * -1.5;
    sp94 = -0xB6;
    temp_v0 = arg0 + (arg2 * 2);
    spA4 = temp_f4 + arg0->unk1C;
    sp96 = temp_v0->unk48;
    sp98 = temp_v0->unk50;
    func_80021E10(&spA8, &sp9C, &sp94);
    func_80021F84(&spA8, *(&D_800DDBD4 + (arg0->unk254 * 4)) * arg0->unk224);
    func_80022180(gGfxPool + (D_80164AF0 << 6) + 0xFAC0, &spA8);
    temp_v0_2 = gDisplayListHead;
    gDisplayListHead = temp_v0_2 + 8;
    temp_v0_2->unk0 = 0x1020040;
    temp_v0_2->unk4 = (gGfxPool + (D_80164AF0 << 6) + 0xFAC0) & 0x1FFFFFFF;
    temp_v0_3 = gDisplayListHead;
    gDisplayListHead = temp_v0_3 + 8;
    temp_v0_3->unk0 = 0x6000000;
    temp_v0_3->unk4 = &D_0D008D10;
    temp_v0_4 = gDisplayListHead;
    gDisplayListHead = temp_v0_4 + 8;
    temp_v0_4->unk4 = 0x8000;
    temp_v0_4->unk0 = 0xBA000E02;
    temp_t9 = arg1 * 2;
    func_8004B614(*(&D_80164B10 + temp_t9), *(&D_80164B20 + temp_t9), *(&D_80164B30 + temp_t9), *(&D_80164B40 + temp_t9), *(&D_80164B50 + temp_t9), *(&D_80164B60 + temp_t9), 0x40);
    temp_v0_5 = gDisplayListHead;
    gDisplayListHead = temp_v0_5 + 8;
    temp_v0_5->unk0 = 0xB900031D;
    temp_v0_5->unk4 = 0x505978;
    temp_v0_6 = gDisplayListHead;
    gDisplayListHead = temp_v0_6 + 8;
    temp_v0_6->unk0 = 0xFD500000;
    temp_v0_6->unk4 = D_80164B08;
    temp_v0_7 = gDisplayListHead;
    gDisplayListHead = temp_v0_7 + 8;
    temp_v0_7->unk4 = 0x7080200;
    temp_v0_7->unk0 = 0xF5500000;
    temp_v0_8 = gDisplayListHead;
    gDisplayListHead = temp_v0_8 + 8;
    temp_v0_8->unk4 = 0;
    temp_v0_8->unk0 = 0xE6000000;
    temp_v0_9 = gDisplayListHead;
    gDisplayListHead = temp_v0_9 + 8;
    temp_v0_9->unk4 = 0x73FF100;
    temp_v0_9->unk0 = 0xF3000000;
    temp_v0_10 = gDisplayListHead;
    gDisplayListHead = temp_v0_10 + 8;
    temp_v0_10->unk4 = 0;
    temp_v0_10->unk0 = 0xE7000000;
    temp_v0_11 = gDisplayListHead;
    gDisplayListHead = temp_v0_11 + 8;
    temp_v0_11->unk0 = 0xF5481000;
    temp_v0_11->unk4 = 0x80200;
    temp_v0_12 = gDisplayListHead;
    gDisplayListHead = temp_v0_12 + 8;
    temp_v0_12->unk0 = 0xF2000000;
    temp_v0_12->unk4 = 0xFC07C;
    temp_v0_13 = gDisplayListHead;
    gDisplayListHead = temp_v0_13 + 8;
    temp_v0_13->unk0 = 0x400103F;
    temp_t5 = (arg1 * 4) + &D_800DDBB4;
    temp_v0_13->unk4 = *temp_t5 + (arg3 * 0x10);
    temp_v0_14 = gDisplayListHead;
    gDisplayListHead = temp_v0_14 + 8;
    temp_v0_14->unk4 = &D_0D008C78;
    temp_v0_14->unk0 = 0x6000000;
    temp_v0_15 = gDisplayListHead;
    gDisplayListHead = temp_v0_15 + 8;
    temp_v0_15->unk0 = 0xFD500000;
    temp_v0_15->unk4 = D_80164B0C;
    temp_v0_16 = gDisplayListHead;
    gDisplayListHead = temp_v0_16 + 8;
    temp_v0_16->unk4 = 0x7080200;
    temp_v0_16->unk0 = 0xF5500000;
    temp_v0_17 = gDisplayListHead;
    gDisplayListHead = temp_v0_17 + 8;
    temp_v0_17->unk4 = 0;
    temp_v0_17->unk0 = 0xE6000000;
    temp_v0_18 = gDisplayListHead;
    gDisplayListHead = temp_v0_18 + 8;
    temp_v0_18->unk4 = 0x73FF100;
    temp_v0_18->unk0 = 0xF3000000;
    temp_v0_19 = gDisplayListHead;
    gDisplayListHead = temp_v0_19 + 8;
    temp_v0_19->unk4 = 0;
    temp_v0_19->unk0 = 0xE7000000;
    temp_v0_20 = gDisplayListHead;
    gDisplayListHead = temp_v0_20 + 8;
    temp_v0_20->unk0 = 0xF5481000;
    temp_v0_20->unk4 = 0x80200;
    temp_v0_21 = gDisplayListHead;
    gDisplayListHead = temp_v0_21 + 8;
    temp_v0_21->unk0 = 0xF2000000;
    temp_v0_21->unk4 = 0xFC07C;
    temp_v0_22 = gDisplayListHead;
    gDisplayListHead = temp_v0_22 + 8;
    temp_v0_22->unk0 = 0x400103F;
    temp_v0_22->unk4 = *temp_t5 + ((arg3 + 4) * 0x10);
    temp_v0_23 = gDisplayListHead;
    gDisplayListHead = temp_v0_23 + 8;
    temp_v0_23->unk4 = &D_0D008C78;
    temp_v0_23->unk0 = 0x6000000;
    temp_v0_24 = gDisplayListHead;
    gDisplayListHead = temp_v0_24 + 8;
    temp_v0_24->unk4 = 0x10001;
    temp_v0_24->unk0 = 0xBB000000;
    D_80164AF0 = D_80164AF0 + 1;
}
#else
GLOBAL_ASM("asm/non_matchings/code_8001F980/func_80025DE8.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80021E10(? *, f32 *, s16 *); // extern
? func_80021F84(? *, f32); // extern
? func_80022180(void *, ? *); // extern
? func_8004B614(u16, u16, u16, u16, s32, s32, s32); // extern
extern ? D_0D008C78;
extern ? D_0D008CD8;
extern ? D_800DDBB4;
extern ? D_800DDBD4;
extern s16 D_80164AF0;
extern s32 D_80164B08;
extern s32 D_80164B0C;
extern ? D_80164B10;
extern ? D_80164B20;
extern ? D_80164B30;
extern ? D_80164B40;
extern ? D_80164B50;
extern ? D_80164B60;
extern void *gDisplayListHead;

void func_800262E0(void *arg0, s8 arg1, s8 arg2, s8 arg3) {
    ? spA8;
    f32 spA4;
    f32 spA0;
    f32 sp9C;
    s16 sp98;
    s16 sp96;
    s16 sp94;
    f32 *temp_a1;
    s32 *temp_t5;
    s32 temp_t8;
    void *temp_t1;
    void *temp_t2;
    void *temp_v0;
    void *temp_v0_10;
    void *temp_v0_11;
    void *temp_v0_12;
    void *temp_v0_13;
    void *temp_v0_14;
    void *temp_v0_15;
    void *temp_v0_16;
    void *temp_v0_17;
    void *temp_v0_18;
    void *temp_v0_19;
    void *temp_v0_20;
    void *temp_v0_21;
    void *temp_v0_22;
    void *temp_v0_2;
    void *temp_v0_3;
    void *temp_v0_4;
    void *temp_v0_5;
    void *temp_v0_6;
    void *temp_v0_7;
    void *temp_v0_8;
    void *temp_v0_9;

    sp94 = 0;
    temp_v0 = arg0 + (arg2 * 2);
    sp96 = temp_v0->unk48;
    temp_a1 = &sp9C;
    sp98 = temp_v0->unk50 + 0x8000;
    sp9C = arg0->unk14;
    spA0 = arg0->unk74 + (4.0f * arg0->unk224);
    spA4 = arg0->unk1C;
    if ((arg0->unk2 & (4 << (arg2 * 4))) == 0) {
        arg3 = 8;
    } else {
        arg3 = 0;
    }
    func_80021E10(&spA8, temp_a1, &sp94);
    func_80021F84(&spA8, *(&D_800DDBD4 + (arg0->unk254 * 4)) * arg0->unk224);
    func_80022180(gGfxPool + (D_80164AF0 << 6) + 0xFAC0, &spA8);
    temp_t1 = gDisplayListHead;
    gDisplayListHead = temp_t1 + 8;
    temp_t1->unk0 = 0x1020040;
    temp_t1->unk4 = (gGfxPool + (D_80164AF0 << 6) + 0xFAC0) & 0x1FFFFFFF;
    temp_t2 = gDisplayListHead;
    gDisplayListHead = temp_t2 + 8;
    temp_t2->unk0 = 0x6000000;
    temp_t2->unk4 = &D_0D008CD8;
    temp_v0_2 = gDisplayListHead;
    gDisplayListHead = temp_v0_2 + 8;
    temp_v0_2->unk4 = 0x8000;
    temp_v0_2->unk0 = 0xBA000E02;
    temp_t8 = arg1 * 2;
    func_8004B614(*(&D_80164B10 + temp_t8), *(&D_80164B20 + temp_t8), *(&D_80164B30 + temp_t8), *(&D_80164B40 + temp_t8), *(&D_80164B50 + temp_t8), *(&D_80164B60 + temp_t8), arg0->unkC6 / 2);
    temp_v0_3 = gDisplayListHead;
    gDisplayListHead = temp_v0_3 + 8;
    temp_v0_3->unk0 = 0xB900031D;
    temp_v0_3->unk4 = 0x504A50;
    temp_v0_4 = gDisplayListHead;
    gDisplayListHead = temp_v0_4 + 8;
    temp_v0_4->unk0 = 0xFD500000;
    temp_v0_4->unk4 = D_80164B08;
    temp_v0_5 = gDisplayListHead;
    gDisplayListHead = temp_v0_5 + 8;
    temp_v0_5->unk4 = 0x7080200;
    temp_v0_5->unk0 = 0xF5500000;
    temp_v0_6 = gDisplayListHead;
    gDisplayListHead = temp_v0_6 + 8;
    temp_v0_6->unk4 = 0;
    temp_v0_6->unk0 = 0xE6000000;
    temp_v0_7 = gDisplayListHead;
    gDisplayListHead = temp_v0_7 + 8;
    temp_v0_7->unk4 = 0x73FF100;
    temp_v0_7->unk0 = 0xF3000000;
    temp_v0_8 = gDisplayListHead;
    gDisplayListHead = temp_v0_8 + 8;
    temp_v0_8->unk4 = 0;
    temp_v0_8->unk0 = 0xE7000000;
    temp_v0_9 = gDisplayListHead;
    gDisplayListHead = temp_v0_9 + 8;
    temp_v0_9->unk0 = 0xF5481000;
    temp_v0_9->unk4 = 0x80200;
    temp_v0_10 = gDisplayListHead;
    gDisplayListHead = temp_v0_10 + 8;
    temp_v0_10->unk0 = 0xF2000000;
    temp_v0_10->unk4 = 0xFC07C;
    temp_v0_11 = gDisplayListHead;
    gDisplayListHead = temp_v0_11 + 8;
    temp_v0_11->unk0 = 0x400103F;
    temp_t5 = (arg1 * 4) + &D_800DDBB4;
    temp_v0_11->unk4 = *temp_t5 + (arg3 * 0x10);
    temp_v0_12 = gDisplayListHead;
    gDisplayListHead = temp_v0_12 + 8;
    temp_v0_12->unk4 = &D_0D008C78;
    temp_v0_12->unk0 = 0x6000000;
    temp_v0_13 = gDisplayListHead;
    gDisplayListHead = temp_v0_13 + 8;
    temp_v0_13->unk0 = 0xFD500000;
    temp_v0_13->unk4 = D_80164B0C;
    temp_v0_14 = gDisplayListHead;
    gDisplayListHead = temp_v0_14 + 8;
    temp_v0_14->unk4 = 0x7080200;
    temp_v0_14->unk0 = 0xF5500000;
    temp_v0_15 = gDisplayListHead;
    gDisplayListHead = temp_v0_15 + 8;
    temp_v0_15->unk4 = 0;
    temp_v0_15->unk0 = 0xE6000000;
    temp_v0_16 = gDisplayListHead;
    gDisplayListHead = temp_v0_16 + 8;
    temp_v0_16->unk4 = 0x73FF100;
    temp_v0_16->unk0 = 0xF3000000;
    temp_v0_17 = gDisplayListHead;
    gDisplayListHead = temp_v0_17 + 8;
    temp_v0_17->unk4 = 0;
    temp_v0_17->unk0 = 0xE7000000;
    temp_v0_18 = gDisplayListHead;
    gDisplayListHead = temp_v0_18 + 8;
    temp_v0_18->unk0 = 0xF5481000;
    temp_v0_18->unk4 = 0x80200;
    temp_v0_19 = gDisplayListHead;
    gDisplayListHead = temp_v0_19 + 8;
    temp_v0_19->unk0 = 0xF2000000;
    temp_v0_19->unk4 = 0xFC07C;
    temp_v0_20 = gDisplayListHead;
    gDisplayListHead = temp_v0_20 + 8;
    temp_v0_20->unk0 = 0x400103F;
    temp_v0_20->unk4 = *temp_t5 + ((arg3 + 4) * 0x10);
    temp_v0_21 = gDisplayListHead;
    gDisplayListHead = temp_v0_21 + 8;
    temp_v0_21->unk4 = &D_0D008C78;
    temp_v0_21->unk0 = 0x6000000;
    temp_v0_22 = gDisplayListHead;
    gDisplayListHead = temp_v0_22 + 8;
    temp_v0_22->unk4 = 0x10001;
    temp_v0_22->unk0 = 0xBB000000;
    D_80164AF0 = D_80164AF0 + 1;
}
#else
GLOBAL_ASM("asm/non_matchings/code_8001F980/func_800262E0.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80023BF0(Player *, s8, s8, s8); // extern
? func_80023C84(Player *, s8, s8); // extern
? func_800248D0(Player *, s8, s8, s8); // extern
? func_800256F4(Player *, s8, s8, s8); // extern
? func_80025DE8(Player *, s8, s8, s8); // extern
? func_800262E0(Player *, s8, s8, s8); // extern
? func_80026B4C(s8, s8, s8); // extern
extern OSMesgQueue gDmaMesgQueue;
extern ? D_801651D1;

void func_800267AC(Player *player, s8 arg1, s8 arg2) {
    void *sp34;
    s32 sp30;
    s32 sp2C;
    s32 sp28;
    s32 temp_t1;
    s32 temp_v0;
    s8 phi_v1;

    func_80026B4C(arg1, arg2, *(&D_801651D1 + ((arg2 * 0x10) + (arg1 * 2))));
    temp_v0 = arg2 * 4;
    if ((player->unk_002 & (4 << temp_v0)) == 0) {
        phi_v1 = 0;
    } else {
        phi_v1 = 8;
    }
    sp2C = phi_v1;
    sp30 = temp_v0;
    func_80023BF0(player, arg1, arg2, phi_v1);
    temp_t1 = 8 << temp_v0;
    sp28 = temp_t1;
    if ((temp_t1 == (player->unk_002 & temp_t1)) && (player->unk_124 <= 50.0f) && (player->unk_0F8 != 9)) {
        if ((player->unk_0BC & 0x80000000) == 0x80000000) {
            if (arg1 == arg2) {
                func_80023C84(player, arg1, arg2);
            }
        } else {
            func_80023C84(player, arg1, arg2);
        }
    }
    if ((player->unk_000 & PLAYER_INVISIBLE_OR_BOMB) != PLAYER_INVISIBLE_OR_BOMB) {
        func_800248D0(player, arg1, arg2, sp2F);
    } else {
        func_800256F4(player, arg1, arg2, sp2F);
    }
    osRecvMesg(&gDmaMesgQueue, &sp34, 1);
    if ((sp28 == (player->unk_002 & sp28)) && (player->unk_0F8 == 9) && ((player->unk_0CA & 1) != 1) && (player->unk_124 <= 30.0f)) {
        func_800262E0(player, arg1, arg2, sp2F);
    }
    if (player->unk_080 >= 2.0f) {
        func_80025DE8(player, arg1, arg2, sp2F);
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_8001F980/func_800267AC.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
extern ? D_800DDE74;
extern s32 D_800DDE94;

void func_80026A48(void *arg0, s8 arg1) {
    f32 temp_f0;
    s32 temp_t4;

    if (((arg0->unkBC & 0x4000) == 0x4000) && ((arg0->unk0 & 0x2000) == 0)) {
        temp_t4 = arg0->unk240 + D_800DDE94;
        arg0->unk240 = temp_t4;
        if (temp_t4 >= 0x400) {
            arg0->unk240 = 0;
            return;
        }
        // Duplicate return node #10. Try simplifying control flow for better match
        return;
    }
    temp_f0 = ((arg0->unk94 * (1.0f + arg0->unk104)) / 18.0f) * 216.0f;
    if ((temp_f0 <= 1.0f) || (D_80165520[arg1] == 1)) {
        arg0->unk240 = 0;
    } else {
        arg0->unk240 = arg0->unk240 + *(&D_800DDE74 + ((temp_f0 / 12.0f) * 4));
    }
    if (arg0->unk240 >= 0x400) {
        arg0->unk240 = 0;
    }
}
#else
GLOBAL_ASM("asm/non_matchings/code_8001F980/func_80026A48.s")
#endif

#ifdef MIPS_TO_C
//generated by mips_to_c commit 3c3b0cede1a99430bfd3edf8d385802b94f91307
? func_80027C74(s32, void *, ?); // extern
extern ? D_800DDE34;
extern ? D_800DDE54;

void func_80026B4C(void *arg0, s8 arg1, s8 arg2, s8 arg3) {
    s16 temp_t0;
    s16 temp_t1;
    s16 temp_t2;
    s32 temp_v0;
    s32 temp_v1;

    temp_v1 = arg0->unkBC;
    temp_v0 = arg1 * 2;
    temp_t0 = *(D_801650D0 + ((arg2 * 0x10) + temp_v0));
    temp_t1 = *(D_80165110 + ((arg2 * 0x10) + temp_v0));
    temp_t2 = arg0->unk242;
    if (((temp_v1 & 0x4000) == 0x4000) && ((arg0->unk0 & 0x2000) == 0)) {
        if (((temp_v1 & 0x80) != 0x80) && ((temp_v1 & 0x40) != 0x40) && ((temp_v1 & 0x20000) != 0x20000) && ((temp_v1 & 0x80000) != 0x80000) && ((temp_v1 & 0x800000) != 0x800000) && ((arg0->unk44 & 0x800) == 0)) {
            if (temp_t0 < 0x15) {
                func_80027C74(*(*(&D_800DDE34 + (arg0->unk254 * 4)) + (temp_t1 * 4)) + (temp_t0 << 9) + ((temp_t2 >> 8) << 7), (arg3 << 0xE) + (arg2 << 0xC) + (arg1 << 9) + 0x180 + D_802F1F80, 0x80);
                return;
            }
            func_80027C74(*(*(&D_800DDE54 + (arg0->unk254 * 4)) + (temp_t1 * 4)) + (((temp_t0 << 8) - 0x1500) * 2) + ((temp_t2 >> 8) << 7) + 0xC00, (arg3 << 0xE) + (arg2 << 0xC) + (arg1 << 9) + 0x180 + D_802F1F80, 0x80);
            return;
        }
        if (temp_t0 == 0) {
            func_80027C74(*(*(&D_800DDE34 + (arg0->unk254 * 4)) + (temp_t1 * 4)) + (temp_t0 << 9) + ((temp_t2 >> 8) << 7), (arg3 << 0xE) + (arg2 << 0xC) + (arg1 << 9) + 0x180 + D_802F1F80, 0x80);
            return;
        }
        func_80027C74(*(*(&D_800DDE54 + (arg0->unk254 * 4)) + (temp_t1 * 4)) + (temp_t0 << 9) + ((temp_t2 >> 8) << 7), (arg3 << 0xE) + (arg2 << 0xC) + (arg1 << 9) + 0x180 + D_802F1F80, 0x80);
        return;
    }
    if (((temp_v1 & 0x80) != 0x80) && ((temp_v1 & 0x40) != 0x40) && ((temp_v1 & 0x80000) != 0x80000) && ((temp_v1 & 0x800000) != 0x800000) && ((temp_v1 & 0x20000) != 0x20000) && ((arg0->unk44 & 0x800) == 0)) {
        if (temp_t0 < 0x15) {
            func_80027C74(*(*(&D_800DDE34 + (arg0->unk254 * 4)) + (temp_t1 * 4)) + (temp_t0 << 9) + ((temp_t2 >> 8) << 7), (arg3 << 0xE) + (arg2 << 0xC) + (arg1 << 9) + 0x180 + D_802F1F80, 0x80);
            return;
        }
        func_80027C74(*(*(&D_800DDE54 + (arg0->unk254 * 4)) + (temp_t1 * 4)) + (((temp_t0 << 8) - 0x1500) * 2) + ((temp_t2 >> 8) << 7) + 0xC00, (arg3 << 0xE) + (arg2 << 0xC) + (arg1 << 9) + 0x180 + D_802F1F80, 0x80);
        return;
    }
    if (temp_t0 == 0) {
        func_80027C74(*(*(&D_800DDE34 + (arg0->unk254 * 4)) + (temp_t1 * 4)) + (temp_t0 << 9) + ((temp_t2 >> 8) << 7), (arg3 << 0xE) + (arg2 << 0xC) + (arg1 << 9) + 0x180 + D_802F1F80, 0x80);
        return;
    }
    func_80027C74(*(*(&D_800DDE54 + (arg0->unk254 * 4)) + (temp_t1 * 4)) + (temp_t0 << 9) + ((temp_t2 >> 8) << 7), (arg3 << 0xE) + (arg2 << 0xC) + (arg1 << 9) + 0x180 + D_802F1F80, 0x80);
}
#else
GLOBAL_ASM("asm/non_matchings/code_8001F980/func_80026B4C.s")
#endif
